#INCLUDE "MATXALC.CH" 
#INCLUDE "PROTHEUS.CH"
#INCLUDE "FWEVENTVIEWCONSTS.CH"
#INCLUDE 'FWLIBVERSION.CH'    

#define GRPALLUSERS '************'
 
Static __lPapec
Static __lGotPri := .F.
Static __lPriGrp := .F.
Static __nTamAIUs := 0
Static _oJsonWizard := JsonObject():New()
Static _lWizard := .F.

Static aUsrRetGrp := If(Type("cUsername") <> "U" .And. Type("__cUserID") <> "U" .And. __cUserID <> '', UsrRetGrp(),{})
Static cRetCodUsr := If(Type("cUsername") <> "U" .And. Type("__cUserID") <> "U" .And. __cUserID <> '', RetCodUsr(),"")

Static _nTamPrd
Static _nTamGrp

Static cRelease := GetRpoRelease()

/*/ 
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Descri‡…o ³ PLANO DE MELHORIA CONTINUA        ³Programa     MATXALC.PRX³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ITEM PMC  ³ Responsavel              ³ Data                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³      01  ³Nereu Humberto Junior     ³ 05/04/2006                      ³±±
±±³      02  ³Nereu Humberto Junior     ³ 24/03/2006                      ³±±
±±³      03  ³Alexandre Inacio Lemes    ³ 09/05/2006                      ³±±
±±³      04  ³Alexandre Inacio Lemes    ³ 03/02/2005                      ³±±
±±³      05  ³Alexandre Inacio Lemes    ³ 03/02/2005                      ³±±
±±³      06  ³Nereu Humberto Junior     ³ 05/04/2006                      ³±±
±±³      07  ³Alexandre Inacio Lemes    ³ 09/05/2006                      ³±±
±±³      08  ³Alexandre Inacio Lemes    ³ 05/12/2005                      ³±±
±±³      09  ³Nereu Humberto Junior     ³ 24/03/2006                      ³±±
±±³      10  ³Alexandre Inacio Lemes    ³ 05/12/2005                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

/*/{Protheus.doc} RetCodUsr
	Retorna o ID de Usuário (USR_ID) a partir de um determinado login (USR_CODIGO).
	Caso o parâmetro de login não seja informado, será utilizado o login de usuário corrente para a busca.
@type function
@author leonardo.magalhaes
@since 27/01/1999
@version 2.0
@param cLogin, character, Login do Usuário (USR_CODIGO).
@return cRet, character, ID do Usuário (USR_ID).
/*/
Function RetCodUsr(cLogin)
 
	Local cRet	    := "" //-- Variável de retorno da função
	Local aAux      := {} //-- Array auxiliar para acesso ao arquivo de usuários
	Local nPosLogin := 0  //-- Posição do Login do usuário no array auxiliar

	Default cLogin := cUserName //-- Default é a variável pública cUserName (Login de Usuário Corrente)

	//-- Verificar se o acesso é por Job/WebService
	If GetRemoteType() == -1
		
		//-- Se o parâmetro cLogin estiver preenchido, avaliar a partir dele o arquivo de usuários via FwSFAllUsers
		If !Empty(cLogin) .And. !(AllTrim(cLogin) == AllTrim(cUserName))
			aAux := FwSFAllUsers(, {"USR_CODIGO"}) 					 //-- Obter todos os logins de usuário (USR_CODIGO) do arquivo de usuários
			cLogin := AllTrim(cLogin) 								 //-- Padronizar o login para que a busca pela posição não falhe
			nPosLogin := Ascan(aAux, {|x| AllTrim(x[3]) == cLogin})  //-- Obter no array auxiliar a posição do login desejado
			If nPosLogin > 0 							    		 //-- Verificar se encontrou a posição no array auxiliar
				cRet := aAux[nPosLogin][2] 			     			 //-- Atribuir a variável de retorno o ID de Usuário (USR_ID) obtido pelo Login
			EndIf
		Else
			cRet := __cUserId
		EndIf
		
		//-- Caso nenhuma das formas retorne o ID e ele continuar vazio, retornará em branco
		If Empty(cRet)
			cRet := CriaVar("AN_USER")
		EndIf

	//-- Caso não seja via JOB/WS, retornar a variável pública __cUserId (ID de Usuário Corrente)
	Else
		cRet := __cUserId
	Endif

	//-- Limpar a memória utilizada pelo array auxiliar
    aSize(aAux, 0)
	aAux := Nil

Return cRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³UsrRetGrp ³ Autor ³ Edson Maricate        ³ Data ³27.01.1999³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna os grupos do usuario.                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Codigo do usuario                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ RetA1 = Array contendo os grupos.                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico.                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function UsrRetGrp(cUser,cCodUser)

Local aArea
Local aGrupos		:= {}

//Default somente atribui se parâmetro recebido for nulo, se for vazio não atribui
Default cUser		:= ""
Default cCodUser	:= ""

// Prioriza o ID de usuario para ganho de performance, se cCodUser vazio e utiliza Smart Client
If Empty(cCodUser) .AND. GetRemoteType() != -1
	If Empty(cUser) .OR. AllTrim(cUser) == AllTrim(cUserName)
		cCodUser := __cUserId
	EndIf
EndIf

// Prioriza o ID de usuario para ganho de performance
If !Empty(cCodUser)
	aArea	 := GetArea()
	aGrupos  := FWSFUsrGrps(cCodUser)
	RestArea(aArea)
Else
	If Empty(cUser) .AND. !Empty(cUserName)
		cUser := cUserName
	EndIf
	If !Empty(cUser)
		aArea	 := GetArea()
		PswOrder(2)
		If PswSeek(cUser)
			aGrupos  := PswRet(1)[1][10]
		Else
			PswOrder(1)
			If PswSeek(cUser)
				aGrupos  := PswRet(1)[1][10]
			EndIf
		EndIf
		RestArea(aArea)
	EndIf			
EndIf

Return aGrupos

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³UsrFullName³ Autor ³ Edson Maricate       ³ Data ³27.01.1999³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna o nome do completo do usuario.                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Codigo do usuario a ser verificado.                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ RetC1 = Nome completo do usuario.                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Mata085                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function UsrFullName(cUser)
Local aArea := GetArea() 
Local cName := ""
 
If cUser == Nil
	cUser := cRetCodUsr
EndIf 

If FindFunction("FWGETUSERNAME")
	If !Empty(cUser)
		cName := FwGetUserName(cUser)
	Else
		cName := Space(15)
	EndIf
Else
	PswOrder(1)
	If !Empty(cUser) .And. PswSeek(cUser)
   		cName := PswRet(1)[1][4]
	Else
     	cName := Space(15)
	EndIf
EndIf

RestArea(aArea)

Return( cName )

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³UsrGrComp ³ Autor ³ Edson Maricate        ³ Data ³ 02.09.98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna os Grupos de Compras do Usuario.                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Codigo do usuario a ser verificado.                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ RetA1 = Array contendo os codigos dos grupos.              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Generico.                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function UsrGrComp(cUser)

Local cSaveArea  := GetArea()
Local cSavOrdSAJ := SAJ->(GetArea())

Local aRet:={}

If !Empty(cUser)
	dbSelectArea("SAJ")
	dbSetOrder(2)
	If dbSeek(xFilial("SAJ")+cUser)
		While !Eof() .And. SAJ->AJ_USER == cUser
			AADD(aRet,SAJ->AJ_GRCOM)
			dbSkip()
		End
	EndIf
Endif

RestArea(cSavOrdSAJ)
RestArea(cSaveArea)

Return aRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³VldGrComp ³ Autor ³ Edson Maricate        ³ Data ³ 28.10.98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se o usuario pertence a um grupo de compras.      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Codigo do usuario a ser verificado.                ³±±
±±³          ³ ExpC2 = Codigo do grupo a ser verificado.                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ RetL1 = .T. / .F.                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ MATA150.                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function VldGrComp(cUser,cGrupo)
Local cSaveArea := Alias()
Local cSavOrdem := IndexOrd()
Local lRet := .F.
Local lAjMsblq 	:= SAJ->(FIELDPOS("AJ_MSBLQL ")) > 0 //Valida se o campo reservado foi habilitado


If !Empty(cUser)
	dbSelectArea("SAJ")
	dbSetOrder(2)
	If dbSeek(xFilial("SAJ")+cUser)
		While !Eof() .And. SAJ->AJ_USER == cUser
			If AllTrim(SAJ->AJ_GRCOM) == "*" .Or. cGrupo == SAJ->AJ_GRCOM
				If lAjMsblq
					//Caso o registro esteja bloqueado, sai do while e apresenta help na função MaCanAltCot ou MaCanDelCot (COMXFUN).
					If !RegistroOk("SAJ",.F.)
						Exit
					EndIf
				EndIf
				lRet := .T.
				Exit
			EndIf
			dbSkip()
		End
	EndIf
Endif


If Empty(cGrupo)
	lRet := .T.
EndIf

dbSelectArea(cSaveArea)
dbSetOrder(cSavOrdem)

Return lRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ VldAnCot ³ Autor ³ Edson Maricate        ³ Data ³ 28.10.98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se o usuario pode analizar a cotacao.             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Codigo do usuario a ser verificado.                ³±±
±±³          ³ ExpC2 = Codigo do grupo a ser verificado.                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ RetL1 = .T. / .F.                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ MATA160.                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function VldAnCot(cUser,cGrupo)

Local aArea		:= GetArea()
Local aAreaSAJ	:= SAJ->(GetArea())
Local lRet		:= .F.

If !Empty(cUser) .And. !Empty(cGrupo)
	dbSelectArea("SAJ")
	dbSetOrder(2)
	If dbSeek(xFilial("SAJ")+cUser)
		While !Eof() .And. SAJ->AJ_USER == cUser
			If cGrupo == SAJ->AJ_GRCOM .And. SAJ->AJ_COTACAO == 'S'
				lRet := .T.
				Exit
			EndIf
			dbSkip()
		End
	EndIf
Endif

If Empty(cGrupo) .Or. (Type("lIsACC")=="L" .And. lIsACC)
	lRet := .T.
EndIf

RestArea(aAreaSAJ)
RestArea(aArea)

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MaRetComSC³ Autor ³   Edson Maricate      ³ Data ³ 01.10.98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna o grupo de compradores responsavel pelo processo   ³±±
±±³          ³ de compras  ( Pedido / Cotacao ) da solicitacao.           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Codigo do produto.                                 ³±±
±±³          ³ ExpA1 = Array contendo os grupos do usuario.               ³±±
±±³          ³ ExpC1 = Codigo do usuario a ser verificado.                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ RetC1 = Grupo de compradores destino.                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico.                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaRetComSC(cProduto,aGrpUsr,cUser)

Local aArea		:= GetArea()
Local aAreaSB1	:= SB1->(GetArea())
Local aAreaSAI	:= SAI->(GetArea())
Local cGrpComSC
Local nx

DEFAULT aGrpUsr	:= aClone(aUsrRetGrp)
DEFAULT cUser	:= cRetCodUsr

dbSelectArea("SB1")
dbSetOrder(1)
MsSeek(xFilial("SB1")+cProduto)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica o Usuario                                  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea('SAI')
dbSetOrder(2)
dbSeek(xFilial("SAI")+cUser)
While !Eof() .And. SAI->AI_FILIAL+SAI->AI_USER==xFilial('SAI')+cUser
	If 	SAI->AI_GRUPO == SB1->B1_GRUPO .Or. ;
			SAI->AI_PRODUTO == SB1->B1_COD .Or. ;
			(AllTrim(SAI->AI_PRODUTO) == '*'.And.;
			Alltrim(SAI->AI_GRUPO)=='*')

		If SAI->AI_PRODUTO == SB1->B1_COD
			cGrpComSC := SAI->AI_GRUPCOM
			If !Empty(cGrpComSC)
				Exit
			EndIf
		Else
			If (AllTrim(SAI->AI_PRODUTO) == '*' .And.Alltrim(SAI->AI_GRUPO)=='*' .And. Empty(cGrpComSC))
				cGrpComSC := SAI->AI_GRUPCOM
			Else
				cGrpComSC := SAI->AI_GRUPCOM
			EndIf
		EndIf

	EndIf
	dbSkip()
End

If Empty(cGrpComSC)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica os Grupo de Usuarios.                      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea('SAI')
	dbSetOrder(1)
	For nx := 1 to Len(aGrpUsr)
		dbSeek(xFilial("SAI")+aGrpUsr[nx])
		While !Eof() .And. SAI->AI_FILIAL+SAI->AI_GRUSER==xFilial('SAI')+aGrpUsr[nx]
			If 	SAI->AI_GRUPO == SB1->B1_GRUPO .Or. ;
					SAI->AI_PRODUTO == SB1->B1_COD .Or. ;
					(AllTrim(SAI->AI_PRODUTO) == '*'.And.;
					Alltrim(SAI->AI_GRUPO)=='*')

				If SAI->AI_PRODUTO == SB1->B1_COD
					cGrpComSC := SAI->AI_GRUPCOM
					If !Empty(cGrpComSC)
						Exit
					EndIf
				Else
					If (AllTrim(SAI->AI_PRODUTO) == '*'.And.Alltrim(SAI->AI_GRUPO)=='*' .And. Empty(cGrpComSC))
						cGrpComSC := SAI->AI_GRUPCOM
					Else
						cGrpComSC := SAI->AI_GRUPCOM
					EndIf
				EndIf

			EndIf
			dbSkip()
		End
	Next nx
Endif

If Empty(cGrpComSC)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se existe o o Solicitante TODOS USUARIOS   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea('SAI')
	dbSetOrder(3)
	dbSeek(xFilial("SAI")+GRPALLUSERS)
	While !Eof() .And. SAI->AI_FILIAL+SAI->AI_GRUSER+SAI->AI_USER == xFilial('SAI')+GRPALLUSERS
		If 	SAI->AI_GRUPO == SB1->B1_GRUPO .Or. ;
				SAI->AI_PRODUTO == SB1->B1_COD .Or. ;
				(AllTrim(SAI->AI_PRODUTO) == '*'.And.;
				Alltrim(SAI->AI_GRUPO)=='*')

			If SAI->AI_PRODUTO == SB1->B1_COD
				cGrpComSC := SAI->AI_GRUPCOM
				If !Empty(cGrpComSC)  
					Exit
				EndIf
			Else
				If (AllTrim(SAI->AI_PRODUTO) == '*' .And. Alltrim(SAI->AI_GRUPO)=='*' .And. Empty(cGrpComSC))
					cGrpComSC := SAI->AI_GRUPCOM
				Else
					cGrpComSC := SAI->AI_GRUPCOM
				EndIf
			EndIf

		EndIf
		dbSkip() 
	End
Endif

If Empty(cGrpComSC)
	dbSelectArea("SB1")
	dbSetOrder(1)
	MsSeek(xFilial("SB1")+cProduto)
	cGrpComSC := SB1->B1_GRUPCOM
EndIf

RestArea(aAreaSB1)
RestArea(aAreaSAI)
RestArea(aArea)
FwFreeArray(aAreaSB1)
FwFreeArray(aAreaSAI)
FwFreeArray(aArea)

Return cGrpComSC

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³UsrRetName³ Autor ³ Edson Maricate        ³ Data ³27.01.1999³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna o nome do usuario.                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Codigo do usuario a ser verificado.                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ RetC1 = Nome do usuario.                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico.                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function UsrRetName(cCodUser)

Local aArea := GetArea()
Local cName	:= SPACE(15)

If cCodUser == "******"
	cName := "Todos"
Elseif !Empty(cCodUser)
	PswOrder(1)
	If	PswSeek(cCodUser)
		cName := PswChave(cCodUser)
	Else
		cName := SPACE(15)
	EndIf
Endif

RestArea(aArea)

Return cName

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³GrpRetName³ Autor ³ Edson Maricate        ³ Data ³27.01.1999³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna o nome do grupo de Usuarios.                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Codigo do grupo de usuarios a ser verificado.      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ RetC1 = Nome do grupo de usuarios.                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico.                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GrpRetName(cCodGrup)

Local cAlias	:= Alias()
Local cSavOrd	:= IndexOrd()
Local cName		:= SPACE(15)

If cCodGrup == "******"
	cName := "Todos"
Elseif !Empty(cCodGrup)
	cName := FWSFGroup( cCodGrup, "DATAGROUP", "GR__NOME")
	If Empty(cName)
		cName := SPACE(15)
	EndIf 
EndIf

dbSelectArea(cAlias)
dbSetOrder(cSavOrd)

Return cName 


/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ UsrExist ³ Autor ³ Edson Maricate        ³ Data ³ 30.09.98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica se o usuario existe.                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe e ³ Void UsrExist(ExpC1)                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Codigo do Usuario                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function UsrExist(cUser,lPesqUsr)
Local cAlias		:= Alias()
Local cSavOrd		:= IndexOrd()
Local lRet 		:= .F.

Default lPesqUsr	:= .T.

PswOrder(1)
If PswSeek(cUser,lPesqUsr)
	lRet := .T.
Else
	HELP("   ",1,"USR_EXIST")
EndIf

dbSelectArea(cAlias)
dbSetOrder(cSavOrd)
Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MaAlcDtRef³ Autor ³ Edson Maricate        ³ Data ³29.10.1998³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna a data de referencia para o gravacao do arquivo    ³±±
±±³          ³ de Saldos.                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe e ³ Void MaAlcDtRef(ExpC1,ExpD1,ExpC2)                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Alias do arquivo                                   ³±±
±±³          ³ ExpD1 = Data de referencia                                 ³±±
±±³          ³ ExpC2 = Tipo de saldo                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MaAlcDtRef(cAprov,dDataRef,cTipo)
Local dRet       := Ctod("")
Local aArea 	 := GetArea()
Local aAreaSCR	 := SCR->(GetArea())
Local aAreaSAK   := SAK->(GetArea())

dbSelectArea("SCR")
dbSelectArea("SAK")
SAK->(dbSetOrder(1))
SAK->(dbSeek(xFilial("SAK") + cAprov))
If cTipo == Nil
	cTipo := SAK->AK_TIPO
EndIf

Do Case
	Case cTipo == "D"
		dRet := dDataRef
	Case cTipo == "M"
		dRet := CTOD("01/"+STRZERO(MONTH(dDataRef),2)+"/"+STRZERO(YEAR(dDataRef),4),"ddmmyy")
	Case cTipo == "S"
		dRet := dDataRef
		While DOW(dRet) != 1
			dRet--
		End
	Case cTipo == "A"
		dRet := CTOD("01/01/"+STRZERO(YEAR(dDataRef),4),"ddmmyy")
	OtherWise
		dRet := dDataRef
End

RestArea(aAreaSCR)
RestArea(aAreaSAK)
RestArea(aArea)

Return (dRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³UsrRetMail³ Autor ³Rodrigo de A. Sartorio ³ Data ³03.07.2000³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna o e-mail do usuario                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Codigo do usuario a ser verificado.                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ RetC1 = E-mail do usuario.                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico.                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function UsrRetMail(cCodUser)
Local aArea:=GetArea()
Local cMail:=""
PswOrder(1)
If !Empty(cCodUser) .And. PswSeek(cCodUser)
	cMail:=PswRet(1)[1][14]
EndIf
RestArea(aArea)
Return cMail

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³A120Posic ³Revisao³Alexandre Inacio Lemes ³Data  ³05/05/2006³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Consulta do status das Aprovacoes Documentos PC/AE/CP/NF   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe e ³ Void A120Posic(ExpC1,ExpN1,ExpN2,ExpC2)                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Alias do arquivo                                   ³±±
±±³          ³ ExpN1 = Numero do registro                                 ³±±
±±³          ³ ExpN2 = Opcao selecionada                                  ³±±
±±³          ³ ExpC2 = Tipo do Documento                                  ³±±
±±³          ³ ExpC3 = Informa se salva status                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA120 / MATA125 / MATA103 / CNTA130                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A120Posic(cAlias,nReg,nOpcx,cTipoDoc,lStatus,lResid)
Local aArea			:= GetArea()
Local aSavCols		:= {}
Local aSavHead		:= {}
Local cHelpApv		:= OemToAnsi(STR0052) // "Este documento nao possui controle de aprovacao ou deve ser aprovado pelo controle de alçadas."
Local cAliasSCR		:= GetNextAlias()
Local cComprador	:= ""
Local cSituaca  	:= ""
Local cNumDoc		:= ""
Local cStatus		:= STR0087 // "Documento aprovado"
Local cTitle		:= ""
Local cTitDoc		:= ""
Local cAddHeader	:= ""
Local cAprovador	:= ""
Local nSavN			:= 0
Local nX   			:= 0
Local oDlg			:= NIL
Local oGet			:= NIL
Local oBold			:= NIL
Local lExAprov		:= SuperGetMV("MV_EXAPROV",.F.,.F.)
Local lAprPCEC		:= SuperGetMV("MV_APRPCEC",.F.,.F.)
Local lAprSAEC		:= SuperGetMV("MV_APRSAEC",.F.,.F.)
Local lAprSCEC		:= SuperGetMV("MV_APRSCEC",.F.,.F.)
Local lAprCTEC		:= SuperGetMV("MV_APRCTEC",.F.,0) <> 0
Local lAprMDEC		:= SuperGetMV("MV_APRMDEC",.F.,0) <> 0
Local cAprIPPC		:= SuperGetMv("MV_APRIPPC",.F.,'2')
Local lCtCorp		:= .F.
Local lMdCorp		:= .F.
Local cQuery   		:= ""
Local aStruSCR 		:= SCR->(dbStruct())
Local cFilSCR 		:= ""
Local cFilDBM		:= ""
Local lFluig		:= SuperGetMV("MV_APWFECM",.F.,"1") == "1" .And. !Empty(AllTrim(GetNewPar("MV_ECMURL",""))) .And. FWWFFluig()
Local nTotal 		:= 0
Local aCposPe 		:= {}
Local nP 			:= 0

DEFAULT cTipoDoc := "PC"
DEFAULT lStatus  := .T.
DEFAULT lResid   := .F.
DEFAULT nOpcx    := 2

cFilSCR := IIf(cTipoDoc $ 'IC|CT|IR|RV',CnFilCtr(CN9->CN9_NUMERO),xFilial("SCR"))
cFilDBM := xFilial("DBM")

If lStatus
	aSavCols := aClone(aCols)
	aSavHead := aClone(aHeader)
	nSavN := N
Else
	Private aCols := {}
	Private aHeader := {}
	Private N := 1
EndIf

dbSelectArea(cAlias)
MsGoto(nReg)

IF cTipoDoc $ "PC|AE|IP"
	If !Empty(SC7->C7_APROV) .Or. cTipoDoc == "IP"
		cTitle  	:= OemToAnsi(STR0029) // "Aprovacao do Pedido de Compra"
		cTitDoc 	:= OemToAnsi(STR0012) // "Pedido"
		cHelpApv	:= OemToAnsi(STR0033) // "Este pedido nao possui controle de aprovacao."
		cNumDoc 	:= SC7->C7_NUM
		cComprador	:= UsrRetName(SC7->C7_USER)
	EndIf
ElseIf cTipoDoc == "CP"
	If !Empty(SC3->C3_APROV)
    	cTitle 		:= OemToAnsi(STR0040) // "Aprovacao do Contrato de Parceria"
		cTitDoc 	:= OemToAnsi(STR0039) // "Contrato"
		cHelpApv	:= OemToAnsi(STR0038) // "Este Contrato nao possui controle de aprovacao."
		cNumDoc		:= SC3->C3_NUM
		cComprador	:= UsrRetName(SC3->C3_USER)
	EndIf
ElseIf cTipoDoc == "NF"
	If !Empty(SF1->F1_APROV)
	    cTitle		:= OemToAnsi(STR0047) // "Aprovacao da Nota Fiscal de Entrada"
	    cTitDoc		:= OemToAnsi(STR0048) // "Nota Fiscal"
	    cHelpApv	:= OemToAnsi(STR0049) // "Esta Nota Fiscal nao possui controle de aprovacao."
		cNumDoc		:= SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA
	EndIf
ElseIf cTipoDoc $ "MD|IM"
	cTitle   	:= OemToAnsi(STR0053)//"Aprovação da  Medição de Contrato"
	cTitDoc   	:= OemToAnsi(STR0054)//"Medição"
	cHelpApv  	:= OemToAnsi(STR0055)//"Esta medição não possui controle de aprovação"
	cAprovador	:= OemToAnsi(STR0062)//"Aprovadores"
	lMdCorp	:= Empty(CND->CND_FILIAL)
	cNumDoc   	:= CND->CND_NUMMED
	cComprador	:= CND->CND_APROV + " - " + Posicione("SAL",1,xFilial("SAL")+CND->CND_APROV, "AL_DESC")
ElseIf cTipoDoc $ "CT|IC"
	cTitle    	:= OemToAnsi(STR0076)//"Aprovação de Contrato"
	cTitDoc   	:= OemToAnsi(STR0077)//"Contratos"
	cHelpApv  	:= OemToAnsi(STR0078)//"Este contrato não possui controle de aprovação"
	cAprovador	:= OemToAnsi(STR0079)//"Aprovadores"
	lCtCorp	:= Empty(CN9->CN9_FILIAL)
	cNumDoc   	:= CN9->CN9_NUMERO + " - " + CN9->CN9_REVISA
	cComprador	:= CN9->CN9_APROV + " - " + Posicione("SAL",1,xFilial("SAL")+CN9->CN9_APROV, "AL_DESC")
ElseIf cTipoDoc == "SC"
	cTitle   	:= OemToAnsi(STR0064) // "Aprovacao da Solicitação de Compra"
	cTitDoc  	:= OemToAnsi(STR0065) // "Solicitação"
	cHelpApv  	:= OemToAnsi(STR0066) // "Esta solicitação nao possui controle de aprovacao."
	cNumDoc   	:= SC1->C1_NUM
	cComprador	:= UsrRetName(SC1->C1_USER)
ElseIf cTipoDoc == "SA"
	cTitle    	:= OemToAnsi(STR0069) // "Aprovação da Solicitação de Armazém"
	cTitDoc   	:= OemToAnsi(STR0065) // "Solicitação"
	cHelpApv  	:= OemToAnsi(STR0066) // "Esta solicitação nao possui controle de aprovação."
	cNumDoc   	:= SCP->CP_NUM
	cComprador  := SCP->CP_SOLICIT
ElseIf cTipoDoc $ "RV|IR"
	cTitle		:= OemToAnsi(STR0076)//"Aprovação de Contrato"
	cTitDoc   	:= OemToAnsi(STR0077)//"Contrato"
	cHelpApv  	:= OemToAnsi(STR0078)//"Este contrato não possui controle de aprovação"
	cAprovador	:= OemToAnsi(STR0079)//"Aprovadores"
	lCtCorp	:= Empty(CN9->CN9_FILIAL)
	cNumDoc   	:= CN9->CN9_NUMERO + " - " + CN9->CN9_REVISA
	cComprador	:= CN9->CN9_APROV + " - " + Posicione("SAL",1,xFilial("SAL")+CN9->CN9_APROV, "AL_DESC")
ElseIf cTipoDoc $ "PV|DV"
	cTitle  	:= OemToAnsi(STR0108) // "Aprovação do Pedido de Venda"
	cTitDoc 	:= OemToAnsi(STR0012) // "Pedido"
	cHelpApv	:= OemToAnsi(STR0033) // "Este pedido não possui controle de aprovacao."
	cAprovador	:= OemToAnsi(STR0079) // "Aprovadores"
	cNumDoc 	:= SC5->C5_NUM
EndIf

If !Empty(cNumDoc)
	aHeader:= {}
	aCols  := {}

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Ponto de Entrada para adicionar Campos SCR na MsGetDados     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ExistBlock("A120PSCR")
		cAddHeader := ExecBlock("A120PSCR", .F., .F. )
		aCposPe := StrTokArr2(cAddHeader,"/",.F.) //Tratamento para adcionar campos na query
		If ValType(cAddHeader) <> "C"
			cAddHeader := ""
		Endif
	Endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Faz a montagem do aHeader com os campos fixos.               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	SX3->(dbSetOrder(1))
	SX3->(MsSeek("SCR"))
	If (cTipoDoc $ "PC|IP" .And. lAprPCEC) .Or.;
			(cTipoDoc == "SA" .And. lAprSAEC) .Or.;
			(cTipoDoc == "SC" .And. lAprSCEC) .Or.;
			(cTipoDoc $ "CT|IC" .And. lAprCTEC) .Or.;
			(cTipoDoc $ "MD|IM" .And. lAprMDEC) .Or.;
			(cTipoDoc $ "SC|IP|PC" .and. MtExistDBM(cTipoDoc,cNumDoc))
		AADD(aHeader,{STR0084,"bCR_ITEM","",8,0,"","","C","",""} )	// Item
	Endif

	While !SX3->(EOF()) .And. (SX3->X3_ARQUIVO == "SCR")
		IF AllTrim(SX3->X3_CAMPO)$"CR_NIVEL/CR_OBS/CR_DATALIB/CR_TIPO/CR_ITGRP" + Iif(lFluig,"/CR_FLUIG","") + cAddHeader
			AADD(aHeader,{	TRIM(X3Titulo()),;
							SX3->X3_CAMPO,;
							SX3->X3_PICTURE,;
							SX3->X3_TAMANHO,;
							SX3->X3_DECIMAL,;
							SX3->X3_VALID,;
							SX3->X3_USADO,;
							SX3->X3_TIPO,;
							SX3->X3_ARQUIVO,;
							SX3->X3_CONTEXT } )

			If AllTrim(SX3->X3_CAMPO) == "CR_NIVEL"
				AADD(aHeader,{ OemToAnsi(STR0003),"bCR_NOME",   "",15,0,"","","C","",""} )	//"Aprovador Responsável"
				AADD(aHeader,{ OemToAnsi(STR0004),"bCR_SITUACA","",20,0,"","","C","",""} )	//"Situação"
				AADD(aHeader,{ OemToAnsi(STR0005),"bCR_NOMELIB","",15,0,"","","C","",""} )	//"Avaliado por"
			EndIf
			
			If AllTrim(SX3->X3_CAMPO) == "CR_DATALIB"
				AADD(aHeader,{ OemToAnsi(STR0101),"bCR_GRUPO","",6,0,"","","C","",""} )	//"Grupo"
			EndIf

		Endif

		SX3->(dbSkip())
	EndDo

	ADHeadRec("SCR",aHeader)

	//Caso seja alterado a Query para não apresentar todos os campos da SCR (SELECT SCR.*), avalie o P.E A120PSCR, e adicione a tratativa igual a do PC e IP
	//para adicionar os campos trazidos através do P.E. 
	If cTipoDoc == "PC"

		cQuery    := "SELECT "
		cQuery    += "COALESCE(
		cQuery    += "(SELECT DISTINCT C7_NUM FROM " +RetSqlName("SC7")"
		cQuery    += " WHERE C7_FILIAL = '" + fwxFilial('SC7') + "' 
		cQuery    += " AND C7_NUM = '"+Padr(SC7->C7_NUM,Len(SCR->CR_NUM)) + "' AND C7_RESIDUO = 'S'), ' ' ) C7_RESIDUO, "
		cQuery    += "   SCR.CR_USER, "
		cQuery    += "   SCR.CR_TIPO, "
		cQuery    += "   SCR.CR_GRUPO, "
		cQuery    += "   SCR.CR_STATUS, "
		cQuery    += "   SCR.CR_USERLIB, "
		cQuery    += "   SCR.CR_NIVEL, "
		cQuery    += "   SCR.CR_DATALIB, "
		cQuery    += "   SCR.CR_FLUIG, "
		If Len(aCposPe) > 0
			For nP := 1 To Len(aCposPe)
				cQuery += "SCR." + aCposPe[nP] + ","
			Next nP
		EndIf 		
		cQuery    += "   SCR.R_E_C_N_O_ SCRRECNO, "		    
		cQuery    += "   SCR.CR_OBS "
		cQuery    += "FROM "+RetSqlName("SCR")+" SCR "
		cQuery    += "WHERE SCR.CR_FILIAL='"+cFilSCR+"' AND "
		cQuery    += "SCR.CR_NUM = '"+Padr(SC7->C7_NUM,Len(SCR->CR_NUM)) + "'" 

		If cAprIPPC == "1"//Verificação do parâmetro MV_APRIPPC para mostrar no log de aprovação (IP+PC)
			cQuery    += " AND SCR.CR_TIPO IN ('PC','IP') "
		Else
			cQuery    += " AND SCR.CR_TIPO = 'PC' "
		EndIf 
		cQuery    += " AND SCR.D_E_L_E_T_=' ' "

	ElseIf cTipoDoc == "AE"
		cQuery    := "SELECT SCR.*,SCR.R_E_C_N_O_ SCRRECNO FROM "+RetSqlName("SCR")+" SCR "
		cQuery    += "WHERE SCR.CR_FILIAL='"+cFilSCR+"' AND "
		cQuery    += "SCR.CR_NUM = '"+Padr(SC7->C7_NUM,Len(SCR->CR_NUM))+"' AND "
		cQuery    += "SCR.CR_TIPO = 'AE' "
		If lExAprov .And. lResid
			cQuery    += " "
		Else
			cQuery    += "AND SCR.D_E_L_E_T_=' ' "
		EndIf
	ElseIf cTipoDoc == "CP"
		cQuery    := "SELECT SCR.*,SCR.R_E_C_N_O_ SCRRECNO FROM "+RetSqlName("SCR")+" SCR "
		cQuery    += "WHERE SCR.CR_FILIAL='"+cFilSCR+"' AND "
		cQuery    += "SCR.CR_NUM = '"+Padr(SC3->C3_NUM,Len(SCR->CR_NUM))+"' AND "
		cQuery    += "SCR.CR_TIPO = 'CP' "
		If !lExAprov .Or. SC3->C3_RESIDUO != "S"
			cQuery    += "AND SCR.D_E_L_E_T_=' ' "
		EndIf
	ElseIf cTipoDoc == "NF"
		cQuery    := "SELECT SCR.*,SCR.R_E_C_N_O_ SCRRECNO FROM "+RetSqlName("SCR")+" SCR "
		cQuery    += "WHERE SCR.CR_FILIAL='"+cFilSCR+"' AND "
		cQuery    += "SCR.CR_NUM = '"+Padr(SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA,Len(SCR->CR_NUM))+"' AND "
		cQuery    += "SCR.CR_TIPO = 'NF' "
		cQuery    += "AND SCR.D_E_L_E_T_=' ' "
	ElseIf cTipoDoc == "MD"
		cQuery    := "SELECT SCR.*,SCR.R_E_C_N_O_ SCRRECNO FROM "+RetSqlName("SCR")+" SCR "
		cQuery    += "WHERE "
		If !lMdCorp
			cQuery		+= "SCR.CR_FILIAL='"+cFilSCR+"' AND "
		EndIf
		cQuery    += "SCR.CR_NUM = '"+Padr(CND->CND_NUMMED,Len(SCR->CR_NUM))+"' AND "
		cQuery    += "SCR.CR_TIPO = 'MD' "
		cQuery    += "AND SCR.D_E_L_E_T_=' ' "
	ElseIf cTipoDoc == "SC"
		cAliasSCR  := GetNextAlias()
		cQuery     := "SELECT SCR.*,DBM.DBM_ITEM,DBM.DBM_ITEMRA,DBM.DBM_APROV,SCR.R_E_C_N_O_ SCRRECNO "
		cQuery	   += "FROM "+RetSqlName("SCR")+" SCR LEFT JOIN "
		cQuery	   += RetSqlName("DBM")+" DBM ON "
		cQuery	   += "SCR.CR_TIPO=DBM.DBM_TIPO AND "
		cQuery	   += "SCR.CR_NUM=DBM.DBM_NUM AND "
		cQuery	   += "SCR.CR_GRUPO=DBM.DBM_GRUPO AND "
		cQuery	   += "SCR.CR_ITGRP=DBM.DBM_ITGRP AND "
		If MtVerTipcom(SC1->C1_NUM,cTipoDoc)
			cQuery	   += "SCR.CR_TIPCOM = DBM.DBM_TIPCOM AND "
		Endif
		cQuery	   += "SCR.CR_USER=DBM.DBM_USER AND "
		cQuery	   += "SCR.CR_USERORI=DBM.DBM_USEROR AND "
		cQuery	   += "SCR.CR_APROV=DBM.DBM_USAPRO AND "
		cQuery	   += "SCR.CR_APRORI=DBM.DBM_USAPOR AND "
		cQuery	   += "SCR.D_E_L_E_T_ = DBM.D_E_L_E_T_ "
		cQuery     += "WHERE SCR.CR_FILIAL='"+cFilSCR+"' AND "
		cQuery     += "DBM.DBM_FILIAL='"+cFilDBM+"' AND "
		cQuery     += "SCR.CR_NUM = '"+Padr(SC1->C1_NUM,Len(SCR->CR_NUM))+"' AND "
		cQuery     += "SCR.CR_TIPO = 'SC' "
		
		If (lExAprov .AND. !lResid) .OR. !lExAprov
			cQuery    += "AND SCR.D_E_L_E_T_=' ' "
		Else
			//Realiza Filtro dos Deletados Apenas para os Registros Sem C1_RESIDUO = 'S'
			cQrySC1 := "JOIN " + RetSqlName("SC1") + " SC1 "
			cQrySC1 += "	ON SC1.C1_NUM = SCR.CR_NUM "
			cQrySC1 += "	AND SC1.C1_ITEM = DBM.DBM_ITEM "
			cQrySC1 += "	AND SC1.D_E_L_E_T_ = ' ' "
			cQrySC1 += "	AND (CASE WHEN SC1.C1_RESIDUO = ' ' THEN SCR.D_E_L_E_T_ ELSE ' ' END) = ' ' "
			cQuery := StrTran(cQuery,"WHERE",cQrySC1+"WHERE")
			
			//Adiciona coluna C1_RESIDUO 
			cQuery := StrTran(cQuery,"SCR.*","SC1.C1_RESIDUO,SCR.*") 
			
			//Apresenta somente o último registro da SCR distinto para cada item (não lista registros desnecessários)
			cQuery	  += "AND SCR.R_E_C_N_O_ IN (SELECT DISTINCT MAX(SCR_.R_E_C_N_O_) "
			cQuery    += "FROM "+RetSqlName("SCR") + " SCR_ LEFT JOIN "
			cQuery	   += RetSqlName("DBM")+" DBM_ ON "
			cQuery	   += "SCR_.CR_TIPO=DBM_.DBM_TIPO AND "
			cQuery	   += "SCR_.CR_NUM=DBM_.DBM_NUM AND "
			cQuery	   += "SCR_.CR_GRUPO=DBM_.DBM_GRUPO AND "
			cQuery	   += "SCR_.CR_ITGRP=DBM_.DBM_ITGRP AND "
			cQuery	   += "SCR_.CR_USER=DBM_.DBM_USER AND "
			cQuery	   += "SCR_.CR_USERORI=DBM_.DBM_USEROR AND "
			cQuery	   += "SCR_.CR_APROV=DBM_.DBM_USAPRO AND "
			cQuery	   += "SCR_.CR_APRORI=DBM_.DBM_USAPOR AND "
			cQuery	   += "SCR_.D_E_L_E_T_ = DBM_.D_E_L_E_T_ "	
			cQuery    += "GROUP BY CR_NUM, CR_USER, CR_APROV, CR_ITGRP, CR_DATALIB, CR_USERLIB, CR_LIBAPRO, CR_GRUPO, DBM_.DBM_ITEM)"
		EndIf
	ElseIf cTipoDoc == "SA"
		cQuery    := "SELECT SCR.*,DBM.DBM_ITEM,DBM.DBM_ITEMRA,SCR.R_E_C_N_O_ SCRRECNO "
		cQuery	   += "FROM "+RetSqlName("SCR")+" SCR LEFT JOIN "
		cQuery	   += RetSqlName("DBM")+" DBM ON "
		cQuery	   += "CR_TIPO=DBM_TIPO AND "
		cQuery	   += "CR_NUM=DBM_NUM AND "
		cQuery	   += "CR_GRUPO=DBM_GRUPO AND "
		cQuery	   += "CR_ITGRP=DBM_ITGRP AND "
		cQuery	   += "CR_USER=DBM_USER AND "
		cQuery	   += "CR_USERORI=DBM_USEROR AND "
		cQuery	   += "CR_APROV=DBM_USAPRO AND "
		cQuery	   += "CR_APRORI=DBM_USAPOR "
		cQuery    += "WHERE SCR.CR_FILIAL='"+cFilSCR+"' AND "
		cQuery    += "SCR.CR_NUM = '"+Padr(SCP->CP_NUM,Len(SCR->CR_NUM))+"' AND "
		cQuery    += "SCR.CR_TIPO = 'SA' "
		If !lExAprov
			cQuery    += "AND DBM.D_E_L_E_T_=' ' "
			cQuery    += "AND SCR.D_E_L_E_T_=' ' "
		EndIf
	ElseIf cTipoDoc == "IP"
		cQuery  := "SELECT " 
		If (lExAprov .AND. lResid)
			cQuery    += "DISTINCT DBM_ITEM,"
		endif
		cQuery    += " CR_FILIAL, CR_TIPO, CR_NUM, CR_NIVEL,CR_USER,CR_GRUPO,CR_STATUS,CR_USERLIB,' 'XC7_RESIDUO,"
		cQuery	  += " CR_DATALIB, CR_ITGRP, DBM.DBM_ITEM,DBM.DBM_APROV,DBM.DBM_ITEMRA,SCR.R_E_C_N_O_ SCRRECNO "

		If Len(aCposPe) > 0
			For nP := 1 To Len(aCposPe)
				cQuery += "," + aCposPe[nP]
			Next nP
		EndIf

		cQuery	  += "FROM "+RetSqlName("SCR")+" SCR LEFT JOIN "
		cQuery	  += RetSqlName("DBM")+" DBM ON "
		cQuery    += "	 DBM.DBM_FILIAL='"+cFilDBM+"' AND "
		cQuery	  += "	 SCR.CR_TIPO=DBM.DBM_TIPO AND "
		cQuery	  += "	 SCR.CR_NUM=DBM.DBM_NUM AND "
		cQuery	  += "	 SCR.CR_GRUPO=DBM.DBM_GRUPO AND "
		cQuery	  += "	 SCR.CR_ITGRP=DBM.DBM_ITGRP AND "
		If MtVerTipcom(SC7->C7_NUM,cTipoDoc)
			cQuery	  += "	 SCR.CR_TIPCOM =DBM.DBM_TIPCOM AND "
		Endif
		cQuery	  += "	 SCR.CR_USER=DBM.DBM_USER AND "
		cQuery	  += "	 SCR.CR_USERORI=DBM.DBM_USEROR AND "
		cQuery	  += "	 SCR.CR_APROV=DBM.DBM_USAPRO AND "
		cQuery	  += "	 SCR.CR_APRORI=DBM.DBM_USAPOR "
		
		If (lExAprov .AND. !lResid) .OR. !lExAprov
			cQuery	  += " AND SCR.D_E_L_E_T_ = DBM.D_E_L_E_T_ "
			cQuery	  += " AND DBM.D_E_L_E_T_ = ' ' "
		Endif
		cQuery    += " WHERE SCR.CR_FILIAL='"+cFilSCR+"' AND "		
		cQuery    += " SCR.CR_NUM = '"+Padr(SC7->C7_NUM,Len(SCR->CR_NUM))+"' AND "
		cQuery    += " SCR.CR_TIPO IN('IP','PC')"
		If (lExAprov .AND. !lResid) .OR. !lExAprov
			cQuery    += " AND SCR.D_E_L_E_T_=' ' "
		Else
			//Realiza Filtro dos Deletados Apenas para os Registros Sem C1_RESIDUO = 'S'
			cQrySC7 := " LEFT JOIN " + RetSqlName("SC7") + " SC7 "
			cQrySC7 += "	ON SC7.C7_NUM = SCR.CR_NUM "
			cQrySC7 += "	AND SC7.C7_ITEM = DBM.DBM_ITEM "
			cQrySC7 += "	AND SC7.D_E_L_E_T_ = ' ' "
			cQrySC7 += "	AND (CASE WHEN SC7.C7_RESIDUO = ' ' THEN SCR.D_E_L_E_T_ ELSE ' ' END) = ' ' "
			cQuery := StrTran(cQuery,"WHERE",cQrySC7+"WHERE")
			
			//Adiciona coluna C7_RESIDUO 
			cQuery := StrTran(cQuery,"' 'XC7_RESIDUO,","SC7.C7_RESIDUO,")  
			
			//Apresenta somente o último registro da SCR distinto para cada item (não lista registros desnecessários)
			cQuery	  += "AND SCR.R_E_C_N_O_ IN (SELECT DISTINCT MAX(SCR_.R_E_C_N_O_) "
			cQuery    += "FROM "+RetSqlName("SCR") + " SCR_ LEFT JOIN "
			cQuery	   += RetSqlName("DBM")+" DBM_ ON "
			cQuery	   += "SCR_.CR_TIPO=DBM_.DBM_TIPO AND "
			cQuery	   += "SCR_.CR_NUM=DBM_.DBM_NUM AND "
			cQuery	   += "SCR_.CR_GRUPO=DBM_.DBM_GRUPO AND "
			cQuery	   += "SCR_.CR_ITGRP=DBM_.DBM_ITGRP AND "
			cQuery	   += "SCR_.CR_USER=DBM_.DBM_USER AND "
			cQuery	   += "SCR_.CR_USERORI=DBM_.DBM_USEROR AND "
			cQuery	   += "SCR_.CR_APROV=DBM_.DBM_USAPRO AND "
			cQuery	   += "SCR_.CR_APRORI=DBM_.DBM_USAPOR "
			If (lExAprov .AND. !lResid) .OR. !lExAprov
				cQuery	   += " AND SCR_.D_E_L_E_T_ = DBM_.D_E_L_E_T_ "	
			Endif
			cQuery	   += "AND SCR_.CR_FILIAL  = SCR.CR_FILIAL "
			cQuery	   += "AND SCR_.CR_NUM =   SCR.CR_NUM "

			cQuery    += "GROUP BY CR_NUM, CR_USER, CR_APROV, CR_ITGRP, CR_DATALIB, CR_USERLIB, CR_LIBAPRO, CR_GRUPO)"
		EndIf
	ElseIf cTipoDoc == "CT"
		cQuery    := "SELECT SCR.*,SCR.R_E_C_N_O_ SCRRECNO FROM "+RetSqlName("SCR")+" SCR "
		cQuery    += "WHERE "
		If !lCtCorp
			cQuery		+= "SCR.CR_FILIAL='"+cFilSCR+"' AND "
		EndIf
		cQuery    += "SCR.CR_NUM = '"+Padr(CN9->CN9_NUMERO+CN9->CN9_REVISA,Len(SCR->CR_NUM))+"' AND "
		cQuery    += "SCR.CR_TIPO IN ('CT','RV') "
		cQuery    += "AND SCR.D_E_L_E_T_=' ' "
	ElseIf cTipoDoc == "IC"
		cQuery    := "SELECT SCR.*,DBM.DBM_ITEM,DBM.DBM_ITEMRA,SCR.R_E_C_N_O_ SCRRECNO "
		cQuery	   += "FROM "+RetSqlName("SCR")+" SCR LEFT JOIN "
		cQuery	   += RetSqlName("DBM")+" DBM ON "
		cQuery	   += "CR_TIPO=DBM_TIPO AND "
		cQuery	   += "CR_NUM=DBM_NUM AND "
		cQuery	   += "CR_GRUPO=DBM_GRUPO AND "
		cQuery	   += "CR_ITGRP=DBM_ITGRP AND "
		cQuery	   += "CR_USER=DBM_USER AND "
		cQuery	   += "CR_USERORI=DBM_USEROR AND "
		cQuery	   += "CR_APROV=DBM_USAPRO AND "
		cQuery	   += "CR_APRORI=DBM_USAPOR AND "
		cQuery    += "DBM.D_E_L_E_T_= ' ' "
		cQuery    += "WHERE "
		If !lCtCorp
			cQuery		+= "SCR.CR_FILIAL='"+cFilSCR+"' AND "
		EndIf
		cQuery    += "SCR.CR_NUM LIKE '"+CN9->CN9_NUMERO+CN9->CN9_REVISA+"%' AND "
		cQuery    += "(SCR.CR_TIPO = 'IC' OR SCR.CR_TIPO = 'CT' )"
		cQuery    += "AND SCR.D_E_L_E_T_=' ' "
	ElseIf cTipoDoc == "IM"
		cQuery    := "SELECT SCR.*,DBM.DBM_ITEM,DBM.DBM_ITEMRA,SCR.R_E_C_N_O_ SCRRECNO "
		cQuery	   += "FROM "+RetSqlName("SCR")+" SCR LEFT JOIN "
		cQuery	   += RetSqlName("DBM")+" DBM ON "
		cQuery	   += "CR_TIPO=DBM_TIPO AND "
		cQuery	   += "CR_NUM=DBM_NUM AND "
		cQuery	   += "CR_GRUPO=DBM_GRUPO AND "
		cQuery	   += "CR_ITGRP=DBM_ITGRP AND "
		cQuery	   += "CR_USER=DBM_USER AND "
		cQuery	   += "CR_USERORI=DBM_USEROR AND "
		cQuery	   += "CR_APROV=DBM_USAPRO AND "
		cQuery	   += "CR_APRORI=DBM_USAPOR AND "
		cQuery    += "DBM.D_E_L_E_T_= ' ' "
		cQuery    += "WHERE "
		If !lMdCorp
			cQuery		+= "SCR.CR_FILIAL='"+cFilSCR+"' AND "
		EndIf
		cQuery    += "SCR.CR_NUM LIKE '"+CND->CND_NUMMED+"%' AND "
		cQuery    += "(SCR.CR_TIPO = 'IM' OR SCR.CR_TIPO = 'MD' )"
		cQuery    += "AND SCR.D_E_L_E_T_=' ' "
	ElseIf cTipoDoc == "IR"
		cQuery    := "SELECT SCR.*,DBM.DBM_ITEM,DBM.DBM_ITEMRA,SCR.R_E_C_N_O_ SCRRECNO "
		cQuery	   += "FROM "+RetSqlName("SCR")+" SCR LEFT JOIN "
		cQuery	   += RetSqlName("DBM")+" DBM ON "
		cQuery	   += "CR_TIPO=DBM_TIPO AND "
		cQuery	   += "CR_NUM=DBM_NUM AND "
		cQuery	   += "CR_GRUPO=DBM_GRUPO AND "
		cQuery	   += "CR_ITGRP=DBM_ITGRP AND "
		cQuery	   += "CR_USER=DBM_USER AND "
		cQuery	   += "CR_USERORI=DBM_USEROR AND "
		cQuery	   += "CR_APROV=DBM_USAPRO AND "
		cQuery	   += "CR_APRORI=DBM_USAPOR AND "
		cQuery    += "DBM.D_E_L_E_T_= ' ' "
		cQuery    += "WHERE "
		If !lCtCorp
			cQuery		+= "SCR.CR_FILIAL='"+xFilial("SCR")+"' AND "
		EndIf
		cQuery    += "SCR.CR_NUM LIKE '"+CN9->CN9_NUMERO+CN9->CN9_REVISA+"%' AND "
		cQuery    += "(SCR.CR_TIPO = 'IR' OR SCR.CR_TIPO = 'RV' )"
		cQuery    += "AND SCR.D_E_L_E_T_=' ' "
	ElseIf cTipoDoc $ "PV|DV"
		cQuery    := "SELECT SCR.CR_FILIAL, SCR.CR_NUM, SCR.CR_TIPO, SCR.CR_USER, SCR.CR_APROV, "
		cQuery    += "SCR.CR_NIVEL, SCR.CR_STATUS, SCR.CR_DATALIB, SCR.CR_TOTAL, SCR.CR_EMISSAO, "
		cQuery    += "SCR.CR_USERLIB, SCR.CR_OBS, SCR.CR_LIBAPRO, SCR.CR_VALLIB, SCR.CR_TIPOLIM, "
		cQuery    += "SCR.CR_WF, SCR.CR_MOEDA, SCR.CR_TXMOEDA, SCR.CR_USERORI, SCR.CR_APRORI, "
		cQuery    += "SCR.CR_GRUPO, SCR.CR_ITGRP, SCR.CR_FLUIG, SCR.CR_PRAZO, SCR.CR_AVISO, "
		cQuery    += "SCR.CR_ULTAVIS, SCR.CR_ESCALON, SCR.CR_ESCALSP, SCR.CR_NFMOTBL, SCR.CR_NFMOBLQ, "
		cQuery    += "SCR.CR_TIPCOM, SCR.D_E_L_E_T_, SCR.R_E_C_N_O_ SCRRECNO "
		cQuery    += "FROM "+RetSqlName("SCR")+" SCR "
		cQuery    += "WHERE "
		cQuery	  += "SCR.CR_FILIAL='"+FwxFilial("SCR")+"' AND "
		cQuery    += "SCR.CR_NUM = '"+Alltrim(SC5->C5_NUM)+"' AND "
		cQuery    += "SCR.CR_TIPO IN ('PV','DV') "
		cQuery    += "AND SCR.D_E_L_E_T_=' ' "
	EndIf
	cQuery += "ORDER BY "+SqlOrder(SCR->(IndexKey()))
	cQuery := ChangeQuery(cQuery)
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSCR)

	//Verifica se for pedido de compra e se parâmetro MV_EXAPROV para mostrar histórico de SRC deletada está ativo.
	//Caso não encontre registros ativos (SCR recriada quando eliminado resíduo de PC atendido parcialmente)
	//procura os registros de histórico deletado (pq SCR é deletada e não é recriada se pedido não foi atendido parcialmente)
	If cTipoDoc == "PC" .AND. !((lExAprov .AND. !lResid) .OR. !lExAprov)
		Count To nTotal
		If nTotal == 0

			(cAliasSCR)->(DbCloseArea())
			cQuery := StrTran(cQuery,"SCR.D_E_L_E_T_=' '","SCR.D_E_L_E_T_='*'")

			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSCR)
		Else
			(cAliasSCR)->(DbGoTop())
		EndIf
	EndIf

	For nX := 1 To Len(aStruSCR)
		If aStruSCR[nX][2]<>"C"
			TcSetField(cAliasSCR,aStruSCR[nX][1],aStruSCR[nX][2],aStruSCR[nX][3],aStruSCR[nX][4])
		EndIf
	Next nX

	While !(cAliasSCR)->(Eof())
		aAdd(aCols,Array(Len(aHeader)+1))

		For nX := 1 to Len(aHeader)
			If IsHeadRec(aHeader[nX][2])
				aTail(aCols)[nX] := (cAliasSCR)->SCRRECNO
			ElseIf IsHeadAlias(aHeader[nX][2])
				aTail(aCols)[nX] := "SCR"
			ElseIf aHeader[nX][02] == "bCR_NOME"
				aTail(aCols)[nX] := UsrRetName((cAliasSCR)->CR_USER)
			ElseIf aHeader[nX][02] == "bCR_ITEM"
				If lAprPCEC .Or. lAprSAEC .Or. lAprSCEC .Or. lAprCTEC .Or. lAprMDEC
					If (cAliasSCR)->CR_TIPO $ "SC|SA|IP|IC|IM"
						aTail(aCols)[nX] := AllTrim((cAliasSCR)->DBM_ITEM) + IIF(!Empty((cAliasSCR)->DBM_ITEMRA),"-"+(cAliasSCR)->DBM_ITEMRA,"")
					Else
						aTail(aCols)[nX] := Replicate("-",8)
					Endif
				Endif
			ElseIf aHeader[nX][02] == "bCR_GRUPO"
				aTail(aCols)[nX] := (cAliasSCR)->CR_GRUPO
			ElseIf aHeader[nX][02] == "bCR_SITUACA"
				Do Case
					Case ((cAliasSCR)->CR_TIPO = "SC" .OR. (cAliasSCR)->CR_TIPO = "IP") .And. (cAliasSCR)->CR_STATUS == "01" .And. (cAliasSCR)->DBM_APROV == "1"
						cSituaca := OemToAnsi(STR0008) //"Aprovado"
					Case (cAliasSCR)->CR_STATUS == "01"
						cSituaca := OemToAnsi(STR0006) //"Pendente em níveis anteriores"
						If cStatus == STR0087 //"Documento aprovado"
							cStatus := STR0088 //"Aguardando liberação(ões)"
						EndIf
					Case ((cAliasSCR)->CR_TIPO = "SC" .OR. (cAliasSCR)->CR_TIPO = "IP") .And. (cAliasSCR)->CR_STATUS == "02" .And. (cAliasSCR)->DBM_APROV == "1"
						cSituaca := OemToAnsi(STR0008) //"Aprovado"
					Case (cAliasSCR)->CR_STATUS == "02"
						cSituaca := OemToAnsi(STR0007) //"Pendente"
						If cStatus == STR0087 //"Documento aprovado"
							cStatus := STR0088 //"Aguardando liberação(ões)"
						EndIf
					Case (cAliasSCR)->CR_STATUS == "03"
						cSituaca := OemToAnsi(STR0008) //"Aprovado"
					Case (cAliasSCR)->CR_STATUS == "04"
						cSituaca := OemToAnsi(STR0099) //"Bloqueado"
						If cStatus # STR0100 //"Documento aprovado"
							cStatus := STR0100 //"Documento bloqueado"
						EndIf
					Case (cAliasSCR)->CR_STATUS == "05"
						cSituaca := OemToAnsi(STR0016) //"Aprovado/rejeitado pelo nível"
					Case (cAliasSCR)->CR_STATUS == "06"
						cSituaca := STR0085	//"Rejeitado"
						If cStatus # STR0089 //"Documento rejeitado"
							cStatus := STR0089 //"Documento rejeitado"
						EndIf
					Case (cAliasSCR)->CR_STATUS == "07"
						cSituaca := STR0107	//"Rejeitado/bloqueado por outro usuário"
						If cStatus # STR0089 //"Documento rejeitado"
							cStatus := STR0089//"Documento rejeitado"
						EndIf						
				EndCase
				
				If cTipoDoc == "SC" .AND. !((lExAprov .AND. !lResid) .OR. !lExAprov)
					If (cAliasSCR)->(FieldPos("C1_RESIDUO"))>0 .AND. !Empty((cAliasSCR)->C1_RESIDUO)
						If !(STR0102 $ cStatus)
							cStatus	:= STR0102 + cStatus //"Elim.Resíduo/" + Status
						Endif
						cSituaca 	:= STR0102 + cSituaca //"Elim.Resíduo/" + Situação
					EndIf
				ElseIf cTipoDoc $ "IP|PC" .AND. (cAliasSCR)->(FieldPos("C7_RESIDUO"))>0 .AND. !Empty((cAliasSCR)->C7_RESIDUO)
						If !(STR0102 $ cStatus)
							cStatus	:= STR0102 + cStatus //"Elim.Resíduo/" + Status
						Endif
						cSituaca 	:= STR0102 + cSituaca //"Elim.Resíduo/" + Situação 
				EndIf
				
				aTail(aCols)[nX] := cSituaca
			ElseIf aHeader[nX][02] == "bCR_NOMELIB"
				aTail(aCols)[nX] := UsrRetName((cAliasSCR)->CR_USERLIB)
			ElseIf Alltrim(aHeader[nX][02]) == "CR_OBS"//Posicionar para ler
				SCR->(dbGoto((cAliasSCR)->SCRRECNO))
				aTail(aCols)[nX] := SCR->CR_OBS
			ElseIf ( aHeader[nX][10] != "V")
				aTail(aCols)[nX] := FieldGet(FieldPos(aHeader[nX][2]))
			EndIf
		Next nX
		aTail(aCols)[Len(aHeader)+1] := .F.

		(cAliasSCR)->(dbSkip())
	EndDo

	If !Empty(aCols)
		n:=	 IIF(n > Len(aCols), Len(aCols), n)  // Feito isto p/evitar erro fatal(Array out of Bounds).
		DEFINE FONT oBold NAME "Arial" SIZE 0, -12 BOLD
		DEFINE MSDIALOG oDlg TITLE cTitle From 109,095 To 400,600 OF oMainWnd PIXEL	 //"Aprovacao do Pedido de Compra // Contrato"
		@ 005,003 TO 032,250 LABEL "" OF oDlg PIXEL
		If !(cTipoDoc $ "MD|RV|CT|IC|IM")
			@ 015,007 SAY cTitDoc OF oDlg FONT oBold PIXEL SIZE 046,009 // "Pedido" / "Contrato" / "Nota Fiscal"
			@ 014,041 MSGET cNumDoc PICTURE "" WHEN .F. PIXEL SIZE 150,009 OF oDlg FONT oBold
	        If !(cTipoDoc $ "NF|PV|DV")
				@ 015,095 SAY Iif(cTipoDoc$"SC|SA",STR0105,OemToAnsi(STR0013)) OF oDlg PIXEL SIZE 045,009 FONT oBold //105 -> "Solicitante " 013->"Comprador"
				@ 014,138 MSGET cComprador PICTURE "" WHEN .F. of oDlg PIXEL SIZE 103,009 FONT oBold
	        EndIF
	   	Else
			@ 015,007 SAY cTitDoc OF oDlg FONT oBold PIXEL SIZE 046,009 // "Medicao"
			@ 014,035 MSGET cNumDoc PICTURE "" WHEN .F. PIXEL SIZE 50,009 OF oDlg FONT oBold

			@ 015,095 SAY cAprovador OF oDlg PIXEL SIZE 045,009 FONT oBold //"Aprovador"
			@ 014,138 MSGET cComprador PICTURE "" WHEN .F. of oDlg PIXEL SIZE 103,009 FONT oBold
	   	EndIf

		@ 132,008 SAY STR0030 OF oDlg PIXEL SIZE 052,009 //'Situacao :'
		@ 132,038 SAY cStatus OF oDlg PIXEL SIZE 120,009 FONT oBold
		@ 132,205 BUTTON STR0031 SIZE 035 ,010  FONT oDlg:oFont ACTION (oDlg:End()) OF oDlg PIXEL  //'Fechar'
		oGet:= MSGetDados():New(038,003,120,250,nOpcx,,,"")
		oGet:Refresh()
		@ 126,002 TO 127,250 LABEL "" OF oDlg PIXEL
		ACTIVATE MSDIALOG oDlg CENTERED
	Else
		Aviso(STR0032,cHelpApv,{STR0034}) //"Atencao"###"Este pedido nao possui controle de aprovacao."###"Voltar"
	EndIf

	(cAliasSCR)->(dbCloseArea())

	If lStatus
		aHeader := aClone(aSavHead)
		aCols := aClone(aSavCols)
		N := nSavN
	EndIf
Else
	Aviso(STR0032,cHelpApv,{STR0034}) //"Atencao"###"Este Documento nao possui controle de aprovacao."###"Voltar"
EndIf

dbSelectArea(cAlias)
RestArea(aArea)

Return NIL

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³UserPesqui³ Autor ³ Edson Maricate        ³ Data ³13.11.2000³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Cria uma tela de pesquisa para utilizacao nos ListBox de   ³±±
±±³          ³ usuarios e grupos de usuarios.                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe e ³ Void UserPesqui(ExpA1,ExpN1,ExpA2,Expo1,ExpC1,Expo2)       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpA1 = Array com as posicoes                              ³±±
±±³          ³ ExpN1 = Numero do posicao                                  ³±±
±±³          ³ ExpA2 = Array com os Nomes                                 ³±±
±±³          ³ Expo1 = Objeto                                             ³±±
±±³          ³ ExpC1 = Titulo                                             ³±±
±±³          ³ Expo2 = Objeto da Dialogo                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA085,MATA095,MATA086                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function UserPesqui(aPos,nPos,aNames,oObj,cTitle,oJanela)

Local oDlgSeek
Local lCase		:= .F.
Local lWord		:= .F.
Local lChg		:= .F.
Local lReturn	:= .F.
Local nBefore	:= nPos
Local cSeek		:= Space(20)
Local aCoors	:= Array(4)

If aPos == Nil
	oJanela:CoorsUpdate()
	aCoors[1] := oJanela:nTop+90
	aCoors[2] := oJanela:nLeft+80
	aCoors[3] := aCoors[1]+130
	aCoors[4] := aCoors[2]+370
Else
	aCoors[1] := aPos[1]
	aCoors[2] := aPos[2]
	aCoors[3] := aCoors[1]+130
	aCoors[4] := aCoors[2]+370
EndIf

DEFINE MSDIALOG oDlgSeek FROM aCoors[1],aCoors[2] TO aCoors[3],aCoors[4] TITLE  STR0020+ cTitle PIXEL  //"Localizar - "

@07,02 SAY STR0021 OF oDlgSeek PIXEL  //"Localizar:"
@05,30 GET cSeek OF oDlgSeek PIXEL SIZE 100,9

@05,135 BUTTON STR0026 PIXEL OF oDlgSeek SIZE 44,11;  //"&Próximo"
	ACTION (nPos := ListBoxSeek(cSeek,nPos,aNames,lCase,lWord),oObj:Refresh())

@20,02 TO 62,130 LABEL STR0022 PIXEL OF oDlgSeek  //"Opções"
@27,05 CHECKBOX lCase PROMPT STR0023 FONT oDlgSeek:oFont PIXEL SIZE 80,09  //"&Coincidir maiúsc./minúsc."
@38,05 CHECKBOX lWord PROMPT STR0024 FONT oDlgSeek:oFont PIXEL SIZE 80,09  //"Localizar palavra &inteira"
@49,05 CHECKBOX lChg PROMPT STR0025 FONT oDlgSeek:oFont PIXEL SIZE 80,09  //"Localizar e &alterar"


@18,135 BUTTON STR0027 PIXEL ACTION (lReturn := .T.,oDlgSeek:End()) OF oDlgSeek SIZE 44,11 //"OK"
@31,135 BUTTON STR0028 PIXEL ACTION oDlgSeek:End() OF oDlgSeek SIZE 44,11  //"&Cancelar"

ACTIVATE MSDIALOG oDlgSeek

If lReturn
	lReturn := lChg
Else
	nPos := nBefore
	oObj:Refresh()
EndIf
Return lReturn

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ListBoxSeek³ Autor ³ Edson Maricate       ³ Data ³13.11.2000³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Procura a palavra de acordo com os parametros.             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ UserPesqui()                                               ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function ListBoxSeek(cGet,nLastSeek,aArray,lCase,lWord)
Local nSearch := 0
Local bSearch

cGet := Trim(cGet)

If ( lCase .And. lWord )
	bSearch := {|x| Trim(x) == cGet}
ElseIf ( !lCase .And. !lWord )
	bSearch := {|x| Trim(Upper(SubStr(x,1,Len(cGet)))) == Upper(cGet)}
ElseIf ( lCase .And. !lWord )
	bSearch := {|x| Trim(SubStr(x,1,Len(cGet))) == cGet}
ElseIf ( !lCase .And. lWord )
	bSearch := {|x| Trim(Upper(x)) == Upper(cGet)}
EndIf

nSearch := Ascan(aArray,bSearch,nLastSeek+1)
If ( nSearch == 0 )
	nSearch := Ascan(aArray,bSearch)
	If ( nSearch == 0 )
		nSearch := nLastSeek
	EndIf
EndIf
Return nSearch

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ MaSalAlc ³ Autor ³ Edson Maricate        ³ Data ³29.10.1998³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna o saldo do aprovador.                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe e ³ Void MaSalAlc(ExpC1,ExpD1,ExpL1)                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Codigo do Aprovador                                ³±±
±±³          ³ ExpD1 = Data de referencia para o saldo                    ³±±
±±³          ³ ExpL1 = Criar saldo inicial do aprovador?                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MaSalAlc(cAprov,dDataRef,lCriaSld)
Local aAreaSCS  := SCS->(GetArea())
Local nSavRec	:= 1
Local nSaldo	:= 0
Local dDtSaldo	:= MaAlcDtRef(cAprov,dDataRef)
Local nMoeda	:= 1
Local aRet097SLD := {}
DEFAULT lCriaSld	:= .T.

dbSelectArea("SCS")
nSavRec := SCS->(RecNo())
SCS->(dbSetOrder(2))

dbSelectArea("SAK")
SAK->(dbSetOrder(1))
SAK->(dbSeek(xFilial("SAK") + cAprov))

If SCS->(dbSeek(xFilial("SCS") + cAprov + DTOS(dDtSaldo)))
	nSaldo := SCS->CS_SALDO
	nMoeda := SCS->CS_MOEDA
Else
	If lCriaSld
		Reclock("SCS",.T.)
		SCS->CS_FILIAL := xFilial("SCS")
		SCS->CS_COD		:= SAK->AK_USER
		SCS->CS_APROV	:= SAK->AK_COD
		SCS->CS_DATA	:= dDtSaldo
		SCS->CS_SALDO	:= SAK->AK_LIMITE
		SCS->CS_MOEDA	:= SAK->AK_MOEDA
		MsUnlock()
	EndIf
	nSaldo	:=  SAK->AK_LIMITE
	nMoeda	:=  SAK->AK_MOEDA
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ P.E. para manipular o Saldo, a Moeda e a Data pelo Usuario.  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock("MT097SLD")
	aRet097SLD := ExecBlock("MT097SLD",.F.,.F.,{nSaldo,nMoeda,dDtSaldo})
	If ValType( aRet097SLD ) == "A"
		nSaldo   := aRet097SLD[1]
		nMoeda   := aRet097SLD[2]
        dDtSaldo := aRet097SLD[3]
	EndIf
EndIf

SCS->(MsGoto(nSavRec))

RestArea(aAreaSCS)

Return {nSaldo,nMoeda,dDtSaldo}

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ MaAlcDoc ³ Autor ³ Aline Correa do Vale  ³ Data ³07.08.2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Controla a alcada dos documentos (SCS-Saldos/SCR-Bloqueios)³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ MaAlcDoc(ExpA1,ExpD1,ExpN1,ExpC1,ExpL1)               	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpA1 = aDocto - Array com informacoes do documento        ³±±
±±³          ³       [1] Numero do documento                              ³±±
±±³          ³       [2] Tipo de Documento                                ³±±
±±³          ³           AE: Autorização de Entrega                       ³±±
±±³          ³           CO: Cotações                                     ³±±
±±³          ³           CP: Contrato de Parceria                         ³±±
±±³          ³           NF: Nota Fiscal                                  ³±±
±±³          ³           PC: Pedido de Compras                            ³±±
±±³          ³           SA: Solicitações de Armazenagem                  ³±±
±±³          ³           SC: Solicitações de Compras                      ³±±
±±³          ³           ST: Solicitação de Transferência                 ³±±
±±³          ³           IP: Item do Pedido de Compras                    ³±±
±±³          ³           CT: Tipo do Contrato                             ³±±
±±³          ³           IC: Item Contrato                                ³±±
±±³          ³           RV: Tipo do Contrato - Revisão                   ³±±
±±³          ³           IR: Item Contrato - Revisão                      ³±±
±±³          ³           MD: Medições                                     ³±±
±±³          ³           IM: Item Medições                                ³±±
±±³          ³           GA: Documento de Garantia                        ³±±
±±³          ³           A1->A9: Documento do Agroindustria               ³±±
±±³          ³       [3] Valor do Documento                               ³±±
±±³          ³       [4] Codigo do Aprovador                              ³±±
±±³          ³       [5] Codigo do Usuario                                ³±±
±±³          ³       [6] Grupo do Aprovador                               ³±±
±±³          ³       [7] Aprovador Superior                               ³±±
±±³          ³       [8] Moeda do Documento                               ³±±
±±³          ³       [9] Taxa da Moeda                                    ³±±
±±³          ³      [10] Data de Emissao do Documento                     ³±±
±±³          ³      [11] Grupo de Compras                                 ³±±
±±³          ³      [12] Aprovador Original                               ³±±
±±³          ³      [13] Chave do Registro Aprovado	                      ³±±
±±³          ³ ExpD1 = dDataRef - Data de referencia para o saldo         ³±±
±±³          ³ ExpN1 = nOper - Operacao a ser executada                   ³±±
±±³          ³       1 = Inclusao do documento                            ³±±
±±³          ³       2 = Transferencia para Superior                      ³±±
±±³          ³       3 = Exclusao do documento                            ³±±
±±³          ³       4 = Aprovacao do documento                           ³±±
±±³          ³       5 = Estorno da Aprovacao                             ³±±
±±³          ³       6 = Bloqueio Manual da Aprovacao                     ³±±
±±³          ³       7 = Rejeicão do documento		                      ³±±
±±³          ³ ExpC1 = cDocSF1-Chave(Alternativa) do SF1 para exclusao SCR³±±
±±³          ³ ExpL1 = lResiduo - Eliminacao de Residuos                  ³±±
±±³          ³ ExpC2 = cItGrp-Item Grupo Compras-Entidade Contábil DBM/DBL³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function MaAlcDoc(aDocto,dDataRef,nOper,cDocSF1,lResiduo,cItGrp,aItens,lEstCred,aItensDBM,cChaveRej,lAprovSup,lVlrAlt,aItPedVinc,lItDel)
Local cDocto		:= aDocto[1]
Local cTipoDoc		:= aDocto[2]
Local nValDcto		:= aDocto[3]
Local cAprov		:= If(aDocto[4]==Nil,"",aDocto[4]) 
Local cUsuario		:= If(aDocto[5]==Nil,"",aDocto[5])
Local nMoeDcto		:= If(Len(aDocto)>7,If(aDocto[8]==Nil, 1,aDocto[8]),1)
Local nTxMoeda		:= If(Len(aDocto)>8,If(aDocto[9]==Nil, 0,aDocto[9]),0)
Local cObs      	:= If(Len(aDocto)>10,If(aDocto[11]==Nil, "",aDocto[11]),"")
Local aArea			:= GetArea()
Local aAreaSCS		:= SCS->(GetArea())
Local aAreaSCR		:= SCR->(GetArea())
Local aRetPe		:= {}
Local aRetDBM		:= {.F.,0,0,0}
Local nSaldo		:= 0
Local nCount    	:= 1
Local cGrupo		:= If(aDocto[6]==Nil,"",aDocto[6])
Local lFirstNiv		:= .T.
Local cAuxNivel		:= ""
Local cNextNiv 		:= ""
Local cNivIgual		:= ""
Local cStatusAnt	:= ""
Local cAprovOri 	:= ""
Local cUserOri  	:= ""
Local cObsBloq  	:= STR0061
Local lAchou		:= .F.
Local nRec			:= 0
Local lRetorno		:= .T.
Local aSaldo		:= {}
Local aMTALCGRU 	:= {}
Local lDeletou  	:= .F.
Local lBloqueio 	:= .F.
Local dDataLib 		:= IIF(dDataRef==Nil,dDataBase,dDataRef)
Local cSCRStatus	:= "03"
Local lIntegDef  	:= FWHasEAI("MATA120",.T.,,.T.)
Local lAltpdoc		:= SuperGetMv("MV_ALTPDOC",.F.,.F.)
Local lCnAglFlg		:= SuperGetMV("MV_CNAGFLG",.F.,.F.)
Local lNfLimAl		:= SuperGetMV("MV_NFLIMAL",.F.,.F.)
Local cPerfAlc		:= SuperGetMV("MV_PERFALC",.F.,"1")
Local lTipoDoc		:= .T.
Local lFluig		:= SuperGetMV("MV_APWFECM",.F.,"1") == "1" .And. !Empty(AllTrim(GetNewPar("MV_ECMURL",""))) .And. FWWFFluig()
Local lBlqNivel 	:= .F.
Local cGrupoSAL		:= ""
Local cAprovDBM		:= ""
Local cMTALCAPR		:= ""
Local lUserNiv		:= .F. //Verifica se existe usuário no mesmo nível - Tipo de Lib por Usuário
Local lCalMta235 	:= FwIsInCallStack("MATA235") .Or. FwIsInCallStack("PO400ZERA")
Local lCall235		:= FwIsInCallStack("MATA235")
Local lRecAlc    	:= FwIsInCallStack("MATA235") .or. FwIsInCallStack("MATA120")
Local lCalAppMob 	:= FwIsInCallStack("PUT_APPROVALORDERPC")
Local dPrazo		:= Ctod("//")
Local dAviso		:= Ctod("//")
Local nRecAprov		:= 0
Local lEscalona 	:= .F.
Local lEscalonaS	:= .F.
Local lRetCr 		:= .T.
Local cFilSCR		:= IIf(cTipoDoc $ 'IC|CT|IR|RV',CnFilCtr(cDocto),xFilial("SCR"))
Local lNewFlg		:= .F.
Local nPosDoc		:= 0
Local lIpAprEC		:= SuperGetMv("MV_IPAPREC",.F.,.F.) // Liberação/Rejeição por grupo de aprovação
Local lEasy		    := SuperGetMV("MV_EASY",.F.,"N") == "S"
Local lHistApr   	:= SuperGetMV("MV_HISTAPC",.T.,.F.)
Local cEventId		:= "075" //Evento email para o proximo aprovador.
Local cUser075		:= ""
Local lEvent75		:= .F.
Local cMsg075		:= ""
Local cBkpUsr075	:= ""
Local cQuery		:= ""
Local cAliasS7		:= GetNextAlias()
Local cAliasSR		:= GetNextAlias()
Local nRecnoSCR		:= 0
Local lHistSCR		:= .T. //Afirma se na eliminação por resíduo, o aprovador a ser recriado já existia na alçada histórica.
Local lMTALCAPR		:= ExistBlock("MTALCAPR")
Local lMTALCALT		:= ExistBlock("MTALCALT")
Local lMtUsrSolic	:= ExistBlock('MtUsrSolic')   // Função Fluig (descontinuado)
Local lMTSoliCAT	:= ExistBlock('MTSoliCAT')    // Função Fluig (descontinuado)
Local lLowR033		:= GetRPORelease() < "12.1.033"
Local lFMtUsrSolic	:= FindFunction('MtUsrSolic') .And. lLowR033
Local lFMTSoliCAT	:= FindFunction('MTSoliCAT')  .And. lLowR033
Local lMTALCGRU		:= ExistBlock("MTALCGRU")
Local cAprovSCR		:= ""
Local cQry			:= ""
Local nTpDoc  		:= 0
Local lModoTab	    := FwSX2Util():GetSX2data("SCR",{"X2_MODO"})[1][2] == 'C'  .OR. FwSX2Util():GetSX2data("SC7",{"X2_MODO"})[1][2] == 'C'
Local nX 			:= 1
Local nY			:= 0
Local aRetUser 		:= {}
Local cItDBM 		:= ""
Local lNfMotBloq	:= SCR->(FIELDPOS("CR_NFMOBLQ")) > 0 //Guarda o motivo de bloqueio da NF
Local lPO400        := lEasy .AND. FwIsInCallStack("EICPO400")
Local cTpComp		:= ""
Local lPosCrTipo    := SCR->(FieldPos("CR_TIPCOM")) > 0
Local cTipCom		:= ""
Local aAreaSCRSaldo := SCR->(GetArea())
Local nLimSaldo		:= 0
Local cAprDoSup		:= ""
Local cUsrIOrg      := ""
Local cAprIOrg      := ""
Local cAliasTmp		:= ""
Local cChvApr       := If(Len(aDocto)>12,IF(aDocto[13]==Nil,"",aDocto[13]),"")
Local nRecSCR       := 0
Local cTamCRFil     := TAMSX3('CR_FILIAL')[1]
Local cTamCRTip     := TAMSX3('CR_TIPO')[1]
Local cTamCRNum		:= TAMSX3('CR_NUM')[1]
Local cTamCRApv     := TAMSX3('CR_APROV')[1]
Local cTamCRGrp     := TAMSX3('CR_GRUPO')[1]
Local cTamCRItGrp   := TAMSX3('CR_ITGRP')[1]
Local cTamCRUsOr	:= TAMSX3('CR_USERORI')[1]
Local cTamCRApO     := TAMSX3('CR_APRORI')[1]
Local nChUsrOr      := cTamCRFil+cTamCRTip+cTamCRNum+cTamCRApv+cTamCRGrp+cTamCRItGrp
Local nCHApOri      := cTamCRFil+cTamCRTip+cTamCRNum+cTamCRApv+cTamCRGrp+cTamCRItGrp+cTamCRUsOr
Local lAprovAbsence := FindFunction('A230GetAbsence')
Local lHasAbsence   := .F.
Local lSCRTpTran 	:= SCR->(FieldPos('CR_TPTRAN')) > 0
Local oJsonAbsence  := JsonObject():New()
Local oQuery  		:= Nil
Local nLen			:= 0
Local lPeMt97Grv 	:= ExistBlock("MT097GRV")
Local lMt97Grv 		:= .T.
Local cLibVer		:= FWLibVersion()
Local cQryStat      := Nil
Local cQrySUP       := ""
Local oQrySup       := Nil
Local cQryHist      := ""
Local oQryHist      := Nil

PRIVATE cA120Num 	:= ""

DEFAULT dDataRef  	:= dDataBase
DEFAULT cDocSF1   	:= cDocto
DEFAULT lResiduo  	:= .F.
DEFAULT cItGrp	  	:= ""
DEFAULT aItens	  	:= {}
DEFAULT lEstCred  	:= .T.
DEFAULT cChaveRej 	:= ""
DEFAULT lAprovSup 	:= .F.
DEFAULT lVlrAlt   	:= .F.
DEFAULT aItPedVinc  := {}
DEFAULT lItDel		:= .F.

cDocto  := cDocto+Space(Len(SCR->CR_NUM)-Len(cDocto))
cDocSF1	:= cDocSF1+Space(Len(SCR->CR_NUM)-Len(cDocSF1))

if lPO400 .AND. FindFunction("EicAlcada") 
	lRetorno := EicAlcada()//Verifica se o parâmetro está habilitado para o controle de alçada
ENDIF

If lPeMt97Grv
	lRetorno := (Execblock("MT097GRV",.F.,.F.,{aDocto,dDataRef,nOper,cDocSF1,lResiduo,cAprov,cUsuario,cGrupo})) 
	If Valtype( lRetorno ) <> "L"
		lRetorno := .T.
	Else 
		lMt97Grv := lRetorno
	EndIf
Endif

If type("aDocRelib") == "U"
	 aDocRelib := {}
EndIf

If type("lRelib") == "U"
	 lRelib := .F.
EndIf


If lRetorno

	If Empty(cUsuario) .And. (nOper != 1 .And. nOper != 6) //nao e inclusao ou estorno de liberacao
		dbSelectArea("SAK")
		SAK->(dbSetOrder(1))
		SAK->(MsSeek(xFilial("SAK") + cAprov))
		cUsuario :=	AK_USER
		SAL->(DbSetOrder(1))
		If SAL->(DbSeek(xFilial("SAL")+cGrupo+cUsuario))
			DHL->(DbSetOrder(1))
			If DHL->(DbSeek(xFilial("DHL") + SAL->AL_PERFIL))
				nMoeDcto := DHL->DHL_MOEDA
			Else
				nMoeDcto :=	AK_MOEDA
			Endif
		Else
			nMoeDcto :=	AK_MOEDA
		EndIf
		nTxMoeda	:=	0
	EndIf
	
	If nOper == 1  //Inclusao do Documento
	
		cGrupo := If(!Empty(aDocto[6]),PadR(aDocto[6], TamSX3("AL_COD")[1]),PadR(cGrupo, TamSX3("AL_COD")[1]))
		dbSelectArea("SAL")
		SAL->(dbSetOrder(2))
		If !Empty(cGrupo) .And. SAL->(MsSeek(xFilial("SAL",cFilAnt)+cGrupo))
			If lAltpdoc
				Do Case
				Case cTipoDoc == "AE"
					lTipoDoc := SAL->AL_DOCAE == .T.
				Case cTipoDoc == "CP"
					lTipoDoc := SAL->AL_DOCCP == .T.
				Case cTipoDoc == "NF"
					lTipoDoc := SAL->AL_DOCNF == .T.
				Case cTipoDoc == "PC"
					lTipoDoc := SAL->AL_DOCPC == .T.
				Case cTipoDoc == "SA"
					lTipoDoc := SAL->AL_DOCSA == .T.
				Case cTipoDoc == "SC"
					lTipoDoc := SAL->AL_DOCSC == .T.
				Case cTipoDoc == "ST"
					lTipoDoc := SAL->AL_DOCST == .T.
				Case cTipoDoc == "IP"
					lTipoDoc := SAL->AL_DOCIP == .T.
				Case cTipoDoc $ "CT|IC"
					lTipoDoc := SAL->AL_DOCCT == .T.
				Case cTipoDoc $ "RV|IR"
					lTipoDoc := SAL->AL_DOCCT == .T.
				Case cTipoDoc $ "MD|IM"
					lTipoDoc := SAL->AL_DOCMD == .T.
				Case cTipoDoc == "GA"
					lTipoDoc := SAL->AL_DOCGA == .T.
                Case cTipoDoc >= "A1" .AND. cTipoDoc <= "A9" //Documentos Agro
					lTipoDoc := AGRXCOM12(SAL->AL_AGRCNNG, cTipoDoc, cGrupo)
				Case cTipoDoc == "PV"	//Faturamento - Pedido de Venda
					lTipoDoc := SAL->AL_DOCPV == .T.
				Case cTipoDoc == "DV"	//Faturamento - Pedido de Venda com desconto
					lTipoDoc := SAL->AL_DOCDV == .T.
				End
			EndIf

			If !_lWizard
				cQuery := " SELECT SUM(C7_QUANT) - SUM(C7_QUJE) SALDO "
				cQuery += " FROM "+ RetSqlName("SC7")
				cQuery += " WHERE "
				cQuery += " C7_FILIAL = ? AND "	
				cQuery += " C7_NUM = ? AND "
				cQuery += " C7_FORNECE = ?  AND "
				cQuery += " C7_LOJA = ?  AND  "
				cQuery += " D_E_L_E_T_ = ' ' " 

				oQuery := FWPreparedStatement():New(cQuery)

				oQuery:SetString(1, Iif(lModoTab, xFilial("SC7"), cFilSCR))
				oQuery:SetString(2, cDocto)
				oQuery:SetString(3, SC7->C7_FORNECE)
				oQuery:SetString(4, SC7->C7_LOJA)

				MpSysOpenQuery(oQuery:getFixQuery(), cAliasS7)
				
				If !lCalMta235 .AND. (cAliasS7)->SALDO <> 0
					aDocRelib := {}
				Else
					lRelib := .T.					
				Endif

				(cAliasS7)->(dbCloseArea())
				FreeObj(oQuery)
			EndIf


			SAK->(dbSetOrder(1))

			If _lWizard //-- Garante que a propriedade items existirá quando a execução for via Wizard.
				_oJsonWizard['items'] := {}
			EndIf

			While !SAL->(Eof()) .And. xFilial("SAL",cFilAnt)+cGrupo == SAL->(AL_FILIAL+AL_COD) .And. lTipoDoc
				dPrazo		:= Ctod("//")
				dAviso  	:= Ctod("//")
				nValDcto	:= IIF(nValDcto==0,aDocto[3],nValDcto)//Tratamento para não zerar o valor do documento							

				//-- Verifica se o Registro esta Bloqueado				
				If !RegistroOk("SAL",.F.) .Or. SAK->(! dbSeek(xFilial("SAK")+SAL->AL_APROV )) .Or. !RegistroOk("SAK",.F.)
					SAL->(dbSkip())
					Loop
				EndIf
				
				If  (!cTipoDoc $ "NF|PC|IP" .Or. lNfLimAl) .And. ( cTipoDoc != "SC" .Or. (cTipoDoc == "SC" .And. cPerfAlc == "1") )
					If SAL->AL_AUTOLIM == "S" .And. !MaAlcLim(SAL->AL_APROV,nValDcto,nMoeDcto,nTxMoeda,cGrupo)
						SAL->(dbSkip())
						Loop
					EndIf
				EndIf  
		
				Do Case
				Case cTipoDoc == "NF"
					SF1->(FkCommit())
				Case cTipoDoc == "PC" .Or. cTipoDoc == "AE"
					SC7->(FkCommit())
				Case cTipoDoc == "CP"
					SC3->(FkCommit())
				Case cTipoDoc == "SC"
					SC1->(FkCommit())
				Case cTipoDoc == "CO"
					SC8->(FkCommit())
				Case cTipoDoc == "MD"
					CND->(FkCommit())
				EndCase

				If lAprovAbsence //-- Ausência do aprovador
					oJsonAbsence := A230GetAbsence(SAL->AL_APROV, SAL->AL_USER)
					lHasAbsence := oJsonAbsence['hasAbsence']
				EndIf

				If lHasAbsence //-- Altera para aprovador substituto
					cAprovOri := oJsonAbsence['DKJ_APRSUB']
					cAprIOrg  := oJsonAbsence['DKJ_APRORI']
					cUserOri  := oJsonAbsence['DKJ_USRSUB']
					cUsrIOrg  := oJsonAbsence['DKJ_USRORI']
				Else
					cAprovOri := SAL->AL_APROV
					cUserOri  := SAL->AL_USER
				EndIf
				
				//-- Ponto de entrada para troca do usuario aprovador
				If lMTALCAPR .And. !lHasAbsence
					SAK->(dbSetOrder(2))
					If ValType(cMTALCAPR := ExecBlock("MTALCAPR",.F.,.F.,{cTipoDoc,cDocto,nValDcto,dDataRef})) == "C" .And.;
										SAK->(MsSeek(xFilial("SAK")+cMTAlCAPR))
						cAprovOri := SAK->AK_COD
						cUserOri := SAK->AK_USER
					EndIf
					SAK->(dbSetOrder(1))
				EndIf

				If (cTipoDoc $ "IP|SC" .And. cPerfAlc <> "2") .Or. cTipoDoc == "PC"
					If SAL->AL_AUTOLIM == "S" .And. !MaAlcLim(SAL->AL_APROV,nValDcto,nMoeDcto,nTxMoeda,cGrupo)
						SAL->(dbSkip())
						Loop
					EndIf
				EndIf

				//-- Gravacao dos itens da alcada
				If !Empty(aItens) .And. !(cTipoDoc $ "AE|PC")
					aRetDBM := MaAlcItEC(cDocto,cTipoDoc,cGrupo,cItGrp,cUserOri,aItens,,nOper,cAprovOri,,@aItensDBM,SAL->AL_APROV,nMoeDcto)

					If aRetDBM[1]
						nValDcto 	:= aRetDBM[2]
						dPrazo		:= dDatabase + aRetDBM[3]
						dAviso  	:= dPrazo - aRetDBM[4]
						lEscalona	:= aRetDBM[5]
						lEscalonaS	:= aRetDBM[6]
						cTpComp     := aRetDBM[7]
					Else
						dbSelectArea("SAL")
						dbSkip()
						Loop
					EndIf					
				Elseif cTipoDoc == "PC" .And. !lVlrAlt
					aItens 	:= MaRetItDoc(aDocto[1],xFilial("SC7"),"SC7","PC")
					nValDcto 	:= MaAlcItApG(cDocto,cTipoDoc,cGrupo,cUserOri,aItens,nOper,cAprovOri)
				ElseIf cTipoDoc == "AE" .And. !lVlrAlt
					aItens 	:= MaRetItDoc(aDocto[1],xFilial("SC7"),"SC7","AE")
					nValDcto 	:= MaAlcItApG(cDocto,cTipoDoc,cGrupo,cUserOri,aItens,nOper,cAprovOri)
				EndIf

				If !(IsGctDoc(cTipoDoc)) .And. !_lWizard
					// Nao gera alcada com valor zerado, exceto SC ou chamada via Wizard
					If cTipoDoc <> "NF" .And. cTipoDoc <> "SC" .And. nValDcto == 0
						SAL->(dbSkip())
						Loop
					Endif
				EndIf

				If lFirstNiv
					cAuxNivel := SAL->AL_NIVEL
					lFirstNiv := .F.
				EndIf

				if IsInCallStack('MATA235')

					lHistSCR := .T.

					//Procura se o aprovador consta no histórico da alçada para não recriar SCR com aprovadores que foram
					//incluídos no grupo depois da aprovação original.
					if oQryHist == Nil 
						cQryHist := " SELECT R_E_C_N_O_ "
						cQryHist += " FROM "+ RetSqlName("SCR")
						cQryHist += " WHERE CR_FILIAL = ? "
						cQryHist += " 	AND CR_NUM =  ?  "
						cQryHist += " 	AND CR_USER = ? "
						cQryHist += " 	AND CR_APROV = ? "
						cQryHist += " 	AND D_E_L_E_T_ = ? "
						cQryHist := ChangeQuery(cQryHist)

						oQryHist := FWPreparedStatement():New(cQryHist)
					Endif

					oQryHist:SetString(1, cFilSCR)
					oQryHist:SetString(2, cDocto)
					oQryHist:SetString(3, cUserOri)
					oQryHist:SetString(4, cAprovOri)
					oQryHist:SetString(5, '*')

					cQryStat := oQryHist:GetFixQuery()
                    MpSysOpenQuery(cQryStat,cAliasSR)
				    

					if (cAliasSR)->(Eof())
						lHistSCR := .F.
					else
						nRecnoSCR := (cAliasSR)->(R_E_C_N_O_)

						SCR->(DbGoTo(nRecnoSCR))

						if !empty(SCR->CR_USERLIB) .AND. !empty(SCR->CR_LIBAPRO)
							//se quem liberou for diferente do usuario, significa que foi aprovado pelo superior.
							if cUserOri <> SCR->CR_USERLIB .AND. cAprovOri <> SCR->CR_LIBAPRO
								cUserOri  := Alltrim(SCR->CR_USERLIB)
								cAprovOri := Alltrim(SCR->CR_LIBAPRO)
							endif
						endif
					endif

					(cAliasSR)->(DbCloseArea())

					if lHistSCR

						//Inicializa as váriaveis para não gravar usuario origem/aprovador da SCR anterior.
						cUsrIOrg := ""
						cAprIOrg := ""

						//Busca se o aprovador foi substituido por superior para recriar SCR com o aprovador correto.
						If oQrySup == NIL 
							cQrySUP := " SELECT CR_USER, CR_APROV, CR_USERORI, CR_APRORI "
							cQrySUP += " FROM " + RetSqlName("SCR")
							cQrySUP += " WHERE CR_FILIAL   = ? "
							cQrySUP += " 	AND CR_NUM     = ? "
							cQrySUP += " 	AND CR_USERORI = ? "
							cQrySUP += " 	AND CR_APRORI  = ? "
							cQrySUP += " 	AND D_E_L_E_T_ = ? "
							cQrySUP := ChangeQuery(cQrySUP)
							
							oQrySup := FWPreparedStatement():New(cQrySUP)
						Endif

						oQrySup:SetString(1, cFilSCR)
						oQrySup:SetString(2, cDocto)
						oQrySup:SetString(3, cUserOri)
						oQrySup:SetString(4, cAprovOri)
						oQrySup:SetString(5, '*')

						cQryStat := oQrySup:GetFixQuery()
						MpSysOpenQuery(cQryStat,cAliasSR)

						if (cAliasSR)->(!Eof())
							cUserOri  := Alltrim((cAliasSR)->CR_USER)
							cAprovOri := Alltrim((cAliasSR)->CR_APROV)
							cUsrIOrg  := Alltrim((cAliasSR)->CR_USERORI)
							cAprIOrg  := Alltrim((cAliasSR)->CR_APRORI) 
						endif

						(cAliasSR)->(DbCloseArea())

					endif

					//Se o aprovador posicionado na SAL não constar no histórico que já tinha sido aprovado
					//não pode recriar ele agora.
					if !lHistSCR
						SAL->(dbSkip())
						Loop
					endif

				endif

				nPosDoc := ascan(aDocRelib,{|x|,x[1] = cFilSCR+cTipoDoc+cDocto+cAprovOri})
				
				Reclock("SCR",.T.)
				SCR->CR_FILIAL	:= cFilSCR
				SCR->CR_NUM		:= cDocto
				SCR->CR_TIPO	:= cTipoDoc
				SCR->CR_NIVEL	:= SAL->AL_NIVEL
				SCR->CR_USER	:= cUserOri
				SCR->CR_APROV	:= cAprovOri
				SCR->CR_USERORI := cUsrIOrg
				SCR->CR_APRORI 	:= cAprIOrg
				SCR->CR_STATUS	:= IIF(SAL->AL_NIVEL == cAuxNivel  ,"02","01")
				SCR->CR_TOTAL	:= nValDcto
				SCR->CR_EMISSAO	:= IIF(nPosDoc > 0,aDocRelib[nPosDoc][2],aDocto[10])
				SCR->CR_MOEDA	:= nMoeDcto
				SCR->CR_TXMOEDA	:= nTxMoeda
				SCR->CR_PRAZO	:= dPrazo
				SCR->CR_AVISO	:= dAviso
				SCR->CR_ESCALON	:= lEscalona
				SCR->CR_ESCALSP	:= lEscalonaS
				If lPosCrTipo
					SCR->CR_TIPCOM	:= cTpComp
				Endif
				If lNfMotBloq .and. cTipoDoc == "NF" .and. Type("aNFMotBloq") = "A" .and. !empty(aNFMotBloq)
					SCR->CR_NFMOBLQ := ArrTokStr(aNFMotBloq)
				Endif

				If !Empty(cGrupo)
			   		SCR->CR_GRUPO := cGrupo
				EndIf

				If !Empty(cItGrp)
			   		SCR->CR_ITGRP := cItGrp
				EndIf

				If lHasAbsence .And. lSCRTpTran
					SCR->CR_TPTRAN := '2'
				EndIf

				MsUnlock()

				//Ponto de entrada para alteraçao da SCR
				If lMTALCALT
					Execblock("MTALCALT",.F.,.F.)
				EndIf

				// Gera a nova alçada no Fluig
				If lFluig .And. SCR->CR_STATUS == '02'
					If cTipoDoc $ "CT|IC|IR|IM"
						If cTipoDoc == "IR"
							Aadd(aFluigIR, cDocto)
						EndIf
						If (!lCnAglFlg .Or. cTipoDoc = "IM")
							If lMtUsrSolic
								cUserSolic	:= ExecBlock("MtUsrSolic", .F., .F., {SCR->CR_TIPO,SCR->CR_NUM})
							Elseif lFMtUsrSolic
								cUserSolic	:= MtUsrSolic(SCR->CR_TIPO,SCR->CR_NUM)
							Endif
							
							If lMTSoliCAT
								ExecBlock("MTSoliCAT", .F., .F., {cTipoDoc,cDocto,"","CR_NUM",cUserSolic,.T.})
							Elseif lFMTSoliCAT
								MTSoliCAT(cTipoDoc,cDocto,"","CR_NUM",cUserSolic,.T.)
							Endif
						EndIf
					Elseif cTipoDoc <> "RV"
						If lMtUsrSolic
							cUserSolic	:= ExecBlock("MtUsrSolic", .F., .F., {SCR->CR_TIPO,SCR->CR_NUM})
						Elseif lFMtUsrSolic
							cUserSolic	:= MtUsrSolic(SCR->CR_TIPO,SCR->CR_NUM)
						Endif
						
						If lMTSoliCAT
							ExecBlock("MTSoliCAT", .F., .F., {cTipoDoc,cDocto,"","CR_NUM",cUserSolic,.T.})
						Elseif lFMTSoliCAT
							MTSoliCAT(cTipoDoc,cDocto,"","CR_NUM",cUserSolic,.T.)
						Endif
					EndIf
				EndIf

				If _lWizard //-- Monta json para simulação do fluxo de aprovação via Wizard - Grupo de Aprovação (COMA240)
					Aadd(_oJsonWizard['items'], JsonObject():New())
					
					nLen := Len(_oJsonWizard['items'])
					_oJsonWizard['items'][nLen]['code'] := SCR->CR_APROV
					_oJsonWizard['items'][nLen]['approver'] := AllTrim(GetAdvFVal("SAK", "AK_NOME", FWxFilial("SAK") + SCR->CR_USER, 2))
					_oJsonWizard['items'][nLen]['status'] := SCR->CR_STATUS
					_oJsonWizard['items'][nLen]['level'] := SCR->CR_NIVEL
					_oJsonWizard['items'][nLen]['type'] := SCR->CR_TIPO
				EndIf

				dbSelectArea("SAL")
				SAL->(dbSkip())
			EndDo

			FreeObj(oQryHist)
			FreeObj(oQrySup)
		EndIf
		If cTipoDoc == "NF" .And. !lFirstNiv .And. !Empty(cGrupo)
			lFirstNiv := .T.
		EndIf
		lRetorno := lFirstNiv

		//Envia e-mail para proximo aprovador.
		If !_lWizard
			aRetUser := MATEVENT75(1,cDocto,cTipoDoc,cGrupo,cItGrp)   //Busca proximo aprovador
		EndIf

		For nX := 1 to Len(aRetUser)

			cUser075 := aRetUser[nX]

			If !Empty(cUser075)
				If FindFunction("COMTemSXI")
					lEvent75 := COMTemSXI(cEventId,cUser075)
				Else
					dbSelectarea("SXI") 
					dbsetorder(1)
					If SXI->(DbSeek(cUser075 + '002' + '001' + cEventID))
						lEvent75 := .T.
					Endif 
				Endif

				If lEvent75
					cMsg075	:= MATEVENT75(2,cDocto,cTipoDoc)
					if cLibVer >= "20221004"
						cMsg075 := MATEVENT75(3,cDocto,cTipoDoc,cGrupo,cItGrp,cMsg075)
					endif

					//------------------------------------------------------------------------------
					// Avalia o release do RPO para informar o usuario como parametro no EventInsert
					// https://tdn.totvs.com.br/pages/releaseview.action?pageId=948259373
					//------------------------------------------------------------------------------
					If cRelease >= "12.1.2510"
						//          cChannel                , cCateg                , cEventID, nLevel          , cCargo, cTitle , cMessage, lPublic, cUserEvent
						EventInsert(FW_EV_CHANEL_ENVIRONMENT, FW_EV_CATEGORY_MODULES, cEventID, FW_EV_LEVEL_INFO, ""    , STR0002, cMsg075 , .F.    , cUser075)
					Else
						cBkpUsr075	:= __cUserId 
						__cUserId	:= cUser075
						EventInsert(FW_EV_CHANEL_ENVIRONMENT, FW_EV_CATEGORY_MODULES, cEventID,FW_EV_LEVEL_INFO,""/*cCargo*/,STR0002,cMsg075,.F./*lPublic*/)
						__cUserId	:= cBkpUsr075
					EndIf

				Endif  
			Endif
		
		Next nX
		//Metricas - Verifica qtd de por tipo de documentos e alçadas simples x entidades contabeis
		If lTipoDoc 
			nTpDoc++
			ComMtrAlc("-inc",cTipoDoc,aRetDBM[1],nTpDoc)
			nTpDoc := 0
		EndIf
	EndIf
	
	If nOper == 2  //Transferencia da Alcada para o Superior
		// O SCR deve estar posicionado, para que seja transferido o atual para o Superior
		If !Eof() .And. SCR->CR_FILIAL+SCR->CR_TIPO+SCR->CR_NUM == cFilSCR+cTipoDoc+cDocto
			// Carrega dados do Registro a ser tranferido e exclui
			cTipoDoc := SCR->CR_TIPO
			cAuxNivel:= SCR->CR_STATUS
			nValDcto := SCR->CR_TOTAL
			nMoeDcto := SCR->CR_MOEDA
			cNextNiv := SCR->CR_NIVEL
			nTxMoeda := SCR->CR_TXMOEDA
			dDataRef := SCR->CR_EMISSAO
			cAprovOri:= SCR->CR_APROV
			cUserOri := SCR->CR_USER
			cGrupo	 := SCR->CR_GRUPO
			cItGrp   := SCR->CR_ITGRP
			If lPosCrTipo
				cTpComp	 := SCR->CR_TIPCOM	
			Endif

			If lFluig .And. !Empty(SCR->CR_FLUIG) .And. !(IsInCallStack('U_MTFlgLbDoc') .Or. IsInCallStack('MTFlgLbDoc'))
				CancelProcess(Val(SCR->CR_FLUIG),FWWFUserID(Val(SCR->CR_FLUIG))," cancelado por contingência!",.F.)
			EndIf

			Reclock("SCR",.F.,.T.)
			dbDelete()
			MsUnlock()

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Gravacao dos itens da alcada ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cTipoDoc <> "PC"
				MaAlcItEC(cDocto,cTipoDoc,cGrupo,cItGrp,cUsuario,,cUserOri,nOper,@cAprov,cAprovOri)
			EndIf

			// Inclui Registro para Aprovador Superior
			Reclock("SCR",.T.)
			SCR->CR_FILIAL	:= cFilSCR
			SCR->CR_NUM		:= cDocto
			SCR->CR_TIPO	:= cTipoDoc
			SCR->CR_NIVEL	:= cNextNiv
			SCR->CR_USER	:= cUsuario
			SCR->CR_APROV	:= cAprov
			SCR->CR_STATUS	:= cAuxNivel
			SCR->CR_TOTAL	:= nValDcto
			SCR->CR_EMISSAO := dDataRef
			SCR->CR_MOEDA	:= nMoeDcto
			SCR->CR_TXMOEDA := nTxMoeda
			SCR->CR_OBS 	:= cObs
	   		SCR->CR_GRUPO	:= cGrupo
			SCR->CR_ITGRP 	:= cItGrp
			SCR->CR_APRORI	:= cAprovOri
			SCR->CR_USERORI	:= cUserOri
			If lPosCrTipo
				SCR->CR_TIPCOM	:= cTpComp	 
			Endif
			MsUnlock()

			// Gera a alçada do superior no Fluig
			If SCR->CR_STATUS == "02" .And. lFluig
				If lMtUsrSolic
					cUserSolic	:= ExecBlock("MtUsrSolic", .F., .F., {SCR->CR_TIPO,SCR->CR_NUM})
				Elseif lFMtUsrSolic
					cUserSolic	:= MtUsrSolic(SCR->CR_TIPO,SCR->CR_NUM)
				Endif

				If lMTSoliCAT
					ExecBlock("MTSoliCAT", .F., .F., {cTipoDoc,cDocto,"","CR_NUM",cUserSolic,.T.})
				Elseif lFMTSoliCAT
					MTSoliCAT(cTipoDoc,cDocto,"","CR_NUM",cUserSolic,.T.)
				Endif
			Endif

		EndIf
		lRetorno := .T.
	EndIf
	
	If nOper == 3  //exclusao do documento
		If lHistApr .And. AliasInDic("SGV")
			cQry:= "SELECT MAX(GV_VERSAO) AS CODIGO FROM "+RetSqlName("SGV")+" SGV "
			cQry+= "WHERE GV_FILIAL = '"+xFilial("SGV")+"' AND " 
			cQry+= "SGV.D_E_L_E_T_ = ' ' AND "
			cQry+= "GV_NUM = '"+Alltrim(cDocto)+"'"
			
			cQry := ChangeQuery(cQry)
			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQry),"TRB")
			
			nVersao:= (TRB->CODIGO+1)
			
			TRB->(DbCloseArea())
		
		EndIf
		dbSelectArea("SAK")
		SAK->(dbSetOrder(1))
		dbSelectArea("SCR")
		SCR->(dbSetOrder(1))
		 If	SCR->(MsSeek(cFilSCR+cTipoDoc+cDocto))

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Efetua uma nova busca caso o cDocto nao for encontrado no SCR³
			//³ pois seu conteudo em caso de NF foi alterado para chave unica³
			//³ do SF1, o cDocSF1 sera a busca alternativa com o conteudo ori³
			//³ ginal do lancamento da versao que poderia causar duplicidades³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If SCR->( Eof() ) .And. cTipoDoc == "NF"
				dbSeek(cFilSCR+cTipoDoc+cDocSF1)
				cDocto := cDocSF1
			EndIf
			aUsrLib := {}    
			While SCR->(!Eof()) .And. SCR->CR_FILIAL+SCR->CR_TIPO+SCR->CR_NUM == cFilSCR+cTipoDoc+cDocto
				cGrupo := SCR->CR_GRUPO
				
				If cTipoDoc = "SC" .And. Len(aItPedVinc) > 0
					//DBM_FILIAL+DBM_TIPO+DBM_NUM+DBM_GRUPO+DBM_ITGRP+DBM_USER+DBM_USEROR                                                                                             
					cItDBM := GetAdvFVal("DBM","DBM_ITEM",fwxFilial("DBM")+SCR->(CR_TIPO+CR_NUM+CR_GRUPO+CR_ITGRP),1)

					If ascan(aItPedVinc,{|x|,x == cItDBM}) > 0 .and. MtQtdEnti(SCR->CR_NUM)
						SCR->(dbSkip())
						Loop
					Endif
				Endif

				If cTipoDoc == "IP"
					// IMPORTANTE: A função antiga MtVincNF() somente verifica o saldo em aberto do pedido de compra para 1 item enquanto a nova
					//             função SeekQtdDBM() verifica o saldo em aberto para os itens do pedido de compra por grupo de aprovação (centro de custo).
					
					// Verifica se os itens do pedido possuem vinculo com NF e se possui mais de uma entidade ctb no pedido.
					If SeekQtdDBM(SCR->CR_TIPO, SCR->CR_NUM, SCR->CR_GRUPO, SCR->CR_ITGRP) .and. MtQtEntSC7(SCR->CR_NUM)
						SCR->(dbSkip())
						Loop
					EndIf
				EndIf
				
				If lHistApr .And. cTipoDoc $ "PC|IP"  .And. AliasInDic("SGV")
			
					Reclock("SGV",.T.)
					SGV->GV_FILIAL	:= xFilial("SGV")
					SGV->GV_NUM		:= SCR->CR_NUM
					SGV->GV_TIPO	:= SCR->CR_TIPO
					SGV->GV_USER	:= SCR->CR_USER
					SGV->GV_APROV	:= SCR->CR_APROV
					SGV->GV_NIVEL	:= SCR->CR_NIVEL
					SGV->GV_STATUS	:= SCR->CR_STATUS
					SGV->GV_DATALIB	:= SCR->CR_DATALIB
					SGV->GV_OBS 	:= SCR->CR_OBS 
					SGV->GV_TOTAL	:= SCR->CR_TOTAL
					SGV->GV_EMISSAO	:= SCR->CR_EMISSAO
					SGV->GV_USERLIB	:= SCR->CR_USERLIB
					SGV->GV_LIBAPRO	:= SCR->CR_LIBAPRO
					SGV->GV_VALLIB	:= SCR->CR_VALLIB
					SGV->GV_TIPOLIM	:= SCR->CR_TIPOLIM
					SGV->GV_MOEDA	:= SCR->CR_MOEDA
					SGV->GV_TXMOEDA	:= SCR->CR_TXMOEDA                    
					SGV->GV_USERORI	:= SCR->CR_USERORI
					SGV->GV_APRORI 	:= SCR->CR_APRORI
					If !Empty(FWSX3Util():GetFieldType( "GV_GRUPO" ) ) // campo criado a partir da release 12.33
						SGV->GV_GRUPO	:= SCR->CR_GRUPO
					Endif
					If !Empty(FWSX3Util():GetFieldType( "GV_ITGRP" ) ) // campo criado a partir da release 12.33
						SGV->GV_ITGRP	:= SCR->CR_ITGRP
					Endif
					SGV->GV_VERSAO	:= nVersao
					SGV->( MsUnlock() )

				EndIf
				If SCR->CR_STATUS == "03" .And. lEstCred
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Reposiciona o usuario aprovador.               ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					dbSelectArea("SAK")
					SAK->(MsSeek(xFilial("SAK")+SCR->CR_LIBAPRO))
					dbSelectArea("SAL")
					SAL->(dbSetOrder(3))
					SAL->(dbSeek(xFilial("SAL")+cGrupo+SCR->CR_APROV))
					If SAL->AL_LIBAPR == "A" .AND. (SAK->AK_COD == SAL->AL_APROV .OR. SAK->AK_COD == SAL->AL_APROSUP )
						dbSelectArea("SCS")
						SCS->(dbSetOrder(2))
						If SCS->(MsSeek(xFilial("SCS")+SAK->AK_COD+DTOS(MaAlcDtRef(SCR->CR_LIBAPRO,SCR->CR_DATALIB,SCR->CR_TIPOLIM))))
								RecLock("SCS",.F.)
								If cTipoDoc $ "IP|PC|AE|"
									nValRecNF := RetVlRecNF()
									nLimSaldo := SCS->CS_SALDO + xMoeda(SCR->CR_VALLIB,SCR->CR_MOEDA,SCS->CS_MOEDA,SCR->CR_EMISSAO, TamSX3('CR_TOTAL')[2],SCR->CR_TXMOEDA) - Min(nValRecNF,xMoeda(SCR->CR_VALLIB,SCR->CR_MOEDA,SCS->CS_MOEDA,SCR->CR_EMISSAO, TamSX3('CR_TOTAL')[2],SCR->CR_TXMOEDA))											
								Else
									nLimSaldo := SCS->CS_SALDO + xMoeda(SCR->CR_VALLIB,SCR->CR_MOEDA,SCS->CS_MOEDA,SCR->CR_EMISSAO,TamSX3('CR_TOTAL')[2],SCR->CR_TXMOEDA)
								Endif
								nLimSaldo := Min(nLimSaldo,SAK->AK_LIMITE)
								SCS->CS_SALDO := nLimSaldo
								SCS->( MsUnlock() )
						EndIf
					EndIf

					AADD(aUsrLib,{cGrupo,SAK->AK_COD,SAK->AK_USER})
					If SCR->CR_STATUS == "03"  .and. ascan(aDocRelib,{|x|,x[1] == SCR->CR_FILIAL+SCR->CR_TIPO+SCR->CR_NUM+SCR->CR_APROV+SCR->CR_GRUPO+SCR->CR_ITGRP+SCR->CR_USERORI+SCR->CR_APRORI}) == 0
						cAprovSCR := SCR->CR_APROV
						//Se o CR_APROV for diferente do CR_LIBAPRO, significa que documento foi aprovado pelo superior
						if !empty(SCR->CR_LIBAPRO)
							if Alltrim(SCR->CR_APROV) <> Alltrim(SCR->CR_LIBAPRO)
								cAprovSCR := SCR->CR_LIBAPRO
							endif
						endif
						AADD(aDocRelib,{SCR->CR_FILIAL+SCR->CR_TIPO+SCR->CR_NUM+cAprovSCR+SCR->CR_GRUPO+SCR->CR_ITGRP+SCR->CR_USERORI+SCR->CR_APRORI,SCR->CR_DATALIB,SCR->CR_STATUS,SCR->CR_NIVEL})
					EndIf
				ElseIf ( SCR->CR_STATUS == "05" .and. lRecAlc ).AND.(!lCall235 .or. (lCall235 .and. SCR->CR_VALLIB > 0)) .and. ascan(aDocRelib,{|x|,x[1] == SCR->CR_FILIAL+SCR->CR_TIPO+SCR->CR_NUM+SCR->CR_APROV+SCR->CR_GRUPO+SCR->CR_ITGRP+SCR->CR_USERORI+SCR->CR_APRORI}) == 0
					
					dbSelectArea("SAK")
					SAK->(MsSeek(xFilial("SAK")+SCR->CR_APROV))

					AADD(aUsrLib,{cGrupo,SAK->AK_COD,SAK->AK_USER})
					AADD(aDocRelib,{SCR->CR_FILIAL+SCR->CR_TIPO+SCR->CR_NUM+SCR->CR_APROV+SCR->CR_GRUPO+SCR->CR_ITGRP+SCR->CR_USERORI+SCR->CR_APRORI,SCR->CR_DATALIB,SCR->CR_STATUS,SCR->CR_NIVEL})
			  EndIf
				If lFluig .And. !Empty(SCR->CR_FLUIG) .And. SCR->CR_STATUS == "02" .And. !(IsInCallStack('U_MTFlgLbDoc') .Or. IsInCallStack('MTFlgLbDoc'))
					CancelProcess(Val(SCR->CR_FLUIG),FWWFUserID(Val(SCR->CR_FLUIG))," cancelado por contingência!",.F.)
				EndIf
				Reclock("SCR",.F.,.T.)
				dbDelete()
				MsUnlock()
				dbSkip()
			EndDo
			
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Exclui registros dos itens da alcada ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ			
			MaAlcItEC(cDocto,cTipoDoc,,,,,,nOper,,,,,,aItPedVinc)
		EndIf 		
	EndIf
	
	If nOper == 4 .AND. !Empty(cAprov)//Aprovacao do documento
		dbSelectArea("SCS")
		SCS->(dbSetOrder(2))
		aSaldo := MaSalAlc(cAprov,dDataRef,.T.)
		nSaldo 	:= aSaldo[1]
		dDataRef	:= aSaldo[3]
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualiza o saldo do aprovador.                 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea("SAK")
		SAK->(dbSetOrder(1))
		SAK->(DbSeek(xFilial("SAK") + cAprov))
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Posiciona a Tabela SAL pelo Aprovador de Origem caso o Documento tenha sido ³
		//| transferido por Ausência Temporária ou Transferência superior e o aprovador |
		//| de destino não fizer parte do Grupo de Aprovação.                           |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea("SAL")
		SAL->(dbSetOrder(3))		
		If Empty(SCR->CR_APRORI)
			SAL->(dbSeek(xFilial("SAL") + cGrupo + cAprov))
		Else
			SAL->(MsSeek(xFilial("SAL") + cGrupo + SCR->CR_APRORI))
		EndIf   
		
		If lAprovSup
			cAuxNivel := SCR->CR_NIVEL
		Else
			cAuxNivel := SAL->AL_NIVEL
			If Empty(cAuxNivel) .OR. Alltrim(SCR->CR_NIVEL) <> Alltrim(cAuxNivel)
				cAuxNivel := SCR->CR_NIVEL
			EndIf
		Endif
		
		If !Empty(SCR->CR_APRORI)
			SAL->(MsSeek(xFilial("SAL") + cGrupo + SCR->CR_APRORI))
    	EndIf   
    	
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Posiciona a Tabela SAL pelo Aprovador de Origem caso o Documento que esta   ³
		//| sendo aprovado, pela opcao: SUPERIOR e o aprovador Superior nao fizer parte |
		//| do mesmo Grupo de Aprovação.  									                            |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    	If Len(aDocto)>11 .And. Empty(SCR->CR_APRORI)
	    	If !Empty(aDocto[12])
				SAL->(MsSeek(xFilial("SAL")+cGrupo+aDocto[12]))
				cAprDoSup	:= aDocto[12]
    		EndIf
    	EndIf                               
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Ponto de entrada para alterar o Aprovador 	 												³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	   	If lMTALCGRU
			aMTALCGRU := If(ValType(aRetPe:=ExecBlock("MTALCGRU",.F.,.F.,{cAprov,cGrupo}))=="A",aRetPe,aMTALCGRU)
			If Len(aMTALCGRU) >= 1 .And. ValType(aMTALCGRU[1]) == "C"
				cAprov := aMTALCGRU[1]
			EndIf
			If Len(aMTALCGRU) >= 2 .And. ValType(aMTALCGRU[2]) == "C"
				cGrupoSAL := aMTALCGRU[2]
			EndIf	
		EndIf

		// Cancela processo no Fluig caso a baixa seja feita através de outra rotina
		If lFluig .And. !Empty(SCR->CR_FLUIG) .And. !(IsInCallStack('U_MTFlgLbDoc') .Or. IsInCallStack('MTFlgLbDoc')) .And. !lNewFlg .And. ;
		!(SCR->CR_STATUS == "05" .And. SAL->AL_TPLIBER $ "NP") // Para nao tentar excluir duas vezes quando for aprovação por Documento
			CancelProcess(Val(SCR->CR_FLUIG),FWWFUserID(Val(SCR->CR_FLUIG))," cancelado por contingência!",.F.)
		Endif
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Libera o pedido pelo aprovador.                     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		
		aAreaSCRSaldo  := SCR->(getArea())
		dbSelectArea("SCR")
		SCR->(dbSetOrder(3))
		if lCalMta235 .Or. cTipoDoc $ "PC|AE" .Or. (cTipoDoc == "IP" .And. !Empty(SC7->C7_ENCER)) .Or. (cTipoDoc == "SC" .And. SC1->C1_QUJE >= SC1->C1_QUANT)
			If lAprovSup
				
				lRetCr := SCR->(MsSeek(cFilSCR + cTipoDoc + cDocto + cAprDoSup)) 
			Else	 
			
				cAliasTmp		:= GetNextAlias()
				
				cQuery := " SELECT R_E_C_N_O_ "
				cQuery += " FROM "+RetSqlName("SCR")+" SCR" 
				cQuery += "	WHERE  "
				cQuery += "	SCR.CR_FILIAL  = '"+cFilSCR+"' 	 AND 	" 
				cQuery += "	SCR.CR_TIPO    = '"+cTipoDoc+"'  AND 	"
				cQuery += "	SCR.CR_NUM     = '"+cDocto+"' 	 AND 	"
				cQuery += "	SCR.CR_APROV   = '"+cAprov+"' 	 AND   	"
				cQuery += " SCR.CR_USERORI = '"+Substr(cChvApr,nChUsrOr+1,cTamCRUsOr)+"' 	 AND 	"
				cQuery += " SCR.CR_APRORI  = '"+Substr(cChvApr,nCHApOri+1,cTamCRApO)+"' 	 AND 	"
				cQuery += " D_E_L_E_T_ = ' ' 						"
				cQuery := ChangeQuery(cQuery)
				dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasTmp)

				if (cAliasTmp)->(!Eof())
					nRecSCR := (cAliasTmp)->R_E_C_N_O_
				endif

				(cAliasTmp)->(DbCloseArea())
				
				lRetSCR := IIF(nRecSCR == 0,.F.,.T.)
				
				if lRetSCR 
				   SCR->(DbGoto(nRecSCR))
				endif

			EndIf
		Endif

		If lPosCrTipo
			cTipCom := SCR->CR_TIPCOM  
		EndIf 
		
		If Empty(cItGrp)
	   		cItGrp:= SCR->CR_ITGRP
		EndIf
		If lRetCr
			While SCR->(!Eof()) .and. SCR->(CR_FILIAL+CR_TIPO+CR_NUM) ==cFilSCR+cTipoDoc+cDocto .And. ((cAprov == SCR->CR_APROV) .Or. lAprovSup)
				nPosDoc := ascan(aDocRelib,{|x|,x[1] == SCR->(CR_FILIAL+CR_TIPO+CR_NUM+CR_APROV+CR_GRUPO+CR_ITGRP+CR_USERORI+CR_APRORI)})
				If cGrupo == SCR->CR_GRUPO .And. cItGrp == SCR->CR_ITGRP .And. IF(nPosDoc > 0,aDocRelib[nPosDoc][4], cAuxNivel) == SCR->CR_NIVEL;
				.and. ((Empty(SCR->CR_LIBAPRO) .or. (!Empty(SCR->CR_LIBAPRO) .and. SCR->CR_STATUS == "04")) .Or. SCR->CR_LIBAPRO <> SAK->AK_COD .Or. nPosDoc > 0)
					cSCRStatus := "03"
					If nPosDoc > 0
						dDataLib := aDocRelib[nPosDoc][2]
						dDataRef := dDataLib
						cSCRStatus := if(len(aDocRelib[nPosDoc]) >= 3,aDocRelib[nPosDoc][3],"03")
					EndIf

					If Reclock("SCR",.F.)
						SCR->CR_STATUS	:= cSCRStatus
						SCR->CR_OBS		:= If(Len(aDocto)>10,aDocto[11],"")
						SCR->CR_DATALIB	:= dDataLib
						SCR->CR_USERLIB	:= SAK->AK_USER
						SCR->CR_LIBAPRO	:= SAK->AK_COD
						SCR->CR_VALLIB	:= nValDcto
						SCR->CR_TIPOLIM	:= SAK->AK_TIPO
						SCR->(MsUnlock())
						nRecAprov := SCR->(RecNo())
						nRec := SCR->(RecNo())
					EndIf

					Exit
				EndIf
				SCR->(DBSKIP())			
			EndDo		
		EndIf
	   
		If Empty(cGrupo)
			cGrupo := SCR->CR_GRUPO
		EndIf
		
		cUser		:= SCR->CR_USER
		SCR->(dbSetOrder(1))
		SCR->(MsSeek(cFilSCR + cTipoDoc + cDocto + cAuxNivel))
		nRec := SCR->(RecNo())
		
		If lCall235
			cAuxNivel := SAL->AL_NIVEL
		Endif

		While SCR->(!Eof()) .And. SCR->(CR_FILIAL+CR_TIPO+CR_NUM) == cFilSCR + cTipoDoc + cDocto

			If Empty(SAL->AL_APROV)  // Não conseguiu posicionar SAL pois os campos não existem, efetua posicionamento
		    	SAL->(dbSeek(xFilial("SAL") + cGrupoSAL + SCR->CR_APROV))
		    EndIf
				
			If cAuxNivel == SCR->CR_NIVEL .And. SCR->CR_STATUS != "03" .And. SAL->AL_TPLIBER $ "U " .And. !Alltrim(SCR->CR_OBS) $ cObsBloq + SAK->AK_COD							
				If SCR->(CR_GRUPO+CR_ITGRP) # cGrupo+cItGrp
					SCR->(dbSkip())
					Loop 
				ElseIf nCount > 1 // Indica que ainda existem usuarios neste nivel do mesmo grupo, com pendencia de aprovacao , neste caso nao deve liberar os niveis seguintes
					lBlqNivel := .T.	
					SCR->(dbSkip())
					Loop
				EndIf
				lUserNiv := .T.
			EndIf
			
			If cAuxNivel != SCR->CR_NIVEL .And. lUserNiv .And. SAL->AL_TPLIBER $ "U " .And. cGrupo == SCR->CR_GRUPO
				SCR->(dbSkip())
				Loop
			EndIf
			
		
			//Verifica se nivel anterior ja passou por algum bloqueio
			If cAuxNivel <> SCR->CR_NIVEL  .And. lBloqueio
				Exit
			EndIf

			If cGrupo # SCR->CR_GRUPO
				If cAuxNivel >= SCR->CR_NIVEL
					SCR->(dbSkip())
					Loop
				EndIf
			EndIf

			If cAuxNivel == SCR->CR_NIVEL .And. SCR->CR_STATUS != "03" .And. SAL->AL_TPLIBER $ "NP" .And. SCR->CR_ITGRP == cItGrp .And. IIF(lPosCrTipo,SCR->CR_TIPCOM == cTipCom,.T.)
				
				cAprovDBM := SCR->CR_APROV
			
				If Reclock("SCR",.F.)
					SCR->CR_STATUS	:= "05"
					SCR->CR_DATALIB	:= dDataLib
					SCR->CR_USERLIB	:= SAK->AK_USER
					SCR->CR_APROV	:= cAprovDBM
					SCR->CR_OBS		:= ""
					SCR->(MsUnlock())
				Endif

				If !Empty(cItGrp)
					MaAlcItEC(cDocto,cTipoDoc,cGrupo,cItGrp,SCR->CR_USER,,,nOper,cAprovDBM)
				EndIf

				// Cancela processo no Fluig caso o nível já tenha sido aprovado
				If SCR->CR_STATUS == "05" .And. !Empty(SCR->CR_FLUIG)
					CancelProcess(Val(SCR->CR_FLUIG),FWWFUserID(Val(SCR->CR_FLUIG))," cancelado por contingência!",.F.)
				Endif

			EndIf

			If SCR->CR_NIVEL > cAuxNivel .And. SCR->CR_STATUS != "03" .And. !lAchou .And. cGrupo == SCR->CR_GRUPO .And. SCR->CR_ITGRP == cItGrp
				lAchou := .T.
				cNextNiv := SCR->CR_NIVEL
			EndIf

			If lAchou .And. SCR->CR_NIVEL == cNextNiv .And. !(SCR->CR_STATUS $ "03/05") .And. SCR->CR_ITGRP == cItGrp
				If Reclock("SCR",.F.)
					If SAL->AL_TPLIBER == "P"
						SCR->CR_STATUS := "05"
					ElseIf (Empty(cNivIgual) .Or. cNivIgual == SCR->CR_NIVEL) .And. ( (SAL->AL_TPLIBER == "N") .Or. (cStatusAnt <> "01")) .And. !lBlqNivel
						SCR->CR_STATUS := "02"
						cNivIgual := SCR->CR_NIVEL
					EndIf
					If SCR->CR_STATUS == "05"
						SCR->CR_DATALIB	:= dDataLib
						If !Empty(cItGrp)
			  				MaAlcItEC(cDocto,cTipoDoc,cGrupo,cItGrp,SCR->CR_USER,,,nOper,SCR->CR_APROV)
						EndIf
					EndIf
					SCR->(MsUnlock())
					lAchou    := .F.
				Endif
			Endif
			//Verifica se nivel ja passou por algum bloqueio
			If cAuxNivel $ "02" .And. SCR->CR_STATUS $ "05" .And. Alltrim(SCR->CR_OBS) $ cObsBloq + SAK->AK_COD
				lBloqueio := .T.

				If Reclock("SCR",.F.)
					SCR->CR_STATUS	:= "02"
					SCR->CR_DATALIB	:= Ctod("//")
					SCR->CR_USERLIB	:= ""
					SCR->CR_LIBAPRO	:= ""
					SCR->CR_OBS		:= STR0063+SAK->AK_COD
					SCR->CR_VALLIB	:= 0
					SCR->CR_TIPOLIM	:= ""
					SCR->(MsUnlock())
				Endif
			EndIf

			If cGrupo == SCR->CR_GRUPO .And. SCR->CR_STATUS<>"01"
				cStatusAnt := SCR->CR_STATUS
			EndIf

			// Gera o processo no Fluig ao aprovar o nivel anterior
			If lFluig .And. SCR->CR_STATUS == "02" .And. !cTipoDoc $ "CT|IC|IR" .And. Empty(SCR->CR_FLUIG)
				If lMtUsrSolic
					cUserSolic	:= ExecBlock("MtUsrSolic", .F., .F., {SCR->CR_TIPO,SCR->CR_NUM})
				Elseif lFMtUsrSolic
					cUserSolic	:= MtUsrSolic(SCR->CR_TIPO,SCR->CR_NUM)
				Endif

				aNextTask 	:= {2,FWWFColleagueId(cUserSolic),{FWWFColleagueId(A097UsuApr(SCR->CR_APROV))}}
				StartProcess(cTipoDoc,FWWFColleagueId(cUserSolic),{FWWFColleagueId(cUserSolic)},,,,,aNextTask,.T.)
				lNewFlg	:= .T.
			EndIf

			// Gera a nova alçada no Fluig
			If lFluig .And. SCR->CR_STATUS == '02' .And. cTipoDoc $ "CT|IC|IR"
				If cTipoDoc == "IR"
					Aadd(aFluigIR, cDocto)
				EndIf
				If (!lCnAglFlg .Or. cTipoDoc = "IM")				
					If lMtUsrSolic
						cUserSolic	:= ExecBlock("MtUsrSolic", .F., .F., {SCR->CR_TIPO,SCR->CR_NUM})
					Elseif lFMtUsrSolic
						cUserSolic	:= MtUsrSolic(SCR->CR_TIPO,SCR->CR_NUM)
					Endif

					If lMTSoliCAT
						ExecBlock("MTSoliCAT", .F., .F., {cTipoDoc,cDocto,"","CR_NUM",cUserSolic,.T.})
					Elseif lFMTSoliCAT
						MTSoliCAT(cTipoDoc,cDocto,"","CR_NUM",cUserSolic,.T.)
					Endif
				EndIf
			EndIf

			nCount++

			SCR->(dbSkip())
		EndDo
		
		If !(cTipoDoc $ "IP|SA|SC") 
			//Reposiciona e verifica se ja esta totalmente liberado
			SCR->(MsGoto(nRec))
			While SCR->(!Eof()) .And. cFilSCR+cTipoDoc+cDocto == SCR->(CR_FILIAL+CR_TIPO+CR_NUM)
				If cGrupo == SCR->CR_GRUPO .And. SCR->CR_ITGRP == cItGrp 
					If SCR->CR_STATUS != "03" .And. SCR->CR_STATUS != "05" .And. SCR->CR_STATUS != "04"
						lRetorno := .F.
						Exit
					EndIf
				Endif
				SCR->(dbSkip())
			EndDo
		EndIf
		
		RestArea(aAreaSCRSaldo)
		If cTipoDoc $ "IP|SC" .And. Empty(cAprov) .And. (!Empty(SC7->C7_ENCER) .Or. SC1->C1_QUJE >= SC1->C1_QUANT)
			cAprov := SCR->CR_APROV	
		EndIf
		
		If SAL->AL_LIBAPR == "A" .And. !lItDel .And. !(cTipoDoc $ "NF")
			dbSelectArea("SCS")
			If SCS->(dbSeek(xFilial("SCS") + cAprov + dToS(dDataRef)))
				Reclock("SCS",.F.)
			Else
				Reclock("SCS",.T.)
			EndIf
			SCS->CS_FILIAL:= xFilial("SCS")
			SCS->CS_SALDO := SCS->CS_SALDO - xMoeda(nValDcto,SCR->CR_MOEDA,SCS->CS_MOEDA,SCR->CR_EMISSAO,TamSX3('CR_TOTAL')[2],SCR->CR_TXMOEDA)
			SCS->CS_APROV := cAprov
			SCS->CS_MOEDA := nMoeDcto
			SCS->CS_DATA  := dDataRef
			SCS->(MsUnlock())
		EndIf
		
		//Libera os itens da alcada
		If !Empty(cItGrp)
			SCR->(MsGoto(nRecAprov))

	   		MaAlcItEC(cDocto,cTipoDoc,cGrupo,cItGrp,cUser,,,nOper,If(lAprovSup,aDocto[12],cAprov), SCR->CR_APRORI)
		EndIf

		//Envia e-mail para proximo aprovador.
		aRetUser := MATEVENT75(1,cDocto,cTipoDoc,cGrupo,cItGrp)   //Busca proximo aprovador

		For nY := 1 to Len(aRetUser)

			cUser075 := aRetUser[nY]

			If FindFunction("COMTemSXI")
				lEvent75 := COMTemSXI(cEventId,cUser075)
			Else
				dbSelectarea("SXI") 
				dbsetorder(1)
				If SXI->(DbSeek(cUser075 + '002' + '001' + cEventID))
					lEvent75 := .T.
				Endif 
			Endif

			If lEvent75
				cMsg075	:= MATEVENT75(2,cDocto,cTipoDoc)
				if cLibVer >= "20221004"
					cMsg075 := MATEVENT75(3,cDocto,cTipoDoc,cGrupo,cItGrp,cMsg075)
				endif

				//------------------------------------------------------------------------------
				// Avalia o release do RPO para informar o usuario como parametro no EventInsert
				// https://tdn.totvs.com.br/pages/releaseview.action?pageId=948259373
				//------------------------------------------------------------------------------
				If cRelease >= "12.1.2510"
					//          cChannel                , cCateg                , cEventID, nLevel          , cCargo, cTitle , cMessage, lPublic, cUserEvent
					EventInsert(FW_EV_CHANEL_ENVIRONMENT, FW_EV_CATEGORY_MODULES, cEventID, FW_EV_LEVEL_INFO, ""    , STR0002, cMsg075 , .F.    , cUser075)
				Else
					cBkpUsr075	:= __cUserId
					__cUserId	:= cUser075
					EventInsert(FW_EV_CHANEL_ENVIRONMENT, FW_EV_CATEGORY_MODULES, cEventID,FW_EV_LEVEL_INFO,""/*cCargo*/,STR0002,cMsg075,.F./*lPublic*/)
					__cUserId	:= cBkpUsr075 
				EndIf
			Endif
		Next

	EndIf
	
	If nOper == 5  //Estorno da Aprovacao
		cGrupo := If(!Empty(aDocto[6]),aDocto[6],cGrupo)
		
		If Empty(cGrupo)
			cGrupo := SCR->CR_GRUPO
		EndIf
		
		If Empty(cItGrp)
			cItGrp := SCR->CR_ITGRP
		EndIf	
		
		dbSelectArea("SAK")
		dbSetOrder(1)
		dbSelectArea("SCR")
		dbSetOrder(1)
		dbSeek(cFilSCR+cTipoDoc+cDocto)
		nMoeDcto := SCR->CR_MOEDA
		nTxMoeda := SCR->CR_TXMOEDA
			
		While SCR->(!Eof()) .And. SCR->CR_FILIAL+SCR->CR_TIPO+SCR->CR_NUM == xFilial("SCR")+cTipoDoc+cDocto
			//-- Quando aprovação por item, processa estorno somente das SCR referente ao mesmo item
			If (SCR->CR_TIPO == "SA" .Or. (SCR->CR_TIPO == "IP" .And. lIpAprEc)) .And. SCR->(CR_GRUPO+CR_ITGRP) # cGrupo+cItGrp
				SCR->(dbSkip())
				Loop
			EndIf
			
			If SCR->CR_STATUS == "03"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Reposiciona o usuario aprovador.               ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				dbSelectArea("SAK")
				dbSeek(xFilial("SAK")+SCR->CR_LIBAPRO)
				
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Posiciona a Tabela SAL pelo Aprovador de Origem caso o Documento tenha sido ³
				//| transferido por Ausência Temporária ou Transferência superior e o aprovador |
				//| de destino não fizer parte do Grupo de Aprovação.                           |
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				SAL->(dbSetOrder(3))
				SAL->(dbSeek(xFilial("SAL")+cGrupo+SAK->AK_COD))
				If SAL->(Eof())
		    		SAL->(dbSeek(xFilial("SAL")+cGrupo+SCR->CR_APRORI)) 	    			
	   			EndIf
	   			
				If SAL->AL_LIBAPR == "A" .And. SCR->CR_TIPO != "NF"
					SCS->(dbSetOrder(2))
					If SCS->(dbSeek(xFilial("SCS")+SAK->AK_COD+DTOS(MaAlcDtRef(SAK->AK_COD,SCR->CR_DATALIB))))
						nLimSaldo := SCS->CS_SALDO + If(nValDcto>0 .And. nValDcto < SCR->CR_VALLIB,xMoeda(nValDcto,SCR->CR_MOEDA,SCS->CS_MOEDA,SCR->CR_EMISSAO, TamSX3('CR_TOTAL')[2],SCR->CR_TXMOEDA),xMoeda(SCR->CR_VALLIB,SCR->CR_MOEDA,SCS->CS_MOEDA,SCR->CR_EMISSAO, TamSX3('CR_TOTAL')[2],SCR->CR_TXMOEDA))
						nLimSaldo := Min(nLimSaldo,SAK->AK_LIMITE)
						RecLock("SCS",.F.)						
						SCS->CS_SALDO := nLimSaldo
						SCS->(MsUnlock())
					EndIf
				EndIf
			EndIf
			Reclock("SCR",.F.,.T.)
						
			If !(SCR->CR_TIPO $ "SA|SC|IP") .And. nValDcto > 0 .And. nValDcto < SCR->CR_TOTAL
				SCR->CR_TOTAL	:= IIF(FwIsInCallStack("MATA235"),SCR->CR_TOTAL ,SCR->CR_TOTAL  - nValDcto)
				SCR->CR_VALLIB	:= IIF(FwIsInCallStack("MATA235"),SCR->CR_VALLIB,SCR->CR_VALLIB - nValDcto)
			Else
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³A variavel lResiduo informa se devera ou nao reconstituir um  ³
				//³novo bloqueio SCR  se ainda houver saldo apos a eliminacao de ³
				//³residuos, em caso da opcao de estorno a recosntituicao do SCR ³
				//³e obrigatoria, apos a delecao.                                ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ		
				If lResiduo
					If (SCR->CR_TIPO $ "SC")
						lDeletou := .T.
					Else
						lDeletou := IF(SCR->CR_TOTAL - nValDcto > 0,.T.,.F.)
					EndIf
				ElseIf !(SCR->CR_TIPO $ "SA|IP")
					lDeletou := .T.
				EndIf
				//-- Reconstrói somente quando por documento
				If !(SCR->CR_TIPO $ "SA|SC|IP")
					SCR->(dbDelete())
				//-- Por item desfaz liberação, pois não tem os dados para regerar
				//-- E o custo deste processamento é muito alto
				Else
					SCR->CR_STATUS	:= If(IsFirstLev(SCR->CR_GRUPO,SCR->CR_NIVEL,SCR->CR_NUM,SCR->CR_TIPO),'02','01') //Verifica se é primeiro nivel, se não for gera como bloqueado
					SCR->CR_DATALIB	:= CriaVar("CR_DATALIB",.F.)
					SCR->CR_OBS		:= CriaVar("CR_OBS",.F.)
					SCR->CR_USERLIB	:= CriaVar("CR_USERLIB",.F.)
					SCR->CR_LIBAPRO	:= CriaVar("CR_LIBAPRO",.F.)
					SCR->CR_VALLIB	:= CriaVar("CR_VALLIB",.F.)
					SCR->CR_TIPOLIM	:= CriaVar("CR_TIPOLIM",.F.)
					
					DBM->(dbSetOrder(3))
					DBM->(dbSeek(xFilial("DBM")+SCR->(CR_TIPO+CR_NUM+CR_GRUPO+CR_ITGRP+CR_APROV+CR_APRORI)))
					While !DBM->(EOF()) .And. DBM->(DBM_FILIAL+DBM_TIPO+DBM_NUM+DBM_GRUPO+DBM_ITGRP+DBM_USAPRO+DBM_USAPOR) == xFilial("DBM")+SCR->(CR_TIPO+CR_NUM+CR_GRUPO+CR_ITGRP+CR_APROV+CR_APRORI)
						RecLock("DBM",.F.)
						DBM->DBM_APROV := '2'
						DBM->(MsUnLock())
						
						DBM->(dbSkip())
					End 
				EndIf
			EndIf
			MsUnlock()
			
			SCR->(dbSkip())
		EndDo

		dbSelectArea("SAL")
		dbSetOrder(2)
		If	!(cTipoDoc $ "SA|SC|IP") .And.;
			((!Empty(cGrupo) .And. dbSeek(xFilial("SAL")+cGrupo) .And. ( nValDcto > 0 .Or. FwIsInCallStack("GCTAlcEnt") ) .And. lDeletou) .Or. ;
			(!Empty(cGrupo) .And. dbSeek(xFilial("SAL")+cGrupo) .And. cTipoDoc == "NF" .And. lDeletou))
			
			SAK->(dbSetOrder(1))
			
			While !Eof() .And. xFilial("SAL")+cGrupo == AL_FILIAL+AL_COD
							
				If !RegistroOk("SAL",.F.) .Or. SAK->(! dbSeek(xFilial("SAK")+SAL->AL_APROV )) .Or. !RegistroOk("SAK",.F.)
					SAL->(dbSkip())
					Loop
				EndIf

				If cTipoDoc <> "NF"
					If SAL->AL_AUTOLIM == "S" .And. !MaAlcLim(SAL->AL_APROV,nValDcto,nMoeDcto,nTxMoeda,cGrupo)
						dbSelectArea("SAL")
						dbSkip()
						Loop
					EndIf
				EndIf

				cAprovOri := SAL->AL_APROV
				cUserOri := SAL->AL_USER

				//-- Ponto de entrada para troca do usuário aprovador
				If lMTALCAPR
					SAK->(dbSetOrder(2))
					If ValType(cMTALCAPR := ExecBlock("MTALCAPR",.F.,.F.,{cTipoDoc,cDocto,nValDcto,dDataRef})) == "C" .And.;
										SAK->(MsSeek(xFilial("SAK")+cMTAlCAPR))
						cAprovOri := SAK->AK_COD
						cUserOri := SAK->AK_USER
					EndIf
				EndIf

				If lFirstNiv
					cAuxNivel := SAL->AL_NIVEL
					lFirstNiv := .F.
				EndIf
				
				Reclock("SCR",.T.)
				SCR->CR_FILIAL	:= cFilSCR
				SCR->CR_NUM		:= cDocto
				SCR->CR_TIPO	:= cTipoDoc
				SCR->CR_NIVEL	:= SAL->AL_NIVEL
				SCR->CR_USER	:= cUserOri
				SCR->CR_APROV	:= cAprovOri
				SCR->CR_STATUS	:= IIF(SAL->AL_NIVEL == cAuxNivel,"02","01")
				SCR->CR_TOTAL	:= nValDcto
				SCR->CR_EMISSAO	:= dDataRef
				SCR->CR_MOEDA	:= nMoeDcto
				SCR->CR_TXMOEDA	:= nTxMoeda
				SCR->CR_GRUPO	:= cGrupo
   				SCR->CR_ITGRP 	:= cItGrp

				MsUnlock()

				// Gera a alçada no Fluig
				If SCR->CR_STATUS == "02" .And. lFluig
					If lMtUsrSolic
						cUserSolic	:= ExecBlock("MtUsrSolic", .F., .F., {SCR->CR_TIPO,SCR->CR_NUM})
					Elseif lFMtUsrSolic
						cUserSolic	:= MtUsrSolic(SCR->CR_TIPO,SCR->CR_NUM)
					Endif
					
					If lMTSoliCAT
						ExecBlock("MTSoliCAT", .F., .F., {cTipoDoc,cDocto,"","CR_NUM",cUserSolic,.T.})
					Elseif lFMTSoliCAT
						MTSoliCAT(cTipoDoc,cDocto,"","CR_NUM",cUserSolic,.T.)
					Endif
				Endif

				dbSelectArea("SAL")
				dbSkip()
			EndDo
		EndIf
		lRetorno := lFirstNiv
	EndIf
	
	If nOper == 6  //Bloqueio manual
		dbSelectArea("SAK")
		dbSetOrder(1)
		dbSeek(xFilial("SAK")+cAprov)
	
		Reclock("SCR",.F.)
		CR_STATUS   := "04"
		CR_OBS	    := If(Len(aDocto)>10,aDocto[11],"")
		CR_DATALIB  := dDataRef
		CR_USERLIB	:= SAK->AK_USER
		CR_LIBAPRO	:= SAK->AK_COD
		cAuxNivel   := CR_NIVEL
		MsUnlock()
		lRetorno 	:= .F.
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Bloqueia todos os Aprovadores do Nível  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSeek(cFilSCR+cTipoDoc+cDocto+cAuxNivel)
		nRec := RecNo()
		While !Eof() .And. cFilSCR+cDocto+cTipoDoc+cAuxNivel == CR_FILIAL+CR_NUM+CR_TIPO+CR_NIVEL
			
			//Aprovação por item bloqueia apenas o grupo de aprovação envolvido
			If (SCR->CR_TIPO $ "SA|SC" .Or. (SCR->CR_TIPO == "IP" .And. lIpAprEc)) .And. SCR->(CR_GRUPO+CR_ITGRP) # cGrupo+cItGrp
				SCR->(dbSkip())
				Loop
			Endif
			
			
			If CR_STATUS != "04"
				Reclock("SCR",.F.)
				CR_STATUS	:= "07"
				CR_OBS	    := STR0061+SAK->AK_COD
				CR_DATALIB	:= dDataRef
				CR_USERLIB	:= SAK->AK_USER
				CR_LIBAPRO	:= SAK->AK_COD
				MsUnlock()
			EndIf

			// Cancelar no Fluig quando a aprovação ficar bloqueada no Protheus
			If !Empty(SCR->CR_FLUIG)
				CancelProcess(Val(SCR->CR_FLUIG),FWWFUserID(Val(SCR->CR_FLUIG))," cancelado por contingência!",.F.)
			EndIf

			dbSkip()
		EndDo
	EndIf
	
	If nOper == 7  //Evento de rejeição do documento
		cAuxNivel := SCR->CR_NIVEL
		cAprovOri := SCR->CR_APROV
		cUserOri  := SCR->CR_USER
		
		//-- Rejeita aprovacoes pendentes do mesmo nivel e niveis superiores, grupo e item
		SCR->(dbSetOrder(1))
		SCR->(dbSeek(cFilSCR+cTipoDoc+cDocto))
		While !SCR->(EOF()) .And. SCR->(CR_FILIAL+CR_TIPO+CR_NUM) == cFilSCR+cTipoDoc+cDocto
		
			//Aprovação por item rejeita apenas o grupo de aprovação envolvido
			If (SCR->CR_TIPO $ "SA|SC" .Or. (SCR->CR_TIPO == "IP" .And. lIpAprEc)) .And. SCR->(CR_GRUPO+CR_ITGRP) # cGrupo+cItGrp
				SCR->(dbSkip())
				Loop
			Endif
		
			If SCR->CR_NIVEL >= cAuxNivel	.And. SCR->CR_STATUS <> "03"
				RecLock("SCR",.F.) 
				SCR->CR_DATALIB := dDataBase
				SCR->CR_USERLIB := cUserOri
				SCR->CR_LIBAPRO := cAprovOri
				
				If lCalAppMob .And. !Empty(cObs) //AppMobile
					SCR->CR_OBS := cObs
				Endif
				If SCR->CR_APROV == cAprovOri 
					SCR->CR_STATUS := "06"
				Else
					SCR->CR_STATUS := "07"
				EndIf
				SCR->(MsUnLock())
			EndIf
			

			If cTipoDoc $ "PC|ST|AE|CP"
				Do Case
					Case SCR->CR_TIPO == "ST"
						NNS->(dbSetOrder(1))
						If NNS->(MsSeek(cChaveRej))
							RecLock("NNS",.F.)
							NNS->NNS_STATUS := '4'
							NNS->NNS_JUSTIF := FwFldGet("CR_OBS")
							NNS->(MsUnlock())
						EndIf
					Case SCR->CR_TIPO $ "PC|AE"
						SC7->(dbSetOrder(1))
						SC7->(MsSeek(cChaveRej))
						While !SC7->(EOF()) .And. SC7->(C7_FILIAL+C7_NUM) == cChaveRej
							RecLock("SC7",.F.)
							SC7->C7_CONAPRO := 'R'
							SC7->C7_FLUXO	:= 'N'
							SC7->(MsUnlock())

							SC7->(dbSkip())
						EndDo
					Case SCR->CR_TIPO $ "CP" 
						SC3->(dbSetOrder(1))
						SC3->(MsSeek(cChaveRej))
						While !SC3->(EOF()) .And. SC3->(C3_FILIAL+C3_NUM) == cChaveRej
							RecLock("SC3",.F.)
							SC3->C3_CONAPRO := 'R'
							SC3->(MsUnlock())

							SC3->(dbSkip())
						EndDo
				EndCase
			ElseIf cTipoDoc >= "A1" .AND. cTipoDoc <= "A9"
				If FindFunction("OGXUtlOrig") //Identifica que esta utilizando o sigaagr
					If OGXUtlOrig() .and.FindFunction("OGX701AALC")	
						If !AGRXCOM8(SCR->CR_NUM, cTipoDoc, SCR->(RECNO()) ) 						
							DisarmTransaction()
							lRetorno := .F.
						EndIf
					EndIF
				Endif
			ElseIf cTipoDoc $ "PV|DV" .And. FindFunction('OpAlcFat')
				OpAlcFat(6,SCR->CR_NUM,cChaveREJ) //-- Rejeição do documento
			Elseif !cTipoDoc $ "CT|IC|RV|IR|MD|IM|PC|ST"
				MaAlcItEC(SCR->CR_NUM,SCR->CR_TIPO,SCR->CR_GRUPO,SCR->CR_ITGRP,SCR->CR_USER,,SCR->CR_USERORI,nOper,SCR->CR_APROV)
			EndIf

			If !Empty(SCR->CR_FLUIG) .And. (SCR->CR_STATUS == "07" .Or. SCR->CR_STATUS == "06")
				CancelProcess(Val(SCR->CR_FLUIG),FWWFUserID(Val(SCR->CR_FLUIG))," cancelado por contingência!",.F.)
			EndIf

			SCR->(dbSkip())
		End
		
		Do Case
			Case SCR->CR_TIPO == "ST"
				NNS->(dbSetOrder(1))
				If NNS->(MsSeek(cChaveRej))
					RecLock("NNS",.F.)
					NNS->NNS_STATUS := '4'
					NNS->NNS_JUSTIF := FwFldGet("CR_OBS")
					NNS->(MsUnlock())
				EndIf
			Case SCR->CR_TIPO == "PC"
				SC7->(dbSetOrder(1))
				SC7->(MsSeek(cChaveRej))
				While !SC7->(EOF()) .And. SC7->(C7_FILIAL+C7_NUM) == cChaveRej
					RecLock("SC7",.F.)
					SC7->C7_CONAPRO := 'R'
					SC7->C7_FLUXO	:= 'N'
					SC7->(MsUnlock())

					SC7->(dbSkip())
				EndDo
		EndCase

		// Verifica se há integração com SIGAEIC
		If lEasy .And. FindFunction("Po400RejAl")
			Po400RejAl(cChaveRej)
		Endif

        //Rejeitar os documento do Agro
		If cTipoDoc >= "A1" .AND. cTipoDoc <= "A9" 
		Else
		    MaMailAlcRej(cDocto, cUserOri, cTipoDoc, cObs) 
        EndIf
	EndIf

	//Envia o pedido de compra ao TOTVS Colaboracao
	If cPaisLoc == "BRA" .And. lRetorno .And. cTipoDoc $ "PC#AE" .And. (nOper == 1 .Or. nOper == 4) .And.;
		SC7->C7_TPOP $ " F" .And. FWLSEnable(TOTVS_COLAB_ONDEMAND)
		ExpXML_PC(SC7->C7_NUM)
	EndIf
			
	If ExistBlock("MTALCDOC")
		Execblock("MTALCDOC",.F.,.F.,{aDocto,dDataRef,nOper,cItGrp})
	EndIf	 

	//Envia o pedido de compra direto para portal MarketPLace
	If lRetorno .And. cTipoDoc $ "PC" .And. nOper == 4 .And. SC7->C7_TPOP $ " F" .And. ;
		lIntegDef .And. SuperGetMV("MV_MKPLACE",.F.,.F.) .And. !Empty(SC7->C7_ACCNUM)
		
	 	cA120Num := SC7->C7_NUM     
	 	If SC7->(MsSeek(xFilial("SC7")+SC7->C7_NUM))  
			Inclui:=.T.	               
			//Dispara thread
			MaEnvPed(cEmpAnt,cFilAnt,cA120Num)
		EndIf
	EndIf
EndIf

If ExistBlock("MTALCFIM")
	lCalculo := Execblock("MTALCFIM",.F.,.F.,{aDocto,dDataRef,nOper,cDocSF1,lResiduo})
	If Valtype( lCalculo ) == "L"
		lRetorno := lCalculo
	EndIf
Endif

// Não restaura na inclusão de alçada pra manter no registro novo
If nOper <> 1
	RestArea(aAreaSCR)
Endif

/*
Ajuste realizado para evitar a geração de Pedido Bloqueado quando o retorno do P.E. MT097GRV for igual a .F.
Esse retorno indica que o processo de geração de Alçada foi interrompido, portanto, o pedido de compra deve ser considerado liberado.
*/
If lPeMt97Grv .And. !lMt97Grv
	lRetorno := .T.
EndIf 

RestArea(aAreaSCS)
RestArea(aArea)

Return(lRetorno)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³ MaAlcLim  ³ Autor ³ Aline Correa do Vale ³ Data ³ 24.03.99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Verifica os limites minimos e maximos do aprovador.        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Codigo do Aprovador.                               ³±±
±±³          ³ ExpN1 = Valor a ser verificado na moeda do Documento       ³±±
±±³          ³ ExpN2 = Moeda do documento                                 ³±±
±±³          ³ ExpN3 = Taxa da moeda do documento original                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA120                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaAlcLim(cAprov,nValor,nMoeda,nTaxa,cGrupo)
Local cSavArea	:= Alias()
Local lRet 		:= .F.
Local nLimMin	:= 0
Local nLimMax	:= 0
Local aAreaSAK	:= SAK->(GetArea())

DEFAULT nMoeda := 1
DEFAULT nTaxa	:= 0

SAK->(DbSetOrder(1))
DHL->(DbSetOrder(1))

SAK->(DbSeek( xFilial("SAK") + cAprov ))
If DHL->(DbSeek( xFilial("DHL") + SAL->AL_PERFIL ))
	If nTaxa > 0
		nLimMin := xMoeda(DHL->DHL_LIMMIN,DHL->DHL_MOEDA,If(nMoeda > 1,nMoeda,1),dDataBase,,,nTaxa)
		nLimMax := xMoeda(DHL->DHL_LIMMAX,DHL->DHL_MOEDA,If(nMoeda > 1,nMoeda,1),dDataBase,,,nTaxa)
		If  nValor >= IIF(nLimMin <> 0, nLimMin,DHL->DHL_LIMMIN) .And. nValor <= IIF(nLimMax <> 0, nLimMax,DHL->DHL_LIMMAX)
			lRet := .T.
		EndIf
	ElseIf nMoeda > 1
		nLimMin := xMoeda(DHL->DHL_LIMMIN,DHL->DHL_MOEDA,If(nMoeda > 1,nMoeda,1),dDataBase)
		nLimMax := xMoeda(DHL->DHL_LIMMAX,DHL->DHL_MOEDA,If(nMoeda > 1,nMoeda,1),dDataBase)
		If  nValor >= IIF(nLimMin <> 0, nLimMin,DHL->DHL_LIMMIN) .And. nValor <= IIF(nLimMax <> 0, nLimMax,DHL->DHL_LIMMAX)
			lRet := .T.
		EndIf
	Else
		nLimMin := xMoeda(DHL->DHL_LIMMIN,DHL->DHL_MOEDA,1,dDataBase)
		nLimMax := xMoeda(DHL->DHL_LIMMAX,DHL->DHL_MOEDA,1,dDataBase)
		If nValor >= Iif(nLimMin <> 0, nLimMin,DHL->DHL_LIMMIN) .And. nValor <= Iif(nLimMax <> 0, nLimMax,DHL->DHL_LIMMAX)
			lRet := .T.
		EndIf
	EndIf
EndIf

RestArea(aAreaSAK)
DbSelectArea(cSavArea)
Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³MaVldSolic³ Autor ³Eduardo Riera          ³ Data ³22.10.2003³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Validacao para controle de solicitantes.                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Codigo do produto.                                 ³±±
±±³          ³ ExpA1 = Array contendo os grupos do usuario.               ³±±
±±³          ³ ExpC1 = Codigo do usuario a ser verificado.                ³±±
±±³          ³ ExpL1 = Variavel que controla a exibicao dos helps.        ³±±
±±³          ³ ExpN1 = Quantidade para verificacao de saldo.              ³±±
±±³          ³ ExpD1 = Data de referencia para verificacao do saldo.      ³±±
±±³          ³ ExpA2 = Array preenchido com informacoes sobre SAI solicit.³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ RetL1 = .T. - usuario/grupo com permissao ao produto.      ³±±
±±³          ³ RetL1 = .F. - usuario/grupo sem permissao ao produto.      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico.                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaVldSolic(cProduto,aGrupo,cUser,lHelp, nQuant, dDataRef, aInfoSAI)

Local aArea      := GetArea()
Local aAreaSAI   := SAI->(GetArea())
Local aAreaSCW   := SCW->(GetArea())
Local aUser      := {}
Local lRetorno   := .F.
Local lRestricao := .F.
Local nX         := 1
Local lExistSoli := SuperGetMV("MV_CHKSOLI",.F.,.F.) // Verifica se existe controle de solicitante 
Local lContinua  := .T.
Local cQuery     := ""
Local lQuery     := .F.
Local cAliasSAI  := "SAI"
Local lMsbLql	:= SAI->(FIELDPOS("AI_MSBLQL"))>0
Local lVerMsb	:= .F.

DEFAULT lHelp  := .T.
DEFAULT aGrupo := aClone(aUsrRetGrp)
DEFAULT cUser  := cRetCodUsr
DEFAULT nQuant   := 0
DEFAULT aInfoSAI := {}
DEFAULT dDataRef := Date()

// aInfoSAI
// [1] Grupo de Produto a ser verificado o saldo
// [2] Produto a ser verificado o saldo
// [3] Grupo de Usuario a ser verificado o saldo
// [4] Usuario a ser verificado o saldo
// [5] Quantidade Limite para o Periodo
// [6] Saldo Disponivel no SCW

dDataRef := FirstDay(dDataRef)
aUser    := {"******",cUser}

If !Empty(cProduto) .And. !PutByAPS()
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se há controle de solicitante                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ	
	If lExistSoli 
		dbSelectArea("SAI")
		dbSetOrder(1)
		If !MsSeek(xFilial("SAI"))
			lContinua := .F.
		Endif
	Endif
	
	If lContinua 		

		dbSelectArea("SB1")
		dbSetOrder(1)
		MsSeek(xFilial("SB1")+cProduto)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica os direitos dos Grupos de usuarios.             ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ			
		cAliasSAI := "MAVLDSOLIC"
		lQuery    := .T.

		cQuery	:= "SELECT "+Char(13)
		cQuery += "	COUNT(AI_FILIAL) NREG "+Char(13)
		cQuery	+= "FROM "+Char(13)
		cQuery	+=	"	"+RetSqlName("SAI")+" SAI "+Char(13)
		cQuery	+= "WHERE "+Char(13)
		cQuery	+= "	SAI.AI_FILIAL='"+xFilial("SAI")+"' AND "+Char(13)
		If !Empty( aGrupo )
			cQuery	+= " ((SAI.AI_GRUSER IN("
			For nX := 1 To Len(aGrupo)
				cQuery	+= "'"+aGrupo[nX]+Iif(nX==Len(aGrupo),"'","',")
			Next nX		
			cQuery	+= ") AND SAI.AI_USER = '******') "
			
			cQuery	+= " OR "
			
			cQuery	+= " (SAI.AI_USER = '" + cUser + "' AND SAI.AI_GRUSER = '******') "
			
			cQuery	+= " OR "
			
			cQuery	+= " (SAI.AI_USER = '******' AND SAI.AI_GRUSER = '******')) AND "+Char(13)
		Else
			cQuery	+= " ((SAI.AI_USER = '" + cUser + "' AND SAI.AI_GRUSER = '******') "
			cQuery	+= " OR "
			cQuery	+= " (SAI.AI_USER = '******' AND SAI.AI_GRUSER = '******')) AND "+Char(13)
		EndIf
		cQuery	+= "(((	SAI.AI_GRUPO='"+SB1->B1_GRUPO+"' OR SAI.AI_GRUPO='* ') 		AND "+Char(13)
		cQuery	+= " 	SAI.AI_PRODUTO='* ') OR SAI.AI_PRODUTO='"+SB1->B1_COD+"') 	AND "+Char(13)
		cQuery += "	SAI.D_E_L_E_T_ =' ' "+Char(13)
		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSAI)

		If (cAliasSAI)->NREG > 0
			lRetorno := .T.		
		EndIf
		(cAliasSAI)->(dbCloseArea())

		cAliasSAI := "MAVLDSOLIC"
		lQuery    := .T.

		cQuery	:= "SELECT "+Char(13)
		  	If lMsbLql 
		  		cQuery	+=  "AI_MSBLQL,"
		  	EndIf 
		cQuery	+= "	AI_FILIAL,AI_USER,AI_GRUSER,AI_GRUPO,AI_PRODUTO,AI_DOMINIO "+",AI_QUANT "+Char(13)
		cQuery	+= "FROM "+Char(13)
		cQuery	+= "	"+RetSqlName("SAI")+" SAI "+Char(13)
		cQuery += "WHERE "+Char(13)
		cQuery +=	"	SAI.AI_FILIAL='"+xFilial("SAI")+"' AND "+Char(13)
		If !Empty( aGrupo )
			cQuery	+= " ((SAI.AI_GRUSER IN("
			For nX := 1 To Len(aGrupo)
				cQuery	+= "'"+aGrupo[nX]+Iif(nX==Len(aGrupo),"'","',")
			Next nX		
			cQuery	+= ") AND SAI.AI_USER = '******') "
			
			cQuery	+= " OR "
			
			cQuery	+= " (SAI.AI_USER = '" + cUser + "' AND SAI.AI_GRUSER = '******') "
			
			cQuery	+= " OR "
			
			cQuery	+= " (SAI.AI_USER = '******' AND SAI.AI_GRUSER = '******')) AND "+Char(13)
		Else
			cQuery	+= " ((SAI.AI_USER = '" + cUser + "' AND SAI.AI_GRUSER = '******') "
			cQuery	+= " OR "
			cQuery	+= " (SAI.AI_USER = '******' AND SAI.AI_GRUSER = '******')) AND "+Char(13)
		EndIf
		cQuery    += "SAI.D_E_L_E_T_ = ' ' "
		cQuery := ChangeQuery(cQuery)

		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSAI)

		While (cAliasSAI)->(!Eof()) .And. (cAliasSAI)->AI_FILIAL == xFilial("SAI")
			If (AllTrim((cAliasSAI)->AI_GRUSER) == "******" .AND. AllTrim((cAliasSAI)->AI_USER) $ cUser) .Or. AllTrim((cAliasSAI)->AI_USER) == "******"
				If (cAliasSAI)->AI_DOMINIO=="I" 
					If ((cAliasSAI)->AI_GRUPO == SB1->B1_GRUPO .Or. Alltrim((cAliasSAI)->AI_GRUPO)=="*") .And.;
						Alltrim((cAliasSAI)->AI_PRODUTO)=="*" .And. !lRestricao .And. (cAliasSAI)->AI_DOMINIO $ "I "
						lRetorno := .T.
						aInfoSAI := {(cAliasSAI)->AI_GRUPO, (cAliasSAI)->AI_PRODUTO, (cAliasSAI)->AI_GRUSER, (cAliasSAI)->AI_USER, (cAliasSAI)->AI_QUANT, 0}
					EndIf
					If (cAliasSAI)->AI_PRODUTO == SB1->B1_COD .And. !lRestricao .And. (cAliasSAI)->AI_DOMINIO$"I "
						lRetorno := .T.
						aInfoSAI := {(cAliasSAI)->AI_GRUPO, (cAliasSAI)->AI_PRODUTO, (cAliasSAI)->AI_GRUSER, (cAliasSAI)->AI_USER, (cAliasSAI)->AI_QUANT, 0}
					EndIf
					If (cAliasSAI)->AI_PRODUTO == SB1->B1_COD .And. lRestricao .And. (cAliasSAI)->AI_DOMINIO$"I " .AND. Alltrim((cAliasSAI)->AI_GRUPO)=="*"
						lRetorno   := .T.
						lRestricao := .F.
						aInfoSAI   := {(cAliasSAI)->AI_GRUPO, (cAliasSAI)->AI_PRODUTO, (cAliasSAI)->AI_GRUSER, (cAliasSAI)->AI_USER, (cAliasSAI)->AI_QUANT, 0}				
					Endif
					EndIf
				If (cAliasSAI)->AI_DOMINIO=="E" 					
					If (cAliasSAI)->AI_PRODUTO == SB1->B1_COD .And. lRestricao .And. (cAliasSAI)->AI_DOMINIO$"E " .AND. Alltrim((cAliasSAI)->AI_GRUPO)=="*"
						lRetorno := .F.
						lRestricao := .T.
					EndIf
					If ((cAliasSAI)->AI_GRUPO == SB1->B1_GRUPO .Or. Alltrim((cAliasSAI)->AI_GRUPO)=="*") .And.;
						(Alltrim((cAliasSAI)->AI_PRODUTO)=="*" .Or. ((cAliasSAI)->AI_PRODUTO)==SB1->B1_COD) .And.;
						!lRestricao .And. (cAliasSAI)->AI_DOMINIO $ "E "
						lRetorno := .F.
						lRestricao := .T.
					EndIf
				EndIf
				If (cAliasSAI)->AI_DOMINIO == "R"
					If (cAliasSAI)->AI_DOMINIO == "R" .And. !lRestricao
						lRetorno := .F.
						lRestricao := .T.
					EndIf
					If (cAliasSAI)->AI_PRODUTO == SB1->B1_COD .And. (cAliasSAI)->AI_DOMINIO == "R"
						lRetorno := .T.
						lRestricao := .T.
						aInfoSAI := {(cAliasSAI)->AI_GRUPO, (cAliasSAI)->AI_PRODUTO, (cAliasSAI)->AI_GRUSER, (cAliasSAI)->AI_USER, (cAliasSAI)->AI_QUANT, 0}
						Exit
					EndIf
					If (cAliasSAI)->AI_USER<>'******' .And. ((cAliasSAI)->AI_GRUPO == SB1->B1_GRUPO .Or. AllTrim((cAliasSAI)->AI_GRUPO)=="*") .And. AllTrim((cAliasSAI)->AI_PRODUTO)=="*".And. (cAliasSAI)->AI_DOMINIO == "R"
						lRetorno := .T.
						lRestricao := .T.
						aInfoSAI := {(cAliasSAI)->AI_GRUPO, (cAliasSAI)->AI_PRODUTO, (cAliasSAI)->AI_GRUSER, (cAliasSAI)->AI_USER, (cAliasSAI)->AI_QUANT, 0}
					EndIf
				EndIf
				IF lMsbLql 
					If (cAliasSAI)->AI_GRUPO == SB1->B1_GRUPO .And. (cAliasSAI)->AI_MSBLQL == '1'      
						Help(" ",1,"A084MSBLQ",,STR0103,1,0)
						lRetorno	:= .F.
						lRestricao	:= .F. 
						lVerMsb		:= .T. 
					EndIf
				EndIf	
			EndIf
			(cAliasSAI)->(dbSkip())
		EndDo

		(cAliasSAI)->(dbCloseArea())

		dbSelectArea("SAI")

	Else
		lRetorno := .T.
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica saldo a requisitar do produto ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRetorno .And. !Empty(aInfoSAI) 
		dbSelectArea("SCW")
		dbSetOrder(1)
		If MsSeek(xFilial("SCW")+aInfoSAI[1]+aInfoSAI[2]+aInfoSAI[3]+aInfoSAI[4]+DToS(dDataRef))
			If SCW->CW_SALDO >= nQuant
				aInfoSAI[6] := SCW->CW_SALDO
				lRetorno := .T.
			Else
				lRetorno := .F.
			EndIf
		Else
			lRetorno := .T.
		EndIf
		If lHelp .And. !lRetorno
			ApMsgStop(STR0035)
		EndIf
	EndIf	
Else
	lRetorno := .T.
EndIf

If !lVerMsb
	If lHelp .And. !lRetorno 
		Help("  ",1,"A110RESTR")
	EndIf
EndIf

RestArea(aAreaSCW)
RestArea(aAreaSAI)
RestArea(aArea)
FwFreeArray(aAreaSCW)
FwFreeArray(aAreaSAI)
FwFreeArray(aArea)

Return(lRetorno)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³AtuSalSCW ³ Autor ³Ernani Forastieri      ³ Data ³18.03.2005³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Atualizacao dos saldo de pre requisicao                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Codigo do grupo de produtos.                       ³±±
±±³          ³ ExpC2 = Codigo de produtos                                 ³±±
±±³          ³ ExpC3 = Codigo do grupo de Usuarios                        ³±±
±±³          ³ ExpC4 = Codigo do usuario                                  ³±±
±±³          ³ ExpN1 = Quantidade para aumentar/diminuir no saldo         ³±±
±±³          ³ ExpN2 = Quantidade para periodo para cricao do saldo       ³±±
±±³          ³ ExpL1 = Variavel que controla a soma/subtracao do saldo    ³±±
±±³          ³ ExpD1 = Data de referencia do saldo.                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ RetL1 = .T. - usuario/grupo com permissao ao produto.      ³±±
±±³          ³ RetL1 = .F. - usuario/grupo sem permissao ao produto.      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico.                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function AtuSalSCW(cGrpProd, cProduto, cGrpUser, cUser, nQuant, nQtdPer, lSoma, dDataRef)
Local aArea       := GetArea()
Local aAreaSCW    := SCW->(GetArea())
Local nSaldo      := 0

DEFAULT lSoma     := .F.
DEFAULT nQuant    := 0
DEFAULT dDataRef  := Date()
DEFAULT nQtdPer   := nQuant

dDataRef  := FirstDay(dDataRef)

dbSelectArea("SCW")
If !MsSeek(xFilial("SCW")+cGrpProd+cProduto+cGrpUser+cUser+DtoS(dDataRef))
	RecLock("SCW",.T.)
	SCW->CW_FILIAL  := xFilial("SCW")
	SCW->CW_GRUPO   := cGrpProd
	SCW->CW_PRODUTO := cProduto
	SCW->CW_GRPUSER := cGrpUser                 
	
	SCW->CW_USER    := cUser
	SCW->CW_DATA    := dDataRef
	SCW->CW_LIMITE  := nQtdPer
	SCW->CW_SALDO   := Min(Max(0, nQtdPer - nQuant)	, nQtdPer)
	MsUnlock()
Else
	RecLock("SCW",.F.)
	SCW->CW_SALDO   := Min(Max(0, SCW->CW_SALDO + IIf(lSoma, nQuant, nQuant * -1)), SCW->CW_LIMITE)
	MsUnlock()
EndIf
nSaldo := SCW->CW_SALDO

RestArea(aAreaSCW)
RestArea(aArea)
Return nSaldo

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡ao    ³MaAvalPerm³ Autor ³Allyson Freitas        ³ Data ³23.01.2012³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡ao ³ Controle de permissoes por produto ou usuario/grupo        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpN1 = Tipo de Permissao                                  ³±±
±±³          ³           1 - Permissao por Rotina                         ³±± 
±±³          ³           2 - Permissao por TM                             ³±±
±±³          ³           3 - Permissao por Armazem                        ³±±
±±³          ³                                                            ³±±
±±³          ³ ExpA1 = Dados da busca                                     ³±±
±±³          ³               TIPO 1       |    TIPO 2     |    TIPO 3     ³±± 
±±³          ³  [1]C1 = Codigo do Produto |TM do documento|Cod. do Armazem³±±
±±³          ³  [2]C2 = Cod. do documento |               |Cod. do Produto³±±
±±³          ³  [3]C3 = Operacao          |               |               ³±±
±±³          ³           3- Inclusao                                      ³±±
±±³          ³           4- Alteracao                                     ³±±
±±³          ³           5- Exclusao                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ RetL1 = .T. - usuario/grupo/produto com permissao.         ³±±
±±³          ³ RetL1 = .F. - usuario/grupo/produto sem permissao.         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico.                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/ 
Function MaAvalPerm(nTipo,aDados,aGrupos)
Local cUsu		:= cRetCodUsr
Local cGProd	:= ""
Local cPermArm	:= SuperGetMV("MV_RESTARM",.F.,"0")
Local aArea		:= GetArea()
Local aGrp		:= {}
Local nTamPrd	:= 0
Local nTamGrp	:= 0
Local lRet 		:= .F.
Local lAchou 	:= .F.
Local nCont     := 0
Local lWmsPerm  := IIf(!(Type('lExecWms')=='U'), .T., .F.)

Default aGrupos := {}
DEFAULT _nTamPrd:= TamSX3("B1_COD")[1]
DEFAULT _nTamGrp:= TamSX3("B1_GRUPO")[1]

nTamPrd	:= _nTamPrd
nTamGrp	:= _nTamGrp

// Recebe grupos do usuario da rotina chamadora para efeito de performance da funcao UsrRetGrp
If Len(aGrupos) > 0
	aGrp := aClone(aGrupos)
Else
	aGrp := aClone(aUsrRetGrp)
EndIf

If !Empty(cUsu) .And. !lWmsPerm  
	Do Case
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Permissoes por Rotina ³
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ aDados[1] = Produto   ³
	//³ aDados[2] = Documento ³
	//³ aDados[3] = Operacao  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Case nTipo == 1
		//-- 1. Busca por produto e usuario
		If !Empty(aDados[1])
			cGProd := Posicione("SB1",1,xFilial("SB1")+aDados[1],"B1_GRUPO")

			SDW->(dbSetOrder(1))
			lAchou := SDW->(dbSeek(xFilial("SDW")+aDados[1]+cUsu+aDados[2]))
			
			//-- 2. Busca por produto e grupos do usuario
			If !lAchou .And. Len(aGrp) > 0
				SDW->(dbSetOrder(2))
				For nCont := 1 To Len(aGrp)
					If SDW->(dbSeek(xFilial("SDW")+aDados[1]+aGrp[nCont]+aDados[2]))
						lAchou := .T.
						Exit
					EndIf
				Next nCont
			EndIf
		
			//-- 3. Busca por grupo de produto e usuario
			If !lAchou .And. !Empty(cGProd)  
				SDW->(dbSetOrder(3))
				lAchou := SDW->(dbSeek(xFilial("SDW")+cGProd+cUsu+aDados[2]))
			EndIf
			
			//-- 4. Busca por grupo de produto e grupos do usuario
			If !lAchou .And. !Empty(cGProd) .And. Len(aGrp) > 0 
				SDW->(dbSetOrder(4))
				For nCont := 1 To Len(aGrp)
					If SDW->(dbSeek(xFilial("SDW")+cGProd+aGrp[nCont]+aDados[2]))
						lAchou := .T.
						Exit
					EndIf
				Next nCont
			EndIf
		Endif
		
		//-- 5. Busca por produto == "*" e usuario
		If !lAchou  
			SDW->(dbSetOrder(1))
			lAchou := SDW->(dbSeek(xFilial("SDW")+PadR("*",nTamPrd)+cUsu+aDados[2]))
		EndIf
		
		//-- 6. Busca por produto == "*" e grupos do usuario
		If !lAchou .And. Len(aGrp) > 0  
			SDW->(dbSetOrder(2))
			For nCont := 1 To Len(aGrp)
				If SDW->(dbSeek(xFilial("SDW")+PadR("*",nTamPrd)+aGrp[nCont]+aDados[2]))
					lAchou := .T.
					Exit
				EndIf
			Next nCont
		EndIf
		
		//-- 7. Busca por grupo de produto == "*" e usuario
		If !lAchou  
			SDW->(dbSetOrder(3))
			lAchou := SDW->(dbSeek(xFilial("SDW")+PadR("*",nTamGrp)+cUsu+aDados[2]))
		EndIf
		
		//-- 8. Busca por grupo de produto == "*" e grupos do usuario
		If !lAchou .And. Len(aGrp) > 0
			SDW->(dbSetOrder(4))
			For nCont := 1 To Len(aGrp)
				If SDW->(dbSeek(xFilial("SDW")+PadR("*",nTamGrp)+aGrp[nCont]+aDados[2]))
					lAchou := .T.
					Exit
				EndIf
			Next nCont
		EndIf
		
		//-- Se achou registro, verifica as permissoes segundo a operacao desejada
		If lAchou 
			Do Case
				Case aDados[3] == 3
					lRet := SDW->DW_INCLUI
				Case aDados[3] == 4
					lRet := SDW->DW_ALTERA
				Case aDados[3] == 5
					lRet := SDW->DW_EXCLUI
			EndCase
		//-- Senao, busca pelo parametro MV_PERMDEF
		Else
			lRet := SuperGetMV("MV_PERMDEF",.F.,.T.)
		EndIf
		

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Permissoes por TM ³
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ aDados[1] = TM   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Case nTipo == 2
		If SuperGetMV("MV_RESTTM",.F.,.F.) .And. !aDados[1] $ "499/999"
			SGP->(DbSetOrder(1))

			//-- 1. Busca permissao para todos os usuarios
			lRet := SGP->(dbSeek(xFilial("SGP")+aDados[1]+PadR("*",TamSX3("GP_USER")[1])))

			//-- 2. Busca por TM e Usuario
			If !lRet
				lRet := SGP->(dbSeek(xFilial("SGP")+aDados[1]+cUsu))
			EndIf
			
			//-- 3. Busca por TM e grupos do usuario
			If !lRet .And. Len(aGrp) > 0
				SGP->(dbSetOrder(2))
				For nCont := 1 To Len(aGrp)
					If (lRet := SGP->(dbSeek(xFilial("SGP")+aDados[1]+aGrp[nCont])))
						Exit
					EndIf
				Next nCont
			EndIf	
			
			//Se nao encontrou, exibe help
			If !lRet
				Help(,,1,"SEMPERM")
			EndIf
		Else
			lRet := .T.
		EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Permissao por Armazem ³
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ aDados[1] = Armazem   ³
	//³ aDados[2] = Produto   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Case nTipo == 3
		cGProd := Posicione("SB1",1,xFilial("SB1")+aDados[2],"B1_GRUPO")

		//-- MV_RESTARM == 0: Nao utiliza permissoes por armazem
		If cPermArm == "0"
			lRet := .T.
		EndIf

		//-- MV_RESTARM == 1 ou 3: Permissoes por usuario
		If !lRet .And. cPermArm $ "13"
			SGQ->(dbSetOrder(1))
			
			//-- 1. Busca por armazem e todos os usuarios
			lRet := SGQ->(dbSeek(xFilial("SGQ")+"1"+aDados[1]+PadR("*",TamSX3("GQ_USER")[1])))
			
			//-- 2. Busca por armazem e o usuario
			If !lRet
				lRet := SGQ->(dbSeek(xFilial("SGQ")+"1"+aDados[1]+PadR(cUsu,TamSX3("GQ_USER")[1])))
			EndIf

			//-- 3. Busca por armazem e grupos do usuario
			If !lRet .And. Len(aGrp) > 0
				SGQ->(DbSetOrder(2))
				For nCont := 1 To Len(aGrp)
					If (lRet := SGQ->(dbSeek(xFilial("SGQ")+"1"+aDados[1]+aGrp[nCont])))
						Exit
					EndIf
				Next nCont
			EndIf
			 
			//-- Libera acesso para usuário administrador
			If __CUSERID == '000000'
				lRet := .T.
			EndIf
		EndIf
		
		//-- MV_RESTARM == 1 ou 2 ou 3: Permissoes por produto
		If (!lRet .And. cPermArm == "1") .or. (!lRet .And. cPermArm == "2") .Or. (lRet .And. cPermArm == "3")

			//-- 1. Busca por armazem e todos os produtos
			SGQ->(dbSetOrder(3))
			lRet := SGQ->(dbSeek(xFilial("SGQ")+"2"+aDados[1]+PadR("*",nTamPrd)))
			
			//-- 2. Busca por armazem e produto
			If !lRet
				lRet := SGQ->(dbSeek(xFilial("SGQ")+"2"+aDados[1]+aDados[2]))
			EndIf
						
			//-- 3. Busca por armazem e grupo do produto
			If !lRet .And. !Empty(cGProd)
				SGQ->(dbSetOrder(4))
				lRet := SGQ->(dbSeek(xFilial("SGQ")+"2"+aDados[1]+cGProd))
			EndIf
		EndIf
			
		//Se nao encontrou, exibe help
		If !lRet 
			Do Case
				Case cPermArm == "1"		// Por usuario
					Help(" ",1,"RESTPRD",,I18N(STR0106,{Alltrim(aDados[1])}),2,0) // Operação não permitida. Há uma restrição de acesso no local de estoque '#1[01]#' para este usuário.
				Case cPermArm $ "23" 	// Por produto e/ou usuario
					Help(" ",1,"RESTPRD",,STR0073+STR0074+Alltrim(aDados[2])+STR0075+Alltrim(aDados[1])+"'.",2,0) //"Operação não permitida. Há uma restrição "###"de acesso ao produto '"###"' no armazém '"
			EndCase
		EndIf
	EndCase
Else
	lRet := .T.
EndIf

FwFreeArray(aGrp)

RestArea(aArea)
FwFreeArray(aArea)

Return lRet


// --------------------------------------------------------------------------------------
/*/{Protheus.doc} MaEnvPed
Prepara ambiente do JOB que enviará o pedido de compra para o Market Place
@author  Leonarndo Quintania
@version P11.8
@since   13/05/2013
/*/
// --------------------------------------------------------------------------------------

Function MaEnvPed(cEmp,cFil, cPedido)

Inclui:=.T.	
cA120Num := cPedido
FwIntegDef('MATA120')

Return .T.

// --------------------------------------------------------------------------------------
/*/{Protheus.doc} MaRetAglEC
Retorna os itens aglutinados por entidade contabil/grupo de aprovação
@author  Leandro Kenji
@version P11.8
@since   26/08/2013

aItensAgl

@aItensAgl Array com os itens para aglutinar

@return aRet
/*/
// --------------------------------------------------------------------------------------
Function MaRetAglEC(aItensAgl,cTpDoc)
                             	
Local aArea			:= GetArea()
Local aRet			:= {}
Local aEntCtb		:= {}
Local aGrpIt		:= {}
Local aGrpItApr		:= {}
Local aItemEC		:= {}
Local cKeyEtCtb		:= ""
Local cDoc			:= ""
Local cItem       	:= ""
Local cRateio		:= ""
Local cKeyGrpIt		:= ""
Local cTipCom 		:= ""
Local nForIt		:= 0
Local nVlrItem		:= 0

For nForIt := 1 to Len(aItensAgl)
	cDoc := aItensAgl[nForIt][1]
	cItem := aItensAgl[nForIt][2]
	cRateio := aItensAgl[nForIt][3]
	nVlrItem := aItensAgl[nForIt][4]
		
	aEntCtb := aClone(aItensAgl[nForIt][5])
	cTipCom := aItensAgl[nForIt][6]
	
	cKeyEtCtb := ""
	aItemEC		:= {}
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Monta chave para busca da entidade ctb. ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aEval(aEntCtb,{|x| cKeyEtCtb += x })

	aGrpIt := MaGrpApEC(aClone(aEntCtb),.T.,cTpDoc)

	cKeyGrpIt := aGrpIt[1] + aGrpIt[2] + cTipCom
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se aglutina ou adiciona a entidade ctb. ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If (nGrpItApr := aScan( aGrpItApr,{|x|,x[1] == cKeyGrpIt } )) > 0
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Aglutina o item e valor da entidade ctb.  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aAdd( aRet[nGrpItApr][2], {cItem,cRateio,nVlrItem,cTipCom} )
		aRet[nGrpItApr][3] += nVlrItem
	Else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Adiciona nova entidade ctb. no array de retorno³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Aadd(aItemEC,{cItem,cRateio,nVlrItem,cTipCom})
		Aadd( aRet , { cDoc, aClone(aItemEC) , nVlrItem, aClone(aEntCtb) } )

		Aadd( aGrpItApr, { cKeyGrpIt , Len(aRet) } )
	EndIf
	
Next nForIt

RestArea(aArea)

Return aRet

//-------------------------------------------------------------------
/*{Protheus.doc} MaEntCtb()
Funcao utilizada para gerar a alcada de aprovacao por itens aglutinados por Entidade Ctb. e valor.

@author Leandro.Moura
@since 28/08/2013
@version 1.0

cAlias,cAlsRat,cDocto,cTpDoc,aHeader,aCols,aHeadRat,aColsRat,nOpcao,dDtDoc

@param cAlias Alias da tabela.
@param cAlsRat Alias da tabela de rateio
@param cDoc Documento
@param cTpDoc Tipo de documento na SCR
@param aHeader aHeader da rotina
@param aCols aCols da rotina
@param aHeadRat aHeader da rotina de rateio
@param aColsRat aCols da rotina de rateio
@param nOpcao Inclusao, Alteracao, Exclusao, Rejeição
@param dDtDoc Data do documento

@return lGerouApv 
/*/
//-------------------------------------------------------------------

Function MaEntCtb(cAlias,cAlsRat,cDocto,cTpDoc,aHeader,aCols,aHeadRat,aColsRat,nOpcao,dDtDoc,aValItPc,cGrupoPC)
Local oModel		:= Nil

Local aItens  		:= {}
Local aAglut		:= {}
Local aEntCtb		:= {}
Local aAlcDoc		:= {}
Local aGrpAprov		:= {}
Local aItensDBM		:= {}
Local cTpAprCtEc	:= SuperGetMV("MV_CTAPREC",.F.,"0")
Local cItemPln		:= ""
Local cItemDoc		:= ""
Local cItemApr		:= ""
Local cAlsCpo		:= ""
Local cAlsRatCpo	:= ""
Local cGrpAprov 	:= ""
Local cItAprov		:= ""
Local cTipcom		:= ""
Local cCpo	 		:= ""
Local cNumDoc		:= ""
Local cRatCpo		:= ""

Local lContinua		:= .T.
Local lDelItem		:= .F.
Local lDeleta		:= Iif( nOpcao == 3, .T. , .F. )
Local lResiduo		:= .F.
Local lEstorna	:= Iif( ( (nOpcao == 2) .OR. (nOpcao == 3) ) , .T. , .F. )
Local lGerouApv	:= .F.
Local lFirstNiv	:= .F.
Local lEntCtb		:= .T.
Local lGravaB		:= .F.
Local lGravaL		:= .F.
Local lCtAprEc	:= .F.

Local nPosIt		:= 0
Local nPosQtd 	:= 0
Local nPosVlr		:= 0
Local nPosPrd		:= 0
Local nPosPln		:= 0
Local nPosRev		:= 0
Local nPosRes		:= 0
Local nPosItCtb		:= 0
Local nPosPerc		:= 0
Local nPosTipCom	:= 0
Local nPosPedido 	:= 0
Local nForIt		:= 0
Local nVlrIt		:= 0
Local nRateio		:= 0
Local nX			:= 0
Local nI			:= 0
Local nMoeda		:= If(Type("nMoedaPed") == "N",nMoedaPed,NIL)
Local nPosItDBM		:= 0
Local nTaxaMoeda	:= If(Type("nTxMoeda") == "N",nTxMoeda,NIL)
Local nPosItPc      := aScan(aHeader,{|x| AllTrim(x[2])=="C7_ITEM"})
Local nPosValIt     := 0
Local nQUJE			:= 0
Local nQUANT 		:= 0
Local cAprIPPC		:= SuperGetMv("MV_APRIPPC",.F.,'2') // Aprovação Item de Pedido em 2 etapas (IP+PC) 1-S 2-N
Local lCallMta235	:= FwIsInCallStack("MATA235")
Local lCallMta110	:= FwIsInCallStack("MATA110")
Local aItPedVinc	:= {} //Itens do acols SC que já possuem pedido de compra vinculado

Default aHeadRat	:= {}
Default aColsRat	:= {}
Default aValItPc    := {}	// Recebe da cotacao o valor do pedido com impostos
Default cGrupoPC	:= Space(TamSX3("C7_APROV")[1])

If type("aDocRelib") == "U"
Private	 aDocRelib := {}
EndIf

If type("lRelib") == "U"
Private	 lRelib := .F.
EndIf

If type("aUsrLib") == "U"
Private aUsrLib     := {}
EndIf

If Type("Altera") == "U"
Private	Altera := .F.
EndIf

//-- Caso seja alias iniciado com S desconsidera a primeira letra
If SubStr(cAlias,1,1) == "S"
	cAlsCpo := SubStr(cAlias,2,Len(cAlias) )
Else
	cAlsCpo := cAlias
EndIf

//-- Caso seja alias iniciado com S desconsidera a primeira letra
If SubStr(cAlsRat,1,1) == "S"
	cAlsRatCpo := SubStr(cAlsRat,2,Len(cAlsRat) )
Else
	cAlsRatCpo := cAlsRat 
EndIf

//-- Verifica Planilha do Item caso seja IC, IR ou IM
If cTpDoc $ "IC|IR|IM"
	cCpo := cAlsCpo + "_NUMERO"
	If lContinua .AND. !Empty( (cAlias)->( FieldPos(cCpo) ) )
		nPosPln := aScan(aHeader, {|x| Alltrim(x[2]) == cCpo })
	ElseIf lContinua
		lContinua := .F.
	EndIf
EndIf

//-- Verifica Revisão do Item caso seja IC, IR ou IM
If cTpDoc $ "IC|IR|IM"
	cCpo := cAlsCpo + "_REVISA"
	If lContinua .AND. !Empty( (cAlias)->( FieldPos(cCpo) ) )
		nPosRev := aScan(aHeader, {|x| Alltrim(x[2]) == cCpo })
	ElseIf lContinua
		lContinua := .F.
	EndIf
EndIf

//-- Verifica Resídop do Item caso seja IC, IR ou IM
If cTpDoc $ "SC|PC|IP"
	cCpo := cAlsCpo + "_RESIDUO"
	If lContinua .AND. !Empty( (cAlias)->( FieldPos(cCpo) ) )
		nPosRes := aScan(aHeader, {|x| Alltrim(x[2]) == cCpo })
	ElseIf lContinua
		lContinua := .F.
	EndIf
EndIf

//-- Verifica posicao do item
cCpo := cAlsCpo + "_ITEM"
If lContinua .AND. !Empty( (cAlias)->( FieldPos(cCpo) ) )
	nPosIt := aScan(aHeader, {|x| Alltrim(x[2]) == cCpo })	
ElseIf lContinua
	lContinua := .F.	
EndIf

//-- Verifica posicao da Qtde
cCpo := cAlsCpo + "_QUANT"
If lContinua .AND. !Empty( (cAlias)->( FieldPos(cCpo) ) )
	nPosQtd := aScan(aHeader, {|x| Alltrim(x[2]) == cCpo })
ElseIf lContinua
	lContinua := .F.
EndIf

//-- Verifica posicao do Produto
If cTpDoc $ "IC|IR|IM"
	cCpo := cAlsCpo + "_PRODUT"
Else
	cCpo := cAlsCpo + "_PRODUTO"
EndIf

If lContinua .AND. !Empty( (cAlias)->( FieldPos(cCpo) ) )
	nPosPrd := aScan(aHeader, {|x| Alltrim(x[2]) == cCpo })
ElseIf lContinua
	lContinua := .F.
EndIf

//-- Verifica posicao do Valor caso seja IP, IC ou IR
If cTpDoc $ "IC|IR|IM"
	cCpo := cAlsCpo + "_VLUNIT"
ElseIf cTpDoc $ "SC|SA"
	cCpo := cAlsCpo + "_VUNIT"
Else
	cCpo := cAlsCpo + "_PRECO" 
EndIf

If lContinua .AND. cTpDoc $ "IP|IC|IR|IM|SC|SA" .AND. !Empty( (cAlias)->( FieldPos(cCpo) ) )
	nPosVlr := aScan(aHeader, {|x| Alltrim(x[2]) == cCpo })
ElseIf (cTpDoc == "IP" ) .AND. lContinua
	lContinua := .F.
EndIf

//-- Verifica posicao do Tipo de Compra
If lContinua .And. cTpDoc $ "SC|IP"
	cCpo := cAlsCpo + "_TIPCOM"
	nPosTipCom := aScan(aHeader, {|x| Alltrim(x[2]) == cCpo })
EndIf

If lContinua
	//-- Para cada item, preenche o array para aglutinacao
	For nForIt := 1 to Len(aCols)
		
		nVlrIt := 0	
		
		//-- Valida item deletado
		If ValType( aCols[nForIt][Len( aCols[nForIt] )] ) == "L"
			lDelItem := aCols[nForIt][Len( aCols[nForIt] ) ]
		EndIf

		//Guarda os itens que possuem pedido de compra vinculado.
		If cTpDoc == "SC" .and. lCallMta110

			nPosPedido := aScan(aHeader, {|x| Alltrim(x[2]) == "C1_PEDIDO" })

			If nPosPedido > 0 .and. !Empty(aCols[nForIt][nPosPedido])
				aAdd(aItPedVinc,aCols[nForIt][1])
				Loop
			Endif 
		Endif

		If cTpDoc == "IP" .And. !_lWizard
			//verifica se o pedido + item possui vinculo com NF
			If MtVincNF(cDocto, aCols[nForIt][nPosIt])
				Loop
			EndIf
		EndIf
		//Checa Eliminação de Resíduo
		If cTpDoc $ "SC|IP|PC" .and. nPosRes>0
			lResiduo := !Empty(aCols[nForIt][nPosRes])
			If cTpDoc == "SC"
				nQUJE := GetAdvFVal("SC1","C1_QUJE",xFilial("SC1")+cDocto+aCols[nForIt][nPosIt],1)
				nQUANT := GetAdvFVal("SC1","C1_QUANT",xFilial("SC1")+cDocto+aCols[nForIt][nPosIt],1)
			Else
				nQUJE 	:= GetAdvFVal("SC7","C7_QUJE",xFilial("SC7")+cDocto+aCols[nForIt][nPosIt],1)
				nQUANT 	:= GetAdvFVal("SC7","C7_QUANT",xFilial("SC7")+cDocto+aCols[nForIt][nPosIt],1)		
			EndIf
				
			If lResiduo .AND. nQUJE <> nQUANT //-- Não pode gerar alçada de itens eliminados resíduos e que foram atendidos parcialmente.
				Loop
			EndIf
		EndIf
		
		If !lDelItem .And. !Empty(aCols[nForIt][nPosIt])
			cItemDoc	:= aCols[nForIt][nPosIt]
			If nPosTipCom > 0
				cTipCom		:= aCols[nForIt][nPosTipCom]
			EndIf

			//-- Verifica se o item possui rateio
			If cTpDoc $ "IC|IR|IM"
				nPosItCtb := aScan(aHeadRat, {|x| Alltrim(x[2]) == 'CNZ_ITCONT' })
				nRateio := aScan(aColsRat, {|x| x[nPosItCtb] == cItemDoc})
			Else
				nRateio := aScan(aColsRat, {|x| x[1] == cItemDoc .And. !Empty(x[2])} )

				cRatCpo := cAlsRatCpo + "_PERC"
				nPosPerc := aScan(aHeadRat, {|x| Alltrim(x[2]) == cRatCpo })

				If(nRateio > 0 .And. Empty(aColsRat[nRateio][2][1][nPosPerc]))
            		nRateio := 0 //tratativa para pedido por cotação pois ele cria o aColsRat mesmo sem rateio com os campos da SCH vazios
				EndIf
			EndIf
			
			//Adiciona Valor Total do Item conforme cálculos Fiscais (Com Frete, despesas e Impostos AdValorem)
			If !Empty(aValItPc)
				If nPosItPc > 0
					If ( nPosValIt := aScan(aValItPc[2],{|x| x[1] == aCols[nForIt][nPosItPc]}) ) > 0
						nVlrIt := aValItPc[2][nPosValIt][2]
					EndIf
				EndIf
			ElseIf MaFisFound()
				nVlrIt := MaFisRet(nForIt,"IT_TOTAL")
			EndIf
			
			If nVlrIt == 0
				If cTpDoc $ "IP|IC|IR|IM|SC|SA" .And. nPosVlr > 0
					nVlrIt := aCols[nForIt][nPosVlr]
				EndIf
				
				If nVlrIt == 0
					nVlrIt := MTGetVProd(aCols[nForIt][nPosPrd],cTpDoc)
				EndIf
				
				nVlrIt := nVlrIt * aCols[nForIt][nPosQtd]
			EndIf

			If nRateio == 0
	   			//-- Carrega array com as entidades contabeis
				aEntCtb := MtGetValEC(cAlias, cAlsCpo, aHeader, aCols, nForIt, {} )

				If cTpDoc $ "IC|IR|IM"
					If !(Empty(aEntCtb[1][1]) .AND. Empty(aEntCtb[1][2]) .AND. Empty(aEntCtb[1][3]))
						Aadd(aItens,{cDocto,cItemDoc,"",nVlrIt,aClone(aEntCtb[1]),cTipCom})
					EndIf
				Else
					Aadd(aItens,{cDocto,cItemDoc,"",nVlrIt,aClone(aEntCtb[1]),cTipCom})
				EndIf
			Else
				//-- Rotina para montagem do array de rateio
				If cTpDoc $ "IC|IR|IM"
					lContinua := MaMtRateio(cAlsRat,cDocto,cItemDoc,nVlrIt,@aItens,aHeadRat,aColsRat,cTipCom)
				Else
					lContinua := MaMtRateio(cAlsRat,cDocto,cItemDoc,nVlrIt,@aItens,aHeadRat,aColsRat[nRateio][2],cTipCom)
				EndIf
			EndIf
		EndIf
		If !lContinua
			Exit
		EndIf
		
		lDelItem := .F.
	Next nForIt
EndIf

//Guarda os itens que possuem pedido de compra vinculado
//Utilizado somente quando for execauto
If cTpDoc == "SC" .and. lCallMta110 .and. l110Auto
	aItPedVinc := MtPedVinc(cDocto)
EndIf

If lContinua
	//-- Estorna todas as aprovacoes do documento caso necessario
	If lEstorna
		MaEstAlcEC(cDocto,cTpDoc,dDtDoc,aItPedVinc)
	EndIf

	//-- Funcao para aglutinar os itens por entidade ctb
	aAglut := MaRetAglEC( aItens , cTpDoc )


	//-- Gera SCR para cada entidade contabil
	For nForIt := 1 to Len(aAglut)
		//-- Verifica tolerância na geração da alçada de pedido
		If cTpDoc == "IP"
			lTolera := MaRetTolIt( aAglut[nForIt] )
			If lTolera
				Loop
			Endif
		Endif

		//-- Busca grupo de aprovadores
		aGrpAprov		:= MaGrpApEC( aClone(aAglut[nForIt][4]),@lEntCtb,cTpDoc)
		cGrpAprov 		:= Iif( Len(aGrpAprov) >= 1 , aGrpAprov[1] , "")
		cItAprov		:= Iif( Len(aGrpAprov) >= 2 , aGrpAprov[2] , "")

		If !Empty(cGrpAprov) .or. Altera
			If cTpDoc $ "IC|IR|IM"
				If ((cTpDoc == "IC" .And. cTpAprCtEc $ "1|3") .Or. (cTpDoc == "IR" .And. cTpAprCtEc $ "2|3"))
					cGrpAprCt 	:= 	CnGetAprDc(cDocto,,cTpDoc)
					lCtAprEc 	:=	cGrpAprCt == cGrpAprov
				EndIf

				If nForIt <= Len(aCols) .AND. cItemPln <> aCols[nForIt][nPosPln]
					cItemPln	:= aCols[nForIt][nPosPln]
					cItemApr 	:= "000"
				EndIf
				cItemApr := soma1(cItemApr)

				If !lCtAprEc
					cNumDoc := aAglut[nForIt][1]+cItemPln+cItemApr

					aAlcDoc := { 	cNumDoc			,; 		// Num. Documento
									cTpDoc				,; 		// Tipo Doc.
									aAglut[nForIt][3]	,; 		// Valor aprovac.
														,;		// Aprovador
														,;		// Cod. Usuario
									cGrpAprov			,;		// Grupo Aprovac.
														,;		// Aprov. Superior
									nMoeda				,;		// Moeda Docto
									nTaxaMoeda			,;		// Taxa da moeda
									dDtDoc				}		// Data Emissao
				Else
					cItemApr := Tira1(cItemApr)
				EndIf
			Else
				aAlcDoc := { 	aAglut[nForIt][1]	,; 		// Num. Documento
		  				  		cTpDoc				,; 		// Tipo Doc.
						  		aAglut[nForIt][3]	,; 		// Valor aprovac.
						  							,;		// Aprovador
						  							,;		// Cod. Usuario
						  		cGrpAprov			,;		// Grupo Aprovac.
						  							,;		// Aprov. Superior
			              	nMoeda				,;		// Moeda Docto
			              	nTaxaMoeda			,;		// Taxa da moeda
			             		dDtDoc				}		// Data Emissao
			EndIf

			//-- Chama rotina para controle de alcada
			If !lDeleta .And. !lCtAprEc
				If nOpcao == 4   
					IF lRelib .AND. !Empty(aUsrLib)
						For nI := 1 to len(aUsrLib)
							aAlcDoc[4] := aUsrLib[nI][2]
							MaAlcDoc(aAlcDoc,,4,,,cItAprov,aClone(aAglut[nForIt,2]),,@aItensDBM)
						Next
					Else	
						lFirstNiv := MaAlcDoc(aAlcDoc,,4,,,cItAprov,aClone(aAglut[nForIt,2]),,@aItensDBM)
					Endif
			  Else
					lFirstNiv := MaAlcDoc(aAlcDoc,,1,,,cItAprov,aClone(aAglut[nForIt,2]),,@aItensDBM)
					IF IsInCallStack('MATA235') .and. !Empty(aUsrLib)
						For nI := 1 to len(aUsrLib)
							aAlcDoc[4] := aUsrLib[nI][2]
							MaAlcDoc(aAlcDoc,,4,,,cItAprov,aClone(aAglut[nForIt,2]),,@aItensDBM)
						Next
					ENDIF
				EndIf
				
				For nX := 1 To Len(aAglut[nForIt,2])
					Do Case
					Case cTpDoc $ "SC|SA|IP"
						If (cAlias)->(dbSeek(xFilial(cAlias)+aAglut[nForIt,1]+aAglut[nForIt,2,nX,1]))
							nPosItDBM := aScan(aItensDBM , {|x| x[1] == PadR(aAglut[nForIt,2,nX,1],Len(DBM->DBM_ITEM))})
							lGravaB := nPosItDBM > 0 .And. ;
							MtExistSCR(cTpDoc,Padr(cDocto,TamSX3('CR_NUM')[1]),.F.) // Verifica se gerou alçada para o Doc atual
							If !lGravaB
								lGravaL := MtGLastDBM(cTpDoc,aAglut[nForIt,1],aAglut[nForIt,2,nX,1])
							EndIf

							RecLock(cAlias,.F.)
							Do Case
							Case cTpDoc == "SC" .AND. (!ALTERA .OR. (Empty(SC1->C1_COTACAO) .OR. Alltrim(SC1->C1_COTACAO) = 'IMPORT') )
								If !lCallMta235 .Or. (lCallMta235 .and. (SCR->CR_STATUS <> "03" .AND. SCR->CR_STATUS <> "05"))
									SC1->C1_APROV := If(lGravaB,"B",If(lGravaL,"L",	SC1->C1_APROV))
								Endif
							Case cTpDoc == "SA"
								SCP->CP_STATSA := If(lGravaB,"B",If(lGravaL,"L",SCP->CP_STATSA))
							Case cTpDoc == "IP" .And. Empty(SC7->C7_ENCER)
								If !lCallMta235 .Or. (lCallMta235 .and. (SCR->CR_STATUS <> "03" .AND. SCR->CR_STATUS <> "05"))
									SC7->C7_CONAPRO := If(lGravaB,"B",If(lGravaL,"L",SC7->C7_CONAPRO))
									//Atualiza Grupo de Aprovação para aprovação IP + PC
									If cAprIPPC == '1' .And. Empty(SC7->C7_APROV)
										SC7->C7_APROV   := cGrupoPC  
									Endif
								EndIf
									/*REVISAR junto com soluções do spike de alçadas - checar evidência técnica do DMANMAT02-7553
								•	CASO 2. Correção gravação do grupo de aprovação da entidade contábil no campo C7_APROV quando gravado via Entidade Contábil.
								•	CASO 3. Correção limpeza do campo C7_APROV quando não gerado mais SCR e DBM relacionado a MV_APRPCEC habilitado.
								If lGravaB
									SC7->C7_APROV   := aItensDBM[nPosItDBM][2]
								ElseIf !Empty(SC7->C7_APROV) .AND. (SC7->C7_CONAPRO$"L| ")
									SC7->C7_APROV   := Space(Len(SC7->C7_APROV))
								EndIf*/
							EndCase
							(cAlias)->(MsUnlock()) 
						EndIf
					Case cTpDoc == "IC"
						CN9->(dbSetOrder(1))
						If CN9->(dbSeek(xFilial('CN9')+aAglut[nForIt,1]))
							RecLock("CN9",.F.)
							CN9->CN9_SITUAC := "04"
							CN9->(MsUnlock())
						EndIf
					Case cTpDoc == "IR" .And. !lFirstNiv
						CN9->(dbSetOrder(1))
						If CN9->(dbSeek(xFilial('CN9')+aAglut[nForIt,1]))
							RecLock("CN9",.F.)
							CN9->CN9_SITUAC := "A"
							CN9->(MsUnlock())
						Else
							oModel := FwModelActive()
							oModel:LoadValue("CN9MASTER","CN9_SITUAC","A")
						EndIf				
					EndCase
				Next nX
			EndIf

			If !lGerouApv .And. !lFirstNiv .And. !lCtAprEc
				lGerouApv := .T.
			EndIf
		Else 
			If cTpDoc == "SC" .and. !lCallMta235 .and. SC1->C1_APROV == "B" .And. !lGravaB
				If Reclock("SC1", .F.)
					SC1->C1_APROV := "L"
				EndIf
			Elseif cTpDoc == "IP" .and. cAprIPPC == '1' .And. Empty(SC7->C7_APROV) .and. !lCallMta235 .and. Empty(SC7->C7_ENCER)
				For nX := 1 To Len(aAglut[nForIt,2])
					If SC7->(dbSeek(xFilial("SC7")+aAglut[nForIt,1]+aAglut[nForIt,2,nX,1]))
						If Reclock("SC7", .F.)
							SC7->C7_APROV   := cGrupoPC
							SC7->(MsUnlock())
						EndIf
					Endif
				next nX
			Endif
		EndIf
	Next nForIt
EndIf

Return lGerouApv

//-------------------------------------------------------------------
/*/{Protheus.doc} MaMtRateio()
Funcao utilizada para montar o array de rateio do item.

@author Leandro.Moura
@since 28/08/2013
@version 1.0

cAlias,cDoc,cItem,nQtde,aItens,aHead,aCols

@param cAlias Alias da tabela.
@param cDoc Documento
@param cItem Item do Documento
@param aHead aHeader da rotina
@param aCols aCols da rotina

@return lRet
/*/
//-------------------------------------------------------------------
Static Function MaMtRateio(cAlias,cDoc,cItem,nVlrItem,aItens,aHead,aCols,cTipCom)
Local aEntCtb		:= {}
Local aRateio		:= aClone(aItens)

Local cAlsCpo		:= ""
Local cCpo			:= ""
Local cItemRat		:= ""

Local nPosItem	:= 0
Local nPosItRat		:= 0
Local nPosPerc		:= 0
Local nFor			:= 0
Local nVlrRat		:= 0
Local nPerRat		:= 0

Local lRet			:= .T.

Default cTipCom	:= ""

//-- Caso seja alias iniciado com S desconsidera a primeira letra
If SubStr(cAlias,1,1) == "S"
	cAlsCpo := SubStr(cAlias,2,Len(cAlias) )
Else
	cAlsCpo := cAlias 
EndIf

//-- Verifica posicao do item da tabela CNZ
If lRet .AND. cAlias == "CNZ"
	cCpo := cAlsCpo + "_ITCONT"
	If !Empty( (cAlias)->( FieldPos(cCpo) ) )
		nPosItem := aScan(aHead, {|x| Alltrim(x[2]) == cCpo })
	Else
		lRet := .F.
	EndIf
EndIf

//-- Verifica posicao do item do Rateio
cCpo := cAlsCpo + "_ITEM"
If lRet .AND. !Empty( (cAlias)->( FieldPos(cCpo) ) )
	nPosItRat := aScan(aHead, {|x| Alltrim(x[2]) == cCpo })
Else
	lRet := .F.
EndIf

//-- Verifica posicao do Percentual caso seja campos de rateio
cCpo := cAlsCpo + "_PERC"
If lRet .AND. !Empty( (cAlias)->( FieldPos(cCpo) ) )
	nPosPerc := aScan(aHead, {|x| Alltrim(x[2]) == cCpo })	
ElseIf lRet 
	lRet := .F.
EndIf

//-- Verifica posicao do Tipo de Compra
If lRet .And. cAlias $ "SC1|SC7"
	cCpo := cAlsCpo + "_TIPCOM"
	nPosTipCom := aScan(aHead, {|x| Alltrim(x[2]) == cCpo })
EndIf

If lRet
	//-- Monta array conforme rateio do item
	For nFor := 1 to Len(aCols)
		If !aTail(aCols[nFor])
			cItemRat := aCols[nFor][nPosItRat]

			//-- Aplica o percentual do rateio sobre a quantidade
			nPerRat := (aCols[nFor][nPosPerc]) / 100
			nVlrRat := nVlrItem * nPerRat

			//-- Carrega array com as entidades contabeis
			aEntCtb := MtGetValEC(cAlias, cAlsCpo, aHead, aCols, nFor, {} )

			If cAlias <> "CNZ" .OR. (cAlias == "CNZ" .AND. cItem == aCols[nFor][nPosItem])
				Aadd( aRateio, { cDoc			,;		// Documento
								cItem			,;		// Item Dcto.
								cItemRat		,;		// Item Rateio
								nVlrRat			,; 		// Valor item
								aClone(aEntCtb[1]),;	// Array com Entidades Ctb.
								cTipCom } ) 			//Tipo de Compra
			EndIf
		EndIf
	Next nFor
EndIf

//-- Insere no array oficial os itens de rateio
aItens := aClone(aRateio)

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} MaEstAlcEC()
Funcao utilizada para estornar a liberacao do documento

@author Leandro.Moura
@since 28/08/2013
@version 1.0

cDocto,cTpDoc,dDtDoc

@param cDoc Documento
@param cTpDoc Tipo do Documento
@param dDtDoc Data do Documento

@return
/*/
//-------------------------------------------------------------------
Static Function MaEstAlcEC(cDocto,cTpDoc,dDtDoc,aItPedVinc)

Local aEstDoc	:= {}
Local aArea		:= GetArea()
Local cGrpApv	:= ""
Local ccDocto	:= Padr(cdocto,Len(SCR->CR_NUM))

Default aItPedVinc := {}

BeginSQL Alias "TMPSCR"

	SELECT SCR.CR_NUM AS DOC, SCR.CR_TOTAL AS VLRDOC, SCR.CR_GRUPO AS GRPAPV
	FROM %Table:SCR% SCR
	WHERE SCR.%NotDel% AND	
		SCR.CR_FILIAL 		= %xFilial:SCR% AND
		SCR.CR_NUM 			= %Exp:ccDocto% AND
		SCR.CR_TIPO 		= %Exp:cTpDoc%
		GROUP BY SCR.CR_NUM,SCR.CR_TOTAL,SCR.CR_GRUPO

EndSQL

While TMPSCR->(!EOF())

	cGrpApv := TMPSCR->GRPAPV

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Monta array para estorno do documento³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aEstDoc := { Alltrim(TMPSCR->DOC)	,; 		// Num. Documento
	  			  cTpDoc				,; 		// Tipo Doc.
				  TMPSCR->VLRDOC   		,; 		// Valor aprovac.
				  						,;		// Aprovador
				  						,;		// Cod. Usuario
				  cGrpApv				,;		// Grupo Aprovac.
				  						,;		// Aprov. Superior
				  						,;		// Moeda Docto
				  						,;		// Taxa da moeda
	              dDtDoc				}		// Data Emissao
	              						
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Chama rotina para estorno ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	MaAlcDoc(aEstDoc,,3,,,,,,,,,,aItPedVinc)
	
	TMPSCR->(dbSkip())
End

TMPSCR->(dbCloseArea())

RestArea(aArea)
Return

//-------------------------------------------------------------------
/*/{Protheus.doc} MtGetValEC()
Retorna array com os valores das entidades contabeis

@author Aecio Gomes
@since 28/08/2013
@version 1.0

cTab, cPrefix, aHeader, aCols, nLinAcols, aCampos

@param cTab Alias da tabela.
@param cPrefix Prefixo da tabela.
@param aHeader aHeader da rotina
@param aCols aCols da rotina
@param nLinAcols Linha atual do aCols
@param aCampos entidades contábeis já existentes no array. 

@return aCampos 
/*/
//-------------------------------------------------------------------
Function MtGetValEC(cTab, cPrefix, aHeader, aCols, nLinAcols, aCampos)
Local aArea 	:= GetArea()
Local aRetEc	:= {}
Local aFieldsEC	:= {}
Local nX, nY		:= 0

Default aHeader := {}
Default aCampos	:= {}
Default aCols	:= {}
Default cTab 	:= ""
Default cPrefix := ""
Default nLinAcols := 0

If Empty(aCampos)
	aCampos	:= {cPrefix+"_CC",cPrefix+"_CONTA", cPrefix+IIf(Len(cPrefix)==3,"_ITEMCT","_ITEMCTA"), cPrefix+"_CLVL"}
EndIf

For nX := 1 To Len(aCampos)
	If (cTab)->(FieldPos(aCampos[nX])) > 0
		AADD(aFieldsEC, aCampos[nX])
	EndIf
Next nX

aFieldsEC := MTGETFEC(cTab, cPrefix, aFieldsEC)

If nLinAcols > 0 
	AADD(aRetEc, {})
	For nX := 1 To Len(aFieldsEC)
		xConteudo := GDFieldGet(aFieldsEC[nX], nLinAcols, .F., aHeader, aCols)
		If Valtype(xConteudo) == "C"
			AADD(aTail(aRetEc), xConteudo)
		Else
			AADD(aTail(aRetEc), "")
		Endif
	Next		
Else
	For nX := 1 To Len(aCols)
		AADD(aaRetEc, {})
		For nY := 1 To Len(aFieldsEC)
			xConteudo := GDFieldGet(aFieldsEC[nY], nX, .F., aHeader, aCols)
			If Valtype(xConteudo) == "C"
				AADD(aTail(aRetEc), xConteudo)
			Else
				AADD(aTail(aRetEc), "")
			Endif
		Next nY
	Next nX
EndIf		

RestArea(aArea)
Return(aRetEc)

//-------------------------------------------------------------------
/*/{Protheus.doc} MaGrpApEC()
Funcao utilizada para retornar o grupo de aprovacao conforme entidades ctb.

@author Leandro.Moura
@since 29/08/2013
@version 1.0

aEntCtb,lEntCtb

@param aEntCtb Array com as entidades contabeis
@param lEntCtb Informa se existe entidade ctb preenchida

@return aApv
/*/
//-------------------------------------------------------------------
Function MaGrpApEC(aEntCtb,lEntCtb,cTpDoc)

Local aArea	  		:= GetArea()
Local aApv			:= {}
Local aApvPE		:= {}
Local aCondEC		:= MtGetFEC("DBL", "DBL", { "DBL_CC","DBL_CONTA","DBL_ITEMCT","DBL_CLVL" })
Local aAuxGrp		:= {}
Local cGrupo		:= ""
Local cItGrp		:= ""
Local cVldEC		:= "%"
Local cCampos		:= "%"
Local cJoin			:= "%"
Local cWhere		:= "%"
Local cAls			:= GetNextAlias()
Local cGrpDfl		:= SuperGetMv("MV_APGRDFL",.F.,"")
Local lAltpdoc		:= SuperGetMv("MV_ALTPDOC",.F.,.F.)
Local lOK			:= .T.
Local lAchou 		:= .F.
Local nForEnt		:= 0
Local lFilEntCtb	:= .F.
Local aPeso			:= {'15','7','3','1'}
Local nX			:= Len(aPeso)

Default __lPapec := ExistBlock("GRPAPEC")
Default lEntCtb		:= .T.

IF __lPapec
   aApvPE := ExecBlock("GRPAPEC",.f.,.f.,{aEntCtb,lEntCtb,cTpDoc})
   If ValType(aApvPE) == "A" .And. Len(aApvPE) == 2
		aApv := aClone(aApvPE)
		Return aApv
	EndIf
Endif 

For nX :=  Len(aPeso) To Len(aEntCtb)
	aAdd(aPeso,'1')
Next nX

If !( Len(aEntCtb) >= 1 )
	lEntCtb := .F.
	lOK := .F.
EndIf

If lAltpdoc
	Do Case
		Case cTpDoc == "AE"
			cTpDoc := 'SAL.AL_DOCAE'
		Case cTpDoc == "CP"
			cTpDoc := 'SAL.AL_DOCCP'
		Case cTpDoc == "NF"
			cTpDoc := 'SAL.AL_DOCNF'
		Case cTpDoc == "PC"
			cTpDoc := 'SAL.AL_DOCPC'
		Case cTpDoc == "SA"
			cTpDoc := 'SAL.AL_DOCSA'
		Case cTpDoc == "SC"
			cTpDoc := 'SAL.AL_DOCSC'
		Case cTpDoc == "ST"
			cTpDoc := 'SAL.AL_DOCST'
		Case cTpDoc == "IP"
			cTpDoc := 'SAL.AL_DOCIP'
		Case cTpDoc $ "CT|IC"
			cTpDoc := 'SAL.AL_DOCCT'
		Case cTpDoc $ "RV|IR"
			cTpDoc := 'SAL.AL_DOCCT'
		Case cTpDoc $ "MD|IM"
			cTpDoc := 'SAL.AL_DOCMD'
		Case cTpDoc == "GA"
			cTpDoc := 'SAL.AL_DOCGA'
	End
EndIf

If lOK
	//-- Adiciona verificação de proximidade das entidades ctb. dinamicamente
	If Len(aEntCtb) > 0
		cCampos += " , ( "
		For nForEnt := 1 to Len(aEntCtb)
			If nForEnt > 1
				cCampos += " + "
			EndIf
			cCampos += " CASE WHEN DBL." + aCondEC[nForEnt] + " = '" +  aEntCtb[nForEnt] + "'THEN " + aPeso[nForEnt] + " ELSE "
			cCampos += " CASE WHEN DBL." + aCondEC[nForEnt] + " = '' THEN 0 ELSE -30 END END"				
		Next nForEnt
		cCampos += " ) MATCH %"
		lFilEntCtb		:= .T.

		//-- Validação Entidades contabeis
		cVldEC += " ( "
		For nForEnt := 1 to Len(aEntCtb)
			If nForEnt == 1 
				cVldEC += "DBL." + aCondEC[nForEnt] + " <> ' ' "
			Else 
				cVldEC += " OR DBL." + aCondEC[nForEnt] + " <> ' ' "
			EndIf
		Next nForEnt
		cVldEC += " ) %"
	EndIf
	
	If lAltpdoc 
		cJoin += " INNER JOIN " + RetSQLName("SAL") + " SAL ON SAL.AL_FILIAL = DBL.DBL_FILIAL " 
		cJoin += " AND SAL.AL_COD = DBL.DBL_GRUPO AND SAL.D_E_L_E_T_ = ' ' %"
	EndIf 

	//-- Somente é necessário a verificação do Centro de Custo (Primario)
	For nForEnt := 1 to Len(aEntCtb)	
		If aCondEC[nForEnt] == 'DBL_CC'
			cWhere += " AND DBL." + aCondEC[nForEnt] + " = '" +  aEntCtb[nForEnt] + "' "
			lFilEntCtb		:= .T.			 
		EndIf
	Next nForEnt 
	
	For nForEnt := Len(aEntCtb)+1 to Len(aCondEC)
		cWhere += " AND DBL." + aCondEC[nForEnt] + " = ' ' "
	Next nForEnt

	If lAltpdoc
		cWhere += " AND " + cTpDoc + " = 'T' "
	EndIf
	
	cWhere += "%"

	//-- Somente executa a query se tiver where de entidade contabil
	If lFilEntCtb
		//- Para compatibilidade com Oracle não é possivel utilizar LIMIT 1.
		BeginSQL Alias cAls
			SELECT DBL.DBL_GRUPO GRPAPV,
				DBL.DBL_ITEM ITEMGRP
				%Exp:cCampos%
			FROM %Table:DBL% DBL
			%Exp:cJoin%
			WHERE DBL.DBL_FILIAL = %xFilial:DBL%
				%Exp:cWhere% AND
				%Exp:cVldEC% AND
				DBL.%NotDel% 
			ORDER BY MATCH DESC
		EndSQL

		If (cAls)->(!EOF()) .and. (cAls)->MATCH >= 15
			lAchou	:= .T.
			cGrupo 	:= (cAls)->GRPAPV
			cItGrp	:= (cAls)->ITEMGRP
		EndIf
		(cAls)->( dbCloseArea() )
	Endif
EndIf

If !lAchou .And.  Empty(cGrupo) .AND. !Empty(cGrpDfl)
	aAuxGrp := Separa(cGrpDfl,';',.F.)
	Aadd(aApv,aAuxGrp[1])
	Aadd(aApv,IIF(len(aAuxGrp)>=2,aAuxGrp[2],""))
Else
	Aadd(aApv,cGrupo)
	Aadd(aApv,cItGrp)
EndIf
	
RestArea(aArea)

Return aApv

//-------------------------------------------------------------------
/*/{Protheus.doc} MaAlcItEC()
Funcao utilizada para atualizacao dos itens da alcada por Ent. Ctb.

@author Leandro.Moura
@since 29/08/2013
@version 1.0

cDocto,cTpDoc,cGrp,cItGrp,cUser,aItens,cUsrOld,nOpcao,cAprov,cAprOld

@param cDocto Documento
@param cTpDoc Tipo do Documento (SC,SA,IP,etc.)
@param cGrp	 Grupo de aprovacao
@param cItGrp	 Item do Grupo de aprovacao
@param cUsrApv Usuario da aprovacao
@param aItens Array com os itens da aprovacao
@param cUsrOld Antigo Usuario da aprovacao
@param nOpcao Opcao (1-Inclusao,2-Alteracao,3-Exclusao)
@param cAprov Código do Aprovador
@param cAprOld Código do Aprovador antigo

@return
/*/
//-------------------------------------------------------------------
Function MaAlcItEC(cDocto,cTpDoc,cGrp,cItGrp,cUsrApv,aItens,cUsrOld,nOper,cAprov,cAprOld,aItensDBM,cAprOri,nMoeda,aItPedVinc)

Local aArea			:= GetArea()
Local aAreaSC7		:= SC7->(GetArea())
Local aTipCom		:= {}
Local cItem			:= ""
Local cRateio		:= ""
Local cKeyDBM		:= ""
Local cKeyDoc		:= ""
Local cItOld	 	:= ""
Local cRatOld 		:= ""
Local cGrpOld		:= ""
Local cItGrpOld		:= ""
Local cTpComp		:= ""
Local cTpCompOld	:= ""
Local nValorIt  	:= 0
Local nValorOld  	:= 0
Local lOk			:= .T.
Local lLog			:= GetNewPar("MV_HABLOG",.F.)
Local nFor	 		:= 0
Local nTamRateio 	:= TamSX3("DBM_ITEMRA")[1]
Local nTamItem   	:= TamSX3("DBM_ITEM")[1]
Local nTotal		:= 0
Local nPrazo		:= 99
Local nAviso		:= 99
Local lGravaDBM		:= .T.
Local lGerouDBM		:= .F.
Local lEscalona		:= .F.
Local lEscalonaS	:= .F.
Local lAprovEsp		:= .F.
Local aAliasDBM		:= {}
Local lIpAprEC		:= SuperGetMv("MV_IPAPREC",.F.,.F.) // Liberação/Rejeição por grupo de aprovação
Local cPerfAlc		:= SuperGetMV("MV_PERFALC",.F.,"1")
Local lPosCrTipo    := SCR->(FieldPos("CR_TIPCOM")) > 0
Local cCompTipCom   := ""

Default cGrp		:= Space(TamSX3("DBM_GRUPO")[1])
Default cItGrp		:= Space(TamSX3("DBM_ITGRP")[1])
Default cUsrApv		:= Space(TamSX3("DBM_USER")[1])
Default aItens		:= {}
Default cAprOld		:= ""
Default cUsrOld		:= ""
Default cAprov 		:= Space(TamSX3("DBM_USAPRO")[1])
Default aItensDBM	:= {}
Default nMoeda		:= 1
Default aItPedVinc	:= {}

If lOK
	If nOper == 1 //Inclusao
		If 	Len(aItens) > 1 //Verifica se o array possui mais de um centro de custos, para definir qual indice utilizar para gravação/alteração da DBM
			DBM->( dbSetOrder(2) ) // DBM_FILIAL,DBM_TIPO,DBM_NUM,DBM_ITEM,DBM_ITEMRA,DBM_GRUPO,DBM_ITGRP,DBM_USER,DBM_USEROR, R_E_C_N_O_, D_E_L_E_T_                                                                          
		Else 
			DBM->( dbSetOrder(4) ) // DBM_FILIAL, DBM_TIPO, DBM_NUM, DBM_ITEM, DBM_GRUPO, DBM_ITGRP, DBM_USER, DBM_USAPRO, R_E_C_N_O_, D_E_L_E_T_
		EndIf 
		//-- Grava cada item da alcada por entidade ctb
		For nFor := 1 to Len(aItens)
			lGravaDBM	:= .T.
			cItem		:= Padr(aItens[nFor][1],nTamItem)
			cRateio		:= Padr(aItens[nFor][2],nTamRateio)
			nValorIt	:= aItens[nFor][3]

			If cTpDoc $ "SC|IP|PC"
				cTpComp	:= aItens[nFor][4]

				If !Empty(cTpComp)
					aTipCom := GetTpComp(cGrp,cAprOri,cTpComp)
					lAprovEsp := !Empty(aTipCom)
	
					DHK->(DbSetOrder(1))
					If DHK->(DbSeek(xFilial("DHK")+cTpComp))
						If (lAprovEsp .And. aScan(aTipCom,{|x| AllTrim(x) == AllTrim(cTpComp)}) == 0) .Or.;
								(cTpDoc == "SC" .And. !If(lAprovEsp,DHK->DHK_APROVE,DHK->DHK_APROVP)) .Or.;
								(cTpDoc == "IP" .And. !If(lAprovEsp,DHK->DHK_PAPRES,DHK->DHK_PAPRPA)) .Or.;
								(cTpDoc == "SC" .And. lAprovEsp .And. DHK->DHK_APROVP) .Or.;
								(cTpDoc == "IP" .And. lAprovEsp .And. DHK->DHK_PAPRPA)
							Loop
						EndIf
					EndIf
				EndIf
			EndIf

			If !(IsGctDoc(cTpDoc))				
				If !(cTpDoc $ "NF|SC") .And. Empty(nValorIt) 
					lGravaDBM := .F.
				EndIf
			EndIf
			
			If SAL->AL_AUTOLIM == "S" .And. !MaAlcLim(cAprov,nValorIt, nMoeda,,cGrp) .And. cPerfAlc == '2' .And. cTpDoc $ "IP|SA|SC"
				Loop
			EndIf
			
			If lGravaDBM
				If 	Len(aItens) > 1 //Verifica se o array aItens possui mais de um centro de custos, para realizar a pesquisa do campo DBM_ITEMRA
					If 	(DBM->(DbSeek(xFilial("DBM")+cTpDoc+cDocto+cItem+cRateio+cGrp+cItGrp+cUsrApv+cAprov)))
						RecLock("DBM",.F.)
					Else		
						RecLock("DBM",.T.)
					EndIf 	
				Else 
					If (DBM->(DbSeek(xFilial("DBM")+cTpDoc+cDocto+cItem+cGrp+cItGrp+cUsrApv+cAprov)))				
						RecLock("DBM",.F.)
					Else		
						RecLock("DBM",.T.)	
					endif
				EndIf 
				DBM->DBM_FILIAL := FWXfilial("DBM")
				DBM->DBM_TIPO	:= cTpDoc
				DBM->DBM_NUM	:= cDocto
				DBM->DBM_ITEM	:= cItem
				DBM->DBM_ITEMRA := cRateio
				DBM->DBM_GRUPO	:= cGrp
				DBM->DBM_ITGRP	:= cItGrp
				DBM->DBM_USER	:= cUsrApv
				DBM->DBM_USEROR := cUsrOld
				DBM->DBM_USAPRO	:= cAprov
				DBM->DBM_USAPOR	:= cAprOld
				DBM->DBM_APROV	:= "2"
				DBM->DBM_VALOR	:= nValorIt
				DBM->DBM_TIPCOM	:= cTpComp
				
				DBM->(MsUnLock())

				If Empty(aScan(aItensDBM, {|x| x[1] == cItem}))
					aAdd(aItensDBM ,{cItem,cGrp})
				Endif

				lGerouDBM := .T.
				
			EndIf

			If cTpDoc $ "SC|IP"
				If DHK->(DbSeek(xFilial("DHK")+cTpComp))
					If cTpDoc == "SC"
						If DHK->DHK_PRAZO < nPrazo
							nPrazo := DHK->DHK_PRAZO
						EndIf
						If DHK->DHK_AVISO < nAviso
							nAviso := DHK->DHK_AVISO
						EndIf
						If DHK->DHK_ESCALO .And. !lEscalona
							lEscalona := .T.
						EndIf
						If DHK->DHK_ESCTSC .And. !lEscalonaS
							lEscalonaS := .T.
						EndIf
					ElseIf cTpDoc == "IP"
						If DHK->DHK_PRAZOP < nPrazo
							nPrazo := DHK->DHK_PRAZOP
						EndIf
						If DHK->DHK_AVISOP < nAviso
							nAviso := DHK->DHK_AVISOP
						EndIf
						If DHK->DHK_ESCALP .And. !lEscalona
							lEscalona := .T.
						EndIf
						If DHK->DHK_ESCTPC .And. !lEscalonaS
							lEscalonaS := .T.
						EndIf
					Endif
				Endif
			EndIf

			nTotal += nValorIt
    	Next nFor

	//--------------------------------------------
	//2 - Transferencia de alcada para superior
	//3 - Exclusao de registros de alcada
	//5 - Estorno de liberacao
	//--------------------------------------------
	ElseIf (nOper == 2) .OR. (nOper == 3) .OR. (nOper == 5)
		
		//--------------------------------------------
		//Monta chave para exclusao dos registros
		//--------------------------------------------
		If (nOper == 3) //Exclui todos os registros
			cKeyDBM := FWXFilial("DBM") + cTpDoc + cDocto
		ElseiF (nOper == 5)// Apenas os registros pertencente ao Grupo
			cKeyDBM := FWXFilial("DBM") + cTpDoc + cDocto  +  cGrp + cItGrp
		Else // cria alcada para o superior (apenas registro selecionado)
			cKeyDBM := FWXFilial("DBM") + cTpDoc + cDocto  +  cGrp + cItGrp + cAprOld
		EndIf

		   DBM->( dbSetOrder(3) )
		If DBM->(dbSeek( cKeyDBM ) )
			If (nOper == 3) //Exclui todos os registros
				cSeek := "DBM->(DBM_FILIAL+DBM_TIPO+DBM_NUM)"
			ElseiF (nOper == 5) // Apenas os registros pertencente ao Grupo
				cSeek := "DBM->(DBM_FILIAL+DBM_TIPO+DBM_NUM+DBM_GRUPO+DBM_ITGRP)"
			ELSE // cria alcada para o superior (apenas registro selecionado)
				cSeek := "DBM->(DBM_FILIAL+DBM_TIPO+DBM_NUM+DBM_GRUPO+DBM_ITGRP+DBM_USAPRO)"
			EndIf

			While ( !(DBM->( EOF() )) .And.  ALLTRIM(cKeyDBM) == ALLTRIM(&cSeek)  )
				
				If nOper == 3 .AND. cTpDoc == "SC" .And. Len(aItPedVinc) > 0
					If ascan(aItPedVinc,{|x|,x == DBM->DBM_ITEM}) > 0
						DBM->(dbSkip())
						Loop
					Endif
				Endif

				If nOper == 3 .AND. cTpDoc == "IP" .AND. MtVincNF(Alltrim(DBM->DBM_NUM), DBM->DBM_ITEM)
					DBM->(dbSkip())
					Loop
				Endif

				//---------------------------------------------------
				//Transfere as aprovacoes somente do usuario antigo
				//---------------------------------------------------
            	If (nOper == 2) .AND. !(DBM->DBM_USAPRO == cAprOld ) .and. !Empty(cAprOld)
   					DBM->( dbSkip() )
					Loop
            	EndIf

				//---------------------------------------------------------------------------
				//Se for transferencia ou estorno, salva informacoes para gerar nova alcada
				//---------------------------------------------------------------------------
				If (nOper == 2) .OR. (nOper == 5)
					cItOld 		:= DBM->DBM_ITEM
					cRatOld 	:= DBM->DBM_ITEMRA
					cGrpOld		:= DBM->DBM_GRUPO
					cItGrpOld	:= DBM->DBM_ITGRP
					nValorOld	:= DBM->DBM_VALOR
					cTpCompOld	:= DBM->DBM_TIPCOM

					If (nOper == 5)
						cAprov := DBM->DBM_USAPRO
						cAprOld := ""
					EndIf
				EndIf

				RecLock("DBM",.F.)
				DBM->( dbDelete() )
				DBM->( MsUnLock() )

				//-- Se for transferencia ou estorno, inclui nova alcada
				If (nOper == 2) .OR. (nOper == 5)
					aAliasDBM := DBM->(GetArea())
					DBM->( dbSetOrder(4) )
                    If !DBM->(DbSeek( FWXFilial("DBM") + cTpDoc + cdocto + cItOld + cGrp + cItGrp + cUsrApv + cAprov) )
						RecLock("DBM",.T.)
							DBM->DBM_FILIAL	:= FWXfilial("DBM")
							DBM->DBM_TIPO	:= cTpDoc
							DBM->DBM_NUM	:= cDocto
							DBM->DBM_ITEM	:= cItOld
							DBM->DBM_ITEMRA := cRatOld
							DBM->DBM_GRUPO	:= cGrpOld
							DBM->DBM_ITGRP	:= cItGrpOld
							DBM->DBM_USER	:= cUsrApv
							DBM->DBM_USEROR := cUsrOld
							DBM->DBM_USAPRO	:= cAprov
							DBM->DBM_USAPOR	:= cAprOld
	 						DBM->DBM_APROV	:= "2"
	 						DBM->DBM_VALOR	:= nValorOld
	 						DBM->DBM_TIPCOM	:= cTpCompOld
						DBM->( MsUnLock() )
					EndIf 
					RestArea(aAliasDBM)
				EndIf
				DBM->( dbSkip() )
			End
		EndIf

		//Ajuste do pedido na alteração em caso de alteração do parâmetro MV_PERFALC
		If (nOper == 3) .And. cTpDoc $ 'IP|PC|AE'

			cKeyDoc  := xFilial("SC7")+Padr(cDocto,TamSX3('C7_NUM')[1])
			SC7->(dbSetOrder(1))

			
			SC7->(MsSeek(cKeyDoc))
			While !SC7->(EOF()) .And. SC7->(C7_FILIAL+C7_NUM) == cKeyDoc
				If cPerfAlc == '2' .And. SC7->C7_QUJE < SC7->C7_QUANT
					RecLock("SC7",.F.)
					SC7->C7_CONAPRO := " "  
					SC7->C7_APROV 	:= " "
					SC7->(MsUnlock())					
				Endif
				SC7->(dbSkip())
			EndDo			

		Endif

	//-- Aprovacao dos itens da alcada
	ElseIf (nOper == 4)
		cKeyDBM := FwXFilial("DBM")  + cTpDoc + cDocto +  cGrp + cItGrp + cAprov + cAprOld
		
		DBM->( dbSetOrder(3) )
		DBM->(dbSeek(cKeyDBM))
		//-- Informa todos os itens como liberados
		While ! DBM->( EOF() ) .And. ( DBM->(DBM_FILIAL+DBM_TIPO+DBM_NUM+DBM_GRUPO+DBM_ITGRP+DBM_USAPRO+DBM_USAPOR) == cKeyDBM )
			cCompTipCom   := If(lPosCrTipo .And. !Empty(SCR->CR_TIPCOM) ,"DBM->DBM_TIPCOM == SCR->CR_TIPCOM", "1==1")
			If &cCompTipCom
				RecLock("DBM",.F.)
				DBM->DBM_APROV		:= "1"
				DBM->(MsUnLock())
			Endif

			//--------------------------------------
			// Log de liberacao de pedido de compra
			//--------------------------------------
			If lLog .And. cTpDoc == "IP"
				DbSelectArea("SC7")
				SC7->(DbSetOrder(1)) //C7_FILIAL+C7_NUM+C7_ITEM+C7_SEQUEN
				If SC7->(DbSeek(xFilial("SC7")+Substr(SCR->CR_NUM,1,len(SC7->C7_NUM))+DBM->DBM_ITEM))
					RSTSCLOG("LIB",1,/*cUser*/,/*cDados*/)
				EndIf
			EndIf

			DBM->(dbSkip())

		End

	//-- Rejeicao do documento
	ElseIf (nOper == 7)
		
		
		cKeyDBM := xFilial("DBM")+cTpDoc+cDocto+cGrp+cItGrp+cUsrApv+cUsrOld
		
		DBM->(dbSetOrder(1))
		DBM->(dbSeek(cKeyDBM))
		While !DBM->(EOF()) .And. DBM->(DBM_FILIAL+DBM_TIPO+DBM_NUM+DBM_GRUPO+DBM_ITGRP+DBM_USER+DBM_USEROR) == cKeyDBM
			cCompTipCom   := If(lPosCrTipo .And. !Empty(SCR->CR_TIPCOM) ,"DBM->DBM_TIPCOM == SCR->CR_TIPCOM", "1==1")
			If &cCompTipCom
				RecLock("DBM",.F.)
				DBM->DBM_APROV := '3'
				DBM->(MsUnLock())
			
				If cTpDoc == 'SC'
					cKeyDoc := xFilial("SC1")+PadR(DBM->DBM_NUM,Len(SC1->C1_NUM))+PadR(DBM->DBM_ITEM,Len(SC1->C1_ITEM))
					SC1->(dbSetOrder(1))
					SC1->(MsSeek(cKeyDoc))
					While !SC1->(EOF()) .And. SC1->(C1_FILIAL+C1_NUM+C1_ITEM) == cKeyDoc
						RecLock("SC1",.F.)
						SC1->C1_APROV := 'R'
						SC1->(MsUnlock())
						SC1->(dbSkip())
					End				
				ElseIf cTpDoc == 'IP'
					If lIpAprEc
						cKeyDoc := xFilial("SC7")+PadR(DBM->DBM_NUM,Len(SC7->C7_NUM))+PadR(DBM->DBM_ITEM,Len(SC7->C7_ITEM))
						SC7->(dbSetOrder(1))
						SC7->(MsSeek(cKeyDoc))
						While !SC7->(EOF()) .And. SC7->(C7_FILIAL+C7_NUM+C7_ITEM) == cKeyDoc
							RecLock("SC7",.F.)
							SC7->C7_CONAPRO := 'R'
							SC7->C7_FLUXO	:= 'N'
							SC7->(MsUnlock())
			
							SC7->(dbSkip())
						EndDo
					Else
						cKeyDoc := xFilial("SC7")+PadR(DBM->DBM_NUM,Len(SC7->C7_NUM))
						SC7->(dbSetOrder(1))
						SC7->(MsSeek(cKeyDoc))
						While !SC7->(EOF()) .And. SC7->(C7_FILIAL+C7_NUM) == cKeyDoc
							RecLock("SC7",.F.)
							SC7->C7_CONAPRO := 'R'
							SC7->C7_FLUXO	:= 'N'
							SC7->(MsUnlock())
			
							SC7->(dbSkip())
						EndDo
					Endif
				ElseIf cTpDoc == 'SA'
					cKeyDoc := xFilial("SCP")+PadR(DBM->DBM_NUM,Len(SCP->CP_NUM))+PadR(DBM->DBM_ITEM,Len(SCP->CP_ITEM))
					SCP->(dbSetOrder(1))
					SCP->(MsSeek(cKeyDoc))
					While !SCP->(EOF()) .And. SCP->(CP_FILIAL+CP_NUM+CP_ITEM) == cKeyDoc
						RecLock("SCP",.F.)
						SCP->CP_STATSA := 'R'
						SCP->(MsUnlock())
						SCP->(dbSkip())
					End
				EndIf
			Endif
			DBM->(dbSkip())
		EndDo

Endif
	
EndIf

RestArea(aAreaSC7)
RestArea(aArea)

FwFreeArray(aAreaSC7)
FwFreeArray(aArea)

Return {lGerouDBM,nTotal,nPrazo,nAviso,lEscalona,lEscalonaS,cTpComp}

//--------------------------------------------------------------------
/*/{Protheus.doc} MtGLastDBM()
Valida se o(s) item(s) do documento foram liberados quando tipo do documento "IP".
@author Aecio Gomes
@Param cNum: Numero do documento
@Param cItem: Item do documento
@Param cItemRA: Item do Rateio
@since 30/08/2013
@version 1.0
@return Ret :=  .T. = Está liberado, .F. = não está liberdado.
/*/
//--------------------------------------------------------------------
Function MtGLastDBM(cTipo,cNum, cItem, cItemRA, cGrupo, cItGrp,cTipCom,lConsItem)
Local lRet			:= .T.
Local cQuery		:= ""
Local aArea			:= GetArea()
Local lGrupo		:= .F.
Local cAliasQry		:= GetNextAlias()
Local lVerTipCom	:= MtVerTipcom(cNum,cTipo)
Local lIpAprEC		:= SuperGetMv("MV_IPAPREC",.F.,.F.) // Liberação/Rejeição por grupo de aprovação
Default cItem		:= ""
Default cItemRA		:= ""
Default cGrupo		:= ""
Default cItGrp		:= ""
Default cTipCom		:= ""
Default lConsItem	:= .F.

lGrupo	:= !Empty(cGrupo) .And. !Empty(cItGrp)

//Previne manter bloqueado PC que foi alterado e removido centro de custo.
if FwIsInCallStack("MATA120") .and. cTipo=="IP" .and. !empty(cItem) .and. Type("Altera") == "L" .and. Altera .and. Empty(cGrupo) .and. empty(SC7->C7_CC) .and. SC7->C7_RATEIO == "2"
	lGrupo := .T.
endif

cQuery += "SELECT COUNT(*) AS NREG "
cQuery += "FROM "+RetSqlName("DBM")+" DBM "	
	 
// Verifica somente itens que possuam aprovação (SCR)
cQuery	+= " INNER JOIN "+RetSqlName("SCR")+" SCR ON "
cQuery	+= " CR_FILIAL = '"+xFilial("SCR")+"'"
cQuery	+= " AND CR_TIPO = DBM_TIPO"
cQuery	+= " AND CR_NUM = DBM_NUM"
cQuery	+= " AND CR_USER = DBM_USER"
cQuery	+= " AND CR_APROV = DBM_USAPRO"
cQuery	+= " AND CR_GRUPO = DBM_GRUPO"
cQuery	+= " AND CR_ITGRP = DBM_ITGRP"
cQuery	+= " AND SCR.D_E_L_E_T_ = ' ' "
IF cTipo == "SC" .AND. lVerTipCom
	cQuery	+= " AND CR_TIPCOM = DBM_TIPCOM "
Endif
cQuery += "WHERE DBM.DBM_FILIAL = '"+xFilial("DBM")+"'"
cQuery += " AND DBM_TIPO = '" +cTipo +"' "
		
If cTipo == "IC"
	cNum	:= Left(AllTrim(cNum),TAMSX3('CNB_CONTRA')[1])
	cQuery += " AND DBM_NUM LIKE '"+cNum+"%' "
ElseIf cTipo == "IR"
	cNum	:= Left(AllTrim(cNum),TAMSX3('CNB_CONTRA')[1]+TAMSX3('CNB_REVISA')[1])
	cQuery += " AND DBM_NUM LIKE '"+cNum+"%' "
ElseIf cTipo == "IM"
	cNum	:= Left(AllTrim(cNum),TAMSX3('CND_NUMMED')[1])
	cQuery += " AND DBM_NUM LIKE '"+cNum+"%' "
ElseIf cTipo == "SC" .AND. lVerTipCom
	cQuery += " AND DBM_TIPCOM ='" + CTIPCOM +"' "
	cQuery += " AND DBM_NUM = '" +PadR(cNum,Len(DBM->DBM_NUM)) +"' "
Else
	cQuery += " AND DBM_NUM = '" +PadR(cNum,Len(DBM->DBM_NUM)) +"' "
EndIf

cQuery += " AND CR_STATUS IN('01','02') "

If lGrupo
	cQuery	+= " AND DBM_GRUPO = '"+cGrupo+"'"
	cQuery	+= " AND DBM_ITGRP = '"+cItGrp+"'"
	If !Empty(cItem)
		cQuery += " AND DBM_ITEM = '" +PadR(cItem,Len(DBM->DBM_ITEM)) +"' "
	Endif
		If !Empty(cItemRA)
		cQuery += " AND DBM_ITEMRA = '" +PadR(cItemRA,Len(DBM->DBM_ITEMRA)) +"' "
	Endif	
ElseIf cTipo == "SC" .AND. !Empty(cItem)
	cQuery += " AND DBM_ITEM = '" +PadR(cItem,Len(DBM->DBM_ITEM)) +"' "
ElseIf cTipo == "IP" .AND. !Empty(cItem) .AND. (lIpAprEC .Or. lConsItem)
	cQuery += " AND DBM_ITEM = '" +PadR(cItem,Len(DBM->DBM_ITEM)) +"' "
Endif

cQuery += " AND DBM_APROV = '2' "
cQuery += " AND DBM.D_E_L_E_T_ = ' ' "

cQuery := ChangeQuery(cQuery)
dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry)

lRet := (cAliasQry)->NREG == 0
(cAliasQry)->(dbCloseArea())

RestArea(aArea)
Return(lRet)

//--------------------------------------------------------------------
/*/{Protheus.doc} MtExistDBM()
Valida se existe DBM para o tipo de documento selecionado
@author Leonardo Quintania
@Param cTipo: Tipo do documento
@Param cNum: Numero do documento
@Param cItem: Item do documento
@Param cItemRA: Item do Rateio
@since 23/10/2013
@version 1.0
@return Ret :=  .T. = Existe, .F. = Não Existe
/*/
//--------------------------------------------------------------------
Function MtExistDBM(cTipo,cNum, cItem, cItemRA,lExAprov)
Local lRet 		:= .T.
Local cWhere		:= ""

Default cItem 	:= ""
Default cItemRA 	:= ""
Default lExAprov 	:= SuperGetMV("MV_EXAPROV",.F.,.F.)

cWhere += " AND DBM_TIPO = '"+cTipo+"' "
cWhere += " AND DBM_NUM = '"+cNum+"' "	

If !Empty(cItem) 
	cWhere += "AND DBM_ITEM = '"+cItem+"' "
	If !Empty(cItemRA)
		cWhere += "AND DBM_ITEMRA = '"+cItemRA+"' "
	EndIf	
EndIf	

IF !lExAprov
   cWhere += " AND D_E_L_E_T_=' ' "
EndIf
cWhere := '%'+cWhere+'%'

BeginSql Alias "TMPDBM"

	SELECT COUNT(*) AS NREG
	FROM %table:DBM% DBM
	WHERE DBM.DBM_FILIAL = %xFilial:DBM%
		%Exp:cWhere%	
EndSql

lRet := TMPDBM->NREG # 0 //Se for diferente de Zero encontrou registro.
TMPDBM->(dbCloseArea())
	
Return(lRet)

//--------------------------------------------------------------------
/*/{Protheus.doc} MtQtdEnti()
Verifica se existe mais de uma combinação de entidade contábil
C1_CC, C1_CONTA, C1_ITEMCTA, C1_CLVL
dentro da solicitação de compra.
@author Leandro Fini
@Param cDocNum: Número do documento na SC1
@since 28/04/2022
@version 1.0
@return Ret :=  .T. = Mais de uma combinação, .F. = Apenas uma combinação
/*/
//--------------------------------------------------------------------
Function MtQtdEnti(cDocNum)

Local cQuery		:= ""
Local lRet 			:= .F. //.F.-> SC possui uma única combinação de entidade contábil, .T.-> SC possui mais de uma combinação de endidade contábil
Local nTotReg		:= 1
Local cAliasSC1		:= GetNextAlias()


cQuery := "SELECT C1_CC, C1_CONTA, C1_ITEMCTA, C1_CLVL FROM " + RetSqlName("SC1") + " SC1 "
cQuery += "WHERE C1_FILIAL = '"+fwxFilial("SC1")+"' "
cQuery += "AND C1_NUM = '"+cDocNum+"' "
cQuery += "AND D_E_L_E_T_ = ' ' "
cQuery += "GROUP BY C1_CC, C1_CONTA, C1_ITEMCTA, C1_CLVL "

dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSC1)

Count To nTotReg

lRet := If(nTotReg > 1, .T., .F.)

(cAliasSC1)->(dbCloseArea())
	
Return lRet

//--------------------------------------------------------------------
/*/{Protheus.doc} MtQtEntSC7()
Verifica se existe mais de uma combinação de entidade contábil
C7_CC, C7_CONTA, C7_ITEMCTA, C7_CLVL
dentro da solicitação de compra.
@author Leandro Fini
@Param cDocNum: Número do documento na SC7
@since 28/04/2022
@version 1.0
@return Ret :=  .T. = Mais de uma combinação, .F. = Apenas uma combinação
/*/
//--------------------------------------------------------------------
Function MtQtEntSC7(cPedNum)

Local cQuery		:= ""
Local lRet 			:= .F. //.F.-> SC possui uma única combinação de entidade contábil, .T.-> SC possui mais de uma combinação de endidade contábil
Local nTotReg		:= 1
Local cAliasSC7		:= GetNextAlias()

Default cPedNum := ""


cQuery := "SELECT C7_CC, C7_CONTA, C7_ITEMCTA, C7_CLVL FROM " + RetSqlName("SC7") + " SC7 "
cQuery += "WHERE C7_FILIAL = '"+fwxFilial("SC7")+"' "
cQuery += "AND C7_NUM = '"+cPedNum+"' "
cQuery += "AND D_E_L_E_T_ = ' ' "
cQuery += "GROUP BY C7_CC, C7_CONTA, C7_ITEMCTA, C7_CLVL "

dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSC7)

Count To nTotReg

lRet := If(nTotReg > 1, .T., .F.)

(cAliasSC7)->(dbCloseArea())
	
Return lRet

//--------------------------------------------------------------------
/*/{Protheus.doc} MtVincNF()
Verifica se o pedido + item está sendo usado em alguma NF
@author Leandro Fini
@Param cNumPC: Número do pedido na SC7
@since 27/05/2022
@version 1.0
@return Ret :=  .T. = pedido está sendo usado, .F. = não possui NF vinculada
/*/
//--------------------------------------------------------------------
Function MtVincNF(cNumPC, cItemPC)

Local cQuery		:= ""
Local lRet 			:= .F.
Local nTotReg		:= 1
Local cAliasSD1		:= GetNextAlias()

Default cNumPC  := ""
Default cItemPC := ""

cQuery := " SELECT C7_NUM FROM " + RetSqlName("SC7") + " SC7 "
cQuery += " WHERE C7_FILIAL = '"+fwxFilial("SD1")+"' "
cQuery += " AND C7_NUM = '"+cNumPC+"' "
cQuery += " AND C7_ITEM = '"+cItemPC+"' "
cQuery += " AND SC7.D_E_L_E_T_ = ' '  "
cQuery += " AND C7_RESIDUO = ' ' "
cQuery += " AND C7_QUJE = C7_QUANT "


dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSD1)

Count To nTotReg

lRet := If(nTotReg >= 1, .T., .F.)

(cAliasSD1)->(dbCloseArea())
	
Return lRet

//--------------------------------------------------------------------
/*/{Protheus.doc} MtQtdEnti()
Retorna os itens da SC que possuem pedido vinculado
Será chamado quando for alteração via execauto.
@author Leandro Fini
@Param cDocNum: Número do documento na SC1
@since 02/05/2022
@version 1.0
@return aRet := Itens da SC que possuem vínculo com pedido de compra.
/*/
//--------------------------------------------------------------------
Function MtPedVinc(cDocNum)

Local cQuery		:= ""
Local aRet			:= {}
Local cAliasSC1		:= GetNextAlias()

cQuery := "SELECT C1_ITEM FROM " + RetSqlName("SC1") + " SC1 "
cQuery += "WHERE C1_FILIAL = '"+fwxFilial("SC1")+"' "
cQuery += "AND C1_NUM = '"+cDocNum+"' "
cQuery += "AND C1_PEDIDO <> ' ' "
cQuery += "AND D_E_L_E_T_ = ' ' "

dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSC1)

While (cAliasSC1)->(!Eof())

	aAdd(aRet,(cAliasSC1)->C1_ITEM)

	(cAliasSC1)->(DbSkip())
Enddo

(cAliasSC1)->(dbCloseArea())
	
Return(aRet)

//--------------------------------------------------------------------
/*/{Protheus.doc} MtExistSCR()
Valida se existe SCR para o tipo de documento selecionado
@author Brunno de Medeiros da Costa
@Param cTipo: Tipo do documento
@Param cNum: Numero do documento
@Param lExAprov: Verifica registros deletados
@since 10/01/2018
@version 1.0
@return Ret :=  .T. = Existe, .F. = Não Existe
/*/
//--------------------------------------------------------------------
Function MtExistSCR(cTipo, cNum, lExAprov)

	Local cAliasAux	 := GetNextAlias()

	Local lRet		 := .T.

	Default cTipo    := ""
	Default cNum     := ""
	Default lExAprov := SuperGetMV("MV_EXAPROV", .F., .F.)
	
	If lExAprov
		BeginSQL Alias cAliasAux

			SELECT 	COUNT(R_E_C_N_O_) AS CNTREC
			FROM 	%Table:SCR% SCR
			WHERE 	SCR.CR_FILIAL 	= %xFilial:SCR%
					AND SCR.CR_TIPO = %Exp:cTipo%
					AND SCR.CR_NUM  = %Exp:cNum%	
		EndSQL
	Else
		BeginSQL Alias cAliasAux

			SELECT 	COUNT(R_E_C_N_O_) AS CNTREC
			FROM 	%Table:SCR% SCR
			WHERE 	SCR.CR_FILIAL 	= %xFilial:SCR%
					AND SCR.CR_TIPO = %Exp:cTipo%
					AND SCR.CR_NUM  = %Exp:cNum%
					AND SCR.%NotDel%
		EndSQL
	EndIf

	lRet := (cAliasAux)->CNTREC # 0 //Se for diferente de Zero encontrou registro.

	(cAliasAux)->(DbCloseArea())
	
Return lRet

//--------------------------------------------------------------------
/*/{Protheus.doc} ElExistSCR()
Função auxiliar da eliminação de resíduo
Valida se existe SCR para o tipo de documento selecionado mesmo com D_E_L_E_T_='*',
para não criar uma alçada para um aprovador que não participou da mesma.
@author Kevin Alexander
@Param cTipo: Tipo do documento
@Param cNum: Numero do documento
@Param cAprov: Código do Aprovador
@Param cOper: Número da Operação
@since 10/04/2019
@version 1.0
@return Ret :=  .T. = Existe, .F. = Não Existe
/*/
//--------------------------------------------------------------------

Function ElExistSCR(cTipo,cNum,cAprov,nOper,cItGrp)
Local lRet 			:= .T.
Local cQuery		:= ""
Local cAliasEr := GetNextAlias()
 
cQuery += "  SELECT COUNT(*) AS NREG "
cQuery += " From "+  RetSqlName("SCR")+ " SCR, "  + RetSqlName("SC7") + " SC7 "  
If cTipo == 'IP'
	cQuery += ","+ RetSqlName("DBM")+ " DBM" 
EndIf
cQuery += " WHERE "
cQuery += " CR_TIPO = '"+cTipo+"' "
cQuery += " AND CR_NUM = '"+cNum+"' "
If nOper == 1
	cQuery += " AND CR_APROV = '"+cAprov+"' "			
ElseIf nOper == 4
	cQuery += " AND CR_LIBAPRO = '"+cAprov+"' "
EndIf
cQuery += " AND CR_ITGRP = '"+cItGrp+"' " 
cQuery += " AND SCR.CR_NUM = SC7.C7_NUM  "
cQuery += " AND (SC7.C7_QUJE <> 0 OR SC7.C7_RESIDUO <> 'S' ) "
cQuery += " AND SC7.D_E_L_E_T_= '' "
cQuery += " AND SCR.CR_FILIAL = '"+ xfilial("SCR")+ "'"
cQuery += " AND SC7.C7_FILIAL = '"+ xfilial("SC7")+ "'"
If cTipo == 'IP'
	cQuery += " AND DBM_NUM   = C7_NUM 
	cQuery += " AND DBM_ITEM  = C7_ITEM 
	cQuery += " AND DBM_GRUPO = CR_GRUPO 
	cQuery += " AND DBM_ITGRP = CR_ITGRP 
	cQuery += " AND DBM.DBM_FILIAL = '"+ xfilial("DBM")+ "'"
EndIf
	cQuery := ChangeQuery(cQuery)
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasEr)
	lRet := (cAliasEr)->NREG # 0 //Se for diferente de Zero encontrou registro.
	(cAliasEr)->(dbCloseArea())
	
Return(lRet)

//-------------------------------------------------------------------
/*/{Protheus.doc} MTPVLSOLPD()
Função para preparar valiçao do produto X solicitante X entidade contábil

@author Alexandre.Gimenez
@since 03/09/2013
@version 1.0
@return lRet 
/*/
//-------------------------------------------------------------------

Function MTPVLSOLPD(cTab,cProd, lLinha)
Local lRet		:= .T.
Local lErro		:= .F.
Local lRateio	:= .F.
local aColsRat	:= {}
Local aHeaderRat:= {}
Local aEC  		:= {}
Local aCampos 	:= {}
Local aNoFields := {"CX_FILIAL","CX_CUSTO1","CX_CUSTO2","CX_CUSTO3","CX_CUSTO4","CX_CUSTO5","CX_SOLICIT","CX_ITEMSOL"}
Local cItemRat	:= ""
local nPosRat	:= 0
Local nX		:= 0
Local nY		:= 0
Local lRestSCC	:= SuperGetMv("MV_RESTSCC",.F.,.F.) .And. !PutByAPS()
Local lRestSAC	:= SuperGetMv("MV_RESTSAC",.F.,.F.)
Local cUser		:= cRetCodUsr
Local aGrpUsr	:= aClone(aUsrRetGrp)

Default cTab  := Substr(ReadVar(),At(">",ReadVar())+1 , At("_",ReadVar()) - At(">",ReadVar()) -1 )
Default cProd := &(ReadVar())
Default lLinha:= .F.

If cTab # "C1" .Or. !IsBlind() //-- Se não for execauto (na execauto, já vai validar pelo linhaok e tudook, então é mais performático que não se repita o valid do campo aqui)
	Do Case
		Case cTab == "C1" .And. lRestSCC // Solicitação de compra
			aCampos := MTGETFEC("SC1","C1")
			aEC := MTGETVALEC("SC1","C1",aHeader,aCols,n)
		Case cTab == "CP" .And. lRestSAC // Solicitação Armazem
			aCampos := MTGETFEC("SCP","CP")
			aEC := MTGETVALEC("SCP","CP",aHeader,aCols,n)
		Case cTab == "CX" .And. lRestSCC // Solicitação de compra
			aCampos := MTGETFEC("SCX","CX")
			aEC := MTGETVALEC("SCX","CX",aHeader,aCols,n)
	EndCase
	
	If cTab $ 'C1/CP' .And. !(Empty(cProd)) 
		If lLinha .And. lRestSCC .And. cTab == 'C1' ; //valida Toda a Linha da SC
		.And. aCols[n,GDFieldPos("C1_RATEIO")] == '2'
			lErro := !(MTVLDSOLEC(cProd,aEC[1,1],aCampos[1], cUser, aGrpUsr,{aCampos,aEC[1]}))
		Else
			For nX := 1 to len(aCampos)
				IF !(empty(aEC[1][nX])) 
					If !(MTVLDSOLEC(cProd,aEC[1][nX],aCampos[nX], cUser, aGrpUsr))
						lErro := .T.
						aCols[n,GDFieldPos(aCampos[nX])] := Criavar(aCampos[nX],.F.)
					EndIf 				
				EndIf
			Next Nx
		Endif
	ElseIf cTab $ 'CX' .And. !(Empty(cProd))
		If lLinha .AND. lRestSCC//valida Toda a Linha
			lErro := !(MTVLDSOLEC(cProd,aEC[1,1],aCampos[1], cUser, aGrpUsr,{aCampos,aEC[1]}))
		Else
			For nX := 1 to len(aCampos)
				IF !(empty(aEC[1][nX])) 
					If !(MTVLDSOLEC(cProd,aEC[1][nX],aCampos[nX], cUser, aGrpUsr))
						lErro := .T.
						aCols[n,GDFieldPos(aCampos[nX])] := Criavar(aCampos[nX],.F.)
					EndIf 				
				EndIf
			Next Nx
		EndIf
	EndIf
	If lErro	
		Help(' ', 1,'SOLPRODEC')
	EndIf
	
	//Zerar variaveis para testar rateio
	If ! lErro 
		aCampos:= {}
		
		Do Case
			Case cTab == "C1" .And. lRestSCC // Solicitação de compra
				IF( GDFieldGet("C1_RATEIO") == "1" )
					lRateio := .T.
					cItemRat:= GDFieldGet("C1_ITEM")
					aColsRat   := A110GETSCX()
					nPosRat := aScan(aColsRat, { |x|  x[1] == cItemRat })
					aCampos := MTGETFEC("SCX","CX")
					If Len(aCPHSCX) == 0
						aCPHSCX := COMXHDCO("SCX",,aNoFields) //Carrega array aCPHSCX
					EndIf
					aHeaderRat := aClone(aCPHSCX)			
				EndIf
			Case cTab == "CP" .And. lRestSAC // Solicitação Armazem
				IF GDFieldGet("CP_RATEIO") == "1"
					lRateio := .T.
					cItemRat:= GDFieldGet("CP_ITEM")
					aColsRat   := A105GETSGS()
					nPosRat := aScan(aColsRat, { |x|  x[1] == cItemRat })
					aCampos := MTGETFEC("SGS","GS")
					aHeaderRat := aClone(aCPHSGS)
				EndIf
		EndCase
		
		If lRateio
			If Len (aColsRat) > 0
				For nY := 1 to len(aColsRat[nPosRat][2])
					For nX := 1 to len(aCampos)
						If !(MTVLDSOLEC(cProd, aColsRat[nPosRat][2][nY][aScan(aHeaderRat,{ |x|  x[2] = aCampos[nX] })], aCampos[nX], cUser, aGrpUsr))
							lErro := .T.
							exit
						EndIF	
					Next nX	
					If lErro 
						exit
					EndIf			
				Next nY	
				If lErro
					ADel(aColsRat,nPosRat)
					aSize(aColsRat,len(aColsRat)-1)
					If cTab == "C1"
						A110SETSCX(aColsRat)
						aCols[n,GDFieldPos("C1_RATEIO")] := "2"
					ElseIf cTab == "CP"
						A105SETSGS(aColsRat)
						aCols[n,GDFieldPos("CP_RATEIO")] := "2"
					EndIf
					Help(' ', 1,'SOLRATEC')
				EndIf
			EndIf
		EndIf
	EndIf
EndIf
If lErro .And. lLinha
	lRet := .F.
EndIF	

Return lRet


//-------------------------------------------------------------------
/*/{Protheus.doc} MTPVLSOLEC()
Função para preparar valiçao solicitante X entidade contábil

@param lVldDeCpo, Indica se é valid chamado direto do campo (.T.) ou 
                  se é chamada de LinhaOk ou TudoOk (.F.)

@author antenor.silva
@since 30/08/2013
@version 1.0
@return lRet 
/*/
//-------------------------------------------------------------------

Function MTPVLSOLEC( lVldDeCpo )
Local lRet		 := .T.
Local cEC  		 := ""
Local cCampo 	 := ""
Local cTab		 := ""
Local cProd		 := ""
Local lVldSolici := .F.
Local lRestSCC	 := SuperGetMv("MV_RESTSCC",.F.,.F.) .And. !PutByAPS()
Local lRestSAC	 := SuperGetMv("MV_RESTSAC",.F.,.F.)
Local lMATA106	 := FwIsInCallStack("A106PROC")
Local lMATI110   := .F.
Local cEcc 		 := ""
Local cEcoN		 := ""
Local cEclV   	 := ""
Local cEitEm	 := ""
Local nAtPont    := 0
Local nAtUnder   := 0
Local lLinhaDel  := .F.
Local cUser		 := ""
Local aGrpUsr	 := {}
Local cUsrAtu	 := RetCodUsr()
Default lVldDeCpo := .T.

If !lMATA106

	If lVldDeCpo
	
		cCampo 	 := ReadVar()
		If !Empty( cCampo )
			nAtPont := At( ">", cCampo )
			nAtUnder := At( "_", cCampo )
			If nAtPont > 0 .And. nAtUnder > 0
				cEC := &( cCampo )
				
				cTab := Substr( cCampo, nAtPont + 1, nAtUnder - nAtPont - 1 )									
				lMATI110 := FwIsInCallStack('MATI110')
				
				If !lMATI110
					Do Case
						Case cTab == "C1" // Solicitação de compra
							cProd := GDFieldGet("C1_PRODUTO")
							lVldSolici := lRestSCC
						
						Case cTab == "CP" // Solicitação Armazem
							cProd := GDFieldGet("CP_PRODUTO")
							lVldSolici := lRestSAC
						
						Case cTab == "CX" // Rateio - Solicitação de compra
							If IsInCallStack('COMA110')
								cProd := FwFldGet("C1_PRODUTO")
							Else
								cProd := GDFieldGet("C1_PRODUTO",If(Type("nOrigN") <> "U",nOrigN,),,If(Type("aOrigHeader") <> "U",aOrigHeader,),If(Type("aOrigAcols") <> "U",aOrigAcols,))
							EndIf
							lVldSolici := lRestSCC
						
						Case cTab == "GS" // Rateio - Solicitação Armazem
							cProd := GDFieldGet("CP_PRODUTO",If(Type("nOrigN") <> "U",nOrigN,),,If(Type("aOrigHeader") <> "U",aOrigHeader,),If(Type("aOrigAcols") <> "U",aOrigAcols,))	
							lVldSolici := lRestSAC
					EndCase
					
					If !Empty( cProd ) .And. !Empty( cEC ) .And. lVldSolici
						If IsBlind() .And. cRetCodUsr <> cUsrAtu
							COMDocUser(cUsrAtu) 
						Endif
						lRet := MTVLDSOLEC( cProd, cEC, cCampo)
					EndIf
				EndIf
				
			EndIf
		EndIf
	
	ElseIf(!lVldDeCpo) //Se essa validação for chamada do linhaOk ou TudoOk (Valida entidades preenchidas via gatilho) 
		
		lLinhaDel := aCols[n][Len(aCols[n])] //Verifica se a linha posicionada está deletada  
		If lRestSCC .And. !lLinhaDel 
			cProd	:= GDFieldGet("C1_PRODUTO")
			cEcc 	:= GDFieldGet("C1_CC")
			cEcoN	:= GDFieldGet("C1_CONTA")
			cEclV   := GDFieldGet("C1_CLVL")
			cEitEm	:= GDFieldGet("C1_ITEMCTA")
			
			cUser	:= RetCodUsr()
			aGrpUsr	:= UsrRetGrp(cUser)
			
			If !Empty(cEcc) .And. lRet
				lRet := MTVLDSOLEC(cProd,cEcc ,"M->C1_CC", cUser, aGrpUsr)
			EndIf
			If !Empty(cEcoN) .And. lRet
				lRet := MTVLDSOLEC(cProd,cEcoN,"M->C1_CONTA", cUser, aGrpUsr)
			EndIf	
			If !Empty(cEclV) .And. lRet
				lRet := MTVLDSOLEC(cProd,cEclV,"M->C1_CLVL", cUser, aGrpUsr)
			EndIf		
			If !Empty(cEitEm) .And. lRet
				lRet := MTVLDSOLEC(cProd,cEitEm,"M->C1_ITEMCTA", cUser, aGrpUsr)
	        EndIf
	        
	        FwFreeArray(aGrpUsr)
	    EndIf
	
	EndIf

	If !lRet
		Help(' ', 1,'SOLEC')
	EndIf

EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} MTVLDSOLEC()
Função para validar solicitante X entidade contábil

@author antenor.silva
@since 30/08/2013
@version 1.0
@return lRet 
/*/
//-------------------------------------------------------------------

Function MTVLDSOLEC(cProd,cEC,cCampo, cUser, aGrpUser, aEnts)
Local aArea		:= GetArea()
Local lRet		:= .F.
Local cFiltOpc 	:= ''
Local cAllUser	:= ""
Local cGrpProd	:= ""
Local nLenGrp	:= 0
Local cAliasSql := GetNextAlias()
Local cUltRedf	:= Replicate('0',TamSX3('AI_ITEM')[1])
Local nX 		:= 0

Default cProd		:= ""
Default cEC			:= &(ReadVar())
Default cCampo		:= ReadVar()
Default cUser		:= cRetCodUsr
Default aGrpUser	:= aClone(aUsrRetGrp)
Default aEnts		:= {}

If __nTamAIUs == 0
	__nTamAIUs := TamSX3("AI_USER")[1]
EndIf
cAllUser := Replicate( '*', __nTamAIUs )

//Ajusta Campo, retira prefixo e adiciona Novamente com DBK
cCampo 		:= Substr(cCampo,At("_",cCampo))
cCampo 		:= "DBK" + Substr(cCampo,1,7)

//cria a cláusula where
cFiltOpc := "%( DBK_USER = '" + cUser + "' ) "

nLenGrp := IIF(RetGrpPri( cUser ), 1, Len(aGrpUser))
If nLenGrp > 0
	cFiltOpc := "%(( DBK_USER = '" + cUser + "' ) "
	For nX := 1 To nLenGrp
		cFiltOpc += " OR ( DBK_USER = '" + cAlluser + "' "  
		cFiltOpc += " AND DBK_GRUSER = '" + aGrpUser[nX] + "' )"
	Next
	cFiltOpc += ")"
Endif

cFiltOpc += " AND (" +cCampo +" = '" +cEC +"' OR " +cCampo +" = '*') %"
 
 //Buscar grupo de Produto
SB1->( dbSetOrder(1) ) //B1_FILIAL+B1_COD
If SB1->( msSeek( FWxFilial("SB1") + cProd ) )
	cGrpProd := SB1->B1_GRUPO
EndIf

// Query para validar regra onde DBK_PRODUT == C1_PRODUTO
// Query para validar regra onde DBK_GRUPO == B1_GRUPO e DBK_PRODUT == '*'
// Query para validar regra onde DBK_GRUPO == '*' e DBK_PRODUT == '*'
BeginSQL Alias cAliasSql
    SELECT DBK.R_E_C_N_O_ RecDBK,
    SAI.R_E_C_N_O_ RecSAI
    FROM %Table:DBK% DBK
    INNER JOIN %table:SAI% SAI  ON
    AI_GRUPO  = DBK_GRUPO AND 
    AI_USER = DBK_USER AND
    AI_GRUSER  = DBK_GRUSER
    WHERE DBK_FILIAL   = %xFilial:DBK%
        AND AI_FILIAL  = %xFilial:SAI%
        AND DBK_PRODUT = %Exp:cProd%
        AND AI_ITEM    > %Exp:cUltRedf%
        AND %Exp:cFiltOpc%
        AND SAI.%NotDel%
        AND DBK.%NotDel%
        
    UNION
    
    SELECT DBK.R_E_C_N_O_ RecDBK,
    SAI.R_E_C_N_O_ RecSAI
    FROM %Table:DBK% DBK
    INNER JOIN %table:SAI% SAI  ON
    AI_GRUPO  = DBK_GRUPO AND 
    AI_USER = DBK_USER AND
    AI_GRUSER  = DBK_GRUSER
    WHERE DBK_FILIAL   = %xFilial:DBK%
        AND AI_FILIAL  = %xFilial:SAI%
		AND DBK_GRUPO  = %Exp:cGrpProd%
        AND DBK_PRODUT = '*'
        AND AI_ITEM    > %Exp:cUltRedf%
        AND %Exp:cFiltOpc%
        AND SAI.%NotDel%
        AND DBK.%NotDel%
        
    UNION
    
    SELECT DBK.R_E_C_N_O_ RecDBK,
    SAI.R_E_C_N_O_ RecSAI
    FROM %Table:DBK% DBK
    INNER JOIN %table:SAI% SAI  ON
    AI_GRUPO  = DBK_GRUPO AND
    AI_GRUPO  = DBK_GRUPO AND 
    AI_USER   = DBK_USER AND
    AI_GRUSER = DBK_GRUSER 
    WHERE DBK_FILIAL   = %xFilial:DBK%
        AND AI_FILIAL  = %xFilial:SAI%
        AND DBK_GRUPO  = '*'
        AND DBK_PRODUT = '*' 
        AND AI_ITEM    > %Exp:cUltRedf% 
        AND %Exp:cFiltOpc%
        AND SAI.%NotDel%
        AND DBK.%NotDel%
EndSQL

While !(cAliasSql)->(EOF())
	SAI->(MsGoto((cAliasSql)->RecSAI))
	If SAI->AI_DOMINIO = 'R' .AND. SAI->AI_ITEM > cUltRedf
		cUltRedf := SAI->AI_ITEM
	Endif
	(cAliasSql)->(DBSkip())	
End

(cAliasSql)->(DbGoTop())

While !(cAliasSql)->(EOF())
	DBK->(MsGoto((cAliasSql)->RecDBK))
	SAI->(MsGoto((cAliasSql)->RecSAI))
	If Len(aEnts)==0
		If (DBK->&(cCampo) == cEC .Or. Alltrim(DBK->&(cCampo)) == '*') ;
		.And. SAI->AI_ITEM > cUltRedf .And. DBK->DBK_PRODUT == SAI->AI_PRODUTO
			lRet := .T.
			Exit
		EndIf	
	Else
		If SAI->AI_ITEM > cUltRedf .And. DBK->DBK_PRODUT == SAI->AI_PRODUTO
			lRet := .T.
			For nX := 1 to Len(aEnts[1])
				cCampo := aEnts[1,nX]
				cCampo := "DBK" + Substr(cCampo,At('_',cCampo))
				cDBK := DBK->&(cCampo) 
				If ( cDBK == aEnts[2,nX] .Or. Alltrim(cDBK) == '*')
				Else
					lRet := .F.
					Exit
				EndIf	
			Next
			If lRet
				Exit
			EndIf	
		EndIf	
	Endif
	(cAliasSql)->(DBSkip())	
Enddo

( cAliasSql )->( dbCloseArea() )

RestArea( aArea )
FwFreeArray( aArea )
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} RetGrpPri()
Função que verifica se deve priorizar o grupo do usuario

@author Rodrigo M Pontes
@since 11/04/18
@version 1.0
@return lRet 
/*/
//-------------------------------------------------------------------
Static Function RetGrpPri(cCodUser)
	Local lRet := .F.
	Default cCodUser := ""
	
	/*Uso de variável estática para controle de execucao (visto que o usuário nao irá mudar no meio do processo, 
	só verifica uma vez e guarda para as demais execuçoes do mesmo usuário, ganhando performance)*/
	If __lGotPri
		lRet := __lPriGrp
	Else
		__lGotPri := .T.
		
		//Prioriza o ID de usuario para ganho de performance, se cCodUser vazio e utiliza Smart Client
		If Empty(cCodUser) .AND. GetRemoteType() != -1
			cCodUser := __cUserId
		EndIf
		
		//Prioriza o ID de usuario para ganho de performance
   		If !Empty(cCodUser)
      		lRet := FWUsrGrpRule(cCodUser) == "1"
		EndIf  
		
		__lPriGrp := lRet		
	EndIf	
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} IsFirstLev()
Função que verifica se é o primeiro nivel do grupo de aprovação

@author Leonardo Quintania
@since 04/11/2013
@version 1.0
@return lRet 
/*/
//-------------------------------------------------------------------

Function IsFirstLev(cGrupo,cNivel,cDocto,cTipoDoc)
Local lRet		:= .T.
Local cTRB		:= GetNextAlias()
Local cQuery	:= ""

cQuery    := "  SELECT CR_GRUPO, MIN(CR_NIVEL) MINNIVEL "
cQuery    += "  FROM "+RetSqlName("SCR")+" SCR "
cQuery    += "	WHERE CR_FILIAL ='"+xFilial("SCR")+"'
cQuery    += "	AND	CR_NUM = '"+cDocto+"' "
cQuery    += "	AND	CR_TIPO = '"+cTipoDoc+"' " 
cQuery    += "	AND	CR_GRUPO = '"+cGrupo+"' " 
cQuery    += "	GROUP BY CR_GRUPO "
cQuery := ChangeQuery(cQuery)

dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cTRB)

If (cTRB)->MINNIVEL # cNivel
	lRet := .F.
EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} ExistSCR()
Função que verifica se existe SCR para o documento

@author Leonardo Quintania
@since 04/11/2013
@version 1.0
@return lRet 
/*/
//-------------------------------------------------------------------

Function ExistSCR(cTipo,cNum)
Local lRet := .F.

SCR->(dbSetOrder(1)) //CR_FILIAL+CR_TIPO+CR_NUM+CR_NIVEL
If SCR->(dbSeek(xFilial('SCR')+cTipo+cNum))
	lRet := .T.
EndIf

Return lRet	    

//-------------------------------------------------------------------
/*/{Protheus.doc} MTGetAlcPE()
Função que retorna os dados customizados de alçadas


@author Andre Anjos
@since 23/09/2015
@version 1.0
@return lRet 
/*/
//-------------------------------------------------------------------
Function MTGetAlcPE(cTpDoc)
Local aRet := {}
Local nPos := 0
//-- Layout do aMTAlcDoc
//-- aMTAlcDoc[nx,1]: Codigo do tipo (conforme CR_TIPO)
//-- aMTAlcDoc[nx,2]: Alias do documento com alcada customizada
//-- aMTAlcDoc[nx,3]: Indice para pesquisa
//-- aMTAlcDoc[nx,4]: Chave que compoe o CR_NUM
//-- aMTAlcDoc[nX,5]: Bloco de codigo para visualizacao do documento
//-- aMTAlcDoc[nX,6]: Bloco de codigo para bloqueio de estorno da aprovacao
//-- aMTAlcDoc[nX,7]: Array com os dados do campo de controle da situacao
//-- aMTAlcDoc[nX,7,1]: Nome do campo no alias
//-- aMTAlcDoc[nX,7,2]: Flag de bloqueio (pendente aprovacao)
//-- aMTAlcDoc[nX,7,3]: Flag de liberado
//-- aMTAlcDoc[nX,7,4]: Flag de rejeitado

Static aMTAlcDoc := NIL

//-- Se array vazio, instancia com chamada ao PE
If aMTAlcDoc == NIL .And. ExistBlock("MTALCPER")
	aMTAlcDoc := Execblock("MTALCPER",.F.,.F.)
	If ValType(aMTAlcDoc) # "A" .Or. (!Empty(aMTAlcDoc) .And. Len(aMTAlcDoc[1]) <> 7)
		aMTAlcDoc := {}
	EndIf
EndIf

If !Empty(aMTAlcDoc) .And. !Empty(nPos := aScan(aMTAlcDoc,{|x| x[1] == cTpDoc}))
	aRet := aClone(aMTAlcDoc[nPos])
EndIf

Return aRet

//-------------------------------------------------------------------
/*/{Protheus.doc} GetTpComp()
Retona um array com os Tipos de Compra do Grupo X Aprovador.

@author raphael.augustos
@since 31/08/2015
@version 1.0
@return aRet
/*/
//-------------------------------------------------------------------

Function GetTpComp(cGrupo,cAprov,cTpComp)
Local aRet 		:= {}
Local aAreaDHM	:= DHM->(GetArea())
DEFAULT cGrupo	:= ""
DEFAULT cAprov	:= ""
DEFAULT cTpComp	:= ""

DHM->(dbSetOrder(1)) //DHM_FILIAL+DHM_GRUPO+DHM_APROV+DHM_TIPCOM
If DHM->(dbSeek(xFilial("DHM")+cGrupo+cAprov+cTpComp))
	While !DHM->(Eof()) .And. xFilial("DHM")+cGrupo+cAprov == DHM->(xFilial("DHM")+DHM_GRUPO+DHM_APROV) .And. cTpComp == DHM->DHM_TIPCOM
		AADD(aRet, DHM->DHM_TIPCOM)
	DHM->(DbSkip())
	End
EndIf

RestArea(aAreaDHM)
Return aRet

//-------------------------------------------------------------------
/*/{Protheus.doc} SchedComAlc()
Schedule de aviso de encerramento de prazo e escalonamento de
aprovação.

@author Flavio Lopes Rasta
@since 01/09/2015
@version 12
/*/
//-------------------------------------------------------------------
Function SchedComAlc(aParam)
Local cTipo			:= ""
Local aMail 		:= {}
Local cRet			:= ""
Local cHTMLSrc		:= "samples/wf/MATXALC_Mail001.html"
Local cHTMLDst		:= "samples/wf/MATXALC_MTmp001.htm" //Destino deve ser .htm pois o metodo :SaveFile salva somente neste formato.
Local oHTMLBody		:= Nil
Local lRet			:= .F.
Local cTit			:= "Prazo para aprovação de documento próximo do vencimento"
Local lFluig		:= .F.
Local lMtUsrSolic 	:= .F.
Local lMTSoliCAT 	:= .F.
Local lFMtUsrSolic 	:= .F.
Local lFMTSoliCAT 	:= .F.
Local lLowR033		:= .F.

RpcSetType(3)
RpcSetEnv(aParam[1],aParam[2],,,"COM")

lFluig		:= SuperGetMV("MV_APWFECM",.F.,"1") == "1" .And. !Empty(AllTrim(GetNewPar("MV_ECMURL",""))) .And. FWWFFluig()
lMtUsrSolic := ExistBlock("MtUsrSolic")
lMTSoliCAT 	:= ExistBlock("MTSoliCAT")
lLowR033	:= GetRPORelease() < "12.1.033"
lFMtUsrSolic:= FindFunction("MtUsrSolic") .And. lLowR033
lFMTSoliCAT := FindFunction("MTSoliCAT") .And. lLowR033

//-- Envia Aviso
BeginSQL Alias "AVISO"
	SELECT R_E_C_N_O_ SCRRECNO
	FROM %Table:SCR% SCR
	WHERE SCR.%NotDel% AND
		SCR.CR_FILIAL	= %xFilial:SCR% AND
		SCR.CR_STATUS = '02' AND
		SCR.CR_TIPO IN ('SC','IP') AND
		SCR.CR_PRAZO >= %Exp:dDataBase% AND
		SCR.CR_AVISO <= %Exp:dDataBase% AND
		SCR.CR_ULTAVIS < %Exp:dDataBase%
EndSQL

While !AVISO->(Eof())
	SCR->(dbGoTo(AVISO->SCRRECNO))

	If SCR->CR_TIPO == 'SC'
		cTipo := "Solicitação de Compra"
	ElseIf SCR->CR_TIPO == 'IP'
		cTipo := "Pedido de Compra"
	Endif

	If File(cHTMLSrc)
		oHTMLBody:= TWFHTML():New(cHTMLSrc)
		lRet	 := .T.
	EndIf

	If lRet
		oHTMLBody:ValByName('cTitulo'	, cTit)
		oHTMLBody:ValByName('cContato'	, UsrFullName(SCR->CR_USER) + ',')
		oHTMLBody:ValByName('cTipo'	,cTipo)
		oHTMLBody:ValByName('cDoc'	,SCR->CR_NUM)
		oHTMLBody:ValByName('cDias'	,Str(SCR->CR_PRAZO - dDatabase ))
		oHTMLBody:ValByName('cPrazo',DTOC(SCR->CR_PRAZO))
		If SCR->CR_ESCALON
			oHTMLBody:ValByName('cEscalona','Caso a aprovação não ocorra até o prazo informado, seu superior será notificado.')
		EndIf

		oHTMLBody:SaveFile(cHTMLDst)
		cRet:= MtHTML2Str(cHTMLDst)
		FErase(cHTMLDst)
	EndIf

	PswOrder(1)
	If	PswSeek(SCR->CR_USER)
		aMail := {PswRet(1)[1][14]}
	EndIf
	If !Empty(aMail)
		If MTSendMail(aMail,cTit,cRet)
			RecLock("SCR",.F.)
				SCR->CR_ULTAVIS := dDataBase
			MsUnlock()
		EndIf
	Endif
	aMail 	:= {}
	oHTMLBody	:= Nil
	AVISO->(dbSkip())
EndDo

AVISO->(dbCloseArea())

//-- Envia notificação do escalonamento
cTit := "Vencimento do prazo para aprovação de documento"
cHTMLSrc	:= "samples/wf/MATXALC_Mail002.html"
cHTMLDst	:= "samples/wf/MATXALC_MTmp002.htm"

BeginSQL Alias "PRAZO"
	SELECT R_E_C_N_O_ SCRRECNO
	FROM %Table:SCR% SCR
	WHERE SCR.%NotDel% AND
		SCR.CR_FILIAL	= %xFilial:SCR% AND
		SCR.CR_STATUS = '02' AND
		SCR.CR_ESCALON = 'T' AND
		SCR.CR_TIPO IN ('SC','IP') AND
		CR_PRAZO < %Exp:dDataBase%
EndSQL

While !PRAZO->(Eof())
	SCR->(dbGoTo(PRAZO->SCRRECNO))

	If SCR->CR_TIPO == 'SC'
		cTipo := "Solicitação de Compra"
	ElseIf SCR->CR_TIPO == 'IP'
		cTipo := "Pedido de Compra"
	Endif

	If File(cHTMLSrc)
		oHTMLBody:= TWFHTML():New(cHTMLSrc)
		lRet	 := .T.
	EndIf

	SAK->(dbSetOrder(1))//AK_FILIAL+AK_COD                                                                                                                                                
	If SAK->(dbSeek(xFilial("SAK") + SCR->CR_APROV))
    	cSuperior := SAK->AK_APROSUP
		If !Empty(cSuperior)
			cSuperior := GetAdvFVal("SAK","AK_USER",fwxFilial("SAK") + cSuperior,1)
		Endif
    EndIf

	If lRet
		oHTMLBody:ValByName('cTitulo'	, cTit)
		oHTMLBody:ValByName('cContato'	, UsrFullName(cSuperior) + ',')
		oHTMLBody:ValByName('cAprov'	, UsrFullName(SCR->CR_USER))
		oHTMLBody:ValByName('cTipo'	,cTipo)
		oHTMLBody:ValByName('cDoc'	,SCR->CR_NUM)
		oHTMLBody:ValByName('cPrazo',DTOC(SCR->CR_PRAZO))

		oHTMLBody:SaveFile(cHTMLDst)
		cRet:= MtHTML2Str(cHTMLDst)
		FErase(cHTMLDst)
	EndIf

	PswOrder(1)
	If	PswSeek(cSuperior)
		aMail := {PswRet(1)[1][14]}
	Endif
	If !Empty(aMail) .And. Valtype(SCR->CR_ESCALSP) == "L" .And. SCR->CR_ESCALSP
		If MTSendMail(aMail,cTit,cRet)
			If lFluig .And. !Empty(SCR->CR_FLUIG)
				CancelProcess(Val(SCR->CR_FLUIG),FWWFUserID(Val(SCR->CR_FLUIG))," cancelado por contingência!",.F.)				
			EndIf
			RecLock("SCR",.F.)
				SCR->CR_ESCALON 	:= .F.
				SCR->CR_ESCALSP	:= .F.
				SCR->CR_USER		:= cSuperior
				SCR->CR_APROV		:= A097UsuApr(cSuperior,2)
			MsUnlock()
			// Gera a alçada do superior no Fluig
			If lFluig .And. !Empty(SCR->CR_FLUIG)
				If lMtUsrSolic
					cUserSolic	:= ExecBlock("MtUsrSolic", .F., .F., {SCR->CR_TIPO,SCR->CR_NUM})
				Elseif lFMtUsrSolic
					cUserSolic	:= MtUsrSolic(SCR->CR_TIPO,SCR->CR_NUM)
				Endif
				
				If lMTSoliCAT
					ExecBlock("MTSoliCAT", .F., .F., {cTipoDoc,cDocto,"","CR_NUM",cUserSolic,.T.})
				Elseif lFMTSoliCAT
					MTSoliCAT(cTipoDoc,cDocto,"","CR_NUM",cUserSolic,.T.)
				Endif
			Endif
		EndIf
	Endif
	aMail 	:= {}
	oHTMLBody	:= Nil
	PRAZO->(dbSkip())
EndDo

PRAZO->(dbCloseArea())

RpcClearEnv()

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} MaRetTolIt()
Retorna se o item está dentro da tolerância para geração de alçada
de acordo com o tipo de compra

@author Flavio Lopes Rasta
@since 01/09/2015
@version 12
/*/
//-------------------------------------------------------------------
Function MaRetTolIt( aItAlgu )
Local aAreaSC1	:= SC1->(GetArea())
Local aAreaDHK	:= DHK->(GetArea())
Local aAreaDBM	:= DBM->(GetArea())
Local nTamDoc	:= TamSX3("DBM_NUM")[1]
Local nTamIte	:= TamSX3("DBM_ITEM")[1]
Local aBuscaDBM	:= {}
Local lTolera	:= .F.
Local lUsaTol	:= .F.
Local lLibTpCom	:= .T.
Local nX		:= 1
Local nAprTotal	:= 0

SC1->(DbSetOrder(6))
For nX:=1 To Len(aItAlgu[2])
	If SC1->(DbSeek(xFilial("SC1")+aItAlgu[1]+aItAlgu[2][nX][1]))
		aAdd(aBuscaDBM,{SC1->C1_NUM, SC1->C1_ITEM})
	EndIf
Next nX

If !Empty(aBuscaDBM)
	For nX:=1 To Len(aBuscaDBM)
		DBM->(DbSetOrder(2))
		If DBM->(DbSeek(xFilial("DBM")+"SC"+PadR(aBuscaDBM[nX][1],nTamDoc)+PadR(aBuscaDBM[nX][2],nTamIte)))
			DHK->(DbSetOrder(1))
			If DHK->(DbSeek(xFilial("DHK")+DBM->DBM_TIPCOM))
				If DHK->DHK_LIBPC
					If DHK->DHK_TOLERA
						lUsaTol := .T.
						nAprTotal += DBM->DBM_VALOR * (1 + (DHK->DHK_TOLDFS/100))
					Else
						nAprTotal += DBM->DBM_VALOR
					Endif
				Else
					lLibTpCom := .F.
					Exit
				Endif
			Else
				lLibTpCom := .F.
			Endif
		Else
			lLibTpCom := .F.
		Endif
	Next nX

	If lLibTpCom
		If !lUsaTol
			lTolera := .T.
		Else
			If aItAlgu[3] <= nAprTotal
				lTolera := .T.
			Endif
		Endif
	Endif
Endif

RestArea( aAreaSC1 )
RestArea( aAreaDHK )
RestArea( aAreaDBM )

Return lTolera

//-------------------------------------------------------------------
/*/{Protheus.doc} MaMailAlcRej()
Envia e-mail de rejeição de documento ao solicitante

@author Flavio Lopes Rasta
@since 01/09/2015
@version 12
/*/
//-------------------------------------------------------------------
Function MaMailAlcRej(cNumDoc,cAprov,cTipoDoc,cObs)
Local aArea		:= GetArea()
Local cTipo		:= ""
Local aMail 	:= {}
Local cSolic	:= ""

Local cRet		:= ""
Local cHTMLSrc	:= "samples/wf/MATXALC_Mail003.html"
Local cHTMLDst	:= "samples/wf/MATXALC_MTmp003.htm" //Destino deve ser .htm pois o metodo :SaveFile salva somente neste formato.
Local oHTMLBody	:= Nil
Local lRet		:= .F.
Local cTit		:= "Rejeição de Documento"

If cTipoDoc == 'SC'
	cTipo := "Solicitação de Compra"
	SC1->(DbSetOrder(1))
	SC1->(DbSeek(xFilial("SC1")+AllTrim(cNumDoc)))
	cSolic := SC1->C1_USER
ElseIf cTipoDoc == 'IP'
	cTipo := "Pedido de Compra"
	SC7->(DbSetOrder(1))
	SC7->(DbSeek(xFilial("SC7")+AllTrim(cNumDoc)))
	cSolic := SC7->C7_USER
Endif

If File(cHTMLSrc)
	oHTMLBody:= TWFHTML():New(cHTMLSrc)
	lRet	 := .T.
EndIf

If lRet
	oHTMLBody:ValByName('cTitulo'	, cTit)
	oHTMLBody:ValByName('cSolic'	, UsrFullName(cSolic) + ',')
	oHTMLBody:ValByName('cTipo'	,cTipo)
	oHTMLBody:ValByName('cDoc'	,AllTrim(cNumDoc))
	oHTMLBody:ValByName('cAprov'	,UsrFullName(cAprov))
	oHTMLBody:ValByName('cObs',AllTrim(cObs))

	oHTMLBody:SaveFile(cHTMLDst)
	cRet:= MtHTML2Str(cHTMLDst)
	FErase(cHTMLDst)

	PswOrder(1)
	If	PswSeek(cSolic)
		aMail := {PswRet(1)[1][14]}
	Endif
	If !Empty(aMail)
		MTSendMail(aMail,cTit,cRet)
	Endif
EndIf



oHTMLBody	:= Nil

RestArea( aArea )

Return

//--------------------------------------------------------------------
/*/{Protheus.doc} MtGLastSCR()
Verifica se todos os niveis de alçada foram liberados
@author Rafael Duram
@Param cTipo:	Tipo do documento
@Param cNum:	Numero do documento
@since 25/09/2015
@version 1.0
@return Ret :=  .T. = Está liberado, .F. = não está liberdado.
/*/
//--------------------------------------------------------------------
Function MtGLastSCR(cTipo,cNum)
Local lRet 		:= .T.
Local cWhere		:= ""

cWhere += " AND CR_NUM = '"+cNum+"' "
cWhere += " AND CR_TIPO = '"+cTipo+"' "
cWhere += " AND CR_STATUS IN ('01','02','06') "

cWhere := '%'+cWhere+'%'

BeginSql Alias "TMPSCR"

	SELECT COUNT(*) AS NREG
	FROM
		%table:SCR% SCR
	WHERE
		SCR.%notDel% AND
		SCR.CR_FILIAL = %xFilial:SCR%
		%Exp:cWhere%
EndSql

lRet := TMPSCR->NREG == 0
TMPSCR->(dbCloseArea())

Return(lRet)

//-------------------------------------------------------------------
/*/{Protheus.doc} MaAlcItApG()
Funcao utilizada para retornar o valor das aprovações gerais, quando há política de compra para os aprovadores

@author rafael.duram
@since 17/05/2016
@version 1.0

cDocto,cTpDoc,cGrp,cUsrApv,aItens,nOpcao,cAprov

@param cDocto Documento
@param cTpDoc Tipo do Documento (SC,SA,IP,etc.)
@param cGrp	 Grupo de aprovacao
@param cUsrApv Usuario da aprovacao
@param aItens Array com os itens da aprovacao
@param nOpcao Opcao (1-Inclusao,2-Alteracao,3-Exclusao)
@param cAprov Código do Aprovador

@return nTotal
/*/
//-------------------------------------------------------------------
Function MaAlcItApG(cDocto,cTpDoc,cGrp,cUsrApv,aItens,nOper,cAprov)

Local aArea		:= GetArea()
Local aTipCom		:= {}
Local cTpComp		:= ""
Local nValorIt  	:= 0
Local nDescontoIt := 0 
Local nFreteIt    := 0
Local nSeguroIt   := 0
Local nDespesaIt  := 0
Local nFor	 		:= 0
Local nTotal		:= 0
Local lAprovEsp	:= .F.
Local nPosIt
Local nLinItem
Local lAtuMaFis	:= .F.

Default cGrp		:= Space(TamSX3("DBM_GRUPO")[1])
Default cUsrApv	:= Space(TamSX3("DBM_USER")[1])
Default aItens	:= {}
Default cAprov 	:= Space(TamSX3("DBM_USAPRO")[1])

/*aItem
aItens[nx,1] C7_ITEM
aItens(nx,2] C7_PRODUTO
aItens[nx,3] C7_TOTAL
aItens[nx,4] C7_TIPCOM
aItens[nx,5] C7_VLDESC
aItens[nx,6] C7_VALFRE
aItens[nx,7] C7_SEGURO
aItens[nx,8] C7_DESPESA
aItens[nx,9] IT_TOTAL
*/

If nOper == 1 //Inclusao
	//Soma os itens que estejam dentro do range do Aprovador
	For nFor := 1 to Len(aItens)
		lAtuMaFis		:= .F.
		nValorIt  	   	:= aItens[nFor][3]
		nDescontoIt  	:= aItens[nFor][5]
		nFreteIt     	:= aItens[nFor][6]
		nSeguroIt    	:= aItens[nFor][7]
		nDespesaIt   	:= aItens[nFor][8]
		
		If cTpDoc $ "SC|PC|AE"
			cTpComp	:= aItens[nFor][4]
			aTipCom := GetTpComp(cGrp,cAprov,cTpComp)
			lAprovEsp := !Empty(aTipCom)

			DHK->(DbSetOrder(1))
			If DHK->(DbSeek(xFilial("DHK")+cTpComp))
				If (lAprovEsp .And. aScan(aTipCom,{|x| AllTrim(x) == AllTrim(cTpComp)}) == 0) .Or.;
						(cTpDoc == "SC" .And. !If(lAprovEsp,DHK->DHK_APROVE,DHK->DHK_APROVP)) .Or.;
						(cTpDoc == "PC" .And. !If(lAprovEsp,DHK->DHK_PAPRES,DHK->DHK_PAPRPA)) .Or.;
						(cTpDoc == "SC" .And. lAprovEsp .And. DHK->DHK_APROVP) .Or.;
						(cTpDoc == "PC" .And. lAprovEsp .And. DHK->DHK_PAPRPA)
					Loop
				EndIf
			EndIf
		EndIf
		
		If Len(aItens[nFor]) > 8 .AND. aItens[nFor][9] > 0
			nTotal += aItens[nFor][9]
		Else
			If MaFisFound() .and. Type("aHeader") == "A"
				nPosIt 		:= aScan(aHeader, {|x| Alltrim(x[2]) == "C7_ITEM" })
				If nPosIt > 0
					nLinItem 	:= aScan(aCols, {|x| x[nPosIt] == aItens[nFor][1]})
					If nLinItem > 0// .and. !IsInCallStack('MATA160') .And. !IsInCallStack('MATA161') .AND. !IsInCallStack('EICPO400') .AND. !IsInCallStack('MATA235') .AND. !IsInCallStack('MATA170')
						nTotal 		+= MaFisRet(nLinItem,"IT_TOTAL")
						lAtuMaFis := .T.
					EndIf
				EndIf
			EndIf
			If !lAtuMaFis
				nTotal += nValorIt - nDescontoIt + nDespesaIt + nSeguroIt + nFreteIt
			EndIf
		EndIf
	Next nFor

Endif

RestArea(aArea)

Return nTotal

//-------------------------------------------------------------------
/*/{Protheus.doc} MaRetItDoc()
Funcao utilizada para retornar os itens de um determinado documento

@author rafael.duram
@since 18/05/2016
@version 1.0

cDocto,cFilDoc,cAliasDoc,cTpDoc

@param cDocto    Documento
@param cFilDoc   Filial do Documento
@param cAliasDoc Alias do Documento
@param cTpDoc	   Tipo de Documento

@return aItens
/*/
//-------------------------------------------------------------------
Function MaRetItDoc(cDocto,cFilDoc,cAliasDoc,cTpDoc)
Local aAreaAnt 	:= GetArea()
Local aAreaSC7 	:= {}
Local aItens	:= {}
Local aRefImp	:= MaFisRelImp('MT100',{"SC7"})
Local nTotal	:= 0, nA
Local aStru		:= FWFormStruct(3,"SC7")[1]
Local nPos		:= 0

If (cTpDoc == "PC" .Or. cTpDoc == "AE") .And. cAliasDoc == "SC7"
	aAreaSC7 := SC7->(GetArea())
	SC7->(DbSetOrder(1))
	If SC7->(DbSeek(cFilDoc+cDocto))
		While !SC7->(Eof()) .And. cFilDoc+cDocto == SC7->(C7_FILIAL+C7_NUM) 
			If SC7->C7_RESIDUO <> 'S' .OR. SC7->C7_QUJE > 0
				If ( FwIsInCallStack('MATA160') .OR. FwIsInCallStack('MATA161') .OR. FwIsInCallStack('MATA235') .or. FwIsInCallStack('PGCGERDOC') )
					MaFisIni(SC7->C7_FORNECE,SC7->C7_LOJA,"F","N","R",aRefImp)						
					MaFisIniLoad(1)
					For nA := 1 To Len(aRefImp)
						nPos := aScan(aStru,{|x| AllTrim(x[3]) == AllTrim(aRefImp[nA][2])})
						If nPos > 0 .And. !aStru[nPos,14]
							MaFisLoad(aRefImp[nA][3],SC7->(&(aRefImp[nA][2])),1)
						Endif
					Next nA
					MaFisRecal("",1)
					MaFisEndLoad(1)
					MaFisAlt("IT_ALIQIPI",SC7->C7_IPI,1)
					MaFisAlt("IT_ALIQICM",SC7->C7_PICM,1)
					If cPaisLoc == "BRA"
						MaFisAlt("IT_VALSOL", SC7->C7_ICMSRET,1)
					EndIf							
					MaFisWrite(1,"SC7",1)
					nTotal := MaFisRet(1,"IT_TOTAL")
					MaFisEnd()
				EndIf
				
				If Empty(SC7->C7_ITEMGRD)
					Aadd(aItens,{SC7->C7_ITEM,SC7->C7_PRODUTO,SC7->C7_TOTAL,SC7->C7_TIPCOM,SC7->C7_VLDESC,SC7->C7_VALFRE,SC7->C7_SEGURO,SC7->C7_DESPESA,nTotal})
				Else
					Aadd(aItens,{SC7->C7_ITEMGRD,SC7->C7_PRODUTO,SC7->C7_TOTAL,SC7->C7_TIPCOM,SC7->C7_VLDESC,SC7->C7_VALFRE,SC7->C7_SEGURO,SC7->C7_DESPESA,nTotal})
				EndIf
			Endif
			SC7->(DbSkip())
		EndDo
	Endif
	RestArea(aAreaSC7)
Endif

RestArea(aAreaAnt)

Return aItens

/*/{Protheus.doc} ClrVarXAlc
Função para limpar as variáveis estáticas do matxalc, utilizadas no processo de 
controle de permissões do solicitante x entidades contábeis, na inclusão de SC  

@author pedro.alencar
@since 10/07/2019
@version 1
@return Nil
/*/
Function ClrVarXAlc()
	__lGotPri := .F.
	__lPriGrp := .F.
	__nTamAIUs := 0
Return Nil

/*/{Protheus.doc} RetVlRecNF
Retorna valor de pedido recebido por NF para descontar do Estorno

@author rd.santos
@since 13/12/2019
@version 1
@return Nil
/*/
Function RetVlRecNF()
Local nRet 			:= 0
Local cQrySc7 		:= ""
Local cAliasTmpc7	:= GetNextAlias()
local cQryStat      := ""
local oQuery        := nil

oQuery := FWPreparedStatement():New()

cQrySc7	:= " SELECT C7_PRODUTO, C7_QUJE, C7_PRECO "
cQrySc7	+= " FROM "+RetSqlName("SC7")+"  C7  "
cQrySc7	+= " INNER JOIN "+RetSqlName("SCR")+" SCR "  
cQrySc7	+= " ON  C7_NUM = CR_NUM  "  
cQrySc7	+= " AND CR_FILIAL = ?  " 
cQrySc7	+= " AND CR_NUM = ? "
cQrySc7	+= " AND CR_APROV = ?  "
cQrySc7	+= " AND SCR.D_E_L_E_T_ = '' "
cQrySc7	+= " AND CR_STATUS  = '03' "	
cQrySc7	+= " WHERE C7_QUJE > 0  "
cQrySc7	+= " AND C7.C7_FILIAL = ? "
cQrySc7	+= " AND C7.D_E_L_E_T_ = '' "

cQrySc7 := ChangeQuery(cQrySc7)

oQuery:SetQuery(cQrySc7) 

oQuery:SetString(1,xFilial("SCR"))
oQuery:SetString(2,SCR->CR_NUM)
oQuery:SetString(3,SCR->CR_APROV)
oQuery:SetString(4,xFilial("SC7"))

cQryStat := oQuery:GetFixQuery()
MpSysOpenQuery(cQryStat,cAliasTmpc7)

While !(cAliasTmpc7)->(Eof())
	nRet += (cAliasTmpc7)->C7_QUJE * (cAliasTmpc7)->C7_PRECO
	(cAliasTmpc7)->(DbSkip())
EndDo

(cAliasTmpc7)->(DbCloseArea())
	
Return nRet

/*/{Protheus.doc} MATEVENT75
Retorna proximo aprovador (eventviewer)
Montagem da mensagem

@author rodrigo.mpontes
@since 06/11/2020
@version 1
@return Nil
/*/

Static Function MATEVENT75(nOpc,cDocto,cTipoDoc,cGrupo,cItGrp,cMsg)

Local cQuery		As Character
Local cAliasQry 	As Character
Local nOrder		As Numeric
Local oQry      	As Object

Local cRet		:= ""
Local aRet 		:= {}
Local lModoTab	:= FwSX2Util():GetSX2data("SCR",{"X2_MODO"})[1][2] == 'C'  .OR. FwSX2Util():GetSX2data("SC7",{"X2_MODO"})[1][2] == 'C'
Local cFilSCR	:= IIf(cTipoDoc $ 'IC|CT|IR|RV',CnFilCtr(cDocto),xFilial("SCR"))
Local cFilDoc 	:= If(lModoTab, fwxFilial('SC7'), cFilSCR)
Local cCrStatus := "" 

Default cMsg := ""

If nOpc == 1 //Busca pelo proximo aprovador
	
	cQuery 		:= ""
	cCrStatus  	:= "02" //Aguardando Aprovação
	cAliasQry 	:= GetNextAlias()
	nOrder 		:= 1  
	oQry 		:= Nil

	cQuery := " SELECT CR_USER"
	cQuery += 	" FROM ?"
	cQuery += 	" WHERE CR_FILIAL 		= ?"
	cQuery += 		" AND CR_TIPO 		= ?"
	cQuery += 		" AND CR_NUM		= ?"
	cQuery += 		" AND CR_GRUPO 		= ?"
	cQuery += 		" AND CR_ITGRP 		= ?"
	cQuery += 		" AND CR_STATUS 	= ?"
	cQuery += 		" AND D_E_L_E_T_ 	= ?"

	oQry := FWPreparedStatement():New()
	oQry:SetQuery(cQuery)

	oQry:SetNumeric(nOrder++,RetSqlName("SCR"))
	oQry:SetString(nOrder++,xFilial("SCR"))
	oQry:SetString(nOrder++,cTipoDoc)
	oQry:SetString(nOrder++,cDocto)
	oQry:SetString(nOrder++,cGrupo)
	oQry:SetString(nOrder++,cItGrp)
	oQry:SetString(nOrder++,cCrStatus)
	oQry:SetString(nOrder++,Space(1))

	cQuery      := oQry:GetFixQuery()
	cAliasQry := MpSysOpenQuery(cQuery,cAliasQry)

	FreeObj(oQry)

	While (cAliasQry)->(!EOF())

		aAdd(aRet, (cAliasQry)->CR_USER)

		(cAliasQry)->(DbSkip())
	Enddo

	(cAliasQry)->(DbCloseArea())
	
Elseif nOpc == 2 //Mensagem (E-mail)
	If cTipoDoc == "IP" .Or. cTipoDoc == "PC"
		cRet := "Pedido: "
	Elseif cTipoDoc == "AE"
		cRet := "Autorização de Entrega: "
	Elseif cTipoDoc == "CO"
		cRet := "Cotação: "
	Elseif cTipoDoc == "CP"
		cRet := "Contrato de Parceria: "
	Elseif cTipoDoc == "NF"
		cRet := "Documento de Entrada: "
	Elseif cTipoDoc == "SA"
		cRet := "Solicitação ao Armazem: "
	Elseif cTipoDoc == "SC"
		cRet := "Solicitação de Compras: "
	Elseif cTipoDoc == "ST"
		cRet := "Solicitação de Transferência: "
	Elseif cTipoDoc == "CT" .Or. cTipoDoc == "IC"
		cRet := "Contrato: "
	Elseif cTipoDoc == "RV" .Or. cTipoDoc == "IR"
		cRet := "Revisão: "
	Elseif cTipoDoc == "MD" .Or. cTipoDoc == "IM"
		cRet := "Medição: "
	Elseif cTipoDoc == "GA"
		cRet := "Documento Garantia: "
	Elseif cTipoDoc >= "A1" .And. cTipoDoc <= "A9"
		cRet := "Documento Agro: "
	Elseif cTipoDoc == "PV"		
		cRet := "Pedido de Venda: "
	Elseif cTipoDoc == "DV"
		cRet := "Desconto Ped. Venda: "
	Endif

	cRet += cFilDoc + ' - ' + Alltrim(cDocto) + " pendente de sua aprovação."
Elseif nOpc == 3 //PushNotification mobile - Lib > 20221004

	cRet :='{'
	cRet +=' "notification": { '
	if cTipoDoc == "SC"
		cRet +=' "title": "Solicitação aguardando aprovação.",'
	else 
		cRet +=' "title": "Pedido aguardando aprovação.",'
	endif
	cRet +=' "body": "' + cMsg + '" '
	cRet +='}, '
	cRet +=' "data": { '
	if cTipoDoc == "SC"
		cRet +=' "type": "purchaseRequest", '
	else 
		cRet +=' "type": "purchaseOrder", '
	endif
	cRet +=' "id": "' + Alltrim(cDocto) +'", '
	cRet +=' "branch": "' + cFilAnt +'", '
	cRet +=' "companyGroup": "' + cEmpAnt +'" '
	cRet +=' }'
	cRet +='}'

	cRet := Alltrim(cRet)

Endif

//Se o nOpc == 1 o retorno deverá ser um array com aprovadores
//Se o nOpc == 2 o retorno deverá ser uma string com tipo do doc.
Return If(nOpc==1,aRet,cRet)

/*/{Protheus.doc} PCPDocUser
Função do modulo PCP para atribuir corretamente usuário/grupo nas variáveis estáticas
a partir da geração de documentos do mrp com uso de multi thread

@author renan.roeder
@since 14/10/2021
@version 1
@return Nil
/*/
Function PCPDocUser(cUserId)
	cRetCodUsr := RetCodUsr(UsrRetName(cUserId))
	aUsrRetGrp := UsrRetGrp( ,cUserId)
Return

/*/{Protheus.doc} COMDocUser
Função do modulo COM para atribuir corretamente usuário/grupo nas variáveis estáticas
a partir da geração de documentos via api REST

@author rodrigo.mpontes
@since 14/10/2021
@version 1
@return Nil
/*/
Function COMDocUser(cUserId)
	cRetCodUsr := RetCodUsr(UsrRetName(cUserId))
	aUsrRetGrp := UsrRetGrp( ,cUserId)
Return

/*/{Protheus.doc} ComMtrAlc
Métrica - Total de documentos com alçadas, por tipo de documento e alçadas simples x entidades contabeis

@Param cOper		inc (Inclusão)
@Param cTipo		Tipo de documento - SC|PC|IP|NF
@Param nItemMetric	Quantidade de documento

@author Fabiano Dantas
@since 26/10/2021
@return Nil, indefinido
/*/
Static Function ComMtrAlc(cOper,cTipo,lDbm,nItemMetric)

Local cRotina		:= "mata094"
Local cIncRot		:= "-tela"
Local cTpDoc		:= "-"+Lower(cTipo)
Local cEntCtb		:= "-entctb"
Local cSubRoutine	:= cRotina+cOper+cIncRot+cTpDoc
Local lContinua		:= (FWLibVersion() >= "20210517") .And. FindClass('FWCustomMetrics')
Local cIdMetric1    := "compras-protheus_total-de-tipos-de-alcadas_total"
Local cIdMetric2	:= "compras-protheus_total-tipos-de-documento_total"

DEFAULT lDbm := .F. 

If lContinua

	If  lDbm
		cSubRoutine := cRotina+cOper+cIncRot+cEntCtb+cTpDoc
		FWCustomMetrics():setSumMetric(cSubRoutine, cIdMetric1, nItemMetric, /*dDateSend*/, /*nLapTime*/, cRotina)
	Else 
		FWCustomMetrics():setSumMetric(cSubRoutine, cIdMetric2, nItemMetric, /*dDateSend*/, /*nLapTime*/, cRotina)
	EndIf 

EndIf 

Return

//--------------------------------------------------------------------
/*/{Protheus.doc} MtUsrSolic()
Retorna o código do Usuário solicitante de acordo com o tipo da alçada posicionada
@author Rafael Duram
@Param cTipo:	Tipo do documento
@Param cNum:	Numero do documento
@since 13/10/2015
@version 1.0
@return cRet
/*/
//--------------------------------------------------------------------
Function MtUsrSolic(cTipo,cNum)

Local cRet 		:= ""
Local nTamCt 	:= TamSx3("CN9_NUMERO")[1]
Local nTamRv 	:= TamSx3("CN9_REVISA")[1]
Local nTamMd	:= TamSx3("CND_NUMMED")[1]

If cTipo == "SC"
 	SC1->(DbSetOrder(1))
 	If SC1->(DbSeek(xFilial("SC1")+Padr(cNum,TamSx3("C1_NUM")[1]))) .And. !Empty(SC1->C1_USER)
		cRet := SC1->C1_USER
	Endif
Elseif cTipo $ "IP|PC"
	SC7->(DbSetOrder(1))
 	If SC7->(DbSeek(xFilial("SC7")+Padr(cNum,TamSx3("C7_NUM")[1]))) .And. !Empty(SC7->C7_USER)
		cRet := SC7->C7_USER
	Endif
Elseif cTipo $ "CT|IC"
	CN9->(DbSetOrder(1))
	If CN9->(DbSeek(xFilial("CN9")+Padr(cNum,nTamCt)))
		If CN9->(FieldPos('CN9_USERGA')) > 0
			cRet := RetCodUsr(FWLeUserlg("CN9_USERGA"))
		ElseIf CN9->(FieldPos('CN9_USERGI')) > 0
			cRet := RetCodUsr(FWLeUserlg("CN9_USERGI"))
		ElseIf !Empty(CN9->CN9_LOGUSR)
			cRet := CN9->CN9_LOGUSR
		EndIf
	EndIf

Elseif cTipo $ "RV|IR"
	CN9->(DbSetOrder(1))
	If CN9->(DbSeek(xFilial("CN9")+Padr(cNum,nTamCt)+Substr(cNum,nTamCt+1,nTamRv)))
		If CN9->(FieldPos('CN9_USERGA')) > 0
			cRet := RetCodUsr(FWLeUserlg("CN9_USERGA"))
		ElseIf CN9->(FieldPos('CN9_USERGI')) > 0
			cRet := RetCodUsr(FWLeUserlg("CN9_USERGI"))
		ElseIf !Empty(CN9->CN9_LOGUSR)
			cRet := CN9->CN9_LOGUSR
		EndIf
	EndIf

Elseif cTipo $ "MD|IM"
	CND->(DbSetOrder(4))
	If CND->(DbSeek(xFilial("CND")+Padr(cNum,nTamMd)))
		If (GetRemoteType() == -1)
			If CND->(FieldPos('CND_USERGI')) > 0
				cRet := RetCodUsr(FWLeUserlg("CND_USERGI"))
			EndIf
		Else
			If CND->(FieldPos('CND_USERGA')) > 0
				cRet := RetCodUsr(FWLeUserlg("CND_USERGA"))
			ElseIf CND->(FieldPos('CND_USERGI')) > 0
				cRet := RetCodUsr(FWLeUserlg("CND_USERGI"))
			EndIf
		EndIf
	Else
		CN9->(DbSetOrder(1))
		If CN9->(DbSeek(xFilial("CN9")+CND->CND_CONTRA+CND->CND_REVISA))
			If CN9->(FieldPos('CN9_USERGA')) > 0
				cRet := RetCodUsr(FWLeUserlg("CN9_USERGA"))
			ElseIf CN9->(FieldPos('CN9_USERGI')) > 0
				cRet := RetCodUsr(FWLeUserlg("CN9_USERGI"))
			ElseIf !Empty(CN9->CN9_LOGUSR)
				cRet := CN9->CN9_LOGUSR
			EndIf
		EndIf
	EndIf

ElseIf cTipo $ "SA"
	SCP->(DbSetOrder(1))
	If SCP->(DbSeek(xFilial("SCP")+Padr(cNum,TamSx3("CP_NUM")[1]))) .And. !Empty(SCP->CP_USER)
		cRet := SCP->CP_USER
	Endif
ElseIf cTipo == "ST"
 	NNS->(DbSetOrder(1))
 	If NNS->(DbSeek(xFilial("NNS")+Padr(cNum,TamSx3("NNS_COD")[1]))) .And. !Empty(NNS->NNS_SOLICT)
		PswOrder(2)
		If PswSeek(NNS->NNS_SOLICT)
			cRet := PswRet(1)[1][1]
		Endif
	Endif
Endif

If Empty(cRet)
	cRet := A097UsuApr(SCR->CR_APROV)
Endif

Return cRet


//--------------------------------------------------------------------
/*/{Protheus.doc} MtVerTipcom()
Retorna se o campo CR_TIPCOM está preenchido ( tratamento registros incluidos antes de 01/02/2023)
@author Leandro Nishihata
@Param cNum:	Numero do documento
@Param cTipo:	ALIAS ( SC ou IP)
@since 30/01/2023
@version 1.0
@return lRet
/*/
//--------------------------------------------------------------------
Static Function MtVerTipcom(cNum,cTipo)

Local lRet			:= .F.
Local cQuery   		:= ""
Local cAliasTmp		:= ""
Local lPosCrTipo    := SCR->(FieldPos("CR_TIPCOM")) > 0

IF lPosCrTipo
	cAliasTmp		:= GetNextAlias()

	cQuery := " SELECT count(CR_TIPCOM) QTD "
	cQuery += " FROM "+RetSqlName("SCR")+" SCR" 
	cQuery += "		WHERE  "
	cQuery += "			SCR.CR_FILIAL= '"+xFilial("SCR")+"' AND " 
	cQuery += "			SCR.CR_NUM = '"+cNum+"' AND "
	cQuery += "			SCR.CR_TIPO = '"+cTipo+"' AND "
	cQuery += "			SCR.CR_TIPCOM <> ' ' "

	cQuery := ChangeQuery(cQuery)
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasTmp)

	lRet := (cAliasTmp)->(QTD) > 0
	(cAliasTmp)->(DbCloseArea())
Endif

Return lRet

/*/{Protheus.doc} IsGctDoc
	Verifica se determinado documento é do Gestão de Contratos
@author philipe.pompeu
@since 15/12/2023
@param cTpDoc, caractere, tipo do documento
@return lRet, lógico, se é um documento oriundo do GCT
/*/
Static Function IsGctDoc(cTpDoc)
	Local lRet := .F.

	lRet := (cTpDoc $ "RV|IR|CT|IC|MD|IM")
	
Return lRet

/*/{Protheus.doc} SeekQtdDBM
Busca a quantidade em aberto nos itens do pedido de compra amarrados a um determinado grupo de aprovação.
@type function
@version 12.1.2310
@author tp.ciro.pedreira
@since 09/04/2024
@param cTipo, character, tipo do registro na tabela SCR
@param cNum, character, número do pedido do registro na tabela SCR
@param cGrupo, character, código do grupo do registro na tabela SCR
@param cItGrp, character, item do grupo do registro na tabela SCR
@return logical, .T. = itens totalmente atendidos; .F. = itens com quantidade em aberto
/*/
Static Function SeekQtdDBM(cTipo, cNum, cGrupo, cItGrp)

	Local cQuery    := ""
	Local cAliasSql := GetNextAlias()
	Local oQry		:= Nil
	Local lRet      := .F.

	cQuery += "SELECT SUM(SC7.C7_QUANT - SC7.C7_QUJE - SC7.C7_QTDACLA) C7_QUANT "
	cQuery += "FROM ? DBM "
	cQuery += "INNER JOIN ? SC7 ON "
	cQuery += "SC7.D_E_L_E_T_ = ? "
	cQuery += "AND SC7.C7_FILIAL = ? "
	cQuery += "AND SC7.C7_NUM = DBM.DBM_NUM "
	cQuery += "AND SC7.C7_ITEM = DBM.DBM_ITEM "
	cQuery += "WHERE DBM.D_E_L_E_T_ = ? "
	cQuery += "AND DBM.DBM_FILIAL = ? "
	cQuery += "AND DBM.DBM_TIPO = ? "
	cQuery += "AND DBM.DBM_NUM = ? "
	cQuery += "AND DBM.DBM_GRUPO = ? "
	cQuery += "AND DBM.DBM_ITGRP = ? "
	cQuery += "GROUP BY C7_QUANT "

	cQuery := ChangeQuery(cQuery)

	oQry := FWPreparedStatement():New(cQuery)
	
	oQry:SetNumeric(1, RetSqlName("DBM"))
	oQry:SetNumeric(2, RetSqlName("SC7"))
	oQry:SetString(3, ' ')
	oQry:SetString(4, FWxFilial("SC7"))
	oQry:SetString(5, ' ')
	oQry:SetString(6, FWxFilial("DBM"))
	oQry:SetString(7, cTipo)
	oQry:SetString(8, cNum)
	oQry:SetString(9, cGrupo)
	oQry:SetString(10, cItGrp)

	cAliasSql := MPSYSOpenQuery(oQry:GetFixQuery(), cAliasSql)

	If (cAliasSql)->(!EOF())
		
		lRet := ((cAliasSql)->C7_QUANT == 0)

	EndIf

	(cAliasSql)->(DBCloseArea())

Return lRet

/*/{Protheus.doc} MaSetWizard
	Define se é a execução é via Wizard - Grupo de Aprovação (COMA240)
@type function
@author juan.felipe
@since 28/10/2024
@param lWizard, logical, chamada via wizard.
@return Nil, nulo.
/*/
Function MaSetWizard(lWizard)
	_lWizard := lWizard
	_oJsonWizard['items'] := {}
Return Nil

/*/{Protheus.doc} MaGetFlowTest
	Obtém Json do fluxo de teste do Wizard - Grupo de Aprovação (COMA240)
@type function
@author juan.felipe
@since 28/10/2024
@return _oJsonWizard, object, json com o fluxo de aprovação.
/*/
Function MaGetFlowTest()
Return _oJsonWizard
