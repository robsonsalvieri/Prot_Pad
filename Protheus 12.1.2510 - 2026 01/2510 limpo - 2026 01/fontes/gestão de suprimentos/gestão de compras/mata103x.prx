#INCLUDE "MATA103X.CH" 
#INCLUDE "PROTHEUS.CH"
#INCLUDE "FWMVCDEF.CH"
#INCLUDE "FWADAPTEREAI.CH" 
#Include "FWLIBVERSION.CH"
#DEFINE VALMERC  01	// Valor total do mercadoria
#DEFINE VALDESC  02	// Valor total do desconto
#DEFINE TOTPED	 03	// Total do Pedido
#DEFINE FRETE    04	// Valor total do Frete
#DEFINE VALDESP  05	// Valor total da despesa
#DEFINE TOTF1	 06	// Total de Despesas Folder 1               
#DEFINE SEGURO	 07	// Valor total do seguro
#DEFINE TOTF3	 08	// Total utilizado no Folder 3	
#DEFINE VNAGREG	 09	// Valor total nao agregado ao total do documento
#DEFINE VALEMB   10 // Valor total da embalagem
#DEFINE _CRLF	Chr(13) + Chr(10)     

Static lIndCteCol
Static lLGPD  		:= FindFunction("SuprLGPD") .And. SuprLGPD()
Static __lVLib      := FWLibVersion() >= "20211116"
Static aBkpDHR    := {}
Static _oPosCpoHdr	:= Nil 
Static _aCTBEnt		:= Nil
Static __lIssMR		:= .F.

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³ MATA103X ³ Autor ³ Eduardo Riera         ³ Data ³ 17.09.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³ Funcoes de validacao e controle de interface do documento de ³±±
±±³          ³ de entrada                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeCabDoc ³Autor  ³ Eduardo Riera         ³ Data ³12.09.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de tratamento do cabecalho do documento de entrada    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpO1: Objeto da Janela que sera disponibilizado os Get      ³±±
±±³          ³ExpA2: Array com as posicoes dos gets do documento de entrada³±±
±±³          ³Expb3: Codeblock para atualizacao dos dados do documento     ³±±
±±³          ³ExpL4: Informa se o cabecalho pode ser alterado              ³±±
±±³          ³ExpL5: Indica se eh uma uma pre-nota                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo exibir/controlar o folder finan³±±
±±³          ³ceiro.                                                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
 
Function NfeCabDoc(oDlg,aPosGet,bRefresh,lVisual,lFiscal,cUfOrig,lClassif,lPreNota,nCombo,oCombo,cCodRet,oCodRet,lNfMedic,aCodR,cRecIss,cNatureza,l140Altera,aNFEletr,aNfeDanfe,aInfAdic)
Local aObjetos   := Array(12)
Local lTpCompl   := SF1->(ColumnPos("F1_TPCOMPL")) > 0 .And. Type("cTpCompl") == "C"
Local lfndVldCpo := FindFunction("COMXVLDCPO")
Local lSubSerie  := cPaisLoc == "BRA" .And. SF1->(ColumnPos("F1_SUBSERI")) > 0 .And. SuperGetMv("MV_SUBSERI",.F.,.F.) .and. lfndVldCpo .and. Empty(COMXVLDCPO({"F1_SUBSERI"},2))
Local aCombo1    := {STR0001,;	//"Normal"
						STR0002,;	//"Devolucao"
						STR0003,;	//"Beneficiamento"
						STR0004,;	//"Compl.  ICMS"
						STR0005,;	//"Compl.  IPI"
						If(lTpCompl,STR0159,STR0006)} 	//"Compl. Preco/Frete"

Local aCombo2    := {STR0007,STR0008} //"Nao"###"Sim"
Local aCombo3    := {"",STR0160,STR0161,STR0162}
Local aCombo2Lan := {STR0007,STR0008,STR0008} // Nao retirar, abrange language=English
Local aAuxCombo1 := {"N","D","B","I","P","C"}
Local aAuxCombo2 := {"N","S","Y"}
Local aAuxCombo3 := {"","1","2","3"}

Local c103SayForn:= IIf(cTipo$"DB" .OR. A103RtCliRT(cTipo, iif(lTpCompl, cTpCompl, ""), cFormul), RetTitle("F2_CLIENTE"), RetTitle("F1_FORNECE"))
Local c103Tipo	 := ""
Local c103TpComp := ""
Local c103Form	 := cFormul
Local cCar       := CHR(34)+CHR(39)        // Caracteres que não serão permitidos na digitação do campo: Nota e Série
Local nAux       := aScan(aAuxCombo1,cTipo)
Local lGspInUseM := If(Type('lGspInUse')=='L', lGspInUse, .F.)
Local nTamGetFor := 45          
Local nScreen    := GetScreenRes()[1]
Local nEspLoja   := 0 
Local nAltNFE    := 0

Local lUfOrig    := ( ValType( cUfOrig ) == "C" )
Local lMt103CPS  := Existblock("MT103CPS")
Local oNfMedic   := .F. 
Local lUsaNewKey := TamSX3("F1_SERIE")[1] == 14 // Verifica se o novo formato de gravacao do Id nos campos _SERIE esta em uso

Local lIntGfe 		:= SuperGetMV("MV_INTGFE",.F.,.F.)
Local oUfOrig 		:= NIL
Local lNCTDES		:= SuperGetMV("MV_NCTDES",.F.,.F.)
Local lNotCTeDesp	:= .T.
Local l103GCDisp	:= A103GCDisp()
Local bWhenBkpDoc	:= Nil
Local lCteSub		:= .F.
Local aTpNCND		:= {}
Local lDocRef       := iif(FindFunction("A103ChkDKNAmb"),A103ChkDKNAmb(),.F.)

//Adiciona as opções de Debito/Credito no combo
If lDocRef 
	aadd(aCombo1,STR0274) //"Credito"
	aadd(aCombo1,STR0275) //"Debito"
	aadd(aAuxCombo1,"5")
	aadd(aAuxCombo1,"6")
endif

If lNCTDES
	lNotCTeDesp	:= !FwIsInCallStack("MATA116") .And. !FwIsInCallStack("MATA119") 
Endif

lClassif:= If( ValType( lClassif ) == "L" , lClassif, .F.) 

cFormul := If( ValType( cFormul ) <> "C" .Or. Empty(cFormul) , "N", cFormul ) 

DEFAULT lPreNota 	:= .F.
DEFAULT l140Altera	:= .F.
Default aCodR	 	:= {}
Default cRecIss	 	:= "1"
Default cNatureza	:= ""
Default aNFEletr    := {}
Default aNfeDanfe   := {}
Default aInfAdic    := {}

Private lChangeNat 	:= .F.

If Type("l103CteSub") == 'L' .And. l103CteSub
	lCteSub := .T. 
Endif

bWhenBkpDoc	:= {|| !lVisual .And. lNotCTeDesp .And. VisualSX3("F1_DOC") .And. cFormul<>"S" .And. A103ChWhen("F1_DOC",cNFiscal,lClassif) .And. !lCteSub} 

If lPreNota
	nEspLoja   := Iif(nScreen<1280 .And. !lVisual, 5,-3)
Else
	nEspLoja   := Iif(nScreen<1280 .And. !lVisual, 5,1)
EndIF					
nAltNFE    := Iif(lPreNota .And. ALTERA  ,15 ,0)   

if lDocRef // Se existir credito e debito
	aCombo1    := IIF(lPreNota,{STR0001,STR0002,STR0003,If(lTpCompl,STR0159,STR0006),STR0274,STR0275},{STR0001,STR0002,STR0003,STR0004,STR0005,If(lTpCompl,STR0159,STR0006),STR0274,STR0275}) //STR0001>"Normal" STR0002>"Devolucao" STR0003>"Beneficiamento" STR0004>"Compl.  ICMS" STR0005>"Compl.  IPI" STR0006>"Compl. Preco/Frete" STR0274> Credito STR0275 > Debito
	aAuxCombo1 := IIF(lPreNota,{"N","D","B","C","5","6"},{"N","D","B","I","P","C","5","6"})
else 
	aCombo1    := IIF(lPreNota,{STR0001,STR0002,STR0003,If(lTpCompl,STR0159,STR0006)},{STR0001,STR0002,STR0003,STR0004,STR0005,If(lTpCompl,STR0159,STR0006)}) //STR0001>"Normal" STR0002>"Devolucao" STR0003>"Beneficiamento" STR0004>"Compl.  ICMS" STR0005>"Compl.  IPI" STR0006>"Compl. Preco/Frete"
	aAuxCombo1 := IIF(lPreNota,{"N","D","B","C"},{"N","D","B","I","P","C"})
endif

nAux       := aScan(aAuxCombo1,cTipo)

if cTipo == '5' //-- Nota de Crédito
	aTpNCND 	:= retTpNCND("NC")
	aCombo3 	:= aClone(aTpNCND[1])
	aAuxCombo3  := aClone(aTpNCND[2])
Elseif cTipo == "6" // -- Nota de Débito
	aTpNCND 	:= retTpNCND("ND")
	aCombo3 	:= aClone(aTpNCND[1])
	aAuxCombo3  := aClone(aTpNCND[2])
endif

If !Empty(cTipo) .And. nAux <> 0
	c103Tipo := aCombo1[nAux]
EndIf
nAux := aScan(aAuxCombo2,cFormul)
If !Empty(cFormul) .And. nAux <> 0
	c103Form := aCombo2Lan[nAux]
EndIf

If lTpCompl
	nAux := aScan(aAuxCombo3,cTpCompl)
	If !Empty(cTpCompl) .And. nAux <> 0
		c103TpComp := aCombo3[nAux]
	EndIf
EndIf

If !lNfMedic
	If TamSX3("A2_COD")[1]< 9 
		nTamGetFor:=(6*TamSX3("A2_COD")[1])
	ElseIf TamSX3("A2_COD")[1]< 15
		nTamGetFor:=(4.8*TamSX3("A2_COD")[1])
	Else
		nTamGetFor:=(4*TamSX3("A2_COD")[1])
	EndIf
EndIf
@ aPosGet[3,1],aPosGet[3,2] TO aPosGet[3,3],aPosGet[3,4] LABEL "" OF oDlg PIXEL

@ aPosGet[3,1]+(2,6),aPosGet[1,1] SAY RetTitle("F1_TIPO") OF oDlg PIXEL SIZE 35,09 
@ aPosGet[3,1]+(2,5),aPosGet[1,2] MSCOMBOBOX aObjetos[1] VAR c103Tipo ITEMS aCombo1 SIZE 60,100; 
	WHEN !lVisual .And. !IsInCallStack("MATA116") .And. !IsInCallStack("MATA119") .And. A103ChWhen("F1_TIPO",c103Tipo,lClassif) .And. !lCteSub ;
	VALID NfeCombo(@cTipo,aCombo1,c103Tipo,aAuxCombo1,"1").And.NfeTipo(cTipo,@cA100For,@cLoja,aObjetos[6],aObjetos[7],aObjetos[8],oDlg,cTpCompl,aObjetos[11],@aCombo3,@aAuxCombo3,cFormul);
	OF oDlg PIXEL

If lTpCompl
	aObjetos[1]:bChange := {||A103TpComp(@aObjetos,c103Tipo,@c103TpComp)}
	
	@ aPosGet[3,1]+(2,6),aPosGet[1,3] SAY RetTitle("F1_TPCOMPL") Of oDlg PIXEL SIZE 52,09
	@ aPosGet[3,1]+(2,5),aPosGet[1,4] MSCOMBOBOX aObjetos[11] VAR c103TpComp ITEMS aCombo3 SIZE 50,100 ;
		WHEN !lVisual .And. !IsInCallStack("MATA116") .And. !IsInCallStack("MATA119") .And. c103Tipo $ "Complemento|Credito|Debito" .And.!lCteSub ;
		VALID NfeCombo(@cTpCompl,aCombo3,c103TpComp,aAuxCombo3,"3") .And. NfeTipo(cTipo,@cA100For,@cLoja,aObjetos[6],aObjetos[7],aObjetos[8],,cTpCompl,,,,cFormul);
		OF oDlg PIXEL

	If !lGspInUseM
		@ aPosGet[3,1]+(2,6),aPosGet[1,5] SAY RetTitle("F1_FORMUL") Of oDlg PIXEL SIZE 52,09
		@ aPosGet[3,1]+(2,5),aPosGet[1,6] MSCOMBOBOX aObjetos[2] VAR c103Form ITEMS aCombo2 SIZE 30,50 ;
			WHEN !lVisual .And. lNotCTeDesp .And. A103ChWhen("F1_FORMUL",c103Form,lClassif) .And. !lCteSub ; 
			VALID NfeCombo(@cFormul,aCombo2Lan,c103Form,aAuxCombo2,"2") .And. NfeFormul(cFormul,@cNFiscal,@cSerie,aObjetos[3],@aObjetos[4], aObjetos[6],aObjetos[7],aObjetos[8],oDlg) ;
			OF oDlg PIXEL
	EndIf
ElseIf !lGspInUseM
	@ aPosGet[3,1]+(2,6),aPosGet[1,3] SAY RetTitle("F1_FORMUL") Of oDlg PIXEL SIZE 52,09
	@ aPosGet[3,1]+(2,5),aPosGet[1,4] MSCOMBOBOX aObjetos[2] VAR c103Form ITEMS aCombo2 SIZE 30,50 ;
		WHEN !lVisual .And. A103ChWhen("F1_FORMUL",c103Form,lClassif) ;
		VALID NfeCombo(@cFormul,aCombo2Lan,c103Form,aAuxCombo2,"2").And.NfeFormul(cFormul,@cNFiscal,@cSerie,aObjetos[3],@aObjetos[4]) ;
		OF oDlg PIXEL                            
Endif

@ aPosGet[3,1]+(2,6),aPosGet[1,7] SAY RetTitle("F1_DOC") Of oDlg PIXEL SIZE 45,09
@ aPosGet[3,1]+(2,5),aPosGet[1,8] MSGET aObjetos[3] VAR cNFiscal PICTURE PesqPict("SF1","F1_DOC") ;
	WHEN !lVisual .And. lNotCTeDesp .And. VisualSX3("F1_DOC") .And. cFormul<>"S" .And. A103ChWhen("F1_DOC",cNFiscal,lClassif) .And. !lCteSub ;
	VALID NfeFornece(cTipo,@cA100For,@cLoja,,@nCombo,@oCombo,@cCodRet,@oCodRet,@aCodR,@cRecIss,@cNatureza,aObjetos[3]).And.CheckSX3("F1_DOC") .And. !A103VldCpo(cNfiscal,cCar);
	OF oDlg PIXEL SIZE 46,09 

@ aPosGet[3,1]+(2,6),aPosGet[1,9] SAY RetTitle("F1_SERIE") Of oDlg PIXEL SIZE 23,09
@ aPosGet[3,1]+(2,5),aPosGet[1,10] MSGET aObjetos[4] VAR cSerie  PICTURE PesqPict("SF1","F1_SERIE") ;
    F3 IIF( lMT103CPS,ExecBlock("MT103CPS",.F.,.F.),"");
    WHEN !lVisual .And. lNotCTeDesp .And. VisualSX3('F1_SERIE').And. cFormul<>"S" .And. A103ChWhen("F1_SERIE",cSerie,lClassif) .And. !lCteSub ;
	VALID NfeFornece(cTipo,@cA100For,@cLoja,,@nCombo,@oCombo,@cCodRet,@oCodRet,@aCodR,@cRecIss,@cNatureza,aObjetos[3]).And.CheckSX3("F1_SERIE") .And. !A103VldCpo(cSerie,cCar);
	OF oDlg PIXEL SIZE 18,09

If lSubSerie
	@ aPosGet[3,1]+(2,6),aPosGet[1,11] SAY RetTitle("F1_SUBSERI") Of oDlg PIXEL SIZE 23,09
	@ aPosGet[3,1]+(2,5),aPosGet[1,12] MSGET aObjetos[12] VAR cSubSerie PICTURE PesqPict("SF1","F1_SUBSERI") ;
		WHEN !lVisual .And. lNotCTeDesp .And. VisualSX3('F1_SUBSERI').And. cFormul<>"S" .And. A103ChWhen("F1_SUBSERI",cSubSerie,lClassif);
		VALID NfeFornece(cTipo,@cA100For,@cLoja,,@nCombo,@oCombo,@cCodRet,@oCodRet,@aCodR,@cRecIss,@cNatureza,aObjetos[3]).And.CheckSX3("F1_SUBSERI") .And. !A103VldCpo(cSubSerie,cCar);
		OF oDlg PIXEL SIZE 18,09
EndIf

If cPaisLoc == "PTG"
	@ aPosGet[3,1]+(2,6),aPosGet[1,9] SAY RetTitle("F1_DIACTB") Of oDlg PIXEL SIZE 30,09
	@ aPosGet[3,1]+(2,5),aPosGet[1,10] MSGET aObjetos[10] VAR cCodDiario PICTURE PesqPict("SF1","F1_DIACTB") WHEN !lVisual .And. VisualSX3("F1_DIACTB") F3 CpoRetF3("F1_DIACTB") ;
	    VALID CheckSX3("F1_DIACTB") OF oDlg PIXEL SIZE 30,09 HASBUTTON
EndIf
@ aPosGet[3,1]+25,aPosGet[2,1] SAY RetTitle("F1_EMISSAO") OF oDlg PIXEL SIZE 35,09
@ aPosGet[3,1]+24,aPosGet[2,2] MSGET aObjetos[5] VAR dDEmissao PICTURE PesqPict("SF1","F1_EMISSAO") ;
	WHEN (!lVisual .or. lClassif).And.VisualSX3("F1_EMISSAO") .And. A103ChWhen("F1_EMISSAO",dDEmissao,lClassif) .And. !lCteSub  Valid CheckSX3("F1_EMISSAO") .And. NfeEmissao(dDEmissao) ;
	OF oDlg PIXEL SIZE 45 ,9 HASBUTTON

If Valtype( lNfMedic ) == "L" .And. !lVisual .And. l103GCDisp // Indica se exibe CheckBox de carga das medicoes de contratos
	@ aPosGet[3,1]+25,aPosGet[2,3]-15 SAY aObjetos[6] VAR c103SayForn Of oDlg PIXEL SIZE 43,09
	@ aPosGet[3,1]+24,aPosGet[2,4]-35 MSGET aObjetos[7] VAR cA100For  ;
		PICTURE PesqPict("SF1","F1_FORNECE") F3 CpoRetF3("F1_FORNECE");
		WHEN !lVisual .And. lNotCTeDesp .And. VisualSX3("F1_FORNECE") .And. A103ChWhen("F1_FORNECE",cA100For,lClassif) .And. !lCteSub  ;
		VALID NfeFornece(cTipo,@cA100For,@cLoja,@cUfOrig,@nCombo,@oCombo,@cCodRet,@oCodRet,@aCodR,@cRecIss,@cNatureza,aObjetos[3],,aNFEletr,aNfeDanfe,aInfAdic).And.CheckSX3("F1_FORNECE",cA100For).And.NfeVldRef("NF_CODCLIFOR",cA100For) ;
		OF oDlg PIXEL SIZE nTamGetFor,09 HASBUTTON
Else
	@ aPosGet[3,1]+25,aPosGet[2,3]-10 SAY aObjetos[6] VAR c103SayForn Of oDlg PIXEL SIZE 43,09
	@ aPosGet[3,1]+24,aPosGet[2,4]-nAltNFE MSGET aObjetos[7] VAR cA100For  ;
		PICTURE PesqPict("SF1","F1_FORNECE") F3 CpoRetF3("F1_FORNECE");
		WHEN !lVisual .And. lNotCTeDesp .And. VisualSX3("F1_FORNECE").And. A103ChWhen("F1_FORNECE",cA100For,lClassif)  .And. !lCteSub ;
		VALID NfeFornece(cTipo,@cA100For,@cLoja,@cUfOrig,@nCombo,@oCombo,@cCodRet,@oCodRet,@aCodR,@cRecIss,@cNatureza,aObjetos[3],,aNFEletr,aNfeDanfe,aInfAdic).And.CheckSX3("F1_FORNECE",cA100For).And.NfeVldRef("NF_CODCLIFOR",cA100For) ;
		OF oDlg PIXEL SIZE nTamGetFor,09 HASBUTTON 
		
		If IsInCallStack("MATA119")  
			NfeFornece(cTipo,@cA100For,@cLoja,@cUfOrig,@nCombo,@oCombo,@cCodRet,@oCodRet,@aCodR,@cRecIss,@cNatureza,aObjetos[3],,aNFEletr,aNfeDanfe,aInfAdic)
	    EndIf
EndIf
@ aPosGet[3,1]+24,aPosGet[2,5]+nEspLoja MSGET aObjetos[8] VAR cLoja ;
	PICTURE PesqPict("SF1","F1_LOJA") ;
	F3 CpoRetF3("F1_LOJA") ;
	WHEN !lVisual .And. lNotCTeDesp .And. VisualSX3("F1_LOJA") .And. A103ChWhen("F1_LOJA",cLoja,lClassif) .And. !lCteSub ;
	VALID NfeFornece(cTipo,@cA100For,@cLoja,@cUfOrig,@nCombo,@oCombo,@cCodRet,@oCodRet,@aCodR,@cRecIss,@cNatureza,aObjetos[3],,aNFEletr,aNfeDanfe,aInfAdic).And.CheckSX3("F1_LOJA",cLoja).And.NfeVldRef("NF_LOJA",cLoja) ;	
	OF oDlg PIXEL SIZE 15,09 HASBUTTON

If !lGspInUseM
	
	@ aPosGet[3,1]+25,aPosGet[2,6]+nAltNFE SAY RetTitle("F1_ESPECIE") Of oDlg PIXEL SIZE 63,09
	@ aPosGet[3,1]+24,aPosGet[2,7]+nAltNFE MSGET aObjetos[9] VAR cEspecie ;
		PICTURE PesqPict("SF1","F1_ESPECIE") ;
		F3 CpoRetF3("F1_ESPECIE");
		WHEN (lClassif.Or.!lVisual).And.VisualSX3("F1_ESPECIE").And. A103ChWhen("F1_ESPECIE",cEspecie,lClassif) .And. !lCteSub ;
		VALID CheckSX3("F1_ESPECIE",cEspecie) .And. Iif(lIntGfe,A103VldEsp(cEspecie),.T.)	.And. ;
        IIf( lUsaNewKey , NfeFornece(cTipo,@cA100For,@cLoja,@cUfOrig,@nCombo,@oCombo,@cCodRet,@oCodRet,@aCodR,@cRecIss,@cNatureza,aObjetos[3]) , .T.) .And. A103VSpec() .And. A103SNFSTra(@aObjetos,bWhenBkpDoc,lClassif);
		OF oDlg PIXEL SIZE 30,09 HASBUTTON

	If lUfOrig
		@ aPosGet[3,1]+25,aPosGet[2,8]+nAltNFE SAY OemToAnsi(STR0028) Of oDlg PIXEL SIZE 63 ,9 // UF.Origem
		@ aPosGet[3,1]+24,aPosGet[2,9]+nAltNFE MSGET oUfOrig VAR cUfOrig PICTURE "@!" F3 "12" ;
			When !lVisual .And.VisualSX3('F1_EST') .And. A103ChWhen("F1_EST",cUfOrig,lClassif) .And. !IsInCallStack("MATA116") .And. !lCteSub Valid CheckSX3('F1_EST',cUfOrig) .And. ;
			MaFisAlt( "NF_UFORIGEM", cUfOrig ) .And. IIF(ExistBlock("M103NFEL") .And. !lPreNota,A103NfElet("F1_EST",cUfOrig,aNFEletr,aNfeDanfe,aInfAdic),.T.) .And. Eval( bGdRefresh ) OF oDlg PIXEL SIZE 20,9 HASBUTTON
		If(lLGPD,OfuscaLGPD(oUfOrig,"F1_EST"),.F.) 
	EndIf 

Endif        
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Indica se exibe CheckBox de carga das medicoes de contratos         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Valtype( lNfMedic ) == "L" .And. (!lVisual .Or. l140Altera) .And. l103GCDisp   
	@ aPosGet[3,1]+25,aPosGet[2,10] SAY STR0053 Of oDlg PIXEL SIZE 40,09 // "Filtra Medicao"
	@ aPosGet[3,1]+24,aPosGet[2,10] + 44 CHECKBOX oNfMedic VAR lNfMedic PROMPT "" SIZE 008,010 ON CLICK( oNfMedic:Refresh() ) OF oDlg PIXEL
EndIf                                                                                       	

bRefresh := {|| NfeCabOk(lVisual,aObjetos[1],aObjetos[3],aObjetos[5],aObjetos[7],aObjetos[8],lFiscal,cUfOrig,,,aObjetos[9],.T.,aObjetos[11],c103TpComp,aObjetos[2])}

aObjetos[1]:SetFocus()

//Salva o cTipo
If Empty(cTipo) 
	NfeCombo(@cTipo,aCombo1,c103Tipo,aAuxCombo1,"1")
Endif  

Return(.T.)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeCabOk  ³Autor  ³ Eduardo Riera         ³ Data ³17.09.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de validacao dos dados do cabecalho do documento de   ³±±
±±³          ³entrada                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpL1: Indica se eh uma operacao de visualizacao             ³±±
±±³          ³ExpO2: Objeto get do tipo do documento de entrada            ³±±
±±³          ³ExpO3: Objeto get do numero do documento de entrada          ³±±
±±³          ³ExpO4: Objeto get da data de emissao do documento de entrada ³±±
±±³          ³ExpO5: Objeto get do codigo do fornecedor do documento       ³±±
±±³          ³ExpO6: Objeto get da loja do fornecedor do documento         ³±±
±±³          ³ExpC7: Unidade federativa de origem                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo exibir/controlar o folder finan³±±
±±³          ³ceiro.                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeCabOk(lVisual,oTipo,oNota,oEmissao,oFornece,oLoja,lFiscal,cUfOrig,cCodMunISS,cUfPresISS,oEspecie,lVldEspec,oTpCompl,cTipCom,oFormul)
Local lRetorno 	:= .T.
Local bIPRefresh:= {|| MaFisToCols(aHeader,aCols,,"MT100"),Eval(bRefresh),Eval(bGdRefresh)}	// Carrega os valores da Funcao fiscal e executa o Refresh
Local lEspObg	:= SuperGetMV("MV_ESPOBG",.F.,.F.)
Local lTpCompl	:= SF1->(ColumnPos("F1_TPCOMPL")) > 0 .And. Type("cTpCompl") == "C" .And. !Empty(MaFisScan("NF_TPCOMPL",.F.)) 
Local lTrbGen   := IIf(FindFunction("ChkTrbGen"),ChkTrbGen("SD1", "D1_IDTRIB"),.F.) // Verificacao se pode ou nao utilizar tributos genericos
Local lMt116    := FwIsInCallStack("A116INCLUI")

DEFAULT lFiscal := .T.
DEFAULT lVldEspec	:= .F.
DEFAULT cUfOrig := ""
DEFAULT cCodMunISS := ""
DEFAULT cUfPresISS := ""
DEFAULT oEspecie	:= NIL

If !lVisual
	Do Case
		Case Empty(cTipo)
			If oTipo<>Nil
				oTipo:SetFocus()
				lRetorno := .F.
			EndIf
		Case lTpCompl .And. cTipo $ "C56" .And. Empty(cTpCompl)
			If oTpCompl<>Nil
				oTpCompl:SetFocus()
				lRetorno := .F.
			EndIf
		Case Empty(cNFiscal) .And. cFormul <> "S"
			If oNota<>Nil
				oNota:SetFocus()
				lRetorno := .F.
			EndIf
		Case Empty(dDEmissao)
			If oEmissao<>Nil
				oEmissao:SetFocus()
				lRetorno := .F.
			EndIf
		Case Empty(cA100For)
			If oFornece<>Nil
				oFornece:SetFocus()
				lRetorno := .F.
			EndIf
		Case Empty(cLoja)
			If oLoja<>Nil
				oLoja:SetFocus()
				lRetorno := .F.
			EndIf
		Case Empty(cEspecie) .And. lEspObg .And. lVldEspec .And. (AllTrim(FunName())<>"MATA140")
			If oEspecie<>Nil 
				oEspecie:SetFocus()
				lRetorno := .F.
			EndIf
		Case (cTipo == "6" .And. cFormul == "S")
			If oFormul<>Nil 
				oFormul:SetFocus()
				lRetorno := .F.
			EndIf
	EndCase
Endif

If lRetorno .And. lFiscal
	If !MaFisFound("NF")
        MaFisIni(cA100For,cLoja,IIf((cTipo$'DB' .Or. A103RtCliRT(cTipo, cTpCompl, cFormul)), "C", "F"),cTipo,Nil,MaFisRelImp("MT100",{"SF1","SD1"}),,!lVisual,NIL,NIL,NIL,,,,,,,,,,,,,,dDEmissao,,,,,,,,lTrbGen)
        If !Empty(cUfOrig)
            MaFisAlt("NF_UFORIGEM",cUfOrig)
		Endif   
        If !Empty(cCodmunISS)
            MaFisAlt("NF_CODMUN",cCodMunISS)
		EndIf

        If !Empty(cUfPresISS)
            MaFisAlt("NF_UFPREISS",cUfPresISS)
		EndIf
	Else
        If (!Empty(cUfOrig) .And. !lMt116)
            MaFisAlt("NF_UFORIGEM",cUfOrig)
		Endif 
		If lMt116
			If cUfOrig <> cUfOri .And. Empty(aInfAdic[10])
				cUfOrig := cUfOri
				MaFisAlt("NF_UFORIGEM",cUfOrig)
			ElseIf !Empty(aInfAdic[10]) .And. aInfAdic[10] <> cUfOrig .And. MaFisRet( ,"NF_UFORIGEM") <> aInfAdic[10] 
				cUfOrig := aInfAdic[10]
				MaFisAlt("NF_UFORIGEM",cUfOrig)
			EndIf	
		EndIf
		If !Empty(cNFiscal) .And. !Empty(MaFisScan("NF_DOC",.F.)) // Verifica se a MATXFIS possui a referentcia NF_DOC
			MaFisAlt("NF_DOC",cNFiscal)
		Endif
		If !Empty(MaFisScan("NF_DTEMISS",.F.))	// Verifica se a MATXFIS possui a referentcia NF_DTEMISS
			MaFisAlt("NF_DTEMISS",dDEmissao)
			Eval(bIPRefresh)
		EndIf	
	EndIf
	If(Type("cEspecie")<>"U" .And. cEspecie<>Nil)
		MaFisAlt("NF_ESPECIE",cEspecie)		
	EndIf
	If lTpCompl
		MaFisAlt("NF_TPCOMPL", cTpCompl)
	EndIf
EndIf

If lRetorno	.And. cFormul<>"S"	
	lRetorno := A103ExstNF()
	If !lRetorno
		If  ValType(oNota) == "O"
			oNota:SetFocus()						
		EndIf
	EndIf
EndIf

Return(lRetorno)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeCombo  ³Autor  ³Alexandre Inacio Lemes ³ Data ³22/01/2009 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de verificacao dos codigos dos combos                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Variavel que recebera conteudo do array de referencia.³±±
±±³          ³ExpA2: Array do combobox                                     ³±±
±±³          ³ExpC3: Valor selecionado do combobox                         ³±±
±±³          ³ExpA4: Objeto say para atualizar o texto                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpN1: Posicicao do combo                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo encontrar a referencia correta ³±±
±±³          ³do combobox                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function NfeCombo(cVariavel,aCombo,cCombo,aReferencia,cIdent)

Local nPos	:= aScan(aCombo,cCombo)
Local lRet  := (nPos>0)
Local nPosProd := aScan(aHeader,{|x| AllTrim(x[2]) == "D1_COD"} )

//Garante que não haverá diferenças de espaço.
cVariavel := Alltrim(cVariavel)
aReferencia[nPos] := Alltrim(aReferencia[nPos])

If Type("cFunTipo") == "U"
	Static cFunTipo := ""
EndIf

If !Empty(cVariavel) .And. cVariavel <> aReferencia[nPos] .And. cIdent == "1" .And. Type( "cForAntNfe" ) == "C" .And. Type( "cLojAntNfe" ) == "C"
	cForAntNFE := ""
	cLojAntNFE := ""
Endif

If !Empty(cVariavel) .And. cVariavel <> aReferencia[nPos] .And. cIdent == "1" .And. (Len(aCols) > 1 .Or. !Empty(aCols[1][nPosProd])) //verifica se tem informação no aCols para excluir
	If MsgYesNo(STR0071,STR0018) //"Ao alterar o tipo da Nota os itens já digitados serão excluídos. Deseja continuar?"
		If IsInCallStack("MATA140")
			A103LimpIT(cTipo,@cA100For,@cLoja)
		EndIf
		If nPos > 0
			cVariavel := aReferencia[nPos]
		EndIf
    Else
        lRet := .F.
	EndIf
ElseIf cIdent == "3" //Tipo de Complemento
	If cVariavel <> aReferencia[nPos] .And. (Len(aCols) > 1 .And. !Empty(aReferencia[nPos]) .Or. !Empty(aCols[1][nPosProd]))
		If MsgYesNo(STR0071,STR0018) //"Ao alterar o tipo da Nota os itens ja digitados serao excluidos. Deseja continuar?"
			If IsInCallStack("MATA140")
				A103LimpIT(cTipo,@cA100For,@cLoja)
			EndIf
			If nPos > 1
				cVariavel := aReferencia[nPos]
			Else
				lRet := .F.
			EndIf
		Else
       	lRet := .F.
		EndIf
	ElseIf (cVariavel <> aReferencia[nPos] .and. Empty(aReferencia[nPos])) //caso o usuário retorne o campo de complemento para vazio
		If (Len(aCols) > 1 .Or. !Empty(aCols[1][nPosProd])) .and. MsgYesNo(STR0071,STR0018) //"Ao alterar o tipo da Nota os itens ja digitados serao excluidos. Deseja continuar?"
			If IsInCallStack("MATA140")
				A103LimpIT(cTipo,@cA100For,@cLoja)
			EndIf
			If nPos > 1
				cVariavel := aReferencia[nPos]
			Else
				lRet := .F.
			EndIf
		Else
			lRet := .F.
		EndIf
	Else
		If nPos > 1
			cVariavel := aReferencia[nPos]
		EndIf
	EndIf
Else
	If nPos > 0
		cVariavel := aReferencia[nPos]
	EndIf
EndIf

If cIdent == "1" //Tipo
	c103Tp := cVariavel
Endif

Return (lRet)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeTipo   ³Autor  ³ Eduardo Riera         ³ Data ³12.09.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de validacao do tipo do documento de entrada          ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Tipo do documento de entrada                          ³±±
±±³          ³ExpC2: Codigo do Fornecedor                                  ³±±
±±³          ³ExpA3: Codigo da Loja                                        ³±±
±±³          ³ExpO4: Objeto say para atualizar o texto                     ³±±
±±³          ³ExpO5: Objeto Get para atualizar o codigo do fornecedor      ³±±
±±³          ³ExpO6: Objeto Get para atualizar o codigo da loja            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Tipo valido                                           ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo validar o tipo do documento de ³±±
±±³          ³entrada                                                      ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeTipo(cTipo,cFornece,cLoja,oSay,oFornece,oLoja,oConsF3,cTpCompl,oCompl,aCombo3,aAuxCombo3, cTpForml)

Local nY 			:= 0
Local cTitulo		:= ""

Local aBusca		:= {} 
Local nPosForR		:= 0
Local nPosForE		:= 0
Local aTpNCND 		:= {}

Default cTpCompl 	:= ""
Default cTpForml 	:= ""

If Type("cFunTipo") == "U"
	Static cFunTipo := ""
EndIf

cFunTipo:= "NfeTipo"

If oConsF3 <> Nil
	aBusca:=aClone(oConsF3:aControls)
	nPosForR:= Ascan(aBusca,{|x| x:cSX1HLP =="F1_FORRET"})
	nPosForE:= Ascan(aBusca,{|x| x:cSX1HLP =="F1_FORENT"})
EndIf

If oCompl <> nil .and. cTipo == "5" //-- Nota de Crédito
	aTpNCND 	:= retTpNCND("NC")
	aCombo3 	:= aClone(aTpNCND[1])
	aAuxCombo3  := aClone(aTpNCND[2])
	oCompl:aItems := aCombo3
Elseif oCompl <> nil .and. cTipo == "6" // -- Nota de Débito
	aTpNCND 	:= retTpNCND("ND")
	aCombo3 	:= aClone(aTpNCND[1])
	aAuxCombo3  := aClone(aTpNCND[2])
	oCompl:aItems := aCombo3
ElseIf oCompl <> nil .and. cTipo == "C"// -- Nota de Complemento
	aCombo3    := {"",STR0160,STR0161,STR0162}
	aAuxCombo3 := {"","1","2","3"}
	oCompl:aItems := aCombo3
Endif
If ( cTipo$"DB" .Or. A103RtCliRT(cTipo, cTpCompl, cTpForml) )
	If oFornece<>Nil
		oFornece:cF3 := CpoRetF3("C5_CLIENTE")
	EndIf
	
	If (oConsF3 <> Nil) .and. (nPosForR>0) .and. (nPosForE>0)
		oConsF3:aControls[nPosForR]:cF3:=CpoRetF3("C5_CLIENTE")
		oConsF3:aControls[nPosForE]:cF3:=CpoRetF3("C5_CLIENTE")
	EndIf 
	
	If oSay<>Nil
		cTitulo := oSay:cCaption
		oSay:SetText(RetTitle("F2_CLIENTE"))
		If oSay:cCaption<>cTitulo
			cFornece := CriaVar("F1_FORNECE",.F.)
			cLoja    := CriaVar("F1_LOJA",.F.)
		Endif
	EndIf
	If MaFisFound("NF") .And. MaFisRet(,"NF_TIPONF") <> cTipo
		cFornece := CriaVar("F1_FORNECE",.F.)
		cLoja    := CriaVar("F1_LOJA",.F.)
	EndIf
Else
	If oFornece <> Nil
		oFornece:cF3 := CpoRetF3("F1_FORNECE")
	EndIf
	
	If (oConsF3 <> Nil) .and. (nPosForR>0) .and. (nPosForE>0)
		oConsF3:aControls[nPosForR]:cF3:= CpoRetF3("F1_FORNECE")
		oConsF3:aControls[nPosForE]:cF3:= CpoRetF3("F1_FORNECE")
	EndIf 

	If oSay <> Nil
		cTitulo := oSay:cCaption
		oSay:SetText(RetTitle("F1_FORNECE"))
		If oSay:cCaption<>cTitulo
			cFornece := CriaVar("F1_FORNECE",.F.)
			cLoja    := CriaVar("F1_LOJA",.F.)		
		Endif
	EndIf
	If MaFisFound("NF") .And. MaFisRet(,"NF_TIPONF") <> cTipo
		cFornece	:= CriaVar("F1_FORNECE",.F.)
		cLoja		:= CriaVar("F1_LOJA",.F.)
	EndIf
EndIf 

If MaFisFound("NF") .And. ((AllTrim(cTipo) <> AllTrim(MafisRet(,"NF_TIPONF")) .Or. AllTrim(cTpCompl) <> AllTrim(MafisRet(,"NF_TPCOMPL")))) .And. !IsInCallStack("A103DEVOL")
	if type("oJDocOrig") <> "U"
		oJDocOrig := nil // -- Restauro a variável de vínculo de documentos com NF de débito e crédito.
	endif
	cCondicao	:= 	CriaVar("F1_COND")
	aCols 		:= {}
	aadd(aCols,Array(Len(aHeader)+1))
	For ny := 1 to Len(aHeader)
		If Trim(aHeader[ny][2]) == "D1_ITEM"
			aCols[1][ny] 	:= StrZero(1,Len(SD1->D1_ITEM))
		Else    
			If Trim(aHeader[ny][2]) <> "D1_ALI_WT".And. Trim(aHeader[nY][2]) <> "D1_REC_WT"
				aCols[1][ny] := CriaVar(aHeader[ny][2])
	    	EndIf
		EndIf
		aCols[1][Len(aHeader)+1] := .F.
	Next nY
	MaFisAlt("NF_CLIFOR",IIf((cTipo$"DB" .Or. A103RtCliRT(cTipo, cTpCompl, cTpForml)), "C", "F"))
	MaFisAlt("NF_TIPONF",cTipo)
	MaFisClear()
	If oSay<>Nil
		oSay:Refresh()
	EndIf
	If oFornece<>Nil
		oFornece:Refresh()
	EndIf
	If oLoja<>Nil
		oLoja:Refresh()
	EndIf
	If bGdRefresh<>Nil
		Eval(bGDRefresh)
	EndIf
	If bRefresh<>Nil
		Eval(bRefresh)
	EndIf
	
	If oConsF3 <> Nil
		oConsF3:Refresh()
	EndIf
		
EndIf
Return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeFormul ³Autor  ³ Eduardo Riera         ³ Data ³16.09.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de validacao do formulario proprio do documento de    ³±±
±±³          ³entrada                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Formulario proprio (S/N)                              ³±±
±±³          ³ExpC2: Numero do documento de entrada                        ³±±
±±³          ³ExpA3: Serie do documento de entrada                         ³±±
±±³          ³ExpO4: Objeto say para atualizar o texto                     ³±±
±±³          ³ExpO5: Objeto Get para atualizar o codigo do fornecedor      ³±±
±±³          ³ExpO6: Objeto Get para atualizar o codigo da loja            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Formulario valido                                     ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo validar se o formulario eh pro-³±±
±±³          ³prio ( S/N )                                                 ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeFormul(cFormul,cNota,cSerie,oNFiscal,oSerie,oSay,oFornece,oLoja,oConsF3)
Local cXEspecie		:=""
Local nPosForR		:= 0
Local nPosForE		:= 0
Local aBusca		:= {}
Local lRetNDb		:= .T.

If Type("cFunTipo") == "U"
	Static cFunTipo := ""
EndIf

//RT - Verifico se o tipo da NF é Débito. Se sim, não pode usar formulário próprio, deve usar uma nota de saída.
if (cTipo == "6" .And. cFormul == "S")
	lRetNDb := .F.
	//"Não é possivel incluir uma nota do tipo 'Débito', com formulário próprio igual a 'Sim', na rotina."/"Para essas situações - nota de Débito e formulário próprio - utilizar a rotina do Faturamento, de Documentos de Saída."
	Help(nil, nil , STR0018, nil, STR0279, 1, 0, nil, nil, nil, nil, nil, {STR0280} )
endif

if (lRetNDb)
	If oConsF3 <> Nil
		aBusca:=aClone(oConsF3:aControls)
		nPosForR:= Ascan(aBusca,{|x| x:cSX1HLP =="F1_FORRET"})
		nPosForE:= Ascan(aBusca,{|x| x:cSX1HLP =="F1_FORENT"})
	EndIf

	If cFormul == "S" 
		cNota		:= CriaVar("F1_DOC",.F.)
		cSerie  	:= SerieNfId("SF1",5,"F1_SERIE")
	Else
		If cPaisLoc == "BRA" .And. Type("lIntermed") == "L" .And. lIntermed
			aInfAdic[16] := ""
			aInfAdic[17] := Space(06)
			Eval(bRefresh)
		Endif
	EndIf

	/*RT Quando formulário próprio for igual a SIM, e for uma nota de crédito, referenciar a entrada de um documento via Cliente, e a pesquisa via SF2, de documento vinculado*/
	If ( cTipo $ "DB" .Or. A103RtCliRT(cTipo, cTpCompl, cFormul) )
		If oFornece<>Nil
			oFornece:cF3 := CpoRetF3("C5_CLIENTE")
		EndIf
		
		If (oConsF3 <> Nil) .and. (nPosForR>0) .and. (nPosForE>0)
			oConsF3:aControls[nPosForR]:cF3:=CpoRetF3("C5_CLIENTE")
			oConsF3:aControls[nPosForE]:cF3:=CpoRetF3("C5_CLIENTE")
		EndIf 
		
		If oSay<>Nil
			cTitulo := oSay:cCaption
			oSay:SetText(RetTitle("F2_CLIENTE"))
			If oSay:cCaption<>cTitulo
				cFornece := CriaVar("F1_FORNECE",.F.)
				cLoja    := CriaVar("F1_LOJA",.F.)
			Endif
		EndIf
	Else
		If oFornece <> Nil
			oFornece:cF3 := CpoRetF3("F1_FORNECE")
		EndIf
		
		If (oConsF3 <> Nil) .and. (nPosForR>0) .and. (nPosForE>0)
			oConsF3:aControls[nPosForR]:cF3:= CpoRetF3("F1_FORNECE")
			oConsF3:aControls[nPosForE]:cF3:= CpoRetF3("F1_FORNECE")
		EndIf 

		If oSay <> Nil
			cTitulo := oSay:cCaption
			oSay:SetText(RetTitle("F1_FORNECE"))
			If oSay:cCaption<>cTitulo
				cFornece := CriaVar("F1_FORNECE",.F.)
				cLoja    := CriaVar("F1_LOJA",.F.)		
			Endif
		EndIf
	EndIf

	//---------------------------//
	//Ponto de Entrada: MT103ESP //
	//---------------------------//
	If ExistBlock("MT103ESP")      
		cXEspecie := ExecBlock("MT103ESP",.F.,.F.,{cFormul})    
		If (ValType(cXEspecie) == 'C' )
			cEspecie := Padr(cXEspecie,TamSX3("F1_ESPECIE")[1])
		EndIf
	EndIf

	If oNFiscal<>Nil
		oNFiscal:Refresh()
	EndIf
	If oSerie<>Nil
		oSerie:Refresh()
	EndIf             
	If oNFiscal<>Nil .And. Empty(cFunTipo)
		IF cFormul == "N"
			oNFiscal:Setfocus()
		EndIf
	EndIf

	cFunTipo:= ""
endif
FwFreeArray(aBusca)
Return(lRetNDb)    

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeFornece³Autor  ³ Eduardo Riera         ³ Data ³16.09.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de validacao do codigo do fornecedor do documento de  ³±±
±±³          ³entrada                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Tipo do documento de entrada                          ³±±
±±³          ³ExpC2: Codigo do documento de entrada                        ³±±
±±³          ³ExpC3: Loja do documento de entrada                          ³±±
±±³          ³ExpC4: Unidade federativa (sera alimentado por referencia)   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Codigo Valido                                         ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo validar se o codigo do fornece-³±±
±±³          ³dor no documento de entrada                                  ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Function NfeFornece(cTipo,cFornece,cCodLoja,cUfOrig,nCombo,oCombo,cCodRet,oCodRet,aCodR,cRecIss,cNatureza,oNrNota,lOkDespImp,aNFEletr,aNfeDanfe,aInfAdic)

Local aArea      	:= GetArea()
Local cNatDup2   	:= ""
Local cCampoVld  	:= ""
Local lRetorno   	:= .F.
Local lForAntNFE 	:= ( Type( "cForAntNfe" ) == "C" ) 
Local lLojAntNFE 	:= ( Type( "cLojAntNfe" ) == "C" ) 
Local a          	:= 0
Local lDespImpor  	:= "MATA119" $ FunName()
Local lPreNota    	:= IsInCallStack("MATA140")
Local lMaFisFound	:= MaFisFound()
Local cA2TIPO		:= ""
Local cNatBloq		:= ""
Local c1DUPNAT	:= SuperGetMV("MV_1DUPNAT",.F.,"")

Default	aCodR		:=	{}
Default cRecIss		:=	"1"
Default cNatureza	:= ""
Default lOkDespImp	:= .F.
Default aNFEletr    := {}
Default aNfeDanfe   := {}
Default aInfAdic    := {}

If Type('l103Auto')=='U'
	Private l103Auto  := .F.
Endif

If Empty(cNatureza) .And. lMaFisFound .And. !("C5_NATUREZ" $ c1DUPNAT) 
	cNatureza := MaFisRet(,"NF_NATUREZA")
Endif

//Verifica se o codigo do fornecedor eh valido
If !Empty(cFornece)
	If ( cTipo$"DB" .Or. A103RtCliRT(cTipo, cTpCompl, cFormul) )
		
		If cCodLoja == Nil .Or. Empty(cCodLoja)
			dbSelectArea("SA1")
			SA1->(dbSetOrder(1))
			If !(xFilial("SA1") == SA1->A1_FILIAL .And. cFornece == SA1->A1_COD)
				If SA1->(MsSeek(xFilial("SA1")+cFornece))
					//-- Se a Loja estiver vazia busco próxima loja desbloqueada
					While SA1->(!Eof()) .And. SA1->A1_COD == cFornece
						If SA1->A1_MSBLQL <> "1"
							cCodLoja := SA1->A1_LOJA
							lRetorno := .T.
							Exit
						EndIf
						SA1->(DbSkip())
					EndDo
				Else
					Help("  ",1,"REGNOIS")
				EndIf
			Else
				cCodLoja := SA1->A1_LOJA
				lRetorno := .T.
			EndIf
		Else
			dbSelectArea("SA1")
			SA1->(dbSetOrder(1))			
			If SA1->(MsSeek(xFilial("SA1")+cFornece+cCodLoja))
				lRetorno := .T.
			Else
				Help("  ",1,"REGNOIS")
			EndIf

			//Verifica se o Registro esta Bloqueado
			If lRetorno .And. !RegistroOk("SA1")
				lRetorno := .F.
			EndIf
		EndIf

		If lRetorno .And. lForAntNFE .And. lLojAntNFE .And. (!(cFornece == cForAntNFE) .Or. !(cCodLoja == cLojAntNFE))
			If IsInCallStack("A103Devol")
				If cUfOrig <> NIL .and. Empty(cUfOrig)
					cUfOrig := SA1->A1_EST 					
				EndIf 					
				cRecIss  := Iif( SA1->A1_RECISS$"1S","1","2" )
			Else
				If cUfOrig <> NIL
					cUfOrig := SA1->A1_EST			
				EndIf 					
				cRecIss  := Iif( SA1->A1_RECISS$"1S","1","2" )
			EndIf
		
			If cTipo <> "D"
				dbSelectArea("SE4")
				SE4->(DbSetOrder(1))
				If SE4->(MsSeek(xFilial("SE4")+SA1->A1_COND))
					If SE4->E4_TIPO <> "9" .And. SE4->E4_TIPO <> "A"
						cCondicao := SA1->A1_COND
					EndIf
				EndIf
				
				dbSelectArea("SED")
				SED->(dbSetOrder(1))
				If SED->(MsSeek(xFilial("SED")+SA1->A1_NATUREZ))
					cNatureza := SA1->A1_NATUREZ
				Else
					cNatureza := CriaVar("E1_NATUREZ",.F.)
				EndIf
				MaFisAlt("NF_NATUREZA",cNatureza)
			Else
				cCondicao := CriaVar("F1_COND",.F.)
				cNatureza := CriaVar("E1_NATUREZ",.F.)
			EndIf
		EndIf

	ElseIf !lOkDespImp
	
		If cCodLoja == Nil .Or. Empty(cCodLoja)
			dbSelectArea("SA2")
			SA2->(dbSetOrder(1))
			If !(xFilial("SA2") == SA2->A2_FILIAL .And. cFornece == SA2->A2_COD)
				If SA2->(MsSeek(xFilial("SA2")+cFornece))
					//-- Se a Loja estiver vazia busco próxima loja desbloqueada
					While SA2->(!Eof()) .And. SA2->A2_COD == cFornece
						If SA2->A2_MSBLQL <> "1"
							cCodLoja := SA2->A2_LOJA
							lRetorno := .T.
							Exit
						EndIf
						SA2->(DbSkip())
					EndDo
				Else
					Help("  ",1,"REGNOIS")
				EndIf
			Else
				cCodLoja := SA2->A2_LOJA
				lRetorno := .T.				
			EndIf
		Else
			dbSelectArea("SA2")
			SA2->(dbSetOrder(1))
			If SA2->(MsSeek(xFilial("SA2")+cFornece+cCodLoja))
				lRetorno := .T.
			Else
				Help("  ",1,"REGNOIS")
			EndIf

			//Verifica se o Registro esta Bloqueado
			If lRetorno .And. !RegistroOk("SA2")
				lRetorno := .F.
			EndIf	
		EndIf
	
		If lRetorno .And. lForAntNFE .And. lLojAntNFE .And. (!(cFornece == cForAntNFE) .Or. !(cCodLoja == cLojAntNFE)) .And. ("CA100FOR" $ ALLTRIM(READVAR()) .Or. "CLOJA" $ ALLTRIM(READVAR()))
			If !(IsInCallStack("A116Inclui"))
				cUfOrig	:= SA2->A2_EST
			Endif
			cA2TIPO	:= SA2->A2_TIPO
			cRecIss	:= Iif( SA2->A2_RECISS$"1S","1","2" )
		
			dbSelectArea("SE4")
			SE4->(dbSetOrder(1))
			If SE4->(MsSeek(xFilial("SE4")+SA2->A2_COND))
				If SE4->E4_TIPO <> "9" .And. SE4->E4_TIPO <> "A"
					cCondicao  := SA2->A2_COND
				Endif
			Else
				cCondicao := Space(TamSx3("F1_COND")[1])
			EndIf			
		
			dbSelectArea("SED")
			SED->(dbSetOrder(1))
			If SED->(MsSeek(xFilial("SED")+SA2->A2_NATUREZ))
				cNatureza := SA2->A2_NATUREZ
			Else
				cNatureza	:= CriaVar("E2_NATUREZ",.F.)
				cNatDup2	:= SuperGetMV("MV_2DUPNAT",.F.,"")
				
				If !Empty(cNatDup2)
					cNatureza:= &(cNatDup2)
				EndIf
			EndIf

			If !Empty(cNatureza)
				cNatBloq := GetAdvFval("SED","ED_MSBLQL", fwxFilial("SED") + cNatureza,1)
				If cNatBloq == "1" //Registro bloqueado
					cNatureza	:= CriaVar("E2_NATUREZ",.F.)
				Endif
			Endif

			MaFisAlt("NF_NATUREZA",cNatureza)
		EndIf

		If lRetorno .And. !lPreNota
			cA2TIPO := SA2->A2_TIPO
			If ExistBlock("MT103DRF")
				aDirfRt := ExecBlock("MT103DRF",.F.,.F.,{nCombo,cCodRet,@oCombo,@oCodRet})		
				If ValType(aDirfRt) == "A" .And. Len(aDirfRt) > 0
					For a := 1 To Len(aDirfRt)
						nCombo  := Iif(aDirfRt[a][2] > 2, 2, aDirfRt[a][2])
						cDirf := cValToChar(nCombo)
						cCodRet := ""
						If nCombo = 1 
							cCodRet := aDirfRt[a][3]
						EndIf
						If !Empty(cCodRet)
							If aScan(aCodR,{|aX| aX[4]==aDirfRt[a][1]})==0
								aAdd( aCodR,{99, cCodRet,1,aDirfRt[a][1]})
							Else
								aCodR[aScan(aCodR, {|aX| aX[4]==aDirfRt[a][1]})][2] := cCodRet
							EndIf
						EndIf
					Next a
				EndIf
				If ValType( oCombo ) == "O"
					oCombo:Refresh()
				EndIf
				If ValType( oCodRet ) == "O"
					oCodRet:Refresh()
				EndIf
				nCombo  := 2
				cCodRet := "    "
			EndIf
		EndIf
		MaFisAlt("NF_TPCLIFOR",cA2TIPO)
	Else
		lRetorno := .T.
	EndIf 
	
	If !FwIsInCallStack("COLATUIMP") //Verifica se a nota existe somente se não for atualização de imposto
		If lRetorno .And. l103auto
			lRetorno := A103ExstNF()
		EndIf
	EndIf        
Else
	lRetorno := .T.
EndIf

If lRetorno .And. lForAntNFE .And. lLojAntNFE
	cForAntNFE := cFornece
	cLojAntNFE := cCodLoja
ElseIf !lRetorno .And. lDespImpor .And. cFormul == "S"
	cNFiscal := " "
	cSerie   := " "
EndIf

// Ponto de entrada para preencher informacoes na aba Danfe e Nota Fiscal Eletronica
If lRetorno .And. ExistBlock("M103NFEL") .And. !lPreNota
	If AllTrim(ReadVar()) == "CA100FOR"
		cCampoVld := "F1_FORNECE"
	ElseIf AllTrim(ReadVar()) == "CLOJA"
		cCampoVld := "F1_LOJA"
	EndIf
	If !Empty(cCampoVld)
		A103NfElet(cCampoVld,cUfOrig,aNFEletr,aNfeDanfe,aInfAdic)
	EndIf
EndIf

RestArea(aArea)

Return(lRetorno)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeFldFin ³Autor  ³ Eduardo Riera         ³ Data ³12.09.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de tratamento do folder financeiro                    ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpO1: Objeto da Janela principal                            ³±±
±±³          ³ExpL2: Indica se o folder eh "somente visualizacao"          ³±±
±±³          ³ExpA3: Array com registros do SE2 quando for visualizacao    ³±±
±±³          ³ExpN4: Indica a posicao X de referencia p/ criacao da Janela ³±±
±±³          ³ExpA5: Array com registros do SE1 quando for visualizacao    ³±±
±±³          ³ExpA6: AHeader dos Titulos a Pagar                           ³±±
±±³          ³ExpA7: ACols   dos Titulos a Pagar                           ³±±
±±³          ³ExpA6: AHeader do SEV                                        ³±±
±±³          ³ExpA7: ACols   do SEV                                        ³±±
±±³          ³ExpL9: Identifica multiplas NF de Desp.Imp. par. MV_NUMITEN  ³±±
±±³          ³       e/ou se passado .T. faz Refresh no folder Duplicatas  ³±±
±±³          ³       mesmo sem acessar a pasta                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo exibir/controlar o folder finan³±±
±±³          ³ceiro.                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeFldFin(oDlg,lVisual,aRecSE2,nPosX,aRecSE1,aHeadSE2,aColsSE2,aHeadSEV,aColsSEV,bRefresh,lCalcula,cModRetPIS,lPccBaixa,lTxNeg,cNatureza,nTaxaMoeda,aColTrbGen,nColsSE2,aParcTrGen,cIdsTrGen)

Local aArea     := GetArea()
Local aStruSEV  := {}
Local aIdSEV	:= {}
Local aItensSEV	:= {}
Local aCpoHead  := {}
Local aCposPE	:= {}
Local aVisTrbGen:= {}
Local cDescricao:= ""
Local cQuery    := ""
Local cAliasSEV := "SEV"
Local cChave    := ""
Local nX        := 0
Local nY        := 0
Local nI        := 0
Local nPosItSEV := 0
Local nMultDec  := GetNewPar( "MV_MULTDEC", 2 ) 
Local nTxDia	:= 0
Local nPosRecno := 0
Local nPosValTrb:= 0
Local lQuery    := .F.
Local lAltera	:= !lVisual 
Local l103BDP   := .F.   
Local lEvValPerc:= SEV->(FieldPos("EV_VALPERC")) > 0
Local aAltNewGd := Nil
Local aNFEGDSEV := {}
Local oCtaPag
Local oMoeda
Local oNatureza
Local oDescri
Local oCondicao
Local oTaxa
Local oTxNeg 
Local oMultNat
Local oDscMoeda
Local lMT103NAT  := Existblock("MT103NAT")
Local lMT103GET  := Existblock("MT103GET")
Local lShowRet   := .F.
Local nPosH      := 0 				 
Local lMult      := .T.
Local lRecalc    := .T.
Local lTrbGen    := IIf(FindFunction("ChkTrbGen"),ChkTrbGen("SD1", "D1_IDTRIB"),.F.) .And. FindFunction("FinImpFis") // Verifica se o sistema esta preparado para utilizar o motor de tributos genericos
Local nValDupAnt := 0
Local cLimRec    := SuperGetMv("MV_LIMREC",.F.,"1")
Local aCpoSE2	 := {}
Local lMT103SE2	 := ExistBlock("MT103SE2")
Local lMULNATP   := SuperGetMV("MV_MULNATP")
Local lDUPBRUT   := GetNewPar ("MV_DUPBRUT", .F.)
Local lMT103BDP	 := ExistBlock("MT103BDP")
Local lNFEGDSEV	 := ExistBlock("NFEGDSEV")
Local cCONFDUP	 := GetNewPar( "MV_CONFDUP", "2" )
Local lMTCOLSE2	 := ExistBlock("MTCOLSE2")
Local aSEVcampos := {}
Local cX3Usado 	 := ''
Local nX3Nivel	 := 0
Local nMoedAux 	 := 0
Local oStruSeV   := FWFormStruct(1, 'SEV'  )
Local lAuto103 :=  (Type("l103Auto") <> "U" .And. (l103Auto))

DEFAULT aRecSE1		:=	{}
DEFAULT aRecSE2		:=	{}
DEFAULT aColTrbGen  := {}
DEFAULT aParcTrGen  := {}
DEFAULT lCalcula  	:= .F.
DEFAULT lPccBaixa 	:= .F.
DEFAULT lTxNeg		:= .F.              
DEFAULT cNatureza	:= ""
DEFAULT nTaxaMoeda	:= 0
DEFAULT nColsSE2    := 0
DEFAULT cIdsTrGen	:= ""

aAdd(aSEVcampos,"EV_NATUREZ")
aAdd(aSEVcampos,"EV_PERC")

// Alguns clientes possuem o campo EV_VALPERC e gatilhos para os campos EV_PERC e EV_VALPERC chamando a funcao NfeRatSEV que atualizam um ao outro
// O campo EV_VALPERC deve constar do aCols de multiplas naturezas, caso contrario o percentual digitado em EV_PERC eh zerado pelo gatilho
If lEvValPerc
	aAdd(aSEVcampos,"EV_VALPERC")
EndIf

/*carrega campos customizados.*/
For nI := 1 to len(oStruSeV:afields) 
 If	GetSx3Cache(oStruSeV:afields[nI][3],"X3_PROPRI") == "U"
 	aAdd(aSEVcampos,oStruSeV:afields[nI][3])
 EndIf
Next

If Type("nTaxa")=="N"
	nTaxaMoeda:= nTaxa
EndIf
If Type("nMoedaCor")=="N"
	nMoedAux := nMoedaCor
EndIf
// Armazena no array aColTrbGen as colunas que serao exibidas na aba Duplicatas referentes ao motor de tributos genericos
If lTrbGen
	aColTrbGen := xFisRetTG(Iif(INCLUI,dDataBase,SF1->F1_EMISSAO))
EndIf

bRefresh    := {|| NfeRFldFin(@cCondicao,@cDescricao,@cNatureza,nMoedaCor,@nTaxaMoeda,oCondicao,oNatureza,oMoeda,oTaxa,oDscMoeda,oCtaPag,oMultNat,!lVisual,@aColsSE2,aHeadSE2,@aColsSEV,aHeadSEV,oDescri,oTxNeg,cLimRec,@lRecalc,@nValDupAnt,aColTrbGen,@aParcTrGen,nColsSE2,@cIdsTrGen)}

//Montagem do aHeader da Getdados do contas a pagar
If Empty(aHeadSE2)
	If cPaisLoc == "BRA"
		aCpoSE2 := {{"E2_PARCELA",".F.",".T."}        ,{"E2_VENCTO","M->E2_VENCTO >= M->dDEmissao",".T."} ,{"E2_VALOR","Positivo()",".T."}           ,;
					{"E2_IRRF"   ,"Positivo()",".T."} ,{"E2_ISS"   ,"Positivo()",".T."}                 ,{"E2_INSS" ,"Positivo()","A103VldInss()"} ,;
					{"E2_PIS"    ,"Positivo()",".T."} ,{"E2_COFINS","Positivo()",".T."}                 ,{"E2_CSLL" ,"Positivo()",".T."}           ,;
					{"E2_SEST"   ,"Positivo()",".T."} ,{"E2_FETHAB","Positivo()",".T."}                 ,{"E2_FABOV","Positivo()",".T."}           ,;
					{"E2_FACS"   ,"Positivo()",".T."} ,{"E2_IMA"   ,"Positivo()",".T."}                 ,{"E2_FAMAD","Positivo()",".T."}           ,;
					{"E2_BTRISS" ,"Positivo()",".T."}}
	Else
		aCpoSE2 := {{"E2_PARCELA",".F.",".T."},{"E2_VENCTO","M->E2_VENCTO>=M->dDEmissao",".T."},{"E2_VALOR","Positivo()",".T."}}
	EndIf

	DbSelectArea("SX3")
	SX3->(dbSetOrder(2))

	For nX := 1 To Len(aCpoSE2)
		If SX3->(MsSeek(aCpoSE2[nX,1]))

			AADD(aHeadSE2,{TRIM(x3titulo()),;
							SX3->X3_CAMPO,;
							SX3->X3_PICTURE,;
							SX3->X3_TAMANHO,;
							SX3->X3_DECIMAL,;
							aCpoSE2[nX,2],;
							SX3->X3_USADO,;
							SX3->X3_TIPO,;
							SX3->X3_F3,;
							SX3->X3_CONTEXT,;
							SX3->X3_CBOX,;
							SX3->X3_RELACAO,;
							aCpoSE2[nX,3]})
		EndIf
	Next nX

    //PE para adicionar campos no aCols da SE2
	If lMT103SE2
		aCposPE:= ExecBlock("MT103SE2",.F.,.F.,{aHeadSE2,lVisual})
		If ValType (aCposPE) == "A" .And. Len(aCposPE) > 0
			For nX:= 1 to Len(aCposPE)
				AADD(aHeadSE2, aCposPE[nX])
			Next nX
		EndIf
	EndIf

	// Inclusao das colunas referentes ao motor de tributos genericos
	If lTrbGen .And. Len(aColTrbGen) > 0
		For nX := 1 To Len(aColTrbGen)
			aAdd(aHeadSE2,;
				{aColTrbGen[nX][1],;
				"F2D_VALOR",;
				PesqPict("F2D","F2D_VALOR"),;
				TamSx3("F2D_VALOR")[1],;
				TamSX3("F2D_VALOR")[2],;
				"Positivo()",;
				"",;
				"N",;
				"",;
				"R",;
				"",;
				"",;
				".T."})
		Next nX
		aAdd(aCpoHead,"F2D_VALOR")
	EndIf

	// Variavel que contem o numero de colunas da tabela SE2 exibidas na aba Duplicatas
	nColsSE2 := Len(aHeadSE2) - Len(aColTrbGen)

EndIf

//Campos editaveis na aba duplicatas.
For nX := 1 To Len(aHeadSE2)
	If aHeadSE2[nX,2] <> "E2_PARCELA"
		aAdd(aCpoHead,aHeadSE2[nX,2])
	Endif
Next nX
	
//Adiciona os campos de Alias e Recno ao aHeader para WalkThru
ADHeadRec("SE2",aHeadSE2)

//Montagem do aHeader da Getdados de multipla natureza
If Empty(aHeadSEV) .And. lMULNATP	
	For nX := 1 To Len(aSEVcampos)
		cX3Usado := GetSx3Cache(aSEVcampos[nX],"X3_USADO")
		nX3Nivel := GetSx3Cache(aSEVcampos[nX],"X3_NIVEL")
		IF X3Uso(cX3Usado) .AND. cNivel >= nX3Nivel		
			AADD(aHeadSEV,{ TRIM(GetSx3Cache(aSEVcampos[nX],"X3_TITULO")),;	//X3_TITULO
							GetSx3Cache(aSEVcampos[nX],"X3_CAMPO"),;	//X3_CAMPO,;
							GetSx3Cache(aSEVcampos[nX],"X3_PICTURE"),; 	//X3_PICTURE,;
							GetSx3Cache(aSEVcampos[nX],"X3_TAMANHO"),;	//X3_TAMANHO,;
							GetSx3Cache(aSEVcampos[nX],"X3_DECIMAL"),;	//X3_DECIMAL,;
							GetSx3Cache(aSEVcampos[nX],"X3_VALID"),;	//X3_VALID,;
							GetSx3Cache(aSEVcampos[nX],"X3_USADO"),;	//X3_USADO,;
							GetSx3Cache(aSEVcampos[nX],"X3_TIPO"),;		//X3_TIPO,;
							GetSx3Cache(aSEVcampos[nX],"X3_F3"),;		//X3_F3,;
							GetSx3Cache(aSEVcampos[nX],"X3_CONTEXT"),;	//X3_CONTEXT,;
							GetSx3Cache(aSEVcampos[nX],"X3_CBOX"),;		//X3_CBOX,;   
							GetSx3Cache(aSEVcampos[nX],"X3_RELACAO"),;	//X3_RELACAO,;
							".T."})
			If AllTrim(aSEVcampos[nX])=="EV_PERC"
				aHeadSEV[nX][3] := "@E 999." + Replicate("9",nMultDec)                
			EndIf
		EndIf		
	Next nX
EndIf

//Adiciona os campos de Alias e Recno ao aHeader para WalkThru
ADHeadRec("SEV",aHeadSEV)

//Montagem do aCols da Getdados das multiplas naturezas
If lVisual
	If !Empty(aRecSE2)
		dbSelectArea("SE2")
		MsGoto(aRecSE2[1])
		
		dbSelectArea("SEV")
		dbSetOrder(1)

		aStruSEV  := SEV->(dbStruct())
		cAliasSEV := "NFEFLDFIN"
		lQuery    := .T.
		cQuery    := " SELECT SEV.*,SEV.R_E_C_N_O_ SEVRECNO "
		cQuery    += " FROM "+RetSqlName("SEV")+" SEV "
		cQuery    += " WHERE SEV.EV_FILIAL = '" + xFilial("SEV") + "'"
		cQuery    += " AND SEV.EV_PREFIXO  = '" + SE2->E2_PREFIXO + "'"
		cQuery    += " AND SEV.EV_NUM	   = '" + SE2->E2_NUM + "'"
		cQuery    += " AND SEV.EV_PARCELA  = '" + SE2->E2_PARCELA + "'"
		cQuery    += " AND SEV.EV_TIPO     = '" + SE2->E2_TIPO + "'"
		cQuery    += " AND SEV.EV_CLIFOR   = '" + SE2->E2_FORNECE + "'"
		cQuery    += " AND SEV.EV_LOJA     = '" + SE2->E2_LOJA + "'"
		cQuery    += " AND SEV.EV_RECPAG   = 'P' "
		cQuery    += " AND SEV.D_E_L_E_T_  = ' ' "
		cQuery    += " ORDER BY "+SqlOrder(SEV->(IndexKey()))

		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSEV)
		
		For nX := 1 To Len(aStruSEV)
			If aStruSEV[nX][2]<>"C"
				TcSetField(cAliasSEV,aStruSEV[nX][1],aStruSEV[nX][2],aStruSEV[nX][3],aStruSEV[nX][4])
			EndIf
		Next nX

		While (cAliasSEV)->(!Eof()) .And. (cAliasSEV)->EV_FILIAL == xFilial("SEV") .And.;
				(cAliasSEV)->EV_PREFIXO == SE2->E2_PREFIXO .And.;
				(cAliasSEV)->EV_NUM     == SE2->E2_NUM 	.And.;
				(cAliasSEV)->EV_PARCELA == SE2->E2_PARCELA .And.;
				(cAliasSEV)->EV_TIPO    == SE2->E2_TIPO 	.And.;
				(cAliasSEV)->EV_CLIFOR  == SE2->E2_FORNECE .And.;
				(cAliasSEV)->EV_LOJA    == SE2->E2_LOJA

			If (cAliasSEV)->EV_RECPAG == "P"
				aadd(aColsSEV,Array(Len(aHeadSEV)+1))
				For nX := 1 To Len(aHeadSEV)
					If IsHeadRec(aHeadSEV[nX][2])
						aColsSEV[Len(aColsSEV)][nX] := IIf(lQuery , (cAliasSEV)->SEVRECNO , SEV->(Recno())  )
						If (cAliasSEV)->EV_IDENT = "2"
							aadd(aIdSEV,IIf(lQuery,(cAliasSEV)->SEVRECNO,SEV->(Recno())))
							nPosRecno := nX
						EndIf
					ElseIf IsHeadAlias(aHeadSEV[nX][2])
						aColsSEV[Len(aColsSEV)][nX] := "SEV"
					ElseIf aHeadSEV[nX,10] == "V"
						aCOLSSEV[Len(aColsSEV)][nX] := CriaVar(aHeadSEV[nX,2],.F.)
					Else
						aCOLSSEV[Len(aColsSEV)][nX] := FieldGet(FieldPos(aHeadSEV[nX,2]))
					EndIf
					If AllTrim(aHeadSEV[nX,2]) == "EV_PERC"
						aCOLSSEV[Len(aColsSEV)][nX] *= 100
					EndIf
				Next nX
				aCOLSSEV[Len(aColsSEV)][Len(aHeadSEV)+1] := .F.
			EndIf
			(cAliasSEV)->(dbSkip())
		EndDo
		
		If Len(aIdSEV) > 0 .And. nPosRecno > 0
			For nX := 1 To Len(aIdSEV)
				If (nPosItSEV := aScan(aColsSEV, {|x| x[nPosRecno]==aIdSEV[nX]})) > 0
					aadd(aItensSEV,aColsSEV[nPosItSEV])
				EndIf
			Next nX
			If Len(aItensSEV) > 0
				aColsSEV := aItensSEV
			EndIf
		EndIf
		
		If lQuery
			(cAliasSEV)->(dbCloseArea())
			dbSelectArea("SEV")
		EndIf
	EndIf
EndIf

If Empty(aColsSEV) .And. lMULNATP
	//Montagem do aCols da Getdados dos titulos a pagar
	aadd(aColsSEV,Array(Len(aHeadSEV)+1))
	For nX := 1 To Len(aHeadSEV)
		If IsHeadRec(aHeadSEV[nX][2])
			aColsSEV[Len(aColsSEV)][nX] := 0
		ElseIf IsHeadAlias(aHeadSEV[nX][2])
			aColsSEV[Len(aColsSEV)][nX] := "SEV"
		Else
			aColsSEV[Len(aColsSEV)][nX] := CriaVar(aHeadSEV[nX,2],.F.)	
		EndIf
	Next nX
	aColsSEV[Len(aColsSEV)][Len(aHeadSEV)+1] := .F.
EndIf

//Montagem do aCols da Getdados dos titulos financeiros
If lVisual
	Do Case
	Case !Empty(aRecSE2)
		For nX := 1 To Len(aRecSE2)
			dbSelectArea("SE2")
			MsGoto(aRecSE2[nX])
			nMoedaCor	:= SE2->E2_MOEDA
			nTaxaMoeda  := SF1->F1_TXMOEDA
			nTxDia		:= RecMoeda(SE2->E2_EMISSAO,nMoedaCor)
			lTxNeg		:= !Empty(SE2->E2_TXMOEDA) .And. nTxDia <> 0 .And. nTxDia <> SE2->E2_TXMOEDA
			If SE2->E2_TIPO == MVNOTAFIS .Or. cPaisLoc <> "BRA"
				If SE2->E2_TIPO == MVNOTAFIS
					cNatureza	:= SE2->E2_NATUREZ
				EndIf

				// Retorna valores de tributos genericos gravados na tabela FKQ para exibir na visualizacao da nota
				If lTrbGen
					cChave := SE2->E2_FILIAL+"|"+SE2->E2_PREFIXO+"|"+SE2->E2_NUM+"|"+SE2->E2_PARCELA+"|"+SE2->E2_TIPO+"|"+SE2->E2_FORNECE+"|"+SE2->E2_LOJA
					aVisTrbGen := FinImpFis(cChave,SE2->E2_FILORIG,"SE2",.F.)
				EndIf

				aadd(aColsSE2,Array(Len(aHeadSE2)+1))
				For nY := 1 To Len(aHeadSE2)
					If IsHeadRec(aHeadSE2[nY][2])
						aColsSE2[Len(aColsSE2)][nY] := SE2->(RecNo())
					ElseIf IsHeadAlias(aHeadSE2[nY][2])
						aColsSE2[Len(aColsSE2)][nY] := "SE2"
					ElseIf aHeadSE2[nY][2] == "F2D_VALOR"
						If Len(aVisTrbGen) > 0 .And. Len(aVisTrbGen[1]) >= 9 .And. (nPosValTrb := aScan(aVisTrbGen,{|x| x[9] == aHeadSE2[nY][1]}) ) > 0	// Verifica se tem valor a exibir na coluna
							aColsSE2[Len(aColsSE2)][nY] := aVisTrbGen[nPosValTrb][3]
						Else
							aColsSE2[Len(aColsSE2)][nY] := CriaVar("F2D_VALOR")
						EndIf
					Else
						aColsSE2[Len(aColsSE2)][nY] := FieldGet(FieldPos(aHeadSE2[nY,2]))
					EndIf
				Next nY
				aColsSE2[Len(aColsSE2)][Len(aHeadSE2)+1] := .F.
				
				If lDUPBRUT
					If (nPosH := aScan (aHeadSE2, {|x| AllTrim (x[2])=="E2_IRRF"}))<>0
						//Conversao do valor do imposto para Moeda 2
					    If nMoedaCor <> 1
							aCOLSSE2[Len(aColsSE2)][3]	+=	NoRound((aCOLSSE2[Len(aColsSE2)][nPosH]/nTaxaMoeda),2)
						Else
							aCOLSSE2[Len(aColsSE2)][3]	+=	aCOLSSE2[Len(aColsSE2)][nPosH]						
						Endif
					EndIf
					If (nPosH := aScan (aHeadSE2, {|x| AllTrim (x[2])=="E2_ISS"}))<>0
						If nMoedaCor <> 1
							aCOLSSE2[Len(aColsSE2)][3]	+=	NoRound((aCOLSSE2[Len(aColsSE2)][nPosH]/nTaxaMoeda),2)
						Else 
							aCOLSSE2[Len(aColsSE2)][3]	+=	aCOLSSE2[Len(aColsSE2)][nPosH]						
						Endif
					EndIf
					If (nPosH := aScan (aHeadSE2, {|x| AllTrim (x[2])=="E2_INSS"}))<>0
						If nMoedaCor <> 1
							aCOLSSE2[Len(aColsSE2)][3]	+=	NoRound((aCOLSSE2[Len(aColsSE2)][nPosH]/nTaxaMoeda),2)
						Else
							aCOLSSE2[Len(aColsSE2)][3]	+=	aCOLSSE2[Len(aColsSE2)][nPosH]
						Endif	
					EndIf
					If (nPosH := aScan (aHeadSE2, {|x| AllTrim (x[2])=="E2_PIS"}))<>0
						If nMoedaCor <> 1
							aCOLSSE2[Len(aColsSE2)][3]	+=	NoRound((aCOLSSE2[Len(aColsSE2)][nPosH]/nTaxaMoeda),2)
						Else 
							aCOLSSE2[Len(aColsSE2)][3]	+=	aCOLSSE2[Len(aColsSE2)][nPosH]
						Endif	
					EndIf
					If (nPosH := aScan (aHeadSE2, {|x| AllTrim (x[2])=="E2_COFINS"}))<>0
						If nMoedaCor <> 1
							aCOLSSE2[Len(aColsSE2)][3]	+=	NoRound((aCOLSSE2[Len(aColsSE2)][nPosH]/nTaxaMoeda),2)
						Else                                                                                
							aCOLSSE2[Len(aColsSE2)][3]	+=	aCOLSSE2[Len(aColsSE2)][nPosH]
						Endif	
					EndIf
					If (nPosH := aScan (aHeadSE2, {|x| AllTrim (x[2])=="E2_CSLL"}))<>0
						If nMoedaCor <> 1
							aCOLSSE2[Len(aColsSE2)][3]	+=	NoRound((aCOLSSE2[Len(aColsSE2)][nPosH]/nTaxaMoeda),2)
						Else
							aCOLSSE2[Len(aColsSE2)][3]	+=	aCOLSSE2[Len(aColsSE2)][nPosH]
						Endif	
					EndIf
					If (nPosH := aScan (aHeadSE2, {|x| AllTrim (x[2])=="E2_FETHAB"}))<>0
						If nMoedaCor <> 1
							aCOLSSE2[Len(aColsSE2)][3]	+=	NoRound((aCOLSSE2[Len(aColsSE2)][nPosH]/nTaxaMoeda),2)
						Else
							aCOLSSE2[Len(aColsSE2)][3]	+=	aCOLSSE2[Len(aColsSE2)][nPosH]
						Endif	
					EndIf
					If (nPosH := aScan (aHeadSE2, {|x| AllTrim (x[2])=="E2_SEST"}))<>0
						If nMoedaCor <> 1
							aCOLSSE2[Len(aColsSE2)][3]	+=	NoRound((aCOLSSE2[Len(aColsSE2)][nPosH]/nTaxaMoeda),2)
						Else
							aCOLSSE2[Len(aColsSE2)][3]	+=	aCOLSSE2[Len(aColsSE2)][nPosH]
						Endif	
					EndIf
					If (nPosH := aScan (aHeadSE2, {|x| AllTrim (x[2])=="E2_FABOV"}))<>0
						If nMoedaCor <> 1
							aCOLSSE2[Len(aColsSE2)][3]	+=	NoRound((aCOLSSE2[Len(aColsSE2)][nPosH]/nTaxaMoeda),2)
						Else
							aCOLSSE2[Len(aColsSE2)][3]	+=	aCOLSSE2[Len(aColsSE2)][nPosH]
						Endif	
					EndIf                                                                 
					If (nPosH := aScan (aHeadSE2, {|x| AllTrim (x[2])=="E2_FACS"}))<>0
						If nMoedaCor <> 1
							aCOLSSE2[Len(aColsSE2)][3]	+=	NoRound((aCOLSSE2[Len(aColsSE2)][nPosH]/nTaxaMoeda),2)
						Else
							aCOLSSE2[Len(aColsSE2)][3]	+=	aCOLSSE2[Len(aColsSE2)][nPosH]
						Endif	
					EndIf
					If (nPosH := aScan (aHeadSE2, {|x| AllTrim (x[2])=="E2_IMA"}))<>0
						If nMoedaCor <> 1
							aCOLSSE2[Len(aColsSE2)][3]	+=	NoRound((aCOLSSE2[Len(aColsSE2)][nPosH]/nTaxaMoeda),2)
						Else
							aCOLSSE2[Len(aColsSE2)][3]	+=	aCOLSSE2[Len(aColsSE2)][nPosH]
						Endif	
					EndIf
					If (nPosH := aScan (aHeadSE2, {|x| AllTrim (x[2])=="E2_FAMAD"}))<>0
						If nMoedaCor <> 1
							aCOLSSE2[Len(aColsSE2)][3]	+=	NoRound((aCOLSSE2[Len(aColsSE2)][nPosH]/nTaxaMoeda),2)
						Else
							aCOLSSE2[Len(aColsSE2)][3]	+=	aCOLSSE2[Len(aColsSE2)][nPosH]
						Endif	
					EndIf
					If (nPosH := aScan (aHeadSE2, {|x| AllTrim (x[2])=="E2_BTRISS"}))<>0
						If nMoedaCor <> 1
							aCOLSSE2[Len(aColsSE2)][3]	+=	NoRound((aCOLSSE2[Len(aColsSE2)][nPosH]/nTaxaMoeda),2)
						Else
							aCOLSSE2[Len(aColsSE2)][3]	+=	aCOLSSE2[Len(aColsSE2)][nPosH]
						EndIf
					EndIf
					// Tratamento para visualizacao dos valores calculados pelo motor de tributos genericos
					If (nPosH := aScan (aHeadSE2, {|x| AllTrim (x[2])=="F2D_VALOR"}))<>0
						If nMoedaCor <> 1
							aCOLSSE2[Len(aColsSE2)][3]	+=	NoRound((aCOLSSE2[Len(aColsSE2)][nPosH]/nTaxaMoeda),2)
						Else
							aCOLSSE2[Len(aColsSE2)][3]	+=	aCOLSSE2[Len(aColsSE2)][nPosH]
						EndIf	
					EndIf
				EndIf
			EndIf
		Next nX

	Case !Empty(aRecSE1)
		For nX	:= 1 To Len(aRecSE1)
			dbSelectArea("SE1")
			MsGoto(aRecSE1[nX])
			cNatureza	:= SE1->E1_NATUREZ
			nMoedaCor	:= SE1->E1_MOEDA
			nTaxaMoeda  := SF1->F1_TXMOEDA
			If Alltrim(SE1->E1_TIPO)$"NF/"+MV_CRNEG .Or. cPaisLoc!="BRA"
				aadd(aColsSE2,Array(Len(aHeadSE2)+1))
				For nY := 1 To Len(aHeadSE2)
					If IsHeadRec(aHeadSE2[nY][2])
						aColsSE2[Len(aColsSE2)][nY] := SE1->(RecNo())
					ElseIf IsHeadAlias(aHeadSE2[nY][2])
						aColsSE2[Len(aColsSE2)][nY] := "SE1"
					ElseIf aHeadSE2[nY][2] == "F2D_VALOR"
						aColsSE2[Len(aColsSE2)][nY] := CriaVar("F2D_VALOR")
					Else									
						If FieldPos("E1"+SubStr(aHeadSE2[nY,2],3)) > 0	
							aColsSE2[Len(aColsSE2)][nY] := FieldGet(FieldPos("E1"+SubStr(aHeadSE2[nY,2],3)))
        	            EndIf                    
                    EndIf
				Next nY
				aColsSE2[Len(aColsSE2)][Len(aHeadSE2)+1] := .F.
			EndIf
		Next nX
	EndCase
EndIf

If Empty(aColsSE2)
	//Montagem do aCols da Getdados dos titulos a pagar
	aadd(aColsSE2,Array(Len(aHeadSE2)+1))
	For nX := 1 To Len(aHeadSE2)
		If IsHeadRec(aHeadSE2[nX][2])
			aColsSE2[Len(aColsSE2)][nX] := 0
		ElseIf IsHeadAlias(aHeadSE2[nX][2])
			aColsSE2[Len(aColsSE2)][nX] := "SE2"
		ElseIf aHeadSE2[nX][2] == "F2D_VALOR"
			aColsSE2[Len(aColsSE2)][nX] := CriaVar("F2D_VALOR")
		Else
			aColsSE2[Len(aColsSE2)][nX] := CriaVar(aHeadSE2[nX,2],.F.)	
		EndIf
	Next nX
	aColsSE2[Len(aColsSE2)][Len(aHeadSE2)+1] := .F.
Elseif !Empty(aColsSE2) .And. lVisual
	If lMTCOLSE2
		aColsPE:= ExecBlock("MTCOLSE2",.F.,.F.,{aColsSE2,0})
		If ValType(aColsPE) == "A"
			aColsSE2	 := aColsPE
		EndIf
	EndIf
EndIf

dbSelectArea("SE4")
SE4->(dbSetOrder(1))

//Inicializa as variaveis dados dos titulos financeiros
If lVisual
	If SE4->(MsSeek(xFilial("SE4")+cCondicao))
		cDescricao := SE4->E4_DESCRI
	EndIf
Else
	If MaFisFound("NF") .And. !IsInCallStack("A103DEVOL")
		cNatureza := MaFisRet(,"NF_NATUREZA")
		lAltera := IIF(MaFisRet(,"NF_BASEDUP")>0,.T.,.F.)
		
		If SE4->(MsSeek(xFilial("SE4")+cCondicao))
			cDescricao := SE4->E4_DESCRI
		Else
			cDescricao := CriaVar("E4_DESCRI",.F.)
		EndIf
	EndIf
EndIf

If ( oDlg<>Nil )                  
	@ 03,04 SAY RetTitle("F1_COND") Of oDlg PIXEL SIZE 40,09	
	@ 02,45 MSGET oCondicao VAR cCondicao  ;
		PICTURE PesqPict('SF1','F1_COND')  ;
		OF oDlg PIXEL SIZE 22,09 ;
		F3 CpoRetF3('F1_COND') ;
		WHEN VisualSX3('F1_COND');
		VALID Vazio().Or.(cTipo<>'D' .And. NfeCond(cCondicao,@oDescri,@cDescricao) .And. CheckSX3('F1_COND') .And. Eval(bRefresh)) HASBUTTON
	oCondicao:lReadOnly := (IIF((INCLUI .Or. ALTERA) .And. lMt103Get,ExecBlock("MT103GET",.F.,.F.),!lAltera) .And. MaFisFound("NF") .And. cTipo <> "D") .Or. cTipo == 'D'  // O Retorno .T. Do ponto MT103GET impede a edicao do Get
	oCondicao:bLostFocus := { || IIf(!Vazio(cCondicao) .And. cTipo<>'D' .And. !NfeCond2(cCondicao),{oFolder:nOption := 6},"")}
   	
	@ 16,04 SAY RetTitle("E4_DESCRI") Of oDlg PIXEL SIZE 30,09
	@ 15,31 MSGET oDescri VAR cDescricao  PICTURE PesqPict('SE4','E4_DESCRI') OF oDlg PIXEL SIZE 55,09	
	oDescri:lReadOnly := .T.

	@ 29,04 SAY RetTitle("A2_NATUREZ") Of oDlg PIXEL SIZE 41,09
	@ 28,31 MSGET oNatureza VAR cNatureza  ;
		PICTURE PesqPict('SE2','E2_NATUREZ') ;    
		OF oDlg PIXEL SIZE 55,09 ;
		F3 CpoRetF3("E2_NATUREZ") ;
		VALID if(lMt103Nat, if(ExecBlock("MT103NAT",.F.,.F.,cNatureza),NfeVldRef("NF_NATUREZA",cNatureza),.F.),;
  		                     Vazio(cNatureza) .Or. (ExistCpo('SED',cNatureza) .And. A103ValNat(cNatureza) .And. NfeVldRef("NF_NATUREZA",cNatureza) .And. (lChangeNat := .T.))) HASBUTTON
		
		//---------------------------------------------------------------------------------------------------------------------
		// Tratamento realizado pois ao preencher a natureza via consulta padrao e logo em seguida clicar na grid dos itens do
		// documento (SD1), o evento GotFocus da grid eh executado antes do valid do campo, executando a funcao NfeRFldFin()
		// que volta o valor do campo natureza para antes da alteracao (cNatureza := MaFisRet(,"NF_NATUREZA"))
		//---------------------------------------------------------------------------------------------------------------------

		// Se a operação for inclusão ou alteração (Classificação), valida a natureza fiscal mantendo o foco no campo
		If (INCLUI .Or. ALTERA)
			oNatureza:bLostFocus := { || NfeVldRef("NF_NATUREZA",cNatureza) }
		EndIf

	    oNatureza:lReadOnly := IIF((INCLUI .Or. ALTERA) .And. lMt103Get,ExecBlock("MT103GET",.F.,.F.),!lAltera) // O Retorno .T. Do ponto MT103GET impede a edicao do Get

	@ 42,04 SAY oDscMoeda PROMPT RetTitle("F1_MOEDA") Of oDlg PIXEL SIZE 30,09
	@ 41,31 MSGET oMoeda VAR nMoedaCor SIZE 12,09 PIXEL OF oDlg ;
		VALID nMoedaCor<=MoedFin().And. nMoedaCor <> 0 .And. a103AtuTaxa(@nMoedAux)  PICTURE X3Picture("F1_MOEDA") HASBUTTON
	oMoeda:lReadOnly := IIF((INCLUI .Or. ALTERA) .And. lMt103Get,ExecBlock("MT103GET",.F.,.F.),!lAltera) // O Retorno .T. Do ponto MT103GET impede a edicao do Get

	@ 41,45 MSGET oTaxa VAR nTaxaMoeda SIZE 41,09 PIXEL OF oDlg PICTURE X3Picture("F1_TXMOEDA");
		VALID Eval(bRefresh)
	oTaxa:lReadOnly := IIF((INCLUI .Or. ALTERA) .And. lMt103Get,ExecBlock("MT103GET",.F.,.F.),!lAltera .And. nMoedaCor <> 1) // O Retorno .T. Do ponto MT103GET impede a edicao do Get

	@ 52,04 CHECKBOX oTxNeg  VAR lTxNeg PROMPT STR0050 SIZE 100,010 ON CLICK( oTxNeg:Refresh() ) OF oDlg PIXEL
	oTxNeg:lReadOnly := !(INCLUI .Or. ALTERA)
	
	lShowRet := ValType( cModRetPIS ) == "C" .And. !lVisual

	//Ponto de Entrada para Bloquear a edicao do aColsSe2 de Duplicatas
	If lMT103BDP
		l103BDP:=ExecBlock("MT103BDP",.F.,.F.,{})
		If ValType(l103BDP)<>'L'
			l103BDP:=.F.
		EndIf
	EndIf
	
	If lMULNATP .And. !__lPyme    
		//Ponto de Entrada permite quais os campos podem ser editados ou nao
		//na getdados do Rateio das Multiplas Naturezas 
		If lNFEGDSEV
			aNFEGDSEV := ExecBlock("NFEGDSEV", .F., .F.)
			If valtype(aNFEGDSEV) == "A"
				aAltNewGd := aNFEGDSEV
			EndIf		
		EndIf

		oCtaPag  := MsNewGetDados():New(004,090,058,(nPosX/2)+060,IIF(lAltera,GD_UPDATE,0),"NfeLOkSE2","NfeTOkSE2",/*inicpos*/,aCpoHead,/*freeze*/,120,"A103VencSE2()",/*superdel*/,/*delok*/,oDlg,aHeadSE2,aColsSE2)
		If l103BDP
			oCtaPag:oBrowse:lReadOnly:= .T.
		EndIf
		
		oMultNat := MsNewGetDados():New(004,(nPosX/2)+064,058,nPosX+066,IIf(lAltera,GD_INSERT+GD_UPDATE+GD_DELETE,0),"NfeLOkSEV",/*TudoOK*/,/*inicpos*/,aAltNewGd,/*freeze*/,200,/*fieldok*/,/*superdel*/,/*delok*/,oDlg,aHeadSEV,aColsSEV)		
		oMultNat:oBrowse:bLostFocus	:= {|| aColsSEV:=aClone(oMultNat:aCols),;
											NfeMultNat(oMultNat,aColsSE2,aHeadSE2,aColsSEV,aHeadSEV),;
		  							       oFolder:nOption := IIf(lMult, Eval( { || oFoco103:Cargo[2] := .T., oFolder:nOption } ), Eval( { || oFoco103:Cargo[2] := .F.,6 } ) )}
		
		oMultNat:oBrowse:bValid	:= { || NfeTOkSEV(oMultNat:aHeader,oMultNat:aCols,@lMult) } 
	Else
		oCtaPag  := MsNewGetDados():New(004,090,058,nPosX+065,IIF(lAltera,GD_UPDATE,0),"NfeLOkSE2","NfeTOkSE2",/*inicpos*/,aCpoHead,/*freeze*/,120,"A103VencSE2()",/*superdel*/,/*delok*/,oDlg,aHeadSE2,aColsSE2)
		
		If l103BDP
			oCtaPag:oBrowse:lReadOnly:= .T.
		EndIf
	EndIf

	If lShowRet
		@ 004,nPosX+068 BUTTON STR0054 SIZE 30,11 FONT oDlg:oFont ; // "Retencao"
			ACTION A103CalcRt(aColsSE2,aHeadSE2,@cModRetPIS,lPccBaixa) OF oDlg PIXEL
	EndIf				

	@ IIF(lShowRet,015,004),nPosX+068 BUTTON STR0055 MESSAGE STR0056 SIZE 30,11 FONT oDlg:oFont ;
	ACTION NfeRatImp(oCtaPag,nMoedaCor,aColsSE2,aHeadSE2,aColTrbGen,nColsSE2,cIdsTrGen) OF oDlg PIXEL // "Rat.Imp.", "Rateio de Impostos Financeiros"

	@ IIF(lShowRet,026,015),nPosX+068 BUTTON STR0235 MESSAGE STR0236 SIZE 30,11 FONT oDlg:oFont ;
	ACTION NfeDedImp() OF oDlg PIXEL // "Deduções", "Deduções de Impostos"
	
	If Type( "oFoco103" ) == "O" .And. cCONFDUP == "1" 
		//Esta secao verifica para qual objeto a getdados do financeiro perdeu o foco
		//Se perder o foco para o objeto oFoco103 ( dummy ) localizado na confirmacao da dialog		
		//marca a variavel de controle da Dialog como .F. impedindo o fechamento da janela caso				
		//a TudoOk da getdados retorne .F.						
		oCtaPag:oBrowse:bLostFocus	:= {|nHand| NfeMultNat(oMultNat,aColsSE2,aHeadSE2,aColsSEV,aHeadSEV),oFolder:nOption := IIf(NfeTotFin(oCtaPag:aHeader,oCtaPag:aCols,IIf(cLimRec=="3",.F.,.T.),@lRecalc,nColsSE2,aColTrbGen),oFolder:nOption, Eval( { |nHand| oFoco103:Cargo[1] := !( nHand == oFoco103:hWnd ),6 }, nHand ) ),aColsSE2:=oCtaPag:aCols }
	Else		
		oCtaPag:oBrowse:bLostFocus	:= {|| NfeMultNat(oMultNat,aColsSE2,aHeadSE2,aColsSEV,aHeadSEV),oFolder:nOption := IIf(NfeTotFin(oCtaPag:aHeader,oCtaPag:aCols,IIf(cLimRec=="3",.F.,.T.),@lRecalc,nColsSE2,aColTrbGen),oFolder:nOption,6),aColsSE2:=oCtaPag:aCols }	
	EndIf 	

EndIf

If lCalcula
	Eval(bRefresh)
EndIf

If lAuto103 .And. cTipo == "N" .And. SED->ED_CALCIRF == 'S' .And. (SA2->A2_TIPO == 'F' .Or. SA2->A2_IRPROG =='1')
	If MaFisFound("NF") .And. MaFisRet(,"NF_BASEDUP")<>0
		If nMoedaCor == 1
			nValor := NoRound(xMoeda(MaFisRet(,"NF_BASEDUP"),MaFisRet(,"NF_MOEDA"),nMoedaCor,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA")),2)
		Else
			nValor := Round(xMoeda(MaFisRet(,"NF_BASEDUP"),MaFisRet(,"NF_MOEDA"),nMoedaCor,dDEmissao,nDecTaxa,Nil,MaFisRet(,"NF_TXMOEDA")),2)
		EndIf
	
		nValIpi := Iif( nValor > 0, NoRound(xMoeda(MaFisRet(,"NF_VALIPI") ,MaFisRet(,"NF_MOEDA"),nMoedaCor,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA")),2), 0 )
		nValSol	:= Iif( nValor > 0, NoRound(xMoeda(MaFisRet(,"NF_VALSOL") ,MaFisRet(,"NF_MOEDA"),nMoedaCor,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA")),2), 0 )
		aVencto	:= Condicao(nValor,cCondicao,nValIpi,dDEmissao,nValSol)
		dVencReal:= aVencto[1][1]
		MaRecIR(dVencReal)
		nIrrf	:= MaFisRet(,"NF_VALIRR")
	EndIf	
EndIf

nTaxa:= nTaxaMoeda
RestArea(aArea)

Return oCtaPag

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeRatImp ³Autor  ³Alexandre Inacio Lemes ³ Data ³13/10/2004 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Faz o rateio dos impostos do folder de duplicatas pelo valor ³±±
±±³          ³das parcelas do titulo.                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ MATA103                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function NfeRatImp(oCtaPag,nMoedaCor,aColsSE2,aHeadSE2,aColTrbGen,nColsSE2,cIdsTrGen)

Local aRateio   := {0,0,0,0,0,0,0}
Local aCols     := {}
Local aTribGen  := {}
Local nPValor   := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_VALOR"})
Local nPIRRF    := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_IRRF"})
Local nPISS     := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_ISS"})
Local nPINSS    := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_INSS"})
Local nPPIS     := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_PIS"})
Local nPCOFINS  := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_COFINS"})
Local nPCSLL    := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_CSLL"})
Local nPSEST    := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_SEST"})
Local nPosValTrb:= 0
Local nX        := 0
Local nZ        := 0
Local nValor    := 0
Local nIrrf		:= 0
Local nIss	    := 0
Local nInss	    := 0
Local nPis      := 0
Local nCofins   := 0
Local nCsll     := 0 
Local nSEST		:= 0
Local lISSNat	:= .T.
Local cNatNF	:= ""
Local lISSTes	:= SuperGetMv("MV_ISSRETD",.F.,.F.)
Local lTrbGen   := IIf(FindFunction("ChkTrbGen"),ChkTrbGen("SD1", "D1_IDTRIB"),.F.) // Verificacao se pode ou nao utilizar tributos genericos
Local cINSSAd	:= "0"

Default cIdsTrGen := ""

//Rateio do Impostos Financeiros
If MaFisFound("NF") .And. MaFisRet(,"NF_BASEDUP")<>0

	//Verifica se deve existir o calculo do ISS pela natureza do titulo
	cNatNF := MaFisRet(,"NF_NATUREZA")
	
	//Verifica se deve existir o calculo do ISS pela natureza do titulo, TES ou Conf. Tributos
	If FindFunction("A103FinIss")
		lISSNat := A103FinIss(cNatNF, cIdsTrGen, @__lIssMR)
	Else
		dbSelectArea("SED")
		If SED->(dbSeek(xFilial("SED")+cNatNF))
			lISSNat := SED->ED_CALCISS <> "N" .Or. lISSTes
		Endif
	EndIf

	If Type("aBaseDup")=="U" .Or. aBaseDup==Nil
		aBaseDup := {MaFisRet(,"NF_BASEDUP"),0}
	EndIf
	
	cINSSAd	:=	MaFisScan("NF_VALINA",.F.)

	nValor  := NoRound(xMoeda(MaFisRet(,"NF_BASEDUP"),MaFisRet(,"NF_MOEDA"),nMoedaCor,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA")),2)
	nIrrf	:= MaFisRet(,"NF_VALIRR")
	nIss	:= A103CalIss(lISSNat, __lIssMR)
	nInss   := MaFisRet(,"NF_VALINS")+Iif(cINSSAd<>"0",MaFisRet(,"NF_VALINA"),0)
	nPis    := MaFisRet(,"NF_VALPIS")
	nCofins := MaFisRet(,"NF_VALCOF")
	nCsll   := MaFisRet(,"NF_VALCSL")
	nSEST	:= MaFisRet(,"NF_VALSES")
	// Retorna valores calculados pelo motor de tributos genericos
	If lTrbGen .And. !Empty(cNatNF)
		aTribGen := MaFisRet(,"NF_TRIBGEN")
		For nZ := 1 To Len(aColTrbGen)
			aAdd(aRateio,0)
		Next nZ
	EndIf

	aCols := IIf(oCtaPag<>Nil,oCtaPag:aCols,aCols)
	
	For nX := 1 To Len(aCols)
		If nPIRRF <> 0
			aCols[nX][nPIRRF] := IIf(nX==Len(aCols),nIRRF-aRateio[1],NoRound(nIRRF*aCols[nX][nPValor]/nValor,2))
			aRateio[1] += aCols[nX][nPIRRF]
		EndIf
		If nPISS <> 0
			aCols[nX][nPISS] := IIf(nX==Len(aCols),nISS -aRateio[2],NoRound(nISS*aCols[nX][nPValor]/nValor,2))
			aRateio[2] += aCols[nX][nPISS]
		EndIf
		If nPINSS <> 0
			aCols[nX][nPINSS] := IIf(nX==Len(aCols),nINSS-aRateio[3],NoRound(nINSS*aCols[nX][nPValor]/nValor,2))
			aRateio[3] += aCols[nX][nPINSS]
		EndIf
		If nPPIS <> 0
			aCols[nX][nPPIS] := IIf(nX==Len(aCols),nPIS-aRateio[4],NoRound(nPIS*aCols[nX][nPValor]/nValor,2))
			aRateio[4] += aCols[nX][nPPIS]
		EndIf
		If nPCOFINS <> 0
			aCols[nX][nPCOFINS] := IIf(nX==Len(aCols),nCOFINS-aRateio[5],NoRound(nCOFINS*aCols[nX][nPValor]/nValor,2))
			aRateio[5] += aCols[nX][nPCOFINS]
		EndIf
		If nPCSLL <> 0
			aCols[nX][nPCSLL] := IIf(nX==Len(aCols),nCSLL-aRateio[6],NoRound(nCSLL*aCols[nX][nPValor]/nValor,2))
			aRateio[6] += aCols[nX][nPCSLL]
		EndIf
		If nPSEST <> 0
			aCols[nX][nPSEST] := IIf(nX==Len(aCols),nSEST-aRateio[7],NoRound(nSEST*aCols[nX][nPValor]/nValor,2))
			aRateio[7] += aCols[nX][nPSEST]
		EndIf		
		// Rateia os valores gerados pelo motor de tributos genericos
		For nZ := 1 To Len(aTribGen)
			If (nPosValTrb := aScan(aColTrbGen,{|x| x[1] == aTribGen[nZ][1]}) ) > 0
				aCols[nX][nColsSE2+nPosValTrb] := IIf(nX==Len(aCols),aTribGen[nZ][3]-aRateio[7+nPosValTrb],NoRound(aTribGen[nZ][3]*aCols[nX][nPValor]/nValor,2))
				aRateio[7+nPosValTrb] += aCols[nX][nColsSE2+nPosValTrb]
			EndIf
		Next nZ
	Next nX

	If oCtaPag<>Nil
		If !Empty(aCols)
			oCtaPag:aCols := aCols
		EndIf
		oCtaPag:nAt   := 1
		oCtaPag:Refresh()
	EndIf
			
EndIf

Return( .T. ) 

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeMultNat³Autor  ³Alexandre Inacio Lemes ³ Data ³05/07/2004 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Rotina de recalculo do valor rateado em multiplas Naturezas. ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ MATA103                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Static Function NfeMultNat(oMultNat,aColsSE2,aHeadSE2,aColsSEV,aHeadSEV)

Local nPValSEV  := aScan(aHeadSEV,{|x| AllTrim(x[2])=="EV_VALPERC"})
Local nPercSEV  := aScan(aHeadSEV,{|x| AllTrim(x[2])=="EV_PERC"})
Local nPValor   := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_VALOR"})
Local nPIRRF    := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_IRRF"})
Local nPISS     := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_ISS"})
Local nPINSS    := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_INSS"})
Local nPPIS     := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_PIS"})
Local nPCOFINS  := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_COFINS"})
Local nPCSLL    := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_CSLL"})
Local nValor    := 0 
Local nValISS   := 0
Local nValIRRF  := 0
Local nValINSS  := 0
Local nValPIS   := 0
Local nValCOF   := 0
Local nValCSLL  := 0
Local nY        := 0
Local nValFun   := 0
Local nMultDec  := GetNewPar( "MV_MULTDEC", 2 ) 
Local nValFet   := Iif( MaFisFound("NF") , MaFisRet(,"NF_VALFET") , 0 )
Local lMT103SEV := ExistBlock("MT103SEV")

If MaFisFound("NF")
	nValFun := MaFisRet(,"NF_FUNRURAL")
EndIf

//Utilizado para manipular naturezas
If oMultNat<>Nil
	If lMT103SEV
		aColsSEV := ExecBlock("MT103SEV",.F.,.F.,{aHeadSEV,aColsSEV})
		If !Empty(aColsSEV)
			oMultNat:aCols := aClone(aColsSEV)
		EndIf
		oMultNat:Refresh()
	Endif
EndIf

//Verifica se ha necessidade da gravacao das multiplas naturezas
If nPValSEV > 0

	If oMultNat<>Nil
	   aColsSEV := aClone(oMultNat:aCols)
	EndIf

	aEval(aColsSE2,{|x| nValor   += x[nPValor] })
	aEval(aColsSE2,{|x| nValISS  += x[nPISS]   })
	aEval(aColsSE2,{|x| nValIRRF += x[nPIRRF]  })
	aEval(aColsSE2,{|x| nValINSS += x[nPINSS]  })
	aEval(aColsSE2,{|x| nValPIS  += x[nPPIS]   })
	aEval(aColsSE2,{|x| nValCOF  += x[nPCOFINS]})
	aEval(aColsSE2,{|x| nValCSLL += x[nPCSLL]  })

    nValor := nValor-nValISS-nValIRRF-nValINSS-nValPIS-nValCOF-nValCSLL
	
	nRateio := 0
	For nY := 1 To Len(aColsSEV)
		If !aColsSEV[nY][Len(aColsSEV[1])] .And. !Empty(aColsSEV[nY][1])
			aColsSEV[nY][nPValSEV] := IIf(nY==Len(aColsSEV),nValor-nValFun-nValFet-nRateio,NoRound(nValor*aColsSEV[nY][nPercSEV]/100,nMultDec))
			nRateio += aColsSEV[nY][nPValSEV]
		EndIf
	Next nY
	
	If oMultNat<>Nil
		If !Empty(aColsSEV)
			oMultNat:aCols := aClone(aColsSEV)
		EndIf
		oMultNat:Refresh()
	EndIf
EndIf

Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeRFldFin³Autor  ³ Eduardo Riera         ³ Data ³12.12.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de atualizacao dos dados do folder financeiro do      ³±±
±±³          ³documento de entrada                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Condicao de Pagamento                                 ³±±
±±³          ³ExpC2: Descricao da condicao de pagamento                    ³±±
±±³          ³ExpC3: Natureza                                              ³±±
±±³          ³ExpN4: Codigo da Moeda                                       ³±±
±±³          ³ExpN5: Taxa da moeda                                         ³±±
±±³          ³ExpO6: Objeto da condicao de pagamento                       ³±±
±±³          ³ExpO7: Objeto da natureza                                    ³±±
±±³          ³ExpO8: Objeto da Moeda                                       ³±±
±±³          ³ExpO9: Objeto da taxa da moeda                               ³±±
±±³          ³ExpOA: Objeto da descricao da moeda                          ³±±
±±³          ³ExpOB: Objeto da getdados do titulos financeiros             ³±±
±±³          ³ExpLC: Indica se a rotina esta em modo de inclusao           ³±±
±±³          ³ExpAD: ACols com as parcelas dos titulos financeiros         ³±±
±±³          ³ExpAE: AHeader das parcelas dos titulos financeiros          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo atualizar os dados do folder   ³±±
±±³          ³financeiro do documento de entrada                           ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function NfeRFldFin(cCondicao,cDescricao,cNatureza,nMoeda,nTaxa,oCondicao,oNatureza,oMoeda,oTaxa,oDscMoeda,oCtaPag,oMultNat,lInclui,aColsSE2,aHeadSE2,aColsSEV,aHeadSEV,oDescri,oTxNeg,cLimRec,lRecalc,nValDupAnt,aColTrbGen,aParcTrGen,nColsSE2,cIdsTrGen)

Local nValor    := 0
Local nValIpi	:= 0
Local nValSol	:= 0
Local nTotDup   := 0
Local nTotIRF   := 0
Local nTotINSS  := 0
Local nTotISS   := 0
Local nTotPIS   := 0
Local nTotCOF   := 0
Local nTotCSLL  := 0
Local nTotSEST	:= 0
Local nTotFet	:= 0
Local nTotFab	:= 0
Local nTotFac   := 0
Local nTotIMA   := 0
Local nTotFAM   := 0
Local nTotBTISS	:= 0
Local nTribGen  := 0
Local nTotTrbGen:= 0
Local nX        := 0
Local nY        := 0
Local nZ        := 0
Local nPParcela := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_PARCELA"})
Local nPVencto  := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_VENCTO"})
Local nPValor   := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_VALOR"})
Local nPIRRF    := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_IRRF"})
Local nPISS     := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_ISS"})
Local nPINSS    := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_INSS"})
Local nPPIS     := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_PIS"})
Local nPCOFINS  := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_COFINS"})
Local nPCSLL    := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_CSLL"})
Local nPValSEV  := aScan(aHeadSEV,{|x| AllTrim(x[2])=="EV_VALPERC"})
Local nPercSEV  := aScan(aHeadSEV,{|x| AllTrim(x[2])=="EV_PERC"})
Local nPSEST    := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_SEST"})
Local nPFETHAB  := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_FETHAB"})
Local nPFABOV 	:= aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_FABOV"})
Local nPFACS  	:= aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_FACS"})
Local nPIMA  	:= aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_IMA"})
Local nPFAMAD  	:= aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_FAMAD"})
Local nPBTISS  	:= aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_BTRISS"})
Local nValSEV   := 0
Local nValFun   := 0
Local nValFet   := 0
Local nValFab   := 0
Local nValFac	:= 0
Local nValIMA	:= 0
Local nValFAMAD := 0
Local nIrrf		:= 0
Local nInss	    := 0
Local nIss	    := 0
Local nPis      := 0
Local nCofins   := 0
Local nCsll     := 0
Local nSEST		:= 0
Local nValBTISS	:= 0
Local nUsadoSE2 := Len(aHeadSE2)
Local nMultDec  := GetNewPar( "MV_MULTDEC", 2 ) 
Local nTamParc  := TamSx3("E2_PARCELA")[1]
Local nDecTaxa  := TamSX3("F1_TXMOEDA")[2]
Local nPosNfOri := 0
Local nPosSerOri:= 0
Local nPosVec    := aScan(aHeadSE2, { |x| AllTrim(x[02]) == "E2_VENCTO"})
Local nPosValTrb:= 0
Local cNfOri	:= ""
Local cSerOri	:= ""
Local aColsTit	:= IIF(Type('lMoedTit')=='L' .And. lMoedTit,Iif(ValType(aCols)=="A",aClone(aCols),Iif(ValType(aColsNF)=="A",aClone(aColsNF),{})),{})
Local dDataTit	:= dDEmissao
Local cAliasBkp	:= ""
Local aD1Bkp	:= aClone(aCols)
Local aCols     := {}
Local aColsDup  := {}
Local aColsPE   := {}
Local aVencto   := {}
Local a103Cnd2  := {}
Local aRateio   := {0,0,0,0,0,0,0,0}
Local cParcela  := SuperGetMV("MV_1DUP") 
Local aRatBasTG := {}
Local aTribGen  := {}
Local cMT103NTZ
Local lVencto   := .F.
Local cCampo    := IIF(FwIsInCallStack("NFEDELITEM"),"CCONDICAO",ReadVar())
Local cMoeda    := "" 
Local lMT103GET  := Existblock("MT103GET")
Local lMT103TXPC:= ExistBlock("MT103TXPC")
Local lRatIRRF	:= SuperGetMV("MV_RATIRRF",.F.,.T.)
Local lRatISS	:= SuperGetMV("MV_RATISS",.F.,.T.)
Local lRatINSS	:= SuperGetMV("MV_RATINSS",.F.,.T.)
Local lRatSEST	:= SuperGetMV("MV_RATSEST",.F.,.T.)
Local lRatPIS	:= SuperGetMV("MV_RATPIS",.F.,.T.) 
Local lRatCOFINS:= SuperGetMV("MV_RATCOF",.F.,.T.)  
Local lRatCSLL	:= SuperGetMV("MV_RATCSLL",.F.,.T.) 
Local lISSNat	:= .T.
Local lISSTes	:= SuperGetMv("MV_ISSRETD",.F.,.F.)
Local lChkDup	:= .F.
Local lDupNew   := .F.
Local lTrbGen   := IIf(FindFunction("ChkTrbGen"),ChkTrbGen("SD1", "D1_IDTRIB"),.F.) .And. FindFunction("FinParcFKK") .And. FindFunction("A103TrbGen") .And. FindFunction("A103AtuTrG") // Verificacao se pode ou nao utilizar tributos genericos
Local cINSSAd	:= "0"
Local bCondLim  := { || .T. }
Local aDadosPC := {}
Local nTotNF	:= 0
Local nI		:= 0
Local nTotRDF	:= 0
LOCAL lExcRetorno := .F.
Local lAv1DUPNAT  := .F.
Local lMTCOLSE2	  := ExistBlock("MTCOLSE2")
Local lA103VLR	 := ExistBlock("A103VLR")
Local lMVNFENAT	:= SuperGetMV("MV_NFENAT",.F.,.F.)
Local c1DUPNAT	:= SuperGetMV("MV_1DUPNAT",.F.,"")
Local c2DUPNAT	:= SuperGetMV("MV_2DUPNAT",.F.,"")
Local lMT103NTZ	:= ExistBlock("MT103NTZ")
Local cTXMOENC	:= SuperGetMv("MV_TXMOENC",.F.,"1")
Local lA103VCTO	:= ExistBlock("A103VCTO")
Local nLIMPAG	:= SuperGetMV("MV_LIMPAG")
Local lA103CND2	:= ExistBlock("A103CND2")
Local c1DUPREF	:= SuperGetMV("MV_1DUPREF")
Local lA1031DUP	:= ExistBlock("A1031DUP")
Local lMT103DUP	:= ExistBlock("MT103DUP")
Local nD1Tes	:= 0
Local nD1Ret	:= 0
Local nD1Ded	:= 0
Local nD1Fat	:= 0
Local nD1Tot	:= 0
Local nE2Vlr	:= 0
Local cNatBloq	:= ""
Local nPosicao  As Numeric
Local lAuto103 	As Logical

DEFAULT cNatureza  := CriaVar("E2_NATUREZ",.F.)
DEFAULT lInclui    := .F.
DEFAULT cLimRec    := "1"
DEFAULT lRecalc    := .T.
DEFAULT nValDupAnt := 0
DEFAULT aColTrbGen := {}
DEFAULT aParcTrGen := {}
DEFAULT nColsSE2   := 0
DEFAULT cIdsTrGen	:= ""

//Inicializa variáveis.
nPosicao := 0
lAuto103 :=  (Type("l103Auto") <> "U" .And. (l103Auto))

If Type('l103Auto')=='U'
	Private l103Auto  := .F.
Endif

//Atualiza o array aColsNF
aColsNF:= {}

//Atualizar o valor das duplicatas ao vincular um pedido de compra.
If empty(cCampo) .and. FwIsInCallStack("NfePC2Acol")
	cCampo := "CCONDICAO"
Endif

//Obtem a natureza do cadastro de fornecedores
If lInclui
	//Ponto de entrada para alterar valor da Duplicata
	If lA103VLR .And. MaFisFound("NF")
		nValor := ExecBlock("A103VLR",.F.,.F.)
		If nValor <> MaFisRet(,"NF_BASEDUP")
			MaFisAlt("NF_BASEDUP",nValor) 
		EndIf
	EndIf
	
	If MaFisFound("NF")
		If Type("lTOPDRFRM") <> "U" .And. lTOPDRFRM .And. ValType(aD1Bkp) == "A" .And. Len(aD1Bkp) > 0
			nTotNF	:= 0

			cAliasBkp := aD1Bkp[1,Len(aD1Bkp[1])-2]

			If cAliasBkp == "SD1"
				nD1Tes	:= GdFieldPos("D1_TES",aHeadD1)
				nD1Ret	:= GdFieldPos("D1_RETENCA",aHeadD1)
				nD1Ded	:= GdFieldPos("D1_DEDUCAO",aHeadD1)
				nD1Fat	:= GdFieldPos("D1_FATDIRE",aHeadD1)
				nD1Tot	:= GdFieldPos("D1_TOTAL",aHeadD1)

				If nD1Tes > 0 .And. nD1Ret > 0 .And. nD1Ded > 0 .And. nD1Fat > 0
					For nI := 1 To Len(aD1Bkp)
						If !aD1Bkp[nI,Len(aHeadD1)+1]
							If GetAdvFval("SF4","F4_DUPLIC",xFilial("SF4") + aD1Bkp[nI,nD1Tes],1) == "S"
								nTotNF += MaFisRet(nI,"IT_TOTAL")

								nTotRDF += aD1Bkp[nI,nD1Ret]
								nTotRDF += aD1Bkp[nI,nD1Ded]
								nTotRDF += aD1Bkp[nI,nD1Fat]
							Endif
						Endif
					Next nI
				Endif
			Elseif cAliasBkp == "SE2"
				nE2Vlr	:= GdFieldPos("E2_VALOR",aHeader)

				If nE2Vlr > 0
					For nI := 1 To Len(aD1Bkp)
						If !aD1Bkp[nI,Len(aHeader)+1]
							nTotNF += aD1Bkp[nI,nE2Vlr]
						Endif
					Next nI
				Endif
				nTotNF := xMoeda(nTotNF,nMoeda,MaFisRet(,"NF_MOEDA"),dDEmissao,Nil,MaFisRet(,"NF_TXMOEDA"),Nil)
			Endif
			
			nTotNF := nTotNF - nTotRDF
			If nTotNF > 0 .And. nTotNF <> 0
				MaFisRet(,"NF_BASEDUP")
				MaFisAlt("NF_BASEDUP",nTotNF)
			EndIf
		Endif

		//Verifica se deve existir o calculo do ISS pela natureza do titulo, TES ou Conf. Tributos
		If FindFunction("A103FinIss")
			If Empty(cNatureza)
				cNatureza := MaFisRet(,"NF_NATUREZA")
			EndIf
			If !Empty(cNatureza)
				If lAuto103
					If lTrbGen
						aTribGen := MaFisRet(,"NF_TRIBGEN")	// Retorna os valores calculados pelo motor	
						If Len(aTribGen) > 0
							If (nPosicao := AScan(aTribGen, {|IDIMPOS| AllTrim(IDIMPOS[11]) == "000020"})) > 0 .And. !Empty(aTribGen[nPosicao,4])
								__lIssMR	:= .T.
							EndIf
						EndIf
					EndIf
				EndIf
				lISSNat := A103FinIss( cNatureza, cIdsTrGen, @__lIssMR )
			EndIf
		Else
			dbSelectArea("SED")
			If SED->(dbSeek(xFilial("SED")+cNatureza))
				lISSNat := SED->ED_CALCISS <> "N" .Or. lISSTes
			EndIf
		EndIf        

		If Empty(cNatureza)
			If ( cTipo$'DB' .Or. A103RtCliRT(cTipo, cTpCompl, cFormul) )
				lAv1DUPNAT := .T.
			EndIf
			
			//Correção posicionamento SC5
			If lMVNFENAT .And. "C5_NATUREZ" $ c1DUPNAT
				lAv1DUPNAT:= FwIsInCallStack("A103PROCDV")
				aAreaSD2x := SD2->(GetArea())
				nPosNfOri := aScan(aHeader,{|x| AllTrim(x[2]) == "D1_NFORI"} )
				If Type("aColSD1") == "A" .And. Len(aColSD1) > 0 .And. nPosNfOri > 0
					If !Empty(aColSD1[1][nPosNfOri])
						nPosSerOri := aScan(aHeader,{|x| AllTrim(x[2]) == "D1_SERIORI"} )
						SD2->(DbSetOrder(3))
						SD2->(DbGoTop())
						If  nPosSerOri > 0 .And. SD2->(DbSeek(xFilial("SD2")+aColSD1[1][nPosNfOri]+aColSD1[1][nPosSerOri]+cA100For+cLoja))
							DbSelectArea("SC5")
							SC5->(DbSetOrder(3))
							If SC5->(DbSeek(xFilial("SC5")+SD2->D2_CLIENTE+SD2->D2_LOJA+SD2->D2_PEDIDO))
								If cTipo == "N" .And. SC5->C5_TIPO == "B"	//Retorno de Beneficiamento
									lAv1DUPNAT := .T.
									lExcRetorno	:= .T.
								Elseif cTipo == "D" .And. SC5->C5_TIPO == "N" //Devolução
								     lAv1DUPNAT := .T.
								Endif 	     
							EndIf
						EndIf
					EndIf
				EndIf
				RestArea(aAreaSD2x)
			EndIf
			
			//Utiliza MacroSubstituição referente MV_1DUPNAT por se tratar de
			//Devolução OU Beneficiamento OU NF de Retorno referente SAÍDA de Beneficiamento
			If lAv1DUPNAT
				cNatureza := &(c1DUPNAT)
				
				//lExcRetorno = .T., NF do Tipo Normal, executa MacroSubstituição
				//da MV_2DUPNAT - Relacionado a Entrada - Fornecedor
				If Empty(cNatureza) .AND. lExcRetorno
					cNatureza := &(c2DUPNAT)
				EndIf
				
				If !Empty(cNatureza)
					MaFisAlt("NF_NATUREZA",cNatureza)
				EndIf
			Else
				cNatureza := &(c2DUPNAT)
				If !Empty(cNatureza)
					MaFisAlt("NF_NATUREZA",cNatureza)
				EndIf
			EndIf
		Else
			cNatureza := MaFisRet(,"NF_NATUREZA")
		EndIf

		If !Empty(cNatureza)
			cNatBloq := GetAdvFval("SED","ED_MSBLQL", fwxFilial("SED") + cNatureza,1)
			If cNatBloq == "1" //Registro bloqueado
				cNatureza	:= CriaVar("E2_NATUREZ",.F.)
				MaFisAlt("NF_NATUREZA",cNatureza)
			Endif
		Endif

		If SED->ED_CALCIRF=='N'
			nCombo	:= 2
			cCodRet := ''
		EndIf		

		//Ponto de Entrada para selecionar a natureza no Documento de Entrada
		If lMT103NTZ
			cMT103NTZ  := ExecBlock("MT103NTZ",.F.,.F.,{cNatureza})    
			If ( ValType(cMT103NTZ ) == 'C' )
			  	dbSelectArea("SED")
				If SED->(dbSeek(xFilial("SED")+cMT103NTZ)) 
					cNatureza := cMT103NTZ
					MaFisAlt("NF_NATUREZA",cNatureza)
				EndIf
			EndIf
		EndIf
	EndIf
	
	//Atualiza a descricao da condicao de pagamento
	If !Empty(cCondicao) 
		dbSelectArea("SE4")
		dbSetOrder(1)
		If ( MsSeek(xFilial("SE4")+cCondicao) )
			cDescricao	:= SE4->E4_DESCRI
	EndIf
			Else
		cDescricao := " "

	EndIf
	
	//Verifica parâmetro MV_MOEDTIT para gerar devolução NCC na mesma moeda e taxa do título original
	If Type('lMoedTit')=='L' .And. lMoedTit .And. cTipo == "D" .And. cTXMOENC == "1"
		nPosNfOri := aScan(aHeader,{|x| AllTrim(x[2]) == "D1_NFORI"} )
		nPosSerOri:= aScan(aHeader,{|x| AllTrim(x[2]) == "D1_SERIORI"} )
		
		If len(aColsTit)>=1 .And. nPosNfOri > 0
			If len(aColsTit[1]) >= nPosNfOri
				cNfOri := aColsTit[1][nPosNfOri]
			EndIf
		EndIf

		If len(aColsTit)>=1 .And. nPosSerOri > 0
			If len(aColsTit[1]) >= nPosSerOri
				cSerOri := aColsTit[1][nPosSerOri]
			EndIf
		EndIf

		IF !Empty(cNfOri)

			DbSelectArea("SF2")
			DbSetOrder(1)
			If MsSeek(xFilial("SF2") + cNfOri + cSerOri)
				cSerOri := IIf(Empty(SF2->F2_PREFIXO),&(c1DUPREF),SF2->F2_PREFIXO)
				cSerOri := PadR( cSerOri, Len( SE1->E1_PREFIXO ) )
		    EndIf
		    
			DbSelectArea("SE1")
			DbSetOrder(2)
            cSerOri := Substr(cSerOri,1,3)
			MsSeek(xFilial("SE1")+cA100For+cLoja+cSerOri+cNfOri)
			While !Eof() .And. xFilial("SE1") == SE1->E1_FILIAL .And.;
					cA100For == SE1->E1_CLIENTE .And.;
					cLoja	 == SE1->E1_LOJA    .And.;
					cSerOri	 == SE1->E1_PREFIXO .And.;
					cNfOri	 == SE1->E1_NUM
				If SE1->E1_TIPO == "NF " .And. SE1->E1_MOEDA > 0 .And. SE1->E1_EMISSAO <> CTOD('  /  /  ')
					nMoedaCor := SE1->E1_MOEDA
					nMoeda	  := nMoedaCor
					If !Empty(SF2->F2_DTTXREF)
						dDataTit := SF2->F2_DTTXREF
					Else
						dDataTit := SE1->E1_EMISSAO
						lBlqTxNeg:= .F.
						nValFat  := SF2->F2_VALFAT
					EndIf
					nTaxa	  := 0
					MaFisAlt("NF_TXMOEDA",nTaxa)
					Exit
				Endif
				SE1->(dbSkip())
			EndDo
		EndIf
	EndIf
	
	//Atualiza a taxa da Moeda
	cMoeda := SuperGetMv("MV_MOEDA"+AllTrim(Str(nMoeda,2)))
	If nMoeda <> 1
		If !"NTAXA"$Upper(cCampo) 
		    If ( l103Auto .Or. lMT103TXPC ) .And. nTaxa <> 0
		        MaFisAlt("NF_TXMOEDA",nTaxa)  
			EndIf
		    If (nTaxa == 0 .And. L103Auto) .Or. (!L103Auto)
				nTaxa := MaFisRet(,"NF_TXMOEDA")
			EndIf
			If nTaxa == 0
				nTaxa := RecMoeda(ddatabase,nMoeda)
				nTaxa := xMoeda(1,nMoeda,MaFisRet(,"NF_MOEDA"),IIF(Type('lMoedTit')=='L' .And. lMoedTit,dDataTit,dDEmissao),nDecTaxa)
				MaFisAlt("NF_TXMOEDA",nTaxa)
			Else
				If ("NMOEDA"$Upper(cCampo))
					nTaxa := RecMoeda(dDEmissao,nMoeda)
					MaFisAlt("NF_TXMOEDA",nTaxa)
			 	EndIf
			EndIf
		Else
			MaFisAlt("NF_TXMOEDA",nTaxa)
		EndIf
	Else
		nTaxa := 0
		nTaxa := RecMoeda(ddatabase,nMoeda)
		MaFisAlt("NF_TXMOEDA",nTaxa)
	EndIf
	
	cINSSAd	:=	MaFisScan("NF_VALINA",.F.)
	
	//Atualiza a getdados dos titulos financeiros
	If !Empty(cCondicao) .And. MaFisFound("NF") .And. MaFisRet(,"NF_BASEDUP")<>0
		If nMoeda == 1
			nValor := NoRound(xMoeda(MaFisRet(,"NF_BASEDUP"),MaFisRet(,"NF_MOEDA"),nMoeda,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA")),2)
		Else
			nValor := Round(xMoeda(MaFisRet(,"NF_BASEDUP"),MaFisRet(,"NF_MOEDA"),nMoeda,dDEmissao,nDecTaxa,Nil,MaFisRet(,"NF_TXMOEDA")),2)
		EndIf
		
		If Type("aBaseDup")=="U" .Or. aBaseDup==Nil
			aBaseDup := {MaFisRet(,"NF_BASEDUP"),0}
		EndIf
		
		nValFun := MaFisRet(,"NF_FUNRURAL")
		nValFet := IIf(MaFisRet(,"NF_RECFET")=="2",MaFisRet(,"NF_VALFET"),0) 		 
		nValFab := IIf(MaFisRet(,"NF_RECFAB")=="2",MaFisRet(,"NF_VALFAB"),0)				
		nValFac := IIf(MaFisRet(,"NF_RECFAC")=="2",MaFisRet(,"NF_VALFAC"),0)
		nValIMA := IIf(MaFisRet(,"NF_RECIMA")=="2",MaFisRet(,"NF_VALIMA"),0)
		nValFAMAD := IIf(MaFisRet(,"NF_RECFMD")=="2",MaFisRet(,"NF_VALFMD"),0)		
		nIrrf	:= MaFisRet(,"NF_VALIRR")
		nInss   := MaFisRet(,"NF_VALINS")+Iif(cINSSAd<>"0",MaFisRet(,"NF_VALINA"),0)
		nIss	:= A103CalIss(lISSNat, __lIssMR)
		nPis    := MaFisRet(,"NF_VALPIS")
		nCOFINS := MaFisRet(,"NF_VALCOF")
		nCSLL   := MaFisRet(,"NF_VALCSL")		
		nSEST	:= MaFisRet(,"NF_VALSES")
		nValBTISS := MaFisRet(,"NF_VALCPM")
		nValIpi := Iif( nValor > 0, NoRound(xMoeda(MaFisRet(,"NF_VALIPI") ,MaFisRet(,"NF_MOEDA"),nMoeda,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA")),2), 0 )
		nValSol	:= Iif( nValor > 0, NoRound(xMoeda(MaFisRet(,"NF_VALSOL") ,MaFisRet(,"NF_MOEDA"),nMoeda,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA")),2), 0 )
		
		If lTrbGen	// Verifica se o sistema esta preparado para utilizar o motor de tributos genericos
			aTribGen := MaFisRet(,"NF_TRIBGEN")	// Retorna os valores calculados pelo motor
		EndIf
		
		aVencto	:= Condicao(nValor,cCondicao,nValIpi,dDEmissao,nValSol)

		//Quando altero a data de vencimento do titulo, atualiza o array de duplicatas
		If cCampo == "M->E2_VENCTO" .And. ValType(aVencto) == "A"
		  // Caso algumas das parcelas esta com a data diferente permanece a data Digitada. 
			If Len(aVencto) == Len(aColsSe2) 
				For nX := 1 To Len (aVencto) 
					If aVencto[nX][1] <> aColsSe2[nX][nPosVec] .And. CTOD('  /  /  ') <> aColsSe2[nX][nPosVec]
						aVencto[1][1] := aColsSe2[nX][nPosVec]
					EndIf
				Next nX
			Else	 
				aVencto[1][1] := M->E2_VENCTO
			EndIf	

		ElseIf cCampo!="CCONDICAO" .And. Type('dNewVenc')=='D' .And. dNewVenc != CTOD('  /  /  ') .And. len(aVencto) > 0 .And. cCampo!="DDEMISSAO"
			aVencto[1][1] := dNewVenc
		ElseIf cCampo=="CCONDICAO" .And. Type('dNewVenc')=='D' .And. dNewVenc != CTOD('  /  /  ')
			dNewVenc := aVencto[1][1]
		EndIf

		If lA103VCTO
        	aDadosPC:=ExecBlock("A103VCTO",.F.,.F.,{ aClone(aColsSE2),nValor,cCondicao,nValIpi,dDEmissao,nValSol})
        	If ValType(aDadosPC) == "A"
        		If Len(aDadosPC) >= 1
        			If Len(aDadosPc[1])>= 2
        				aVencto := aClone(aDadosPC)
        			EndIf
        		EndIf
        	EndIf
  		EndIf

		nTotDup := 0
		aCols := IIf(oCtaPag<>Nil,oCtaPag:aCols,aCols)
		If Len(aCols)>0
			If aCols[nPParcela][nPValor]<>nValor .And. Len(aVencto) == 1   
				If cLimRec == "1" 
					If Abs(aCols[nPParcela][nPValor]-nValor)>=nLIMPAG .Or. nValor != nValDupAnt
					    aCols[nPParcela][nPValor]:= nValor 
					EndIf
				ElseIf cLimRec == "2"
					If Abs(aCols[nPParcela][nPValor]-nValor)>nLIMPAG .Or. nValor != nValDupAnt
						aCols[nPParcela][nPValor]:= nValor 
					EndIF
				ElseIf cLimRec == "3"
					//---------------------------------------------------------------------------------
					// Documentacao de apoio, atualizar conforme necessidade
					//---------------------------------------------------------------------------------
					// Ao carregar pedido, item de pedido ou editar manualmente os itens do
					// documento, a aba duplicatas será atualizada (validacao nValor != nValDupAnt)
					//
					// MV_LIMREC = 3 significa que nao havera recalculo do painel duplicatas quando o
					// usuario estiver alterando os valores na aba duplicatas (ajustes do usuario antes
					// de salvar). 
					//
					// MV_LIMPAG será validado ao tentar gravar os dados, desde que o MV_CONFDUP=1, caso
					// contrário, o sistema ignora as alteracoes do usuario no valor das duplicatas
					//----------------------------------------------------------------------------------
					If nValor != nValDupAnt
						aCols[nPParcela][nPValor]:= nValor
					EndIf
				EndIF
				If cCampo == "CCONDICAO" .Or. Empty(aCols[nPParcela][nPVencto]) .Or. aCols[nPParcela][nPVencto] == dDataBase .Or. aCols[nPParcela][nPVencto] == aColsSE2[nPParcela][nPVencto]
			    	aCols[nPParcela][nPVencto]:=aVencto[1][1]
			    EndIf
			EndIf
        EndIf
		aEval(aCols,{|x| nTotDup+= x[nPValor] })
		If nPIRRF <> 0
			aEval(aCols,{|x| nTotIRF+= x[nPIRRF] })
		EndIf
		If nPINSS <> 0
			aEval(aCols,{|x| nTotINSS+= x[nPINSS] })
		EndIf
		If nPISS <> 0
			aEval(aCols,{|x| nTotISS+= x[nPISS] })
		EndIf
		If nPPIS <> 0
			aEval(aCols,{|x| nTotPis+= x[nPPIS] })
		EndIf
		If nPCOFINS <> 0
			aEval(aCols,{|x| nTotCof+= x[nPCOFINS] })
		EndIf
		If nPCSLL <> 0
			aEval(aCols,{|x| nTotCsll+= x[nPCSLL] })
		EndIf
		If nPSEST <> 0
			aEval(aCols,{|x| nTotSEST+= x[nPSEST] })
		EndIf
		If nPFETHAB <> 0
			aEval(aCols,{|x| nTotFET+= x[nPFETHAB] })
		EndIf		
		If nPFABOV <> 0
			aEval(aCols,{|x| nTotFAB+= x[nPFABOV] })
		EndIf		
		If nPFACS <> 0
			aEval(aCols,{|x| nTotFAC+= x[nPFACS] })
		EndIf
		If nPIMA <> 0
			aEval(aCols,{|x| nTotIMA+= x[nPIMA] })
		EndIf
		If nPFAMAD <> 0
			aEval(aCols,{|x| nTotFAM+= x[nPFAMAD] })
		EndIf
		If nPBTISS <> 0
			aEval(aCols,{|x| nTotBTISS+= x[nPBTISS] })
		EndIf
		If lTrbGen
			For nZ := 1 To Len(aTribGen)
				If (nPosValTrb := aScan(aColTrbGen,{|x| x[1] == aTribGen[nZ][1]}) ) > 0	// Encontra a coluna da duplicata referente ao tributo generico
					nTribGen += aTribGen[nZ][3]											// Guarda o valor total de tributos genericos passiveis de rentecao
					aEval(aCols,{|x| nTotTrbGen += x[nColsSE2+nPosValTrb] })			// Guarda o valot total dos tributos que constam no aCols de Duplicatas
				EndIf
			Next nZ
		EndIf
		//Quando altero a condicao de pagamento ou data de vencimento recalculo o Valor do IRR
		If Type('dDVencAnt')=='U'
			PRIVATE dDVencAnt := IIf(len(aVencto) > 0,aVencto[1][1],stod("")) 
		Endif 
		If nIrrf > 0
			If cCampo=="CCONDICAO" .And. (Empty(cCondicaoOld) .Or. cCondicao<>cCondicaoOld)
	       		dVencReal:= aVencto[1][1]
				MaRecIR(dVencReal)
				nIrrf	:= MaFisRet(,"NF_VALIRR")
			ElseIf (cCampo == "M->E2_VENCTO" .And. dDVencAnt <> &(cCampo) )
				dVencReal:= &(cCampo)
				MaRecIR(dVencReal)
				nIrrf	:= MaFisRet(,"NF_VALIRR")
			ElseIf cCampo == "CNATUREZA" .and. ValType(aVencto[1][1]) == "D"
				dVencReal:= aVencto[1][1]
				MaRecIR(dVencReal)
				nIrrf	:= MaFisRet(,"NF_VALIRR")		
			EndIf
		EndIf		
			
		lVencto := .T.                                                
		//Checa os Vencimentos aCols X Vencimentos Calculados quando ocorrer alteração nos
		//campos Data de Emissão, Condição de Pagamento e Cod.Fornecedor.
		//Quando algum destes campos mudar de conteúdo e o valor anterior for diferente do
		//valor atual, a rotina será executada e a variável que armazena o valor anterior
		//será atualizada.
 		If ((cCampo == "DDEMISSAO" .And. iif(Empty(dEmisOld),.T.,dMudaEmi<>dEmisOld)) .OR. (cCampo == "CCONDICAO" .And. (Empty(cCondicaoOld) .Or. cCondicao<>cCondicaoOld)) .Or. (cCampo == "CA100FOR" .And. (Empty(cCa100ForOLD) .Or. Ca100For<>cCa100ForOLD)) ) .Or. lA103VCTO
			For nX := 1 To Len(aVencto)
				If aScan(aCols,{|x| x[nPVencto]==aVencto[nX][1]})==0
					lVencto := .F.
				EndIf
			Next nX    
			//Atualiza a variável xOld com o conteúdo atual do Cabeçalho da NFE
			If (cCampo == "DDEMISSAO" .And. iif(Empty(dEmisOld),.T.,dMudaEmi<>dEmisOld))
			    dEmisOld := dMudaEmi
			ElseIf (cCampo == "CA100FOR" .And. (Empty(cCa100ForOLD) .Or. cCa100ForOLD<>cA100For))
			    cCa100ForOLD := cA100For 
			ElseIf (cCampo == "CCONDICAO" .And. (Empty(cCondicaoOld) .Or. cCondicaoOLD<>cCondicao))
			    cCondicaoOLD := cCondicao
			EndIF
		EndIf		     
		
		//Verifica se o recalculo deve ser efetuado mesmo se o valor total for igual ao permitido
		If cLimRec == "1"
			//Esta e a situacao "default", ou seja, mesmo que o valor principal esteja igual, recalcula
			//Eh mantida assim em respeito ao legado do sistema			
			bCondLim := { || Abs(nValor-nTotDup)>=nLIMPAG }
		ElseIf cLimRec == "2" 			
			bCondLim := { || Abs(nValor-nTotDup)>nLIMPAG }
		ElseIf cLimRec == "3"
			bCondLim := {||nValor > 0 .And. (nTotDup == nValDupAnt)}
		EndIf	 
		
		If ( Eval( bCondLim ) .Or. nValor == 0 .Or. nTotDup == 0 .Or.;
			MaFisRet(,"NF_VALIRR")<>nTotIRF  .Or.;
			(MaFisRet(,"NF_VALINS")+Iif(cINSSAd<>"0",MaFisRet(,"NF_VALINA"),0))<>nTotINSS .Or.;
			A103CalIss(lISSNat, __lIssMR)<>nTotISS .Or.;
			MaFisRet(,"NF_VALPIS")<>nTotPIS .Or.;
			MaFisRet(,"NF_VALCOF")<>nTotCOF .Or.;
			MaFisRet(,"NF_VALCSL")<>nTotCSLL .Or.;
			MaFisRet(,"NF_VALSES")<>nTotSEST .Or.;
			IIf(MaFisRet(,"NF_RECFET")=="2",MaFisRet(,"NF_VALFET"),0)<>nTotFet .Or.;
			IIf(MaFisRet(,"NF_RECFAB")=="2",MaFisRet(,"NF_VALFAB"),0)<>nTotFab .Or.;
			IIf(MaFisRet(,"NF_RECFAC")=="2",MaFisRet(,"NF_VALFAC"),0)<>nTotFac .Or.;
			IIf(MaFisRet(,"NF_RECIMA")=="2",MaFisRet(,"NF_VALIMA"),0)<>nTotIMA .Or.;
			IIf(MaFisRet(,"NF_RECFMD")=="2",MaFisRet(,"NF_VALFMD"),0)<>nTotFAM .Or.;
			MaFisRet(,"NF_VALCPM")<>nTotBTISS .Or.;
			Len(aVencto) <> Len(aCols) .Or.; 
			!lVencto .Or.;
			(nTribGen<>nTotTrbGen .And. !Empty(cNatureza)) .Or.;
			(Type("lAtuDupPC") == "L" .And. lAtuDupPC .And. !Empty(cCondicao)) .Or.;
			Len(aTribGen) > 0  .And. !Empty(cNatureza) .And. "NTAXA"$Upper(cCampo) .And. nTaxa > 0) .And.;
			IIf(cLimRec == "3",(lRecalc .Or. nValor != nValDupAnt),.T.)  
			
			//Ponto de entrada para alterar condicao de pagamento
			If lA103CND2
				a103Cnd2 := Aclone(aVencto)
				nTotDup := 0
				
				//Ajusta a quebra das parcelas para passar ao ponto de entrada
				For nX := 1 To Len(a103Cnd2)
					a103Cnd2[nX][2] := NoRound(a103Cnd2[nX][2],2)
					If nX <> Len(a103Cnd2)
						nTotDup += a103Cnd2[nx][2]
					Else
						a103Cnd2[nX][2]   := nValor-nTotDup
					EndIf
				Next nX

				a103Cnd2 := ExecBlock("A103CND2",.F.,.F.,a103Cnd2)
				If Valtype(a103Cnd2)=="A"
					aVencto := Aclone(a103Cnd2)
				EndIf
				nValor := 0
				For nX := 1 To Len(aVencto)
					nValor += aVencto[nX][2]
				Next nX
			EndIf
			
			//Montagem do acols das parcelas do titulo financeiro
			nTotDup := 0   
			aColsDup:=aclone(aCols)
			aCols := {}
	        cParcela:= IIF(Len(aVencto)>1,cParcela," ")
			
			If !l103Auto .And. lA1031DUP
				lChkDup:= ExecBlock("A1031DUP",.F.,.F.)
				If ValType(lChkDup) <> "L"
					lChkDup:= .F.
				EndIf
			EndIf
			
        	//Consiste tamanho do campo de parcelas e parametro MV_1DUP
			If !l103Auto .And. lChkDup
				If ( Len(aVencto) > 1 ) .And. ( nTamParc <> Len(cParcela) )
					Help('',1,'A1031DUP')
				EndIf
				
				//Consiste numero de parcelas da condicao e o maximo suportado pelo tamanho do campo
				If  Len(aVencto) > ( IIF ( STRZERO(0,nTamParc) == cParcela .Or. Val(cParcela) > 0,35,25) ** nTamParc ) 
					Help('',1,'A103PARC',,STR0108+Alltrim(STR(( IIF ( STRZERO(0,nTamParc) == cParcela .Or.; //##Numero maximo de parcelas:
					Val(cParcela) > 0,35,25) ** nTamParc )) )+Chr(10)+Chr(13)+STR0109+Alltrim(STR(Len(aVencto))),5,1)//##Parcelas da condicao de pagamento
				EndIf
			EndIf
			For nX := 1 To Len(aVencto)
				aVencto[nX][2] := NoRound(aVencto[nX][2],2)
				aadd(aCols,Array(nUsadoSE2+1))
				For nY := 1 To nUsadoSE2
					If IsHeadRec(aHeadSE2[nY][2])
					    aCols[Len(aCols)][nY] := 0
					ElseIf IsHeadAlias(aHeadSE2[nY][2])
					    aCols[Len(aCols)][nY] := "SE2"
				    Else		
						aCols[Len(aCols)][nY] := CriaVar(aHeadSE2[nY,2],.F.)
			        EndIf			
				Next nY
				aCOLS[Len(aCols)][nUsadoSE2+1] := .F.
				If nX <> Len(aVencto)
					aCols[nX][nPParcela] := cParcela 
					// Se a Data for alterada manualmente mantem a data modificada.
					If !(cCampo $ "CCONDICAO|DDEMISSAO|") .And. (Len(aColsSe2) == Len(aVencto) .And. aVencto[nX][1] <> aColsSe2[nX][nPosVec] .And. !Empty(aColsSe2[nX][nPosVec]))
						aCols[nX][nPVencto] := aColsSe2[nX][nPosVec]
					Else
						aCols[nX][nPVencto] := aVencto[nX][1]
					EndIf
					If EMPTY(cCampo) .And. (Len(aColsSe2) == Len(aVencto) .And. aVencto[nX][2] <> aColsSe2[nX][nPValor] .And. !Empty(aColsSe2[nX][nPValor]))
						aCols[nX][nPValor] := aColsSe2[nX][nPValor]
					Else
						aCols[nX][nPValor]   := aVencto[nX][2]
					Endif
					nTotDup += aVencto[nx][2]
					cParcela := MaParcela(cParcela)
					
				Else
				  If cCampo = "DDEMISSAO"  
				    	aCols[nX][nPParcela] := cParcela
				    	// Se a Data for alterada manualmente mantem a data modificada.
				    	If (nX >= Len(aColsSe2))  .OR. (Len(aColsSe2) == Len(aVencto) .And. aVencto[nX][1] <> aColsSe2[nX][nPosVec])
				    		aCols[nX][nPVencto]  := aVencto[nX][1]
				    	Else
				    		aCols[nX][nPVencto]  := aColsSe2[Len(aColsSe2)][nPosVec]
				    	EndIf
						aCols[nX][nPValor]   := nValor-nTotDup
					Else
					    aCols[nX][nPParcela] := cParcela
				    	// Se a Data for alterada manualmente mantem a data modificada.
						aCols[nX][nPVencto]  := If(Len(aColsSe2) == Len(aVencto) .And. aVencto[nX][1] <> aColsSe2[nX][nPosVec] .And. CTOD('  /  /  ') <> aColsSe2[nX][nPosVec] .AND. READVAR() <> "CCONDICAO"   ,aColsSe2[Len(aColsSe2)][nPosVec],aVencto[nX][1])   
						If Type("lAtuDupPC") == "L" .And. lAtuDupPC 
							aCols[nX][nPVencto] := aVencto[nX][1]
							lAtuDupPC := .F.  
						Endif
						If EMPTY(cCampo).And. (Len(aColsSe2) == Len(aVencto) .And. aVencto[nX][2] <> aColsSe2[nX][nPValor] .And. !Empty(aColsSe2[nX][nPValor]))
							aCols[nX][nPValor] := aColsSe2[nX][nPValor]
						Else
							aCols[nX][nPValor]   := nValor-nTotDup
						Endif
					Endif
					
				EndIf

			Next nX
			
			//Ponto de Entrada: A103DUP
			If lMT103DUP .And. Len(aColsDup)>0 
			    lDupNew:= ExecBlock("MT103DUP",.F.,.F.,{aColsDup,aVencto,nValor})
				If Valtype(lDupNew)<>"L"
					lDupNew:=.F.
				EndIf
			EndIf
			
			If lDupNew
				aCols:=aClone(aColsDup)  
			EndIf

			//Verifica se ha necessidade da gravacao das multiplas naturezas
			If nPValSEV > 0                   
                nValSEV := nValor-nValFun-nValFet-nIrrf-nInss-nIss-nPis-nCOFINS-nCSLL-nValFab-nValFac-nValIMA-nValFAMAD-nValBTISS
				nRateio := 0
				For nY := 1 To Len(aColsSEV)
					If !aColsSEV[nY][Len(aColsSEV[1])] .And. !Empty(aColsSEV[nY][1])
						aColsSEV[nY][nPValSEV] := IIf(nY==Len(aColsSEV),nValSEV-nRateio,NoRound(nValSEV*aColsSEV[nY][nPercSEV]/100,nMultDec))
						nRateio += aColsSEV[nY][nPValSEV]
					EndIf
				Next nY
            EndIf

			// Verifica se o sistema esta preparado para utilizar o motor de tributos genericos
			If Len(aTribGen) > 0
				// Cria o array que ira conter os valores retornados pelo motor de tributos genericos por parcela de duplicata
				aParcTrGen := A103TrbGen(aVencto,aTribGen,aColTrbGen,@aRateio,@aRatBasTG,@cIdsTrGen)
			EndIf

			//Rateio do Impostos Financeiros
			If Len(aCols)>0
				//Gera o valor da Fethab apenas na primeira parcela
				If nPFETHAB <> 0
					aCols[1][nPFETHAB] := nValFet
				EndIf
					
				If nPFABOV <> 0
					aCols[1][nPFABOV] := nValFab
				EndIf	

				If nPFACS <> 0
					aCols[1][nPFACS] := nValFac
				EndIf
				
				If nPIMA <> 0
					aCols[1][nPIMA] := nValIMA
				EndIf
				
				If nPFAMAD <> 0
					aCols[1][nPFAMAD] := nValFAMAD
				EndIf	
				
				//Se o parametro nao permitir o rateio do IRRF/ISS/INSS, o valor sera descontado apenas na primeira parcela
				If !lRatIRRF
					If nPIRRF <> 0
						aCols[1][nPIRRF] := nIRRF- aRateio[1]
						aRateio[1] += aCols[1][nPIRRF]
					EndIf
				Endif       
				If !lRatISS
					If nPISS <> 0
						aCols[1][nPISS] := nISS - aRateio[2]
						aRateio[2] += aCols[1][nPISS]
					EndIf
				Endif       
				If !lRatINSS
					If nPINSS <> 0
						aCols[1][nPINSS] := nINSS - aRateio[3]
						aRateio[3] += aCols[1][nPINSS]
					EndIf   
				Endif
				If !lRatPIS
					If nPPIS <> 0
						aCols[1][nPPIS] := nPIS - aRateio[4]
						aRateio[4] += aCols[1][nPPIS]
					EndIf
				EndIf
				If !lRatCOFINS
					If nPCOFINS <> 0
						aCols[1][nPCOFINS] := nCOFINS - aRateio[5]
						aRateio[5] += aCols[1][nPCOFINS]
					EndIf
				EndIf
				If !lRatCSLL
					If nPCSLL <> 0
						aCols[1][nPCSLL] := nCSLL - aRateio[6]
						aRateio[6] += aCols[1][nPCSLL]
					EndIf
				EndIf
				If !lRatSEST
					If nPSEST <> 0
						aCols[1][nPSEST] := nSEST - aRateio[7]
						aRateio[7] += aCols[1][nPSEST]
					EndIf
				EndIf
				If !lRatISS
					If nPBTISS <> 0
						aCols[1][nPBTISS] := nValBTISS - aRateio[8]
						aRateio[8] += aCols[1][nPBTISS]
					EndIf
				EndIf
				// Preenche com os valores gerados pelo motor de tributos genericos
				If lTrbGen .And. !Empty(cNatureza)
					For nZ := 1 To Len(aTribGen)

						If aParcTrGen[1][nZ][5]	// Indica se retem integralmente na primeira parcela

							If (nPosValTrb := aScan(aColTrbGen,{|x| x[1] == aTribGen[nZ][1]}) ) > 0	// Encontra a coluna da duplicata referente ao tributo generico

								// Atualiza o array de duplicatas na tela
								aCols[1][nColsSE2+nPosValTrb] := aTribGen[nZ][3] - aRateio[8+nPosValTrb]
								aRateio[8+nPosValTrb] += aCols[1][nColsSE2+nPosValTrb]

								// Atualiza o array que sera passado para o Financeiro
								aParcTrGen[1][nZ][2]  := aTribGen[nZ][2] - aRatBasTG[nPosValTrb]	// Base do tributo generico
								aRatBasTG[nPosValTrb] += aParcTrGen[1][nZ][2]						// Saldo da base a ratear
								aParcTrGen[1][nZ][3]  := aCols[1][nColsSE2+nPosValTrb]				// Valor do tributo generico

							EndIf

						EndIf

					Next nZ
				EndIf
			EndIf
			
			For nX := 1 To Len(aCols)
				If nPIRRF <> 0
					If lRatIRRF
						aCols[nX][nPIRRF] := IIf(nX==Len(aCols),nIRRF-aRateio[1],NoRound(nIRRF*aCols[nX][nPValor]/nValor,2))
						aRateio[1] += aCols[nX][nPIRRF]
					Endif
				EndIf
				If nPISS <> 0
					If lRatISS
						aCols[nX][nPISS] := IIf(nX==Len(aCols),nISS -aRateio[2],NoRound(nISS*aCols[nX][nPValor]/nValor,2))
						aRateio[2] += aCols[nX][nPISS]
					Endif
				EndIf
				If nPINSS <> 0
					If lRatINSS
						aCols[nX][nPINSS] := IIf(nX==Len(aCols),nINSS-aRateio[3],NoRound(nINSS*aCols[nX][nPValor]/nValor,2))
						aRateio[3] += aCols[nX][nPINSS]
					Endif
				EndIf
				If nPPIS <> 0
					If lRatPIS
						aCols[nX][nPPIS] := IIf(nX==Len(aCols),nPIS-aRateio[4],NoRound(nPIS*aCols[nX][nPValor]/nValor,2))
						aRateio[4] += aCols[nX][nPPIS]
                    EndIf 
				EndIf
				If nPCOFINS <> 0
					If lRatCOFINS
						aCols[nX][nPCOFINS] := IIf(nX==Len(aCols),nCOFINS-aRateio[5],NoRound(nCOFINS*aCols[nX][nPValor]/nValor,2))
						aRateio[5] += aCols[nX][nPCOFINS]
                    EndIf
				EndIf
				If nPCSLL <> 0
					If lRatCSLL
						aCols[nX][nPCSLL] := IIf(nX==Len(aCols),nCSLL-aRateio[6],NoRound(nCSLL*aCols[nX][nPValor]/nValor,2))
						aRateio[6] += aCols[nX][nPCSLL]
                    EndIf
				EndIf
				If nPSEST <> 0
					If lRatSEST
						aCols[nX][nPSEST] := IIf(nX==Len(aCols),nSEST-aRateio[7],NoRound(nSEST*aCols[nX][nPValor]/nValor,2))
						aRateio[7] += aCols[nX][nPSEST]
					Endif
				EndIf
				If nPBTISS <> 0
					If lRatISS
						aCols[nX][nPBTISS] := IIf(nX==Len(aCols),nValBTISS-aRateio[8],NoRound(nValBTISS*aCols[nX][nPValor]/nValor,2))
						aRateio[8] += aCols[nX][nPBTISS]
					EndIf
				EndIf
				// Preenche com os valores gerados pelo motor de tributos genericos
				If lTrbGen .And. !Empty(cNatureza)
					For nZ := 1 To Len(aTribGen)

						If !aParcTrGen[nX][nZ][5]	// Indica se retem integralmente na primeira parcela

							If (nPosValTrb := aScan(aColTrbGen,{|x| x[1] == aTribGen[nZ][1]}) ) > 0	// Encontra a coluna da duplicata referente ao tributo generico

								// Atualiza o array de duplicatas na tela
								aCols[nX][nColsSE2+nPosValTrb] := IIf(nX==Len(aCols),aTribGen[nZ][3]-aRateio[8+nPosValTrb],NoRound(aTribGen[nZ][3]*aCols[nX][nPValor]/nValor,2))
								aRateio[8+nPosValTrb]   += aCols[nX][nColsSE2+nPosValTrb]

								// Atualiza o array que sera passado para o Financeiro
								// O valor do tributo deve ser igual ao valor exibido na aba Duplicatas, porem a base precisa ser calculada pois a aba Duplicatas nao trabalha com base
								aParcTrGen[nX][nZ][2] := IIf(nX==Len(aCols),aTribGen[nZ][2]-aRatBasTG[nPosValTrb],NoRound(aTribGen[nZ][2]*aCols[nX][nPValor]/nValor,2))	// Base do tributo generico
								aRatBasTG[nPosValTrb] += aParcTrGen[nX][nZ][2]			// Saldo a ratear da base
								aParcTrGen[nX][nZ][3] := aCols[nX][nColsSE2+nPosValTrb]	// Valor do tributo generico

							EndIf

						EndIf

					Next nZ
				EndIf
			Next nX
		EndIf
		
		If cCampo == "M->E2_VENCTO" .And. ValType(aIrrfNew)=="A"
			aIrrfNew := aCols
		EndIf
		nValDupAnt := nValor
	Else
		If MaFisFound("NF")
			aCols   := IIf(oCtaPag<>Nil,oCtaPag:aCols,aCols)
			nValor := NoRound(xMoeda(MaFisRet(,"NF_BASEDUP"),MaFisRet(,"NF_MOEDA"),nMoeda,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA")),2)
			
			If Type("lTOPDRFRM") <> "U" .And. lTOPDRFRM .And. ValType(aD1Bkp) == "A" .And. Len(aD1Bkp) > 0
				nValor	:= 0
				
				cAliasBkp := aD1Bkp[1,Len(aD1Bkp[1])-2]

				If cAliasBkp == "SD1"
					nD1Tes	:= GdFieldPos("D1_TES",aHeadD1)
					nD1Ret	:= GdFieldPos("D1_RETENCA",aHeadD1)
					nD1Ded	:= GdFieldPos("D1_DEDUCAO",aHeadD1)
					nD1Fat	:= GdFieldPos("D1_FATDIRE",aHeadD1)
					nD1Tot	:= GdFieldPos("D1_TOTAL",aHeadD1)

					If nD1Tes > 0 .And. nD1Ret > 0 .And. nD1Ded > 0 .And. nD1Fat > 0
						For nI := 1 To Len(aD1Bkp)
							If !aD1Bkp[nI,Len(aHeadD1)+1]
								If GetAdvFval("SF4","F4_DUPLIC",xFilial("SF4") + aD1Bkp[nI,nD1Tes],1) == "S"
									nValor += MaFisRet(nI,"IT_TOTAL")

									nTotRDF += aD1Bkp[nI,nD1Ret]
									nTotRDF += aD1Bkp[nI,nD1Ded]
									nTotRDF += aD1Bkp[nI,nD1Fat]
								Endif
							Endif
						Next nI
					Endif
				Elseif cAliasBkp == "SE2"
					nE2Vlr	:= GdFieldPos("E2_VALOR",aHeader)

					If nE2Vlr > 0
						For nI := 1 To Len(aD1Bkp)
							If !aD1Bkp[nI,Len(aHeader)+1]
								nValor += aD1Bkp[nI,nE2Vlr]
							Endif
						Next nI
					Endif
				Endif
				
				nValor := nValor - nTotRDF
				nValor := xMoeda(nValor,MaFisRet(,"NF_MOEDA"),nMoeda,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA"))
				If nValor > 0 .And. nValor <> MaFisRet(,"NF_BASEDUP")
					MaFisAlt("NF_BASEDUP",nValor)
				ElseIf nValor == 0
					nValor := MaFisRet(,"NF_BASEDUP")
				EndIf
			Endif
		
			If nValor == 0
				aCols := {}
			EndIf
			nValFun := MaFisRet(,"NF_FUNRURAL")
			nValFet := IIf(MaFisRet(,"NF_RECFET")=="2",MaFisRet(,"NF_VALFET"),0)			                                         
			nValFab := IIf(MaFisRet(,"NF_RECFAB")=="2",MaFisRet(,"NF_VALFAB"),0)				
			nValFac := IIf(MaFisRet(,"NF_RECFAC")=="2",MaFisRet(,"NF_VALFAC"),0)
			nValIMA := IIf(MaFisRet(,"NF_RECIMA")=="2",MaFisRet(,"NF_VALIMA"),0)
			nValFAMAD := IIf(MaFisRet(,"NF_RECFMD")=="2",MaFisRet(,"NF_VALFMD"),0)		
			nIrrf	:= MaFisRet(,"NF_VALIRR")
			nInss   := MaFisRet(,"NF_VALINS")+Iif(cINSSAd<>"0",MaFisRet(,"NF_VALINA"),0)
			nIss	:= A103CalIss(lISSNat, __lIssMR)
			nPis    := MaFisRet(,"NF_VALPIS")
			nCOFINS := MaFisRet(,"NF_VALCOF")
			nCSLL   := MaFisRet(,"NF_VALCSL")			
			nSEST   := MaFisRet(,"NF_VALSES")
			nValBTISS := MaFisRet(,"NF_VALCPM")

			If Empty(aCols)			
				aadd(aCols,Array(nUsadoSE2+1))
			EndIf			
			
			For nY := 1 To nUsadoSE2
				If IsHeadRec(aHeadSE2[nY][2])
					aCols[Len(aCols)][nY] := 0
				ElseIf IsHeadAlias(aHeadSE2[nY][2])
					aCols[Len(aCols)][nY] := "SE2"
				ElseIf nY <> nPVencto
					aCOLS[Len(aCols)][nY] := CriaVar(aHeadSE2[nY,2],.F.)
				Else
					aCols[Len(aCols)][nPVencto]  := IIf(Empty(aCols[Len(aCols)][nPVencto]),dDataBase,aCols[Len(aCols)][nPVencto])
				Endif
			Next nY

			aCOLS[Len(aCols)][nUsadoSE2+1] := .F.
			aCols[Len(aCols)][nPParcela] := Space(Len(SE2->E2_PARCELA))
			aCols[Len(aCols)][nPVencto]  := Iif(Empty(aCols[Len(aCols)][nPVencto]),dDataBase,aCols[Len(aCols)][nPVencto])
			aCols[Len(aCols)][nPValor]   := nValor

			//Verifica se ha necessidade da gravacao das multiplas naturezas
			If nPValSEV > 0
                nValSEV := nValor-nValFun-nValFet-nIrrf-nInss-nIss-nPis-nCOFINS-nCSLL-nValFac-nValFab-nValIMA-nValFAMAD-nValBTISS
				nRateio := 0
				For nY := 1 To Len(aColsSEV)
					If !aColsSEV[nY][Len(aColsSEV[1])] .And. !Empty(aColsSEV[nY][1])
						aColsSEV[nY][nPValSEV] := IIf(nY==Len(aColsSEV),nValSEV-nRateio,NoRound(nValSEV*aColsSEV[nY][nPercSEV]/100,nMultDec))
						nRateio += aColsSEV[nY][nPValSEV]
					EndIf
				Next nY
            EndIf
		EndIf
	EndIf
EndIf

//Atualiza os objetos
If oCondicao<>Nil
	oCondicao:lReadOnly  := (IIF((INCLUI .Or. ALTERA) .And. lMt103Get,ExecBlock("MT103GET",.F.,.F.), nValor == 0) .And. cTipo <> "D") .Or. cTipo == 'D' // O Retorno .T. Do ponto MT103GET impede a edicao do Get
    oCondicao:Refresh()
EndIf
If oNatureza<>Nil
	oNatureza:lReadOnly  := IIF((INCLUI .Or. ALTERA) .And. lMt103Get,ExecBlock("MT103GET",.F.,.F.), nValor == 0) // O Retorno .T. Do ponto MT103GET impede a edicao do Get
EndIf
If oMoeda<>Nil
	oMoeda:lReadOnly := IIF((INCLUI .Or. ALTERA) .And. lMt103Get,ExecBlock("MT103GET",.F.,.F.), nValor == 0) // O Retorno .T. Do ponto MT103GET impede a edicao do Get
EndIf
If oNatureza<>Nil
	oNatureza:Refresh()
EndIf
If oMoeda<>Nil
	oMoeda:Refresh()
EndIf
If oTaxa<>Nil
	oTaxa:lReadOnly := IIF((INCLUI .Or. ALTERA) .And. lMt103Get,ExecBlock("MT103GET",.F.,.F.),nMoedaCor == 1 .Or. ( cTipo=="D" .And. GetNewPar("MV_TXMOENC","1")=="1" .And. Iif(Type('lBlqTxNeg')=='L',lBlqTxNeg,.T.) .And. Iif(Type('nValFat')=='N' .And. nValFat > 0,nValor == nValFat,.T.) ))
	oTaxa:Refresh()
EndIf
If oDscMoeda<>Nil
	If nMoeda == 1
		cMoeda := RetTitle("F1_MOEDA")	
	EndIf
	If Empty(cMoeda)
		cMoeda := SuperGetMv("MV_MOEDA"+AllTrim(Str(nMoeda,2)))
	EndIf
	oDscMoeda:SetText(cMoeda)
EndIf
If oCtaPag<>Nil
	oCtaPag:lUpdate := nValor <> 0
	If !Empty(aCols)
		oCtaPag:aCols := aCols 
		aColsSE2      := aCols
		If lMTCOLSE2
			aColsPE:= ExecBlock("MTCOLSE2",.F.,.F.,{aColsSE2,1})
			If ValType(aColsPE) == "A"
				oCtaPag:aCols:= aColsPE
				aColsSE2	 := aColsPE
			EndIf
		EndIf	
	EndIf
	oCtaPag:nAt   := 1
	oCtaPag:Refresh()
Else
	If !Empty(aCols)
		aColsSE2      := aCols
		If lMTCOLSE2
			aColsPE:= ExecBlock("MTCOLSE2",.F.,.F.,{aColsSE2,1})
			If ValType(aColsPE) == "A"
				aColsSE2	 := aColsPE
			EndIf
		EndIf	
	EndIf
EndIf
// Atualiza array de tributos genericos para que os valores fiquem coerentes com a aba Duplicatas, pois as colunas sao editaveis
If lTrbGen .And. Len(aParcTrGen) > 0
	A103AtuTrG(@aParcTrGen,aColTrbGen,aTribGen,aColsSE2,nColsSE2)
EndIf
If oMultNat<>Nil
	oMultNat:lUpdate := nValor <> 0
	If !Empty(aColsSEV)
		oMultNat:aCols := aColsSEV
	EndIf
	oMultNat:Refresh()
EndIf
If oDescri <> Nil
	oDescri:Refresh()
EndIf
If oTxNeg <> Nil
	oTxNeg:Refresh()
EndIf

Return


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeLOkSE2 ³Autor  ³ Eduardo Riera         ³ Data ³06.12.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de validacao da LinhaOk para a getdados dos titulos   ³±±
±±³          ³financeiros                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL: Indica se a linha da getdados eh valida                ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina valida a getdados dos titulos financeiros        ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeLOkSE2()

Local lRetorno  := .T.
Local nPValor   := aScan(aHeader,{|x| AllTrim(x[2])=="E2_VALOR"})
Local nPIRRF    := aScan(aHeader,{|x| AllTrim(x[2])=="E2_IRRF"})
Local nPISS     := aScan(aHeader,{|x| AllTrim(x[2])=="E2_ISS"})
Local nPINSS    := aScan(aHeader,{|x| AllTrim(x[2])=="E2_INSS"})
Local nPPIS     := aScan(aHeader,{|x| AllTrim(x[2])=="E2_PIS"})
Local nPCOFINS  := aScan(aHeader,{|x| AllTrim(x[2])=="E2_COFINS"})
Local nPCSLL    := aScan(aHeader,{|x| AllTrim(x[2])=="E2_CSLL"})
Local nPFETHAB  := aScan(aHeader,{|x| AllTrim(x[2])=="E2_FETHAB"})
Local nPFABOV  	:= aScan(aHeader,{|x| AllTrim(x[2])=="E2_FABOV"})
Local nPFACS	:= aScan(aHeader,{|x| AllTrim(x[2])=="E2_FACS"})
Local nPIMA		:= aScan(aHeader,{|x| AllTrim(x[2])=="E2_IMA"})
Local nPFAMAD	:= aScan(aHeader,{|x| AllTrim(x[2])=="E2_FAMAD"}) 
Local lM103LSE2	:= Existblock("M103LSE2")

If lM103LSE2
	lRetorno := Execblock("M103LSE2",.F.,.F.)
Endif

If nPIRRF*nPISS*nPINSS*nPPIS*nPCOFINS*nPCSLL*IIf(Empty(nPFETHAB),1,nPFETHAB)*IIf(Empty(nPFABOV),1,nPFABOV)*IIf(Empty(nPFACS),1,nPFACS) > 0
	If aCols[n][nPValor]<=aCols[n][nPIRRF]+aCols[n][nPISS]+aCols[n][nPINSS]+aCols[n][nPPIS]+aCols[n][nPCOFINS]+aCols[n][nPCSLL]+IIf(nPFETHAB>0,aCols[n][nPFETHAB],0) .And.;
		aCols[n][nPValor]+aCols[n][nPIRRF]+aCols[n][nPISS]+aCols[n][nPINSS]+aCols[n][nPPIS]+aCols[n][nPCOFINS]+aCols[n][nPCSLL]+IIf(nPFABOV>0,aCols[n][nPFABOV],0)+ ;
		IIf(nPFACS>0,aCols[n][nPFACS],0)+IIf(nPIMA>0,aCols[n][nPIMA],0)+IIf(nPFAMAD>0,aCols[n][nPFAMAD],0)!=0
		Help(" ",1,"A100VALDUP",,"IRRF/ISS/INSS/PIS/COFINS/CSLL"+IIf(nPFETHAB>0,"/FETHAB","")+IIf(nPFABOV>0,"/FABOV","")+IIf(nPFACS>0,"/FACS","")+IIf(nPIMA>0,"/IMA","")+IIf(nPFAMAD>0,"/FAMAD",""),3,0)
	    lRetorno := .F.
	EndIf
Else
	If nPIRRF*nPISS*nPINSS > 0
		If aCols[n][nPValor]<=aCols[n][nPIRRF]+aCols[n][nPISS]+aCols[n][nPINSS] .And.;
		    aCols[n][nPValor]+aCols[n][nPIRRF]+aCols[n][nPISS]+aCols[n][nPINSS]!=0
			Help(" ",1,"A100VALDUP",,"IRRF/ISS/INSS",3,0)
			lRetorno := .F.
		EndIf
	EndIf
EndIf
Return(lRetorno)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeTOkSE2 ³Autor  ³ Eduardo Riera         ³ Data ³09.09.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de validacao da TudoOk para a getdados do contas a    ³±±
±±³          ³pagar                                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1:Indica se a getdados eh valida                         ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina valida a getdados do contas a pagar              ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeTOkSE2()

Local lRetorno := NfeTotFin(aHeader,aCols)

Return(lRetorno)
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeLOkSEV ³Autor  ³ Eduardo Riera         ³ Data ³09.09.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de validacao da LinhaOk para a getdados das Multiplas ³±±
±±³          ³naturezas                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL: Indica se a linha da getdados eh valida                ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina valida a getdados das multiplas naturezas        ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeLOkSEV()

Local lRetorno   := .T.
Local nPosNat    := aScan(aHeader,{|x| AllTrim(x[2]) == "EV_NATUREZ"})
Local nPosVlr    := aScan(aHeader,{|x| AllTrim(x[2]) == "EV_PERC"})

If MaFisFound("NF") .And. MaFisRet(,"NF_BASEDUP")>0 .And. nPosNat > 0 .And. nPosVlr > 0 .And. ((len(aCols) > 1) .Or. (!Empty(aCols[1,nPosNat]) .Or. !Empty(aCols[1,nPosVlr])))
	lRetorno := MaCheckCols(aHeader,aCols,N)
EndIf      

If nPosNat>0 .And. lRetorno
	lRetorno:=A103ValNat(aCols[N,nPosNat])
EndIf

Return(lRetorno)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeTOkSEV ³Autor  ³ Eduardo Riera         ³ Data ³09.09.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de validacao da TudoOk para a getdados das Multiplas  ³±±
±±³          ³naturezas                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL: Indica se a getdados eh valida                         ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina valida a getdados das multiplas naturezas        ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeTOkSEV(aHeadSev, aColsSev,lvalor)
Local nX       := 0
Local nUsadoSEV:= Len(aHeadSev)
Local nPPerc   := aScan(aHeadSev,{|x| AllTrim(x[2])=="EV_PERC"})
Local nPNat    := aScan(aHeadSev,{|x| AllTrim(x[2])=="EV_NATUREZ"})
Local nSoma    := 0    
Local lRetorno := .T.
Local lMULNATP := SuperGetMV("MV_MULNATP",.F.,.F.)
Local lNFENAT  := SuperGetMV("MV_NFENAT",.F.,.F.)   
                                                      
If (INCLUI .Or. ALTERA)
	If MaFisFound("NF") .And. MaFisRet(,"NF_BASEDUP")>0 .And. nPNat > 0 .And.;
	nPPerc > 0 .And. ((len(aColsSev) > 1) .Or. (!Empty(aColsSev[1,nPNat]) .Or. !Empty(aColsSev[1,nPPerc])))
		For nX:= 1 To len(aColsSev)
			lRetorno := MaCheckCols(aHeadSev,aColsSev,nX)
			If !lRetorno
				Exit
			EndIf
		Next nX
	EndIf
	
	//Verifica se existem naturezas com lançamento sintético
	If nPNat>0 .And. lRetorno
		For nX:= 1 To len(aColsSev)
			lRetorno := A103ValNat(aColsSev[nX][nPNat])
			If !lRetorno
				Exit
			EndIf
		Next nX
	EndIf
	
	//Verifica se a soma dos percentuais eh 100%
	If !(cTipo$"DB" .Or. A103RtCliRT(cTipo, cTpCompl, cFormul)) .And. lRetorno .And. ;
	    MaFisFound("NF") .And. MaFisRet(,"NF_BASEDUP")>0 .And. lMULNATP
		For nX := 1 To Len(aColsSev)
			If !aColsSev[nX][nUsadoSEV+1]
				If aColsSev[nX][nPPerc]<>0
					nSoma += aColsSev[nX][nPPerc]
				Else
					If nPNat == 0 .Or. !Empty(aColsSev[nX][nPNat])
						aColsSev[nX][nUsadoSEV+1] := .T.
					EndIf
				EndIf
			EndIf
		Next nX                       
	 	If Empty( MaFisRet(,"NF_NATUREZA") ) .And. nSoma == 0 .And. lNFENAT
			Help(" ",1,"A103NATURE")
			lRetorno := .F.
		EndIf 	
		If lRetorno .And. nSoma <> 0 .And. nSoma <> 100 
			Help(" ",1,"A103TOKSEV",,STR0040+TransForm(nSoma,"@E 999.99%"),4,0)
			lRetorno := .F.
		EndIf
	EndIf
EndIf

lValor := lRetorno

Return(lRetorno)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NFEVLDSEV³ Autor ³Alexandre Inacio Lemes ³ Data ³28/09/2004³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Exibe o Help de rateio percentual de Multiplas Naturezas   ³±±
±±³          ³apos a funcao NfeTOkSEV tornar .F. a propriedade Cargo[2]  ³±±
±±³          ³do Objeto oFoco103 para impedir a finalizacao da Nfe quando³±±
±±³          ³a soma do percentual do SEV nao for = a 100%.              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA103                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeVldSEV(lRetorno,aHeader,aCols,aHeadSEV,aColsSEV)
Local aRetSEV 	:= {}
Local lNFECTSEV	:= ExistBlock("NFECTSEV")
Local lNFEVLSEV	:= ExistBlock("NFEVLSEV")

If !lRetorno
	Help(" ",1,"A103TOKSEV")
EndIf

If lNFECTSEV
	aRetSEV := ExecBlock('NFECTSEV', .F., .F., {aHeadSEV,aColsSEV})
	
	If valtype(aRetSEV) == "A"
		if len(aRetSEV) >= 1 .And. valtype(aRetSEV[1]) == "A"
			aHeaderSEV := aClone(aRetSEV[1])
		EndIf
		if len(aRetSEV) >= 2 .And. valtype(aRetSEV[2]) == "A"
			aColsSEV   := aClone(aRetSEV[2])
		EndIf	
	EndIf		
EndIf     

If lRetorno .And. lNFEVLSEV
	lRetorno := ExecBlock("NFEVLSEV",.F.,.F.,{aHeader,aCols,aHeadSEV,aColsSEV})
EndIf

Return lRetorno

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NFERATSEV³ Autor ³Alexandre Inacio Lemes ³ Data ³01/07/2004³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³                                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA103                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeRatSEV(nPercSEV,nValSEV)

Local nPPerc   := aScan(aHeader,{|x| AllTrim(x[2])=="EV_PERC"})
Local nPVLperc := aScan(aHeader,{|x| AllTrim(x[2])=="EV_VALPERC"})
Local nValor   := 0 
Local nValFun  := 0
Local nValFet  := 0
Local nIrrf	   := 0
Local nInss	   := 0
Local nIss	   := 0
Local nPis     := 0
Local nCofins  := 0
Local nCsll    := 0
Local nValRet  := 0
Local nTotPerc := 0
Local nMultDec := GetNewPar( "MV_MULTDEC", 2 ) 
Local lISSNat  := .T.
Local cNatNF   := ""
Local lISSTes  := SuperGetMv("MV_ISSRETD",.F.,.F.)
Local cINSSAd  := "0"

If nPVlPerc > 0

	If MaFisFound("NF")		

		//Verifica se deve existir o calculo do ISS pela natureza do titulo
		cNatNF := MaFisRet(,"NF_NATUREZA")
		dbSelectArea("SED")
		If SED->(dbSeek(xFilial("SED")+cNatNF))
			lISSNat := SED->ED_CALCISS <> "N" .Or. lISSTes
		Endif
		
		cINSSAd	:=	MaFisScan("NF_VALINA",.F.)            

		nValor  := MaFisRet(,"NF_BASEDUP")
		nValFun := MaFisRet(,"NF_FUNRURAL")
		nValFet := IIf(MaFisRet(,"NF_RECFET")=="2",MaFisRet(,"NF_VALFET"),0)
		nValFab := IIf(MaFisRet(,"NF_RECFAB")=="2",MaFisRet(,"NF_VALFAB"),0)
		nValFac := IIf(MaFisRet(,"NF_RECFAC")=="2",MaFisRet(,"NF_VALFAC"),0)
		nValIMA := IIf(MaFisRet(,"NF_RECIMA")=="2",MaFisRet(,"NF_VALIMA"),0)
		nValFAMAD := IIf(MaFisRet(,"NF_RECFMD")=="2",MaFisRet(,"NF_VALFMD"),0)		
		nIrrf	:= MaFisRet(,"NF_VALIRR")
		nInss   := MaFisRet(,"NF_VALINS")+Iif(cINSSAd<>"0",MaFisRet(,"NF_VALINA"),0)
		nIss	:= IIf(MaFisRet(,"NF_RECISS")=="2".And.lISSNat,MaFisRet(,"NF_VALISS"),0)
		nPis    := MaFisRet(,"NF_VALPIS")
		nCOFINS := MaFisRet(,"NF_VALCOF")
		nCSLL   := MaFisRet(,"NF_VALCSL")
	EndIf

    nValor := nValor-nValFun-nValFet-nIrrf-nInss-nIss-nPis-nCOFINS-nCSLL-nValFab-nValFac-nValIMA-nValFAMAD

	If nPercSEV > 0
		aCols[n][nPVlPerc] := ( nValor * nPercSEV ) / 100
		aCols[n][nPPerc]   := ( aCols[n][nPVlPerc] / nValor ) * 100
		nValRet := aCols[n][nPPerc]
	Else
		aCols[n][nPVlPerc] := 0
	EndIf
	
	If nValSEV > 0
		aCols[n][nPPerc]   := Round(( nValSEV / nValor ) * 100, nMultDec )
		aCols[n][nPVlPerc] := ( nValor * aCols[n][nPPerc] ) / 100
		nValRet := aCols[n][nPVlPerc]
	Else
		aCols[n][nPPerc] := 0
		nTotPerc := nPercSEV
	EndIf
EndIf

Return nValRet  

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeCond2  ³ Rev   ³ Julio C.Guerato       ³ Data ³06.05.2009 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Condicao de Pagamento                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina Validar se a Condição de Pagamento é valida      ³±±
±±³	         ³porém somente retorna .T. ou .F..							   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function NfeCond2(cCondicao)

Local aArea    := GetArea()
Local lRetorno := Empty(cCondicao)

dbSelectArea("SE4")
dbSetOrder(1)
If !Empty(cCondicao)
	MsSeek(xFilial("SE4")+cCondicao)
	if Eof()
		lRetorno := .F.
	Else	 
	    lRetorno := IIF(SE4->E4_TIPO == "9",.F.,.T.)
	EndIf
EndIf

RestArea(aArea)
Return(lRetorno)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeCond   ³ Rev   ³ Edson Maricate        ³ Data ³07.08.2001 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de tratamento do folder de totais                     ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Condicao de Pagamento                                 ³±±
±±³          ³ExpO2: Objeto da descricao de pagamento                      ³±±
±±³          ³ExpC3: Descricao da condicao de pagamento                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo exibir/controlar o folder finan³±±
±±³          ³ceiro.                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeCond(cCondicao,oDescri,cDescricao)

Local aArea    := GetArea()
Local lRetorno := Empty(cCondicao)

DEFAULT cDescricao := ""

//Valida a condicao de pagamento
dbSelectArea("SE4")
dbSetOrder(1)
If ( !Empty(cCondicao) .And. ExistCpo("SE4",cCondicao) )
	MsSeek(xFilial("SE4")+cCondicao)
	If SE4->E4_TIPO == "9"
		Help("  ",1,"A100COND")
		lRetorno := .F.
	Elseif SE4->E4_TIPO == "A"
		If SuperGetMV("MV_VEICULO") == "S" .and. ( FM_PILHA("VEI") .or. FM_PILHA("OFI") ) // Chamada via execauto - Condição de Pagamento exclusivas para SIGAVEI/SIGAOFI
			lRetorno := .T.
		Else
			Help(" ",1,"A103COND",,STR0214,1,0) //"Condição de Pagamento exclusivas para SIGAVEI/SIGAOFI e não deve gerar duplicata"
			lRetorno := .F.
		EndIf	
	Else
		cDescricao	:= SE4->E4_DESCRI
		lRetorno := .T.
	EndIf
EndIf

//Efetua o refresh no objeto da descricao da condicao de pagto
If oDescri <> Nil
	oDescri:Refresh()
EndIf
RestArea(aArea)
Return(lRetorno)
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeFldTot ³Autor  ³ Eduardo Riera         ³ Data ³12.09.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de atualizacao do folder de totais                    ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpO1: Objeto da Janela que sera disponibilizado os Get      ³±±
±±³          ³ExpA2: Array com os gets de totais                           ³±±
±±³          ³ExpA3: Array com as posicoes dos gets de totais              ³±±
±±³          ³Expb4: Codeblock para atualizaco dos dados do Folder         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo atualizar o folder de totais   ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeFldTot(oDlg,aGets,aPosGet,bRefresh)

Local aObjetos := Array(Len(aGets))
lfndVldCpo := FindFunction("COMXVLDCPO")

@ 06,aPosGet[1] SAY RetTitle("F1_VALMERC") Of oDlg PIXEL SIZE 55 ,9 //"Valor da Mercadoria"
@ 05,aPosGet[2] MSGET aObjetos[VALMERC] VAR aGets[VALMERC] PICTURE PesqPict('SD1','D1_TOTAL') OF oDlg PIXEL When .F. SIZE 80,09			
@ 06,aPosGet[3] SAY RetTitle("F1_DESCONT") Of oDlg PIXEL SIZE 49 ,9 //"Descontos"
@ 05,aPosGet[4] MSGET aObjetos[VALDESC] VAR aGets[VALDESC]  PICTURE PesqPict('SD1','D1_VALDESC') OF oDlg PIXEL When .F. SIZE 80,09			
If Len(aGets)>3
	@ 20,aPosGet[1] SAY RetTitle("F1_FRETE") Of oDlg PIXEL SIZE 45 ,9 //"Valor do Frete"
	@ 19,aPosGet[2] MSGET aObjetos[FRETE] VAR aGets[FRETE]  PICTURE PesqPict('SD1','D1_TOTAL') OF oDlg PIXEL When .F. SIZE 80,09
	@ 20,aPosGet[3] SAY RetTitle("F1_SEGURO") Of oDlg PIXEL SIZE 50 ,9 //"Vlr. do Seguro"
	@ 19,aPosGet[4] MSGET aObjetos[SEGURO] VAR aGets[SEGURO]  PICTURE PesqPict('SD1','D1_TOTAL') OF oDlg PIXEL When .F. SIZE 80,09	
	@ 34,aPosGet[3] SAY RetTitle("F1_DESPESA") Of oDlg PIXEL SIZE 50 ,9 //"Despesas"
	@ 33,aPosGet[4] MSGET aObjetos[VALDESP] VAR aGets[VALDESP]  PICTURE PesqPict('SD1','D1_TOTAL') OF oDlg PIXEL When .F.  SIZE 80,09
	@ 34,aPosGet[1] SAY RetTitle("F1_VALEMB") Of oDlg PIXEL SIZE 50 ,9 //"Valor da embalagem"
	@ 33,aPosGet[2] MSGET aObjetos[VALEMB] VAR aGets[VALEMB]  PICTURE PesqPict('SD1','D1_TOTAL') OF oDlg PIXEL When .F.  SIZE 80,09
	If GetNewPar("MV_VNAGREG",.F.) .And. cPaisLoc == "BRA"
		If Len(aGets) < 10   
			Aadd(aGets,0)
			Aadd(aObjetos,0)
		Endif
		@ 51,aPosGet[1] SAY STR0062 Of oDlg PIXEL SIZE 58 ,9 //"Valor não Agregado"
		@ 49,aPosGet[2] MSGET aObjetos[VNAGREG] VAR aGets[VNAGREG]  PICTURE PesqPict('SF1','F1_VNAGREG') OF oDlg PIXEL When .F. SIZE 80,09
	Endif
EndIf
@ 51,aPosGet[3] SAY RetTitle("F1_VALBRUT") Of oDlg PIXEL SIZE 58 ,9 //"Total do Doc."
@ 49,aPosGet[4] MSGET aObjetos[TOTPED] VAR aGets[TOTPED]  PICTURE PesqPict('SF1','F1_VALBRUT') OF oDlg PIXEL When .F. SIZE 80,09

@ 43,3 TO 46,aPosGet[5] LABEL '' OF oDlg PIXEL

bRefresh := {|| NfeRFldTot(aGets,aObjetos)}       

Return(.T.)
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeRFldTot³Autor  ³ Eduardo Riera         ³ Data ³12.09.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de atualizacao do folder de totais                    ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpA1: Array com as variaveis dos get de totais              ³±±
±±³          ³ExpA2: Array com os objetos dos get de totais                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo atualizar o folder de totais   ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeRFldTot(aGets,aObjetos)

Local nVlrAnterior := 0

nVlrAnterior := aGets[VALMERC]
aGets[VALMERC] := IIf(MaFisFound(),MaFisRet(,"NF_VALMERC"),aGets[VALMERC])
If nVlrAnterior <> aGets[VALMERC] .Or. !MaFisFound()
	aObjetos[VALMERC]:Refresh()
EndIf
nVlrAnterior := aGets[VALDESC]
aGets[VALDESC] := IIf(MaFisFound(),MaFisRet(,"NF_DESCONTO"),aGets[VALDESC])
If nVlrAnterior <> aGets[VALDESC] .Or. !MaFisFound()
	aObjetos[VALDESC]:Refresh()
EndIf
nVlrAnterior := aGets[TOTPED ]
aGets[TOTPED ] := IIF(MaFisFound(),MaFisRet(,"NF_TOTAL"),aGets[TOTPED ])
If nVlrAnterior <> aGets[TOTPED ] .Or. !MaFisFound()
	aObjetos[TOTPED ]:Refresh()
EndIf
If Len(aGets)>3
	nVlrAnterior := aGets[FRETE  ]
	aGets[FRETE  ] := IIF(MaFisFound(),MaFisRet(,"NF_FRETE"),aGets[FRETE  ])
	If nVlrAnterior <> aGets[FRETE  ] .Or. !MaFisFound()
		aObjetos[FRETE  ]:Refresh()
	EndIf
	nVlrAnterior := aGets[SEGURO ]
	aGets[SEGURO ] := IIF(MaFisFound(),MaFisRet(,"NF_SEGURO"),aGets[SEGURO ])
	If nVlrAnterior <> aGets[SEGURO ] .Or. !MaFisFound()
		aObjetos[SEGURO ]:Refresh()
	EndIf
	nVlrAnterior := aGets[VALDESP]
	aGets[VALDESP] := IIF(MaFisFound(),MaFisRet(,"NF_DESPESA"),aGets[VALDESP])
	If nVlrAnterior <> aGets[VALDESP] .Or. !MaFisFound()
		aObjetos[VALDESP]:Refresh()
	EndIf
	nVlrAnterior := aGets[VALEMB]
	aGets[VALEMB] := IIF(MaFisFound(),MaFisRet(,"NF_VALEMB"),aGets[VALEMB])
	If nVlrAnterior <> aGets[VALEMB] .Or. !MaFisFound()
		aObjetos[VALEMB]:Refresh()
	EndIf
	If GetNewPar("MV_VNAGREG",.F.)
		nVlrAnterior := aGets[VNAGREG ]
		aGets[VNAGREG ] := IIF(MaFisFound(),MaFisRet(,"NF_VNAGREG"),aGets[VNAGREG ])
		If nVlrAnterior <> aGets[VNAGREG ] .Or. !MaFisFound()
			aObjetos[VNAGREG ]:Refresh()
		EndIf
	Endif
EndIf
Return .T.
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeFldFor ³Autor  ³ Eduardo Riera         ³ Data ³12.09.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de atualizacao do folder do fornecedor                ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpO1: Objeto da Janela que sera disponibilizado os Get      ³±±
±±³          ³ExpA2: Array com os gets de totais                           ³±±
±±³          ³ExpA3: Array com as posicoes dos gets de totais              ³±±
±±³          ³Expb4: Codeblock para atualizaco dos dados do Folder         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo atualizar o folder de fornece- ³±±
±±³          ³res                                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeFldFor(oDlg,aGets,aPosGet,bRefresh)

Local aObjetos := Array(Len(aGets))
Local nObj := 1

@ 06,aPosGet[1,1] SAY RetTitle("A2_NOME") Of oDlg PIXEL SIZE 37,09
@ 05,aPosGet[1,2] MSGET aObjetos[nObj] VAR aGets[1] ;
	PICTURE PesqPict('SA2','A2_NOME');
	When .F. ;
	OF oDlg PIXEL SIZE 159,09
If(lLGPD,OfuscaLGPD(aObjetos[nObj],"A2_NOME"),.F.)	

nObj++
@ 06,aPosGet[1,3] SAY RetTitle("A2_TEL") Of oDlg PIXEL SIZE 23,09
@ 05,aPosGet[1,4]+5 MSGET aObjetos[nObj] VAR aGets[2] ;
	When .F. ;
	OF oDlg PIXEL SIZE 74,09
If(lLGPD,OfuscaLGPD(aObjetos[nObj],"A2_TEL"),.F.)	
	
nObj++
@ 43,aPosGet[2,1] SAY RetTitle("A2_PRICOM") Of oDlg PIXEL SIZE 32,09
@ 42,aPosGet[2,2] MSGET aObjetos[3] VAR aGets[3] ;
	PICTURE PesqPict('SA2','A2_PRICOM') ;
	When .F. ;
	OF oDlg PIXEL SIZE 40,09
nObj++
@ 43,aPosGet[2,3] SAY RetTitle("A2_ULTCOM") Of oDlg PIXEL SIZE 36,09
@ 42,aPosGet[2,4] MSGET aObjetos[nObj] VAR aGets[4] ;
	PICTURE PesqPict('SA2','A2_ULTCOM');
	WHEN .F. OF oDlg PIXEL SIZE 40,09
nObj++
@ 43,aPosGet[2,5]-30 SAY RetTitle("A2_CGC") Of oDlg PIXEL SIZE 26,09
@ 42,aPosGet[2,5]+20 MSGET aObjetos[nObj] VAR aGets[7] ;
	PICTURE PesqPict('SA2','A2_CGC');
	WHEN .F. OF oDlg PIXEL SIZE 76,09
If(lLGPD,OfuscaLGPD(aObjetos[nObj],"A2_CGC"),.F.)	
	
nObj++
If Len(aGets)>=8
	@ 43,aPosGet[3,3] SAY RetTitle("A2_INSCR") Of oDlg PIXEL SIZE 30,09
	@ 42,aPosGet[3,4] MSGET aObjetos[6] VAR aGets[8] ;
		PICTURE PesqPict('SA2','A2_INSCR');
		WHEN .F. OF oDlg PIXEL SIZE 60,09
	If(lLGPD,OfuscaLGPD(aObjetos[nObj],"A2_INSCR"),.F.)
	nObj++
Endif
@ 24,aPosGet[3,1] SAY RetTitle("A2_END") Of oDlg PIXEL SIZE 49,09
@ 23,aPosGet[3,2] MSGET aObjetos[nObj] VAR aGets[5];
	PICTURE PesqPict('SA2','A2_END');
	WHEN .F. OF oDlg PIXEL SIZE 205,9
	If(lLGPD,OfuscaLGPD(aObjetos[nObj],"A2_END"),.F.)		
nObj++		
@ 24,aPosGet[3,3] SAY RetTitle("A2_EST") Of oDlg PIXEL SIZE 32,09
@ 23,aPosGet[3,4] MSGET aObjetos[nObj] VAR aGets[6] ;
	PICTURE PesqPict('SA2','A2_EST');
	WHEN .F. OF oDlg PIXEL SIZE 21,09
@ If(Len(aGets)>=8,5,42),aPosGet[3,5] BUTTON STR0009 SIZE 30 ,11 FONT oDlg:oFont ; //"Mais Inf."
	ACTION A103ToFC030()  OF oDlg PIXEL
	If(lLGPD,OfuscaLGPD(aObjetos[nObj],"A2_EST"),.F.)
bRefresh := {|| NfeRFldFor(aGets,aObjetos)}

Return(.T.)
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeRFldFor³Autor  ³ Eduardo Riera         ³ Data ³12.09.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de atualizacao do folder do fornecedor                ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpA1: Array com as variaveis dos get de totais              ³±±
±±³          ³ExpA2: Array com os objetos dos get de totais                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo atualizar o folder de fornece- ³±±
±±³          ³dor                                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeRFldFor(aGets,aObjetos)

Local aArea := GetArea()
Local nX    := 0 
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza o array que contem os dados do Fornecedor      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ( cTipo $ "DB" .Or. A103RtCliRT(cTipo, cTpCompl, cFormul) )
	If aGets <> Nil
		dbSelectArea("SA1")
		dbSetOrder(1)
		If MsSeek(xFilial("SA1")+cA100For+cLoja)
			aGets[1] := SA1->A1_NOME					// Nome
			aGets[2] := IIF(!Empty(SA1->A1_DDI),"( "+TransForm(SA1->A1_DDI,PesqPict("SA1","A1_DDI"))+") ","");
			+TransForm(alltrim(SA1->A1_DDD),PesqPict("SA1","A1_DDD"))+" "+TransForm(SA1->A1_TEL,PesqPict("SA1","A1_TEL")) // Telefone
			aGets[3] := SA1->A1_PRICOM	    			//Primeira Compra
			aGets[4] := SA1->A1_ULTCOM      			//Ultima Compra
			aGets[5] := SA1->A1_END+" - "+SA1->A1_MUN	//Endereco
			aGets[6] := SA1->A1_EST         			//Estado
			aGets[7] := SA1->A1_CGC         			//Cgc
			If Len(aGets)>=8
				aGets[8] := SA1->A1_INSCR         			//Inscricao estadual
			Endif
			For nX := 1 To Len(aObjetos)
				If aObjetos[nX]<>Nil
					aObjetos[nX]:Refresh()
				EndIf
			Next nX
		EndIf
	EndIf
Else
	If aGets <> Nil
		dbSelectArea("SA2")
		dbSetOrder(1)
		If MsSeek(xFilial("SA2")+cA100For+cLoja)

			aGets[1] := SA2->A2_NOME					// Nome
			aGets[2] := IIF(!Empty(SA2->A2_DDI),"( "+TransForm(SA2->A2_DDI,PesqPict("SA2","A2_DDI"))+") ","");
			+TransForm(alltrim(SA2->A2_DDD),PesqPict("SA2","A2_DDD"))+" "+TransForm(SA2->A2_TEL,PesqPict("SA2","A2_TEL")) // Telefone
			aGets[3] := SA2->A2_PRICOM					//Primeira Compra
			aGets[4] := SA2->A2_ULTCOM      			//Ultima Compra
			aGets[5] := SA2->A2_END+" - "+SA2->A2_MUN	//Endereco
			aGets[6] := SA2->A2_EST         			//Estado
			aGets[7] := SA2->A2_CGC         			//Cgc
			If Len(aGets)>=8
				aGets[8] := SA2->A2_INSCR         			//Inscricao estadual
			Endif
			For nX := 1 To Len(aObjetos)
				If aObjetos[nX]<>Nil
					aObjetos[nX]:Refresh()
				EndIf
			Next nX
		EndIf
	EndIf
EndIf
RestArea(aArea)
Return(.T.)   

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeFldDsp ³Autor  ³ Eduardo Riera         ³ Data ³12.09.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de atualizacao do folder de Despesas acessorias       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpO1: Objeto da Janela que sera disponibilizado os Get      ³±±
±±³          ³ExpA2: Array com os gets das despesas acessorias             ³±±
±±³          ³ExpA3: Array com as posicoes dos gets das despesas acessorias³±±
±±³          ³Expb4: Codeblock para atualizaco dos dados do Folder         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo atualizar o folder das despesas³±±
±±³          ³acessorias                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeFldDsp(oDlg,aGets,aPosGet,bRefresh)

Local aObjetos := Array(Len(aGets))

@ 09,aPosGet[1,1] SAY RetTitle("F1_DESCONT") Of oDlg PIXEL SIZE 48,09
@ 08,aPosGet[1,2] MSGET aObjetos[VALDESC] VAR aGets[VALDESC] ;
	PICTURE PesqPict("SD1","D1_VALDESC") ;
	OF oDlg PIXEL ;
	WHEN !l103Visual .And. A103LCF("F1_DESCONT") .And. !cTipo$"PI" ;
	VALID CheckSX3("F1_DESCONT",aGets[VALDESC]) .And. aGets[VALDESC]>=0 .And. NfeVldRef("NF_DESCONTO",aGets[VALDESC]) SIZE 80,09 HASBUTTON
@ 09,aPosGet[1,3] SAY RetTitle("F1_FRETE") Of oDlg PIXEL SIZE 35,09
@ 08,aPosGet[1,4] MSGET aObjetos[FRETE] VAR aGets[FRETE] ;
	PICTURE PesqPict("SF1","F1_FRETE") ;
	OF oDlg PIXEL ;
	WHEN !l103Visual .and. A103LCF("F1_FRETE");
	VALID CheckSX3("F1_FRETE",aGets[FRETE]) .And. aGets[FRETE]>=0 .And. NfeVldRef("NF_FRETE",aGets[FRETE]) SIZE 80,09 HASBUTTON
@ 26,aPosGet[1,1] SAY RetTitle("F1_DESPESA") Of oDlg PIXEL SIZE 42,09
@ 25,aPosGet[1,2] MSGET aObjetos[VALDESP] VAR aGets[VALDESP] ;
	PICTURE PesqPict("SF1","F1_DESPESA") ;
	OF oDlg PIXEL ;
	WHEN !l103Visual .And. A103LCF("F1_DESPESA");
	VALID CheckSX3("F1_DESPESA",aGets[VALDESP]) .And. aGets[VALDESP]>=0 .And. NfeVldRef("NF_DESPESA",aGets[VALDESP]) SIZE 80,09 HASBUTTON
@ 26,aPosGet[1,3] SAY RetTitle("F1_SEGURO") Of oDlg PIXEL SIZE 35,09
@ 25,aPosGet[1,4] MSGET aObjetos[SEGURO] VAR aGets[SEGURO] ;
	PICTURE PesqPict("SF1","F1_SEGURO") ;
	OF oDlg PIXEL ;
	WHEN !l103Visual .And. A103LCF("F1_SEGURO");
	VALID CheckSX3("F1_SEGURO",aGets[SEGURO]) .And. aGets[SEGURO]>=0 .And. NfeVldRef("NF_SEGURO",aGets[SEGURO]) SIZE 80,9	HASBUTTON
@ 38,11 TO 40 ,aPosGet[2,1] LABEL "" OF oDlg PIXEL
@ 48,aPosGet[2,2] SAY STR0010 Of oDlg PIXEL SIZE 60,09 //"Total ( Frete+Despesas)"
@ 47,aPosGet[2,3] MSGET aObjetos[TOTF3] VAR aGets[TOTF3] ;
	PICTURE PesqPict("SF1","F1_VALBRUT") ;
	OF oDlg PIXEL ;
	WHEN .F. SIZE 80,09 HASBUTTON

bRefresh := {|| NfeRFldDsp(aGets,aObjetos)}

Return(.T.)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeVldRef ³Autor  ³ Eduardo Riera         ³ Data ³12.09.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de atualizacao das referencias fiscais dos Gets fixos ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Referencias fiscais dos impostos de cabecalho         ³±±
±±³          ³ExpA2: Valor da referencia                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo atualizar o folder das despesas³±±
±±³          ³acessorias                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeVldRef(cReferencia,xValor)

Local aArea	   := GetArea()
Local nPosPc   := aScan(aHeader,{|x| AllTrim(x[2])=="D1_PEDIDO"})
Local nPosItPc := aScan(aHeader,{|x| AllTrim(x[2])=="D1_ITEMPC"}) 
Local nPosTes  := aScan(aHeader,{|x| AllTrim(x[2])=="D1_TES"})
Local nCnt     := 0
Local lPedidos := .F.
Local lRetorno := .T.
Local lRetPE   := .T.
Local lPedPre  := .F.
Local cUfOri   := ""  
Local aVecReal := {}
Local dVecReal := CTOD('//')
Local lCteOriDest	:= SF1->(ColumnPos("F1_UFORITR")) > 0 .And. SF1->(ColumnPos("F1_MUORITR")) > 0 .And. SF1->(ColumnPos("F1_UFDESTR")) > 0 .And. SF1->(ColumnPos("F1_MUDESTR")) > 0
Local cUfDest  := ""
Local lForPCNF := SuperGetMV("MV_FORPCNF",.F., .F.)

If Type("cCondicao") == "C"
   aVecReal := Condicao(1,cCondicao,,dDEmissao) // O valor (parametro 1) não interessa neste momento, mas a funcão Condição() não retorna nada se o primeiro paramentro for 0 (zero), por esse motivo tive que chumbar um valor (1).
EndIf

If Len(aVecReal) > 0
	dVecReal := aVecReal[1][1]
Else
    dVecReal := dDataBase
EndIf  

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se o Fornecedor da Pre-Nota foi alterado quando tiver vinculo com Pedidos |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cReferencia $ "NF_LOJA/NF_CODCLIFOR"  
   	If nPosTes=0 .And. nPosPc>0 .And. nPosItPc>0 .And. Len(aCols)>0 
        DbSelectArea("SC7")
   	    DbSetOrder(1)
		For nCnt := 1 to Len(aCols)
		    If Len(Trim(aCols[nCnt][nPosPc]))>0 .And. Len(Trim(aCols[nCnt][nPosItPc]))>0
	 	  	    MsSeek(xFilial("SC7")+aCols[nCnt][nPosPc]+aCols[nCnt][nPosItPc]) 
		   	    If C7_NUM==aCols[nCnt][nPosPc] .And. C7_ITEM==aCols[nCnt][nPosItPc] 
		    	    If C7_FORNECE<>CA100FOR .Or. C7_LOJA<>CLOJA
		    	       	lPedPre:=.T.
		    	       	exit
		    	     EndIf
		    	EndIf
		    EndIf
		Next nCnt
	EndIf    
EndIf

If (MaFisFound("NF") .And. !(MaFisRet(,cReferencia)==xValor)) .Or. lPedPre 
	If cReferencia $ "NF_LOJA/NF_CODCLIFOR" .And. nPosPc > 0 .And. nPosItPC > 0;
			.And. Len(aCols) > 0 .And. ( lConsLoja .Or. cReferencia == "NF_CODCLIFOR")
		For nCnt := 1 to Len(aCols)
			If !ExistBlock("MT103VCN")
				If !lPedidos .And. !Empty(aCols[nCnt][nPosPc])
					If lForPCNF
						CPX->(dbSetOrder(2))
						If (CPX->(dbSeek(xFilial("CPX")+CA100FOR+CLOJA+SC7->C7_FORNECE+SC7->C7_LOJA)))
							Exit
						EndIf
					EndIf
					If Aviso(OemToAnsi(STR0018),OemToAnsi(STR0027),{OemToAnsi(STR0016),OemToAnsi(STR0017)}) == 2  //"Existem pedidos relacionados a este fornecedor! Estas informações serão apagadas. Deseja Continuar?""###"Continua"###"Abandona"
						lRetorno := .F.
						Exit
					Else
						lPedidos:=.T.
					EndIf
				EndIf
				If lPedidos
					aCols[nCnt][nPosPc]   := Space(Len(aCols[nCnt][nPosPc]))
					aCols[nCnt][nPosItPc] := Space(Len(aCols[nCnt][nPosItPc]))
				EndIf
			Else       
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Ponto de Entrada MT103VCN - Valida se ira manter o acols com  |
				//| os pedidos preenchidos se o Fornecedor / Loja forem alterados |
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				lPedidos := If(ValType(lRetPE:=ExecBlock("MT103VCN",.F.,.F.,{aHeader,aCols,cReferencia,xValor}))=='L',lRetPE,.T.)
				If ValType(lPedidos) == "L"
					If !lPedidos
						aCols[nCnt][nPosPc]   := Space(Len(aCols[nCnt][nPosPc]))
						aCols[nCnt][nPosItPc] := Space(Len(aCols[nCnt][nPosItPc]))
					EndIf
				Endif
			EndIf
		Next
	EndIf                    
	
	If lRetorno .And. !lPedPre     
		If cReferencia == "NF_NATUREZA"
			cUfOri   := MaFisRet(,"NF_UFORIGEM")
			
			If lCteOriDest
				cUfDest := MaFisRet(,"NF_UFDEST")
			Endif		
		Endif	
	
		MaFisAlt(cReferencia,xValor,,,,,,,dVecReal)
		
		/*Re-insere informações após recriação dos array's fiscais pela troca da natureza
		Utiliza MaFisLoad ao Invés de MaFisRef ou MaFisAlt para não alterar recalcular impostos durante mudança da Natureza (ou mudar a CFOP no caso da Modalidade)*/
		If cReferencia == "NF_NATUREZA" 
			//UF DE ORIGEM
			MaFisLoad("NF_UFORIGEM",cUfOri,,,,,,,dVecReal)
			
			If lCteOriDest .And. !Empty(cUfDest)
				//UF DE DESTINO
				MaFisLoad("NF_UFDEST",cUfDest,,,,,,,dVecReal)
			Endif				
			
			//MODALIDADE DE FRETE
			If Type("aNfeDanfe") == "A" .AND. Len(aNfeDanfe)>=23
				If !Empty(MafisScan("NF_MODAL",.F.)) .And. (Left(aNfeDanfe[23],2) $ "  |01|02|03|04|05|06")
					MaFisLoad("NF_MODAL",Left(aNfeDanfe[23],2))
				EndIf
			EndIf		
		Endif
		
		MaFisToCols(aHeader,aCols,,"MT100")
	EndIf
	Eval(bGDRefresh)
	Eval(bRefresh)
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ponto de Entrada MT103DSP                 |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRetorno .And. ExistBlock('MT103DSP')
	lRetorno := If(ValType(lRetPE:=ExecBlock('MT103DSP',.F.,.F.,{aHeader,aCols,cReferencia,xValor}))=='L',lRetPE,.T.)
EndIf

RestArea(aArea)
Return(lRetorno)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeRFldDsp³Autor  ³ Eduardo Riera         ³ Data ³13.09.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de atualizacao do folder das despesas acessorias      ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpA1: Array com as variaveis dos get de totais              ³±±
±±³          ³ExpA2: Array com os objetos dos get de totais                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo atualizar o folder das despesas³±±
±±³          ³acessorias                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeRFldDsp(aGets,aObjetos)

Local nVlrAnterior := 0
Local nX := 1

nVlrAnterior := aGets[VALDESC]
If MaFisFound("NF")
	aGets[VALDESC] := MaFisRet(,"NF_DESCONTO")
EndIf
If nVlrAnterior <> aGets[VALDESC]
	aObjetos[VALDESC]:Refresh()
EndIf
nVlrAnterior := aGets[FRETE]
If MaFisFound("NF")
	aGets[FRETE] := MaFisRet(,"NF_FRETE")
EndIf
If nVlrAnterior <> aGets[FRETE]
	aObjetos[FRETE]:Refresh()
EndIf
nVlrAnterior := aGets[VALDESP]
If MaFisFound("NF")
	aGets[VALDESP] := MaFisRet(,"NF_DESPESA")
EndIf
If nVlrAnterior <> aGets[VALDESP]
	aObjetos[VALDESP]:Refresh()
EndIf
nVlrAnterior := aGets[SEGURO]
If MaFisFound("NF")
	aGets[SEGURO] := MaFisRet(,"NF_SEGURO")
EndIf
If nVlrAnterior <> aGets[SEGURO]
	aObjetos[SEGURO]:Refresh()
EndIf
nVlrAnterior := aGets[TOTF3  ]
aGets[TOTF3  ] := aGets[FRETE]+aGets[SEGURO]+aGets[VALDESP]
If nVlrAnterior <> aGets[TOTF3  ]
	aObjetos[TOTF3  ]:Refresh()
EndIf
For nX := 1 To Len(aObjetos)
	If aObjetos[nX]<>Nil
		aObjetos[nX]:Refresh()
	EndIf
Next nX

Return(.T.)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeFldChg ³Autor  ³ Eduardo Riera         ³ Data ³11.09.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de controle da troca de folder                        ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpN1: Folder de destino                                     ³±±
±±³          ³ExpN2: Folder atual                                          ³±±
±±³          ³ExpO3: Objeto do Folder                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo exibir/controlar os folders do ³±±
±±³          ³rodape do documento de entrada                               ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeFldChg(nFldDst,nFldAtu,oFolder,aCodeBlock)

DEFAULT nFldDst := IIf(oFolder<>Nil,oFolder:nOption,1)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza os objetos do folder de destino                     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty(aCodeBlock) .And. nFldDst<=Len(aCodeBlock) .And. !Empty(aCodeBlock[nFldDst])
	Eval(aCodeBlock[nFldDst])
EndIf
Return(.T.) 

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeDelItem³ Autor ³ Edson Maricate        ³ Data ³04.03.2000 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Esta rotina valida a delecao de um item do documento de entra³±±
±±³          ³da                                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Sempre .T.                                            ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo validar a delecao do item do   ³±±
±±³          ³documento de entrada informado a funcao fiscal               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeDelItem()

STATIC __lExeDel := .F.

Local cIdentB6  := ""
Local nPIdentB6 := GetPosSD1("D1_IDENTB6")
Local nI        := 0
Local nPosCalc  := 0
Local nPosIt	:= 0
Local nPosItD1	:= GetPosSD1("D1_ITEM")
Local nItem		:= 0

__lExeDel := !__lExeDel

If !MaFisFound("IT",n)
	MaFisAdd("","",0,0,0,CriaVar("D1_NFORI"),CriaVar("D1_SERIORI"),,0,0,0,0,0)
EndIf
MaFisDel(n,aCols[n][Len(aCols[n])])

If __lExeDel .And. !GDDeleted()
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Libera a reserva do identificador de poder de terceiros  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    If !Empty( nPIdentB6 )
		If !Empty( cIdentB6 := aCols[ n, nPIdentB6 ] )
			Leave1Code( "SD1_D1_IDENTB6" + cIdentB6 )
		EndIf 		
    EndIf
EndIf

Eval(bRefresh)
Eval(bRefresh,6)

If Type("oLancApICMS")<>"U" .And. oLancApICMS<>Nil .And. nPosItD1>0
	nPosCalc:=	aScan(oLancApICMS:aHeader,{|aX|aX[2]=="CDA_CALPRO"})
	nPosIt	:=	aScan(oLancApICMS:aHeader,{|aX|aX[2]=="CDA_NUMITE"})
	For nI := 1 To Len(oLancApICMS:aCols)
		If aCols[n,nPosItD1]==oLancApICMS:aCols[nI,nPosIt]
			oLancApICMS:aCols[nI,Len(oLancApICMS:aCols[nI])]	:=	aCols[n,Len(aCols[n])]
		EndIf
	Next nI
	oLancApICMS:Refresh()
EndIf

If Type("oLancCDV")<>"U" .And. oLancCDV<>Nil .And. nPosItD1>0
	nPosCalc:=	aScan(oLancCDV:aHeader,{|aX|aX[2]=="CDV_AUTO"})
	nPosIt	:=	aScan(oLancCDV:aHeader,{|aX|aX[2]=="CDV_NUMITE"})
	For nI := 1 To Len(oLancCDV:aCols)
		If aCols[n,nPosItD1]==oLancCDV:aCols[nI,nPosIt]
			oLancCDV:aCols[nI,Len(oLancCDV:aCols[nI])]	:=	aCols[n,Len(aCols[n])]
		EndIf
	Next nI
	oLancCDV:Refresh()
EndIf

IF Type("aHeadDHR") == "A" .And. Len(aHeadDHR) > 0 .And. Type("aColsDHR") == "A" .And. Len(aColsDHR) > 0 ;
   .And. __lExeDel .And. !GDDeleted()
	
	nItem := aScan(aColsDHR,{|x| x[1] == aCols[n][nPosItD1]})
	If nItem > 0
		aAdd(aBkpDHR,aColsDHR[nItem])
		aDel(aColsDHR,nItem)
		aSize(aColsDHR,Len(aColsDHR)-1)
	Endif

Elseif Type("aHeadDHR") == "A" .And. Len(aHeadDHR) > 0 .And. Type("aColsDHR") == "A" ; 
		.And. __lExeDel .And. GDDeleted()
		
		nItem := aScan(aBkpDHR,{|x| x[1] == aCols[n][nPosItD1]})
		If nItem > 0
			aAdd(aColsDHR,aBkpDHR[nItem])
			aDel(aBkpDHR,nItem)
			aSize(aBkpDHR,Len(aBkpDHR)-1)
		endif 
	
endif 

Return(.T.)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeEmissao³ Autor ³ Edson Maricate        ³ Data ³04.03.2000 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Esta rotina valida a data de emissao do documento de entrada ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpD1: Data de Emissao                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica se a data eh valida                            ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo validar a data de emissao do   ³±±
±±³          ³documento de entrada.                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeEmissao(dEmissao)
Local lRet	:= .T.

Static dMudaEmi
Default dMudaEmi := cToD("")

If !Empty(dEmissao) .And. dEmissao > dDataBase
	lRet := .F.
	Help("  ",1,"A103DATAM")
Else                        
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Atualiza folder financeiro quando alterar a data de emissao do documento fiscal³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ     
	If !Empty(dEmissao) .And. dEmissao <> dMudaEmi
		dMudaEmi := dEmissao
		Eval(bRefresh,6)
	Endif
Endif
Return lRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³SetVar113 ³ Autor ³ TOTVS                 ³ Data ³07.07.2011 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Esta rotina seta um novo valor a variavel dMudaEmi           ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: conteudo para a variavel                              ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/  
function SetVar113(cCont) 
  dMudaEmi:=cCont
Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeNextDoc³ Autor ³ Edson Maricate        ³ Data ³04.03.2000 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Esta rotina controla a numeracao do documento de entrada qdo ³±±
±±³          ³o formulario for proprio                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpD1: Data de Emissao                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica se a data eh valida                            ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo controlar/atualizar a numeracao³±±
±±³          ³do documento de entrada quando o formulario for proprio.     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeNextDoc(cNFiscal,cNfSerie,lAtiva,cNumNfGFE)

Local aArea	   := GetArea()
Local aAreaSF1 := SF1->(GetArea())
Local lRetorno := .T.
Local nItensNf := 0
Local cTipoNf  := SuperGetMv("MV_TPNRNFS")
Local cNum103  := ""  
Local cMT103SRI:= ""
Local lUsaNewKey  := TamSX3("F1_SERIE")[1] == 14 // Verifica se o novo formato de gravacao do Id nos campos _SERIE esta em uso
Local cSerieId    := IIf( lUsaNewKey , SerieNfId("SF1",4,"F1_SERIE",dDEmissao,cEspecie,cNfSerie) , cNfSerie )

If cFormul == "S" .And. lAtiva
	Private cNumero:= ""
	Private cSerie := ""
	lRetorno:= Sx5NumNota(@cSerie,cTipoNf,,,,@cSerieId,dDEmissao ) // O parametro cSerieId deve ser passado para funcao Sx5NumNota afim de tratar a existencia ou nao do mesmo numero na funcao VldSx5Num do MATXFUNA.PRX
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Validacao da NF informada pelo usuario                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRetorno .And. cTipoNF <> "3"
		If A103TEMNF( PadR(cNumero,TamSx3("F1_DOC")[1]), SerieNfId("SF1",4,"F1_SERIE",dDEmissao,cEspecie,cSerie), cA100For, cLoja, cFormul )
			Help(" ",1,"EXISTNF")
			lRetorno := .F.
			cNumero:= ""
			cSerie := ""
		EndIf
	EndIf
	If lRetorno
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica o numero de maximo de itens da serie.               ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aEval(aCols,{|x| nItensNf += IIF(x[Len(x)],0,1)})
		If nItensNf > 0 	.And. nItensNf > a460NumIt(cSerie,.T.)
			Help(" ",1,"A100NITENS")
			lRetorno := .F.
		Else
			If cTipoNf <> "3"

				cSerieId := IIf( lUsaNewKey , SerieNfId("SF1",4,"F1_SERIE",dDEmissao,cEspecie,cSerie) , cSerie )

				// Se numeracao for SXE/SXF e usuario alterou numero, respeita numero do usuarop
				If cTipoNf <> "2" .OR. !lMudouNum
					cNumero := NxtSX5Nota(cSerie, NIL, cTipoNf,,,, cSerieId)// O parametro cSerieId deve ser passado para funcao NxtSx5Nota afim de tratar a existencia ou nao do mesmo numero na funcao VldSx5Num do MATXFUNA.PRX
				EndIf	
			Else 
				If !lMudouNum	// Verifica se usuario alterou numero da nota fiscal
					cNumNfGFE := cNumero
					cNumero := Space(TamSx3("F1_DOC")[1])
				EndIf	
			EndIf
		EndIf
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Ponto de entrada para permitir alterar o numero da nota      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ExistBlock("M103NUM",.F.,.F.)
			cNum103 := ExecBlock("M103NUM",.F.,.F.,{cNumero})
			If Valtype( cNum103 ) == "C"
				cNumero := cNum103
			EndIf
		EndIf
	EndIf

	If lRetorno
	   cNFiscal:=Padr(cNumero,TamSX3('F1_DOC')[1])
	   cNFSerie:=cSerie
    Else 
	   cNFiscal:= CriaVar("F1_DOC",.F.)
	   cNFSerie:= SerieNfId("SF1",5,"F1_SERIE")      
    EndIf
ElseIf cFormul == "N" .And. lAtiva
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica o preenchimento dos campos.        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Empty(ca100For) .Or. Empty(dDEmissao) .Or. Empty(cTipo) .Or. (Empty(cNFiscal).And.cFormul<>"S") .Or.(Empty(cSerie).And.X3Obrigat("F1_SERIE"))
		Help(" ",1,"A100FALTA")
		lRetorno := .F.
	EndIf

	If A103TEMNF( cNFiscal, SerieNfId("SF1",4,"F1_SERIE",dDEmissao,cEspecie,cSerie), cA100For, cLoja, cFormul )
		Help(" ",1,"EXISTNF")
		lRetorno := .F.
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Ponto de entrada para manipular o cNFSerie     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ                 
If ExistBlock("MT103SRI")  
	cMT103SRI := ExecBlock("MT103SRI",.F.,.F.,{cNFiscal,cNFSerie})
  	If ValType(cMT103SRI) == "C"
		cNFSerie := cMT103SRI
	EndIf  
EndIf                  

RestArea(aAreaSF1)
RestArea(aArea)
Return(lRetorno)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³A103IniCpo³Autor  ³ Eduardo Riera         ³ Data ³12.09.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de atualizacao dos dados referentes ao codigo de produ³±±
±±³          ³to.                                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Sempre verdadeiro                                     ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo atualizar as informacoes do    ³±±
±±³          ³item do documento de entrada referente ao produto            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A103IniCpo()

Local aArea			:= GetArea() 
Local aTriggerCpo	:= {}
Local nPosCod 		:= GetPosSD1("D1_COD" )
Local nPosUM		:= GetPosSD1("D1_UM" )
Local nPosSegUM		:= GetPosSD1("D1_SEGUM" )
Local nPosCC		:= GetPosSD1("D1_CC" )
Local nPosConta 	:= GetPosSD1("D1_CONTA" )
Local nPosItCt  	:= GetPosSD1("D1_ITEMCTA" )
Local nPosClVl  	:= GetPosSD1("D1_CLVL" )
Local nPosDtValid	:= GetPosSD1("D1_DTVALID" )
Local nPosRateio	:= GetPosSD1("D1_RATEIO" )
Local nPosTotal		:= GetPosSD1("D1_TOTAL" )
Local nPosLocal		:= GetPosSD1("D1_LOCAL" )
Local nPosQtSegum	:= GetPosSD1("D1_QTSEGUM" )
Local nPosTes		:= GetPosSD1("D1_TES" )
Local nPosPedido	:= GetPosSD1("D1_PEDIDO" )
Local nPosItemPC	:= GetPosSD1("D1_ITEMPC" )
Local nPosLoteCtl	:= GetPosSD1("D1_LOTECTL") 
Local nPosChassi 	:= GetPosSD1("D1_CHASSI")  
Local nPosTesAut	:= Nil
Local cReadVar   	:= ReadVar()
Local cProduto   	:= ""
Local uRet       	:= Nil
Local lDtValid   	:= .T.
Local lMT103CPO		:= ExistBlock("MT103CPO")
Local lTesAuto		:= .F.
Local lPedOK		:= .F.
Local lM103lRat     := SuperGetMv("MV_M103LRA",.F.,.F.)
Local lForPcNF		:= SuperGetMv("MV_FORPCNF",.F.,.F.) //Permite vinculo com pedido de outro fornecedor (entrega por terceiros COMA001)
Local lMT103DTLT	:= ExistBlock('MT103DTLT')

If (Type("l103Auto") <> "U" .And. l103Auto .And. len(aAutoItens) >= n)
	nPosTesAut := IIf(Type("aAutoItens")=="U",0,If(Empty(aAutoItens),0,aScan(aAutoItens[n],{|x|Trim(x[1])== "D1_TES" })))
EndIf

If lMT103CPO
	If nPosConta > 0
		AADD(aTriggerCpo,"D1_CONTA")
	EndIf
	aTriggerCpo:= ExecBlock("MT103CPO",.F.,.F.,{aTriggerCpo})
	If ValType(aTriggerCpo) <> "A"
		aTriggerCpo:= {}
	EndIf
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza os dados com base no cadastro de produto       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SB1")
dbSetOrder(1)
If !"D1_COD"$cReadVar
	MsSeek(xFilial("SB1")+aCols[n][nPosCod])
	cProduto := aCols[n][nPosCod]
Else
	MsSeek(xFilial("SB1")+M->D1_COD)
	cProduto := M->D1_COD
EndIf
If nPosUm<>0
	aCols[n][nPosUM] := SB1->B1_UM
EndIf
If nPosSegUM<>0
	aCols[n][nPosSegUM] := SB1->B1_SEGUM
EndIf
If nPosCC > 0
	If aCols[n][nPosRateio]=="1" .And. lM103lRat
		aCols[n][nPosCC] := Space(Len(aCols[n][nPosCC]))
	ElseIf lMT103CPO
		If Len(aTriggerCpo) > 0 .And. Ascan(aTriggerCpo,{|x| x== "D1_CC"})  > 0
			aCols[n][nPosCC] := SB1->B1_CC
		Else	
			aCols[n][nPosCC] := IIF(Empty(aCols[n][nPosCC]),SB1->B1_CC,aCols[n][nPosCC])
		EndIf
	Else
		aCols[n][nPosCC] := IIF(Empty(aCols[n][nPosCC]),SB1->B1_CC,aCols[n][nPosCC])
	EndIf		
EndIf
If nPosConta > 0
	If aCols[n][nPosRateio]=="1" .And. lM103lRat
		aCols[n][nPosConta] := Space(Len(aCols[n][nPosConta]))
	ElseIf lMT103CPO
		If Len(aTriggerCpo) > 0 .And. Ascan(aTriggerCpo,{|x| x== "D1_CONTA"})  > 0 
			aCols[n][nPosConta] := IIF(Empty(aCols[n][nPosConta]),SB1->B1_CONTA,aCols[n][nPosConta])
		Else
			aCols[n][nPosConta] := SB1->B1_CONTA		
		EndIf
	Else
		aCols[n][nPosConta] := SB1->B1_CONTA
	EndIf
EndIf
If nPosItCt > 0
	If aCols[n][nPosRateio]=="1" .And. lM103lRat
		aCols[n][nPosItCt] := Space(Len(aCols[n][nPosItCt]))
	ElseIf lMT103CPO
		If Len(aTriggerCpo) > 0 .And. Ascan(aTriggerCpo,{|x| x== "D1_ITEMCTA"})  > 0
			aCols[n][nPosItCt] := SB1->B1_ITEMCC
		Else
			aCols[n][nPosItCt] := IIF(Empty(aCols[n][nPosItCt]),SB1->B1_ITEMCC,aCols[n][nPosItCt])
		EndIf
	Else
		aCols[n][nPosItCt] := IIF(Empty(aCols[n][nPosItCt]),SB1->B1_ITEMCC,aCols[n][nPosItCt])
	EndIf			
EndIf
If nPosClVl > 0
	If aCols[n][nPosRateio]=="1" .And. lM103lRat
		aCols[n][nPosClVl] := Space(Len(aCols[n][nPosClVl]))
	ElseIf lMT103CPO
		If Len(aTriggerCpo) > 0 .And. Ascan(aTriggerCpo,{|x| x== "D1_CLVL"})  > 0
			aCols[n][nPosClVl] := SB1->B1_CLVL
		Else	
			aCols[n][nPosClVl] := IIF(Empty(aCols[n][nPosClVl]),SB1->B1_CLVL,aCols[n][nPosClVl])
		EndIf
	Else		
		aCols[n][nPosClVl] := IIF(Empty(aCols[n][nPosClVl]),SB1->B1_CLVL,aCols[n][nPosClVl])
	EndIf
EndIf
If nPosLocal > 0
	aCols[n][nPosLocal]	:= RetFldProd(SB1->B1_COD,"B1_LOCPAD")
Endif
If nPosQtSegum<>0
	aCols[n][nPosQtSegum] := 0
	a100SegUM()
EndIf
If nPosChassi > 0 .And. cPaisLoc == "BRA"
	aCols[n][nPosChassi] := SB1->B1_CHASSI
EndIf

If nPosTes > 0
    //Obtem a TES da aAutoItens quando for passado por Rotina Automatica
    If (Type("l103Auto") <> "U" .And. l103Auto) 
	    If Empty(aCols[n][nPosTes]) .And. nPosTesAut>0 .And. !IsInCallStack("TSFGrvNF") //Se foi chamado pelo TSF (Totvs Sped Fiscal), nao atualiza TES no Array
	    	aCols[n][nPosTes]:= aAutoItens[n][nPosTesAut][2]
	    EndIf
	    
	    //Se informou TES via rotina automatica funções fiscais só devem ser executadas 
    	//no preenchimento da TES pela funcao MsGetDAuto 
    	
		If nPosTesAut > 0 .And. !Empty(aAutoItens[n][nPosTesAut][2])
			lTesAuto := .T.
		EndIf	 
	EndIf

    If cPaisLoc <> "COL"
	    If (Empty(aCols[n][nPosTes]) .And. !Empty(RetFldProd(SB1->B1_COD,"B1_TE"))) .Or.;
	    	 (lMT103CPO .And. Len(aTriggerCpo) > 0 .And. Ascan(aTriggerCpo,{|x| x == "D1_TES"})  > 0  .And. !Empty(RetFldProd(SB1->B1_COD,"B1_TE")))
	 		SF4->(dbSetOrder(1))
			If SF4->(dbSeek(xFilial("SF4")+RetFldProd(SB1->B1_COD,"B1_TE")))
				If !RegistroOk("SF4",.F.)
					Aviso("A103NTES",STR0072+CHR(10)+STR0073+RetFldProd(SB1->B1_COD,"B1_TE"),{STR0038})
				Else              
					aCols[n][nPosTes] := RetFldProd(SB1->B1_COD,"B1_TE")
				EndIf
			EndIf
	    EndIf 
	    
		If !lTesAuto .And. MaFisFound("IT",n)
			If !Empty(aCols[n][nPosTes])
				MaFisAlt("IT_TES",aCols[n][nPosTes],n)
			EndIf
			If aCOLS[n][nPosTotal]<>0
				MaFisToCols(aHeader,aCols,N,"MT100")
			EndIf
		EndIf
	EndIf
EndIf
If Rastro(cProduto) .And. nPosDtValid > 0
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ P.E para manipular a data de validade do lote (D1_DTVALID) ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lMT103DTLT
		uRet := ExecBlock( 'MT103DTLT', .F., .F., {aCols[n][nPosCod], ;
												   aCols[n][nPosLocal], ;
								 				   aCols[n][nPosLoteCtl], ;
								 				   aCols[n][nPosDtValid]})
		
		If ValType( uRet ) == 'D'
			aCols[n][nPosDtValid] := uRet
			lDtValid := .F.
		EndIf
	EndIf	
	If lDtValid
		aCols[n][nPosDtValid]:= IIF(Empty(aCols[n][nPosDtValid]),dDataBase + SB1->B1_PRVALID,aCols[n][nPosDtValid]) // Proteje a sobreposicao da data caso o usuario de get no produto ao classificar o produto.
	EndIf
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se o pedido de compra eh valido                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nPosPedido > 0 
	If !Empty(aCols[n][nPosPedido])
		dbSelectArea("SC7")
		
		IF lConsLoja
			dbSetOrder(6) //C7_FILENT, C7_PRODUTO, C7_FORNECE, C7_LOJA, C7_NUM, C7_ITEM, C7_ITEMGRD, R_E_C_N_O_, D_E_L_E_T_
			lPedOK:= SC7->(MsSeek(xFilial("SC7")+ aCols[n][nPosCod] + cA100For + cLoja + aCols[n][nPosPedido]+aCols[n][nPosItemPC]))
			if !lPedOK .and. lForPcNF //Busca o pedido com código de fornecedor da entrega por terceiros(COMA001)
				DbSelectArea("CPX")
				CPX->(DbSetOrder(2))//CPX_FILIAL + CPX_CODFOR + CPX_LOJFOR
				if CPX->(Msseek(fwxFilial("CPX") + cA100For + cLoja))
					lPedOK := SC7->(MsSeek(xFilial("SC7")+ aCols[n][nPosCod] + CPX->CPX_CODIGO + CPX->CPX_LOJA + aCols[n][nPosPedido]+aCols[n][nPosItemPC]))
				endif
			endif
		Else
			dbSetOrder(4) //C7_FILIAL, C7_PRODUTO, C7_NUM, C7_ITEM, C7_SEQUEN, R_E_C_N_O_, D_E_L_E_T_
			lPedOK := MsSeek(xFilial("SC7")+ aCols[n][nPosCod] + aCols[n][nPosPedido]+aCols[n][nPosItemPC]) .and. If(!lForpcnf,SC7->C7_FORNECE == cA100For,.t.)
		Endif
			If lPedOK
				If SC7->C7_PRODUTO <> cProduto
					aCols[n][nPosPedido]	:= Space(Len(aCols[n][nPosPedido]))
					aCols[n][nPosItemPC]	:= Space(Len(aCols[n][nPosItemPC]))
				EndIf
				If !Empty(SC7->C7_LOCAL)
					aCols[n][nPosLocal] := SC7->C7_LOCAL
				EndIf
			Else
				aCols[n][nPosPedido]	:= Space(Len(aCols[n][nPosPedido]))
				aCols[n][nPosItemPC]	:= Space(Len(aCols[n][nPosItemPC]))
			EndIf
	EndIf
EndIf

//-- Preenche entidades contabeis com cadastro do prod. ou PC
FillCTBEnt(If(Empty(nPosPedido) .Or. Empty(aCols[n,nPosPedido]),"SB1","SC7"),n)

RestArea(aArea)
Return(.T.)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³A103Trigge³ Autor ³ Edson Maricate        ³ Data ³07.01.2000 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Esta funcao indica ao sistema que uma referencia de imposto  ³±±
±±³          ³foi alterado em um gatilho                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Nome do campo alterado                                ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: .T. Se o campo esta no aHeader                        ³±±
±±³          ³       .F. Se o campo nao esta no aHeader                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo atualizar as referencias que   ³±±
±±³          ³foram alteradas atraves de um gatilho do dicionario de dados ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A103Trigger(cCampo)

Local aArea 	:= GetArea()
Local aRefer    := {}
Local lRetorno	:= .T.
Local nPosCpo	:= aScan(aHeader,{|x| AllTrim(x[2])==AllTrim(cCampo)})
If nPosCpo > 0
	aRefer := MaFisGetRF(aHeader[nPosCpo][6])
	If !Empty(aRefer[1])
		MaFisRef(aRefer[1],aRefer[2],aCols[N,nPosCpo])
		If cPaisLoc <>"BRA"
			ModxAtuObj()
		EndIf
	EndIf
Else
	lRetorno := .F.
EndIf
Eval(bRefresh)
RestArea(aArea)
Return(lRetorno)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³A103Total ³ Autor ³ Edson Maricate        ³ Data ³07.01.2000 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Esta rotina valida a digitacao do valor total do item do docu³±±
±±³          ³mento de entrada                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpN1: Valor do total digitado                               ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica se o valor eh valido                           ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo verifica se o valor informado  ³±±
±±³          ³como total do item do documento de entrada eh valido         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A103Total(nTotal)

Local aArea	   := GetArea()
Local nPQuant  := GetPosSD1("D1_QUANT")
Local nPPreco  := GetPosSD1("D1_VUNIT")
Local nPTes    := GetPosSD1("D1_TES"  )
Local nPQSegUm := GetPosSD1("D1_QTSEGUM")
Local nQtSegUm := 0
Local nDif	   := 0
Local cTes     := ""
Local lRetorno := .T.
If cPaisLoc  == "PAR"
	If nPQuant > 0 .And. nPPreco > 0 .And. aCols[n][nPQuant] > 0
		nDif := Abs(NoRound(aCols[n][nPQuant]*aCols[n][nPPreco],MsDecimais(Mafisret(,"NF_MOEDA")))-nTotal)
	EndIf
Else
	If nPQuant > 0 .And. nPPreco > 0 .And. aCols[n][nPQuant] > 0 .And. aCols[n][nPPreco] > 0
		nDif := Abs(NoRound(aCols[n][nPQuant]*aCols[n][nPPreco],2)-nTotal)
	EndIf
EndIf

If nPQSegUm > 0
	nQtSegUm := aCols[n][nPQSegUm]
EndIf

If nPTES > 0
	cTes := aCols[n][nPTES]
	if cTes==NIL
	    cTes:=''
	endif
EndIf

// Total pela segunda unidade de medida
If SuperGetMV("MV_CALC2UM")		// indica se irá recalcular o valor unitario pelo total caso exista 2 unidade de medida
	If nQtSegUm > 0 .And. nDif > 0.49
		aCols[n][nPPreco] := nTotal / aCols[n][nPQuant]
		If	MaFisFound("IT",n)
			MaFisAlt("IT_PRCUNI",aCols[n][nPPreco],n)
		EndIf

		If cPaisLoc  == "PAR"
			If nPQuant > 0 .And. nPPreco > 0 .And. aCols[n][nPQuant] > 0
				nDif := Abs(NoRound(aCols[n][nPQuant]*aCols[n][nPPreco],MsDecimais(Mafisret(,"NF_MOEDA")))-nTotal)
			EndIf
		Else
			If nPQuant > 0 .And. nPPreco > 0 .And. aCols[n][nPQuant] > 0
		nDif := Abs(NoRound(aCols[n][nPQuant]*aCols[n][nPPreco],2) - nTotal)
	EndIf
		EndIf
	EndIf
Endif

If cPaisLoc=="PAR"
	If cTipo$"NDB" .And. !MaTesSel(cTES) .And. (IIf(MsDecimais(Mafisret(,"NF_MOEDA"))==0,nDif > 1.00,nDif > 0.49) )
		Help(" ",1,"TOTAL")
		lRetorno := .F.
	EndIf
Else
	If cTipo$"NDB" .And. !MaTesSel(cTES) .And. nDif > 0.49
	Help(" ",1,"TOTAL")
	lRetorno := .F.
	EndIf
EndIF
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Este IF tem como finalidade atualizar o valor total do item no rodapeh da NF³
//³quando digitamos o valor total do item. Executado na PRE-NOTA (MATA140) 	³
//³								OU  	 									³
//³caso seja executado o MsExecAuto do MATA140 com Abertura de Tela 			³ 
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Upper(AllTrim(FunName()))=="MATA140" .Or. (FwIsInCallStack("MATA140") .And. nMostraTela <> 0)
	Eval (bRefresh,,,nTotal)
EndIf

RestArea(aArea)
Return(lRetorno)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeNfS2Acols³ Autor ³ Edson Maricate      ³ Data ³07.01.2000 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Esta rotina atualiza o acols com base no item do documento de³±±
±±³          ³saida                                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpN1: Numero do registro do item do documento de saida      ³±±
±±³          ³ExpN2: Item do acols no documento de entrada                 ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Sempre .T.                                            ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo atualizar a funcao fiscal com  ³±±
±±³          ³base no item do documento de saida e atualizar o acols tb.   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeNfs2Acols(nRecSD2,nItem)

Local aArea		 := GetArea()
Local aAreaSD2	 := SD2->(GetArea())
Local cMvNFEAval :=	GetNewPar( "MV_NFEAFSD", "000" )
Local cNfFilOri	 := ""
Local nPQuant    := 0
Local nValor     := 0
Local nPValAcRS  := 0
Local nPD1FilOri := 0
Local nPDesc     := 0
Local aIndA1U	 := {}
Local cUfTransp	 := ""
Local nX 		 := 1

If IsInCallStack("COMXCOL")
	For nX := 1 to nItem 
		If !MaFisFound("IT",nX)
			MaFisAdd("","",0,0,0,CriaVar("D1_NFORI"),CriaVar("D1_SERIORI"),,0,0,0,0,0)
		EndIf
	Next nX
Endif

MaColsToFis(aHeader,aCols,nItem,"MT100",.T.)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Posiciona na item da Nota Original          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nPQuant   := GetPosSD1("D1_QUANT")
nPValAcRS := GetPosSD1("D1_VALACRS")
nPDesc    := GetPosSD1("D1_DESC")

//Campo D1_FILORI precisa estar como usado para buscar por filial diferente de xFilial("SF2") - usado pela rotina LOJA720 do modulo SIGALOJA
nPD1FilOri:= GetPosSD1("D1_FILORI")
If nPD1FilOri > 0 .And. !Empty(aCols[nItem][nPD1FilOri])  
	cNfFilOri := aCols[nItem][nPD1FilOri]
Else
	cNfFilOri := xFilial("SF2")
EndIf

dbSelectArea("SD2")
MsGoto(nRecSD2)
dbSelectArea("SF2")
dbSetOrder(1)
MsSeek(cNfFilOri+SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_CLIENTE+SD2->D2_LOJA)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Dispara o ponto para cada item da NF        ³
//³ Executa somente se nao for uma chamada da   ³
//³ A103VLDNFO - Preservando comportamento		³
//³ original - Executa somente 1 vez por linha  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock( "MT103INF" ) .And. !IsInCallStack("A103VldNFO") 
	ExecBlock( "MT103INF", .F., .F., { nItem } ) 	
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza a Funcao Fiscal                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If MaFisRet(nItem,"IT_RECORI")<>nRecSD2 
	MaFisAlt("IT_RECORI",nRecSD2,nItem)
EndIf
//Se for integração EAI, não troca a UF de origem
If !IsInCallStack("MATI103") .And. !IsInCallStack("TMSA500ANU") .And. !IsInCallStack("CANANULA")
	If cPaisLoc == "BRA" 
		cUfTransp := If(Type("aInfAdic") <> "U" .And. Len(aInfAdic) > 0,aInfAdic[10],"") //Se foi enviado o campo F1_UFORITR
	Endif
	// Manter o estado da Nota de Saida mesmo para venda com Cupom Fiscal (LOJA).
	If MaFisRet(,"NF_UFORIGEM")<>SF2->F2_EST .and. (cTipo $ "D|B" .and. Empty(cUfTransp))
		MaFisAlt("NF_UFORIGEM",SF2->F2_EST)
		cUfOrig := SF2->F2_EST   
	EndIf
EndIf
If SD2->D2_DESCZFR <> 0
	nValor := A410Arred(IIF(SD2->D2_QUANT-aCols[nItem][nPQuant] == 0 , SD2->D2_DESCZFR, (SD2->D2_DESCZFR/SD2->D2_QUANT)*aCols[nItem][nPQuant]),"D2_DESCZFR")	
	MaFisAlt("IT_DESCZF",nValor,nItem)
	
	nValor := A410Arred(IIF(SD2->D2_QUANT-aCols[nItem][nPQuant] == 0 , SD2->D2_DESCZFC, (SD2->D2_DESCZFC/SD2->D2_QUANT)*aCols[nItem][nPQuant]),"D2_DESCZFC")
	MaFisAlt("IT_DESCZFCOF",nValor,nItem)
	
	nValor := A410Arred(IIF(SD2->D2_QUANT-aCols[nItem][nPQuant] == 0 , SD2->D2_DESCZFP, (SD2->D2_DESCZFP/SD2->D2_QUANT)*aCols[nItem][nPQuant]),"D2_DESCZFP")
	MaFisAlt("IT_DESCZFPIS",nValor,nItem)
EndIf

If !Empty(SD2->D2_CODISS)
	MaFisAlt("IT_CODISS",SD2->D2_CODISS,nItem)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Agrega o Frete/Desp/Seguro  referente a NF Retornada  ³
//| de acordo com o parametro MV_NFEAFSD 				  ³
//ÀÄÄÄÄ--ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ           
If SD2->D2_VALFRE <> 0     
    If len(cMvNFEAval)>=1
        If Substr(cMvNFEAval,1,1)=="1"     
            nValor := A410Arred(IIF(SD2->D2_QUANT-aCols[nItem][nPQuant] == 0 , SD2->D2_VALFRE, (SD2->D2_VALFRE/SD2->D2_QUANT)*aCols[nItem][nPQuant]),"D1_VALFRE")
			MaFisAlt("IT_FRETE",nValor,nItem)
		EndIf
	EndIf                  
EndIf

If SD2->D2_SEGURO <> 0
    If len(cMvNFEAval)>=2
        If Substr(cMvNFEAval,2,1)=="1"
 	        nValor := A410Arred(IIF(SD2->D2_QUANT-aCols[nItem][nPQuant] == 0 , SD2->D2_SEGURO, (SD2->D2_SEGURO/SD2->D2_QUANT)*aCols[nItem][nPQuant]),"D1_SEGURO")
			MaFisAlt("IT_SEGURO",nValor,nItem)
        EndIf
    EndIf
EndIf

If SD2->D2_DESPESA <> 0
    If len(cMvNFEAval)=3
        If Substr(cMvNFEAval,3,1)=="1"
    	    nValor := A410Arred(IIF(SD2->D2_QUANT-aCols[nItem][nPQuant] == 0 , SD2->D2_DESPESA, (SD2->D2_DESPESA/SD2->D2_QUANT)*aCols[nItem][nPQuant]),"D1_DESPESA")
			MaFisAlt("IT_DESPESA",nValor,nItem)
	    EndIf
    EndIf
EndIf       

//Obtém o valor do Acrescimo Financeiro na Nota de Origem e faz o rateio //
If nPValAcRS >0 
    If SD2->D2_VALACRS >0
 	    aCols[nItem][nPValAcRS] := ( SD2->D2_VALACRS / SD2->D2_QUANT ) * aCols[nItem][nPQuant]
    EndIf
Endif

If SD2->D2_DESC <> 0 .And. nPDesc > 0 .And. aCols[nItem][nPDesc] == 0 
	aCols[nItem][nPDesc] := SD2->D2_DESC
EndIf

If cPaisLoc == "BRA" .And. Type("lIntermed") == "L" .And. lIntermed .And. cFormul == "S"
	aIndA1U	:= GetAdvFVal("SC5",{"C5_INDPRES","C5_CODA1U"},xFilial("SC5") + SD2->D2_CLIENTE + SD2->D2_LOJA + SD2->D2_PEDIDO,3)
	If Len(aIndA1U) > 0
		If !Empty(aIndA1U[1])
			aInfAdic[16] := aIndA1U[1]
		Endif
		If !Empty(aIndA1U[2])
			aInfAdic[17] := aIndA1U[2]
		Endif
	Endif
Endif 

MaFisToCols(aHeader,aCols,nItem,"MT100")

RestArea(aArea)
RestArea(aAreaSD2)
Return(.T.)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeNfe2Aco³ Autor ³ Edson Maricate        ³ Data ³07.01.2000 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Esta rotina atualiza o acols com base no item do documento de³±±
±±³          ³entrada                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpN1: Numero do registro do item do documento de entrada    ³±±
±±³          ³ExpN2: Item do acols no documento de entrada                 ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Sempre .T.                                            ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo atualizar a funcao fiscal com  ³±±
±±³          ³base no item do documento de entrada e atualizar o acols tb. ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeNfe2Acols(nRecSD1,nItem)

Local aArea		:= GetArea()
Local aAreaSD1	:= SD1->(GetArea())
Local lAtualiza := .F.
Local aIndA1U	:= {}

dbSelectArea("SD1")
MsGoto(nRecSD1)

If MaFisFound("NF")
	If MaFisRet(nItem,"IT_NFORI")<>SD1->D1_DOC
		MaFisAlt("IT_NFORI",SD1->D1_DOC,nItem)
		lAtualiza := .T.
	EndIf
	If MaFisRet(nItem,"IT_SERORI")<>SD1->D1_SERIE
		MaFisAlt("IT_SERORI",SD1->D1_SERIE,nItem)
		lAtualiza := .T.	
	EndIf
	If MaFisRet(nItem,"IT_RECORI")<>nRecSD1
		MaFisAlt("IT_RECORI",nRecSD1,nItem)
		lAtualiza := .T.
	EndIf
Endif

If lAtualiza
	MaColsToFis(aHeader,aCols,nItem,"MT100",.T.)
EndIf

If lAtualiza
	If cPaisLoc == "BRA" .And. Type("lIntermed") == "L" .And. lIntermed .And. cFormul == "S"
		aIndA1U	:= GetAdvFVal("SF1",{"F1_INDPRES","F1_CODA1U"},xFilial("SF1") + SD1->D1_DOC + SD1->D1_SERIE + SD1->D1_FORNECE + SD1->D1_LOJA + SD1->D1_TIPO,1)
		If Len(aIndA1U) > 0
			If !Empty(aIndA1U[1])
				aInfAdic[16] := aIndA1U[1] 
			Endif
			If !Empty(aIndA1U[2])
				aInfAdic[17] := aIndA1U[2]
			Endif 
		Endif
	Endif
Endif

If bGdRefresh<>Nil
	Eval(bGDRefresh)
EndIf

RestArea(aArea)
RestArea(aAreaSD1)
Return(.T.)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfePC2Acol³ Autor ³ Edson Maricate        ³ Data ³27.01.2000 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Esta rotina atualiza o acols com base no item do pedido de   ³±±
±±³          ³compra                                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpN1 : Numero do registro do SC7                            ³±±
±±³          ³ExpN2 : Item da NF                                           ³±±
±±³          ³ExpN3 : Saldo do Pedido                                      ³±±
±±³          ³ExpC1 : Item a ser carregado no aCols ( D1_ITEM )            ³±±
±±³          ³ExpL1 : Indica se os dados da Pre-Nota devem ser preservados ³±±
±±³          ³ExpA1 : Valores das despesas acessorias do pedido de compras ³±±
±±³          ³ExpA2 : Cabecalho do rateio                                  ³±±
±±³          ³ExpA3 : Itens do rateio                                      ³±±
±±³          ³ExpN4 : Preco unitário na Pré-Nota						   ³±±
±±³          ³ExpL2 : Indica se nota foi importada pelo TOTVS Colaboracao  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Sempre .T.                                            ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo atualizar a funcao fiscal com  ³±±
±±³          ³base no item do pedido de compra.                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NFePC2Acol(nRecSC7,nItem,nSalPed,cItem,lPreNota,aRateio,aHeadSDE,aColsSDE,nPrUPreNf,lTColab)

Local aArea		   := GetArea()
Local aAreaSC7	   := SC7->(GetArea())
Local aAreaSF4	   := SF4->(GetArea())
Local aAreaSB1	   := SB1->(GetArea())
Local aAreaSC1     := SC1->(GetArea())
Local aAreaSTJ
Local aRefSC7      := MaFisSXRef("SC7")

Local cNGMNTNO	   := SuperGetMV("MV_NGMNTNO",.F.,"2")
Local cNGMNTES	   := SuperGetMV('MV_NGMNTES', .F., 'N' )
Local cMVARRPEDC   := SuperGetMV("MV_ARRPEDC", .F., "")
Local cCodFis      := ""
Local lMNTD1OP	   := FindFunction( 'MNTD1OP' )
Local lMNTD1ORDEM  := FindFunction( 'MNTD1ORDEM' )

Local lRateioPC    := SuperGetMv("MV_NFEDAPC")
Local lAllPC       := .T.
Local lAltImpPreNf := .F.
Local lMaFisFound  := MaFisFound()
Local lMT103IPC	   := ExistBlock( "MT103IPC",,.T. )
Local lMT103RCC	   := ExistBlock( "MT103RCC",,.T. )
Local lMT103IP2	   := ExistBlock( "MT103IP2",,.T. )
Local lRateioDE	   := .F.
Local lTOPDRFRM    := FindFunction("A120RDFRM") .And. A120RDFRM("A103")

Local nQuantPed    := 0
Local nX           := 0   
Local nCntFor      := 0 
Local nValUnit     := 0
Local nValFre      := 0
Local nValDesc     := 0
Local nValDesp     := 0
Local nValSeg      := 0
Local nValTot      := 0
Local nPosQtd      := GetPosSD1("D1_QUANT")
Local nPosQtd2     := GetPosSD1("D1_QTSEGUM")
Local nPosTes      := GetPosSD1("D1_TES")
Local nPosVunit    := GetPosSD1("D1_VUNIT")
Local nPValFret	   := GetPosSD1("D1_VALFRE")
Local nPValDesc	   := GetPosSD1("D1_VALDESC")
Local nPValDesp	   := GetPosSD1("D1_DESPESA")
Local nPValSeg	   := GetPosSD1("D1_SEGURO")
Local nPVOrdem 	   := GetPosSD1("D1_ORDEM")
Local nPMSIPC	   := GetNewPar("MV_PMSIPC",2)
Local nTamCFOP     := TamSX3("F4_CF")[1]
Local aVencReal    := {}
Local dVencReal    := Ctod("")
Local lXmlxped	   := .F.
Local lPropFret    := SuperGetMV("MV_FRT103E",.F.,.T.)//Proporcionalização de frete.
Local nBkp		   := 0
Local lM103lRat    := SuperGetMv("MV_M103LRA",.F.,.F.)

Local lDKD		   := ChkFile("DKD") .and. !Empty(aHeadDKD) //Tabela Complementar SD1
local lExistC7CF   := SC7->(FieldPos("C7_CF")) > 0
Local lTrbGen      := IIf(FindFunction("ChkTrbGen"),ChkTrbGen("SD1", "D1_IDTRIB"),.F.) // Verificacao tributos genericos

DEFAULT aHeadSDE   := {}
DEFAULT aColsSDE   := {}

DEFAULT lPreNota := .F.
DEFAULT lTColab  := .F.
DEFAULT aRateio  := {0,0,0}

If lTColab 
	lXmlxped := SuperGetMV("MV_XMLXPED",.F.,.F.) //.T. = Mantém dados provenientes da NF, .F. = Assume dados provenientes do pedido de compra
Endif

//-- Verifica a existencia do item do acols
If nItem == Nil .Or. nItem > Len(aCols)
	aadd(aCols,Array(Len(aHeader)+1))
	For nX := 1 to Len(aHeader)
		If IsHeadRec(aHeader[nX][2])
		    aCols[Len(aCols)][nX] := 0
		ElseIf IsHeadAlias(aHeader[nX][2])
		    aCols[Len(aCols)][nX] := "SD1"
		ElseIf Trim(aHeader[nX][2]) == "D1_ITEM"
			aCols[Len(aCols)][nX] 	:= IIF(cItem<>Nil,cItem,StrZero(1,Len(SD1->D1_ITEM)))
		Else
			aCols[Len(aCols)][nX] := CriaVar(aHeader[nX][2], (aHeader[nX][10] <> "V") )
		EndIf
		aCols[Len(aCols)][Len(aHeader)+1] := .F.
	Next nX
	nItem := Len(aCols)
EndIf

//Posiciona registros
dbSelectArea("SC7")
SC7->(MsGoto(nRecSC7))

lAllPC := SC7->C7_QUANT == nSalPed .And. Empty(SC7->C7_REAJUST)

dbSelectArea("SB1")
SB1->(dbSetOrder(1))
SB1->(DbSeek(xFilial("SB1")+SC7->C7_PRODUTO))

If !lXmlxped
	nQuantPed:= SC7->C7_QUANT
	nValFre  := SC7->C7_VALFRE
	nValDesc := SC7->C7_VLDESC 
	nValDesp := SC7->C7_DESPESA
	nValSeg  := SC7->C7_SEGURO
	If !Empty(cMVARRPEDC) .AND. AllTrim(Upper(cMVARRPEDC)) == "NOROUND"
		nValUnit := NoRound(NfePcReaj(SC7->C7_REAJUST,lReajuste),TamSX3('D1_VUNIT')[2])
		nValTot := NoRound(nSalPed*nValUnit,TamSX3('D1_TOTAL')[2])
	Else
		nValUnit := Round(NfePcReaj(SC7->C7_REAJUST,lReajuste),TamSX3('D1_VUNIT')[2])
		nValTot := Round(nSalPed*nValUnit,TamSX3('D1_TOTAL')[2])
	EndIf
Else
	nValUnit := aCols[nItem][nPosVunit]
	nSalPed  := aCols[nItem][nPosQtd]
	nValFre	 := aCols[nItem][nPValFret]
	nValDesc := aCols[nItem][nPValDesc]
	nValDesp := IIF((nPValDesp > 0),aCols[nItem][nPValDesp],0)
	nValSeg  := IIF((nPValSeg > 0),aCols[nItem][nPValSeg],0)
	If !Empty(cMVARRPEDC)
		If AllTrim(Upper(cMVARRPEDC)) == "ROUND"
			nValTot := Round(nSalPed*nValUnit, TamSX3('D1_TOTAL')[2])
		ElseIf AllTrim(Upper(cMVARRPEDC)) == "NOROUND"
			nValTot := NoRound(nSalPed*nValUnit,TamSX3('D1_TOTAL')[2])
		EndIf
	Else
		nValTot := Round(nSalPed*nValUnit,TamSX3('D1_TOTAL')[2])
	EndIf
EndIf

//Carrega os impostos do pedido de compra para o Doc.Entrada
If lMaFisFound
	//Obtem a condicao de pagamento do pedido de compra
	If (l103Class .and. Empty(cCondicao)) .Or. !l103Class  
		cCondicao := Iif(l103Auto .And. !Empty(cCondicao), cCondicao, SC7->C7_COND)
		aVencReal := Condicao(1,cCondicao,,M->dDEmissao) // O valor (parametro 1) não interessa neste momento, mas a funcão Condição() não retorna nada se o primeiro paramentro for 0 (zero), por esse motivo tive que chumbar um valor (1).
		If Len(aVencReal) > 0
			dVencReal := aVencReal[1][1]
		Else
			dVencReal := dDataBase
		EndIf  
	EndIf

	MaFisIniLoad(nItem)
	For nX := 1 To Len(aRefSc7)
		Do Case
		Case aRefSC7[nX][2] == "IT_QUANT"
			If !lPreNota
				MaFisLoad(aRefSc7[nX][2],nSalPed,nItem)
			EndIf
		Case aRefSc7[nX][2] == "IT_PRCUNI"
			If !lPreNota
				MaFisLoad(aRefSc7[nX][2],nValUnit,nItem)
			EndIf
		Case aRefSc7[nX][2] == "IT_VALMERC"
			If !lPreNota
				MaFisLoad(aRefSc7[nX][2],nValTot,nItem)
			EndIf
		Case aRefSc7[nX][2] == "IT_DESCONTO"
			If !lPreNota
				MaFisLoad(aRefSc7[nX][2],xMoeda(((nValDesc/nQuantPed)* nSalPed),SC7->C7_MOEDA,1,M->dDEmissao,,SC7->C7_TXMOEDA,),nItem)
			EndIf
		Case aRefSc7[nX][2] == "IT_VALEMB"
			MaFisLoad(aRefSc7[nX][2],xMoeda(SC7->C7_VALEMB,SC7->C7_MOEDA,1,M->dDEmissao,,SC7->C7_TXMOEDA,),nItem)
		Case aRefSc7[nX][2] == "IT_SEGURO"
			If lRateioPC
				MaFisLoad(aRefSc7[nX][2],xMoeda(((nValSeg/nQuantPed)*nSalPed),SC7->C7_MOEDA,1,M->dDEmissao,,SC7->C7_TXMOEDA,),nItem)
			Else
				aRateio[1] += xMoeda(((nValSeg/nQuantPed)*nSalPed),SC7->C7_MOEDA,1,M->dDEmissao,,SC7->C7_TXMOEDA)
			EndIf
		Case aRefSc7[nX][2] == "IT_DESPESA"
			If lRateioPC
				MaFisLoad(aRefSc7[nX][2],xMoeda(((nValDesp/nQuantPed)*nSalPed),SC7->C7_MOEDA,1,M->dDEmissao,,SC7->C7_TXMOEDA,),nItem)
			Else
				aRateio[2] += xMoeda(((nValDesp/nQuantPed)*nSalPed),SC7->C7_MOEDA,1,M->dDEmissao,,SC7->C7_TXMOEDA)
			EndIf
		Case aRefSc7[nX][2] == "IT_FRETE"
			If lRateioPC	
				MaFisLoad(aRefSc7[nX][2],xMoeda(((nValFre/nQuantPed)*nSalPed),SC7->C7_MOEDA,1,M->dDEmissao,,SC7->C7_TXMOEDA,),nItem)
			Else
				aRateio[3] += xMoeda(((nValFre/nQuantPed)*nSalPed),SC7->C7_MOEDA,1,M->dDEmissao,,SC7->C7_TXMOEDA)
			EndIf
		Case aRefSc7[nX][2] == "IT_TES"
			If !Empty(SC7->C7_TES)
				dbSelectArea("SF4")
				SF4->(dbSetOrder(1))
				SF4->(DbSeek(xFilial("SF4")+SC7->C7_TES))				
				MaFisLoad("IT_CF",MaFisCFO(nItem,SF4->F4_CF),nItem)
			EndIf
		Case aRefSc7[nX][2] == "IT_BASEICM"
			nD1BaseIcm := SC7->(FieldGet(FieldPos(aRefSc7[nX][1])))
			If !lPreNota .Or. Empty(SD1->D1_BASEICM) .Or. SD1->D1_BASEICM == nD1BaseIcm
				If nD1BaseIcm <> 0
					MaFisLoad(aRefSc7[nX][2],nD1BaseIcm,nItem)
				Else
					lAltImpPreNf := .T.
				EndIf
			Else
				lAltImpPreNf := .T.
			EndIf
		Case aRefSc7[nX][2] == "IT_ALIQICM"
			nD1Picm := SC7->(FieldGet(FieldPos(aRefSc7[nX][1])))
			If !lPreNota .Or. Empty(SD1->D1_PICM) .Or. SD1->D1_PICM == nD1Picm
				If nD1Picm <> 0
					MaFisLoad(aRefSc7[nX][2],nD1Picm,nItem)
				Else
					lAltImpPreNf := .T.
				EndIf
			Else
				lAltImpPreNf := .T.
			EndIf
		Case aRefSc7[nX][2] == "IT_VALICM"
			nD1ValIcm	:= SC7->(FieldGet(FieldPos(aRefSc7[nX][1])))
			If !lPreNota .Or. Empty(SD1->D1_VALICM) .Or. SD1->D1_VALICM == nD1ValIcm
				If nD1ValIcm <> 0
					MaFisLoad(aRefSc7[nX][2],nD1ValIcm,nItem)
				Else
					lAltImpPreNf := .T.
				EndIf
			Else
				lAltImpPreNf := .T.
			EndIf			
		Case aRefSc7[nX][2] == "IT_BASEIPI"
			nD1BaseIpi	:= SC7->(FieldGet(FieldPos(aRefSc7[nX][1])))
			If !lPreNota .Or. Empty(SD1->D1_BASEIPI) .Or. SD1->D1_BASEIPI == nD1BaseIpi
				If nD1BaseIpi <> 0
					MaFisLoad(aRefSc7[nX][2],nD1BaseIpi,nItem)
				Else
					lAltImpPreNf := .T.
				EndIf				
			Else
				lAltImpPreNf := .T.
			EndIf
		Case aRefSc7[nX][2] == "IT_ALIQIPI"
			nD1AliqIpi := SC7->(FieldGet(FieldPos(aRefSc7[nX][1])))
			If !lPreNota .Or. Empty(SD1->D1_IPI) .Or. SD1->D1_IPI == nD1AliqIpi
				If nD1AliqIpi <> 0
					MaFisLoad(aRefSc7[nX][2],nD1AliqIpi,nItem)
				Else
					lAltImpPreNf := .T.
				EndIf				
			Else
				lAltImpPreNf := .T.
			EndIf
		Case aRefSc7[nX][2] == "IT_VALIPI"
			nD1ValIpi	:= SC7->(FieldGet(FieldPos(aRefSc7[nX][1])))	
			If !lPreNota .Or. Empty(SD1->D1_VALIPI) .Or. SD1->D1_VALIPI == nD1ValIpi
				If nD1ValIpi <> 0
					MaFisLoad(aRefSc7[nX][2],nD1ValIpi,nItem)
				Else
					lAltImpPreNf := .T.
				EndIf				
			Else
				lAltImpPreNf := .T.
			EndIf			
		Case aRefSc7[nX][2] == "IT_CF"

			cCodFis := PADR(SC7->(FieldGet(FieldPos(aRefSc7[nX][1]))),nTamCFOP)
			cCodFis := PADR(MaFisCFO(nItem,cCodFis,/*aDados*/),nTamCFOP)

			MaFisLoad(aRefSc7[nX][2],cCodFis,nItem)

		OtherWise
			MaFisLoad(aRefSc7[nX][2],SC7->(FieldGet(FieldPos(aRefSc7[nX][1]))),nItem)
		EndCase
	Next nX
	MaFisEndLoad(nItem)
Else
	//Obtem a condicao de pagamento do pedido de compra
	cCondicao := SC7->C7_COND 
EndIf

//Atualiza o acols com base no pedido de compras
If !lPreNota
	if FwIsInCallStack("MATA103") .and. FwAliasInDic("DHR") .and. FindFunction("A103NatRen") .and. type("aHeadDHR") == "A" .and. type("aColsDHR") == "A"
		nBkp := n
	endif
	For nCntFor := 1 To Len(aHeader)
		Do Case
		Case Trim(aHeader[nCntFor,2]) == "D1_COD"
			aCols[nItem,nCntFor] := SC7->C7_PRODUTO
			//Atualiza a natureza de rendimento do item correspondente.
			if FwIsInCallStack("MATA103") .and. FwAliasInDic("DHR") .and. FindFunction("A103NatRen") .and. type("aHeadDHR") == "A" .and. type("aColsDHR") == "A"
				n := nItem
				A103NatRen(aHeadDHR,aColsDHR,.T.,.F.,,SC7->C7_PRODUTO)
			endif  
			
			//Função responsável por retornar ncm definido na amarração prod x fornecedor 
			Mt060CodFis(aCols[nItem,nCntFor],cA100For,cLoja)

		Case Trim(aHeader[nCntFor,2]) == "D1_REVISAO"
			aCols[nItem,nCntFor] := SC7->C7_REVISAO
		Case Trim(aHeader[nCntFor,2]) == "D1_TOTAL"			
			aCols[nItem,nCntFor] := Round(nSalPed*Round(nValUnit,TamSX3('D1_VUNIT')[2]), TamSX3('D1_TOTAL')[2])
		Case Trim(aHeader[nCntFor,2]) == "D1_TES" .And. !Empty(SC7->C7_TES)
			aCols[nItem,nCntFor] := SC7->C7_TES
		Case Trim(aHeader[nCntFor,2]) == "D1_PEDIDO"
			aCols[nItem,nCntFor] := SC7->C7_NUM
		Case Trim(aHeader[nCntFor,2]) == "D1_QUANT" .Or. Trim(aHeader[nCntFor,2]) == "D1_SLDEXP"
			aCols[nItem,nCntFor] := nSalPed
		Case Trim(aHeader[nCntFor,2]) == "D1_VUNIT"
			aCols[nItem,nCntFor] := Round(nValUnit,TamSX3('D1_VUNIT')[2])
		Case Trim(aHeader[nCntFor,2]) == "D1_ITEMPC"
			aCols[nItem,nCntFor] := SC7->C7_ITEM
		Case Trim(aHeader[nCntFor,2]) == "D1_LOCAL"
			aCols[nItem,nCntFor] := SC7->C7_LOCAL
		Case Trim(aHeader[nCntFor,2]) == "D1_CC"
			aCols[nItem,nCntFor] := SC7->C7_CC     
			If SC7->C7_RATEIO == "1" .And. lM103lRat
				aCols[nItem,nCntFor] := Space(Len(SC7->C7_CC)) // Limpa o conteúdo do campo devido a ativação do parametro MV_M103LRA.
			EndIf
		Case Trim(aHeader[nCntFor,2]) == "D1_OP"
			dbSelectArea("SC1")
			SC1->(dbSetOrder(1))
			SC1->(dbSeek(xFilial("SC1")+SC7->C7_NUMSC+SC7->C7_ITEMSC))
			If AllTrim(SC1->C1_ORIGEM) <> "MATA106" .And. (IIf(nPVOrdem > 0 ,Empty(aCols[nItem,nPVOrdem]) , .T.))
				aCols[nItem,nCntFor] := SC7->C7_OP
			EndIf

			// Integração com Sigamnt - carrega o campo OP
			If cNGMNTES == 'S' .And. Empty( aCols[nItem,nCntFor] ) .And. lMNTD1OP
				MNTD1OP( aHeader, aCols, nItem )
			EndIf

		Case Trim(aHeader[nCntFor,2]) == "D1_ITEMCTA"			// Item Contabil
			aCols[nItem,nCntFor] := Iif( Empty(SC7->C7_ITEMCTA) .AND. SC7->C7_RATEIO !="1", SB1->B1_ITEMCC, SC7->C7_ITEMCTA )
			If SC7->C7_RATEIO == "1" .And. lM103lRat
				aCols[nItem,nCntFor] := Space(Len(SC7->C7_ITEMCTA)) // Limpa o conteúdo do campo devido a ativação do parametro MV_M103LRA.
			EndIf
		Case Trim(aHeader[nCntFor,2]) == "D1_CONTA"				// Conta Contabil
			aCols[nItem,nCntFor] := Iif( Empty(SC7->C7_CONTA) .AND. SC7->C7_RATEIO !="1", SB1->B1_CONTA, SC7->C7_CONTA )
			If SC7->C7_RATEIO == "1" .And. lM103lRat
				aCols[nItem,nCntFor] := Space(Len(SC7->C7_CONTA)) // Limpa o conteúdo do campo devido a ativação do parametro MV_M103LRA.
			EndIf
		Case Trim(aHeader[nCntFor,2]) == "D1_CLVL"				// Classe de Valor
			aCols[nItem,nCntFor] := Iif( Empty(SC7->C7_CLVL) .AND. SC7->C7_RATEIO !="1", SB1->B1_CLVL, SC7->C7_CLVL )
			If SC7->C7_RATEIO == "1" .And. lM103lRat
				aCols[nItem,nCntFor] := Space(Len(SC7->C7_CLVL)) // Limpa o conteúdo do campo devido a ativação do parametro MV_M103LRA.
			EndIf
		Case Trim(aHeader[nCntFor,2]) == "D1_UM"
			aCols[nItem,nCntFor] := SC7->C7_UM
		Case Trim(aHeader[nCntFor,2]) == "D1_SEGUM"
			aCols[nItem,nCntFor] := SC7->C7_SEGUM
		Case Trim(aHeader[nCntFor,2]) == "D1_QTSEGUM"
			aCols[nItem,nCntFor] := IIF(SB1->B1_CONV <> 0 .And. aCols[nItem][nPosQtd] <> 0, ConvUm(SB1->B1_COD,aCols[nItem][nPosQtd],aCols[nItem][nPosQtd2],2),SC7->C7_QTSEGUM) 
		Case Trim(aHeader[nCntFor,2]) == "D1_DESC"
			aCols[nItem,nCntFor] := SC7->C7_DESC
		Case Trim(aHeader[nCntFor,2]) == "D1_VALDESC"
			aCols[nItem,nCntFor] := xMoeda(((SC7->C7_VLDESC/SC7->C7_QUANT)* nSalPed) , SC7->C7_MOEDA,1,M->dDEmissao,,SC7->C7_TXMOEDA)
		Case Trim(aHeader[nCntFor,2]) == "D1_RATEIO" 
			aCols[nItem,nCntFor] := SC7->C7_RATEIO
			If SC7->C7_RATEIO == "1"
				lRateioDE	:= .T.
			Endif
		Case Trim(aHeader[nCntFor,2]) == "D1_VALFRE"
			If nPValFret > 0
				aCols[nItem,nCntFor] := if(lPropFret,xMoeda(((SC7->C7_VALFRE/SC7->C7_QUANT)* nSalPed),SC7->C7_MOEDA,1,M->dDEmissao,,SC7->C7_TXMOEDA),xMoeda(SC7->C7_VALFRE,SC7->C7_MOEDA,1,M->dDEmissao,,SC7->C7_TXMOEDA))
			EndIf
		Case Trim(aHeader[nCntFor,2]) == "D1_DESPESA"
			If nPValDesp > 0
				aCols[nItem,nCntFor] := xMoeda(((SC7->C7_DESPESA/SC7->C7_QUANT)* nSalPed) , SC7->C7_MOEDA,1,M->dDEmissao,,SC7->C7_TXMOEDA)
			Endif
		Case Trim(aHeader[nCntFor,2]) == "D1_SEGURO"
			If nPValSeg > 0
				aCols[nItem,nCntFor] := xMoeda(((SC7->C7_SEGURO/SC7->C7_QUANT)* nSalPed) , SC7->C7_MOEDA,1,M->dDEmissao,,SC7->C7_TXMOEDA)  
			Endif
		Case Trim(aHeader[nCntFor,2]) == "D1_CODGRP"
			aCols[nItem,nCntFor] := SB1->B1_GRUPO
		Case Trim(aHeader[nCntFor,2]) == "D1_CODITE"
			aCols[nItem,nCntFor] := SB1->B1_CODITE  
		Case Trim(aHeader[nCntFor,2]) == "D1_CLASFIS"
			dbSelectArea("SF4")
			SF4->(dbSetOrder(1))
			SF4->(DbSeek(xFilial("SF4")+SC7->C7_TES))		
			aCols[nItem,nCntFor] := SubStr(SB1->B1_ORIGEM,1,1)+SF4->F4_SITTRIB
		Case Trim(aHeader[nCntFor,2]) == "D1_IPI"
			If !Empty(SC7->C7_IPI)
				aCols[nItem,nCntFor] := SC7->C7_IPI
			Else
				aCols[nItem,nCntFor] := SB1->B1_IPI
			EndIf
		Case Trim(aHeader[nCntFor,2]) == "D1_PICM"
			If !Empty(SC7->C7_PICM)
				aCols[nItem,nCntFor] := SC7->C7_PICM
			Else
				aCols[nItem,nCntFor] := SB1->B1_PICM
			EndIf 
		Case Trim(aHeader[nCntFor,2]) == "D1_ITEMMED"
			aCols[nItem,nCntFor] := If( !Empty( SC7->C7_CONTRA ) .And. !Empty( SC7->C7_MEDICAO ), "1", "2" )
		//Nota de empenho	
		Case Trim(aHeader[nCntFor,2]) == "D1_CODNE"
			aCols[nItem,nCntFor] := SC7->C7_CODNE
		Case Trim(aHeader[nCntFor,2]) == "D1_ITEMNE"
			aCols[nItem,nCntFor] := SC7->C7_ITEMNE
		Case Trim(aHeader[nCntFor,2]) == "D1_DTVALID"
			If Rastro(SC7->C7_PRODUTO) 
				If !lTColab
					aCols[nItem,nCntFor] := dDatabase + SB1->B1_PRVALID
				EndIf
			Else
				aCols[nItem,nCntFor] := Ctod( '' )
			EndIf
		Case Trim(aHeader[nCntFor,2]) == "D1_ORDEM"
			
			// Integração com Sigamnt - Carrega campo D1_ORDEM
			If lMNTD1ORDEM
				MNTD1ORDEM( aHeader, aCols, nItem )
			Else
				aAreaSC1 := SC1->(GetArea())
				
				dbSelectArea("SC1")
				SC1->(dbSetOrder(1))
				SC1->(dbSeek(xFilial("SC1")+SC7->C7_NUMSC+SC7->C7_ITEMSC))
				If AllTrim(SC1->C1_ORIGEM) <> "MATA106"
					If cNGMNTNO == "1"
						aAreaSC1 := SC1->(GetArea())
						aAreaSTJ := STJ->(GetArea())
					
						If !Empty(SC7->C7_OP)
							dbSelectArea("STJ") 
							STJ->(dbSetOrder(1))
							
							cOPStj := SubStr(SC7->C7_OP,1,At("OS",SC7->C7_OP)-1)
							
							If !Empty(cOPStj) .And. STJ->(dbSeek(xFilial("STJ")+ cOPStj))
								aCols[nItem,nCntFor] := cOPStj			
							EndIf
						Else
							dbSelectArea("SC1")
							SC1->(dbSetOrder(1))
							If SC1->(dbSeek(xFilial("SC1")+SC7->C7_NUMSC+SC7->C7_ITEMSC))
								dbSelectArea("STJ")
								STJ->(dbSetOrder(1))
								
								cOPStj := if(!empty(SC1->C1_OS),SC1->C1_OS,SubStr(SC1->C1_OP,1,At("OS",SC1->C1_OP)-1))
								
								If !Empty(cOPStj) .And. STJ->(dbSeek(xFilial("STJ")+ cOPStj))
									aCols[nItem,nCntFor] := cOPStj
									NGSDCHKORDEM(cOPStj,nItem)
								Endif
							Endif
						EndIf
					
						RestArea(aAreaSTJ)
						RestArea(aAreaSC1)
					EndIf
				Endif
				RestArea(aAreaSC1)
			Endif
		//Integração RM TOP x Protheus (Retenção/Dedução/Faturamento Direto)
		Case Type("lTOPDRFRM") <> "U" .And. lTOPDRFRM .And. Trim(aHeader[nCntFor,2]) == "D1_RETENCA" 
			aCols[nItem,nCntFor] := SC7->C7_RETENCA-SC7->C7_QUJERET
			
		Case Type("lTOPDRFRM") <> "U" .And. lTOPDRFRM .And. Trim(aHeader[nCntFor,2]) == "D1_DEDUCAO"
			aCols[nItem,nCntFor] := SC7->C7_DEDUCAO-SC7->C7_QUJEDED
			
		Case Type("lTOPDRFRM") <> "U" .And. lTOPDRFRM .And. Trim(aHeader[nCntFor,2]) == "D1_FATDIRE"
			aCols[nItem,nCntFor] := SC7->C7_FATDIRE-SC7->C7_QUJEFAT
		EndCase
	Next nCntFor
	if FwIsInCallStack("MATA103") .and. FwAliasInDic("DHR") .and. FindFunction("A103NatRen") .and. type("aHeadDHR") == "A" .and. type("aColsDHR") == "A"
		n := nBkp
	endif
	FillCTBEnt("SC7",nItem)
	
	//Atualização de campos referente o modulo de Armazenagem - SIGAWMS	
	If IntWMS(SC7->C7_PRODUTO) 
		WmsAvalSD1("8","SD1",aCols,nItem,aHeader)
	EndIf

	If !lMaFisFound
		aRateio[1] += xMoeda(SC7->C7_SEGURO ,SC7->C7_MOEDA,1,M->dDEmissao,,SC7->C7_TXMOEDA)
		aRateio[2] += xMoeda(SC7->C7_DESPESA,SC7->C7_MOEDA,1,M->dDEmissao,,SC7->C7_TXMOEDA)
		aRateio[3] += xMoeda(SC7->C7_VALFRE ,SC7->C7_MOEDA,1,M->dDEmissao,,SC7->C7_TXMOEDA)
	EndIf

	//Complementa o rateio da nota fiscal de saida com o rateio do pedido de compras
	If lRateioDE
		If Empty(aHeadSDE)
			dbSelectArea("SX3")
			SX3->(dbSetOrder(1))
			SX3->(DbSeek("SDE"))
			While SX3->(!EOF()) .And. SX3->X3_ARQUIVO == "SDE"
				IF X3Uso(SX3->X3_USADO) .AND. cNivel >= SX3->X3_NIVEL .And. !"DE_CUSTO" $ SX3->X3_CAMPO
					AADD(aHeadSDE,{TRIM(x3Titulo()),;
						SX3->X3_CAMPO,;
						SX3->X3_PICTURE,;
						SX3->X3_TAMANHO,;
						SX3->X3_DECIMAL,;
						SX3->X3_VALID,;
						SX3->X3_USADO,;
						SX3->X3_TIPO,;
						SX3->X3_F3,;
						SX3->X3_CONTEXT } )
				EndIf
				SX3->(dbSkip())
			EndDo
			//Adiciona os campos de Alias e Recno ao aHeader para WalkThru
			ADHeadRec("SDE",aHeadSDE)	
		Endif

		cItemRat := IIF(cItem<>Nil,cItem,StrZero(nItem,Len(SD1->D1_ITEM)))
		RatPed2NF(aHeadSDE,@aColsSDE,cItemRat,nRecSC7)
	Endif
	If lDKD
		//Atualiza aColsDKD
		A103DKDATU(0,.T.) 
	Endif
	// 1 - utilização a associação automática com o PMS
	// 2 - não utiliza a associação automática com o PMS
	// default: não utilizar a associação automática
	If IntePMS() .And. nPMSIPC == 1
		PMS103IPC(nItem)
	EndIf

	//Efetua a chamada dos pontos de entrada
	If ExistTemplate( "MT103IPC",,.T. ) .AND. HasTemplate("MT103IPC")  
		ExecTemplate( "MT103IPC", .F., .F.,{nItem})
	EndIf

	//Agroindustria
	If FindFunction("OGXUtlOrig") .And. OGXUtlOrig()  //Encontra a função
		If FindFunction("OGX205") //Encontra a função
			OGX205() // Executa a função
		EndIf
	EndIf

	If lMT103IPC
		ExecBlock( "MT103IPC", .F., .F.,{nItem})
	EndIf
	
	If lMT103RCC
		aColsSDE := ExecBlock( "MT103RCC", .F., .F.,{aHeadSDE,aColsSDE})
	EndIf
		
	If lDKD
		//Atualiza aColsDKD
		A103DKDATU(0,.T.) 
	Endif
EndIf

//Quando ha TES no pedido de compra, deve-se recalcular os
//impostos carregados para verificar se nao ha novos impostos
//que devem ser calculados!
If lMaFisFound
	Do Case
	Case cA100For+cLoja <> SC7->C7_FORNECE+SC7->C7_LOJA
		MaFisLoad("IT_TES","",nItem)	
		MaFisAlt("IT_ALIQICM",0,nItem)
		MaFisAlt("IT_ALIQIPI",0,nItem)
		If Empty(SC7->C7_TES)
			MaFisAlt("IT_TES",RetFldProd(SB1->B1_COD,"B1_TE"),nItem)
		Else
			MaFisAlt("IT_TES",SC7->C7_TES,nItem)				
		EndIf
	Case Empty(SC7->C7_TES) .And. !Empty(RetFldProd(SB1->B1_COD,"B1_TE"))
		MaFisLoad("IT_TES","",nItem)
		MaFisAlt("IT_TES",RetFldProd(SB1->B1_COD,"B1_TE"),nItem)
	Case Empty(SC7->C7_TES) .And. Empty(RetFldProd(SB1->B1_COD,"B1_TE")) .And. nPosTes > 0
		MaFisLoad("IT_TES","",nItem)
		MaFisAlt("IT_TES",IF( aCols[nItem,nPosTes] == Nil,CriaVar("D1_TES"),aCols[nItem,nPosTes] ),nItem,,,,,,dVencReal)
	Case !Empty(SC7->C7_TES)
		MaFisLoad("IT_TES","",nItem)
		MaFisAlt("IT_TES",SC7->C7_TES,nItem,,,,,,dVencReal)
		If lAllPC .And. !lAltImpPreNf
			// Quando for Relacionar o Pedido a Nf ou preço unitário da Pré-Nf for igual ao Pedido, entra na Rotina
			// Caso Preço Unitário da Pré-Nf for divergente do pedido, prevalece o preço da Pré-Nf mesmo que a quantidade do pedido seja igual.
		    
		    If nPrUPreNf == Nil .Or. (nPrUPreNf-SC7->C7_PRECO) == 0  
				For nX := 1 To Len(aRefSc7)
					Do Case
					Case !("IT_BAS"$aRefSc7[nX][2] .Or. "IT_VAL"$aRefSc7[nX][2] .Or. "IT_ALIQ"$aRefSc7[nX][2])
						//Não fazer nada
					case !Empty(SC7->(FieldGet(FieldPos(aRefSc7[nX][1]))))
						iF !(SUBSTR(aRefSc7[NX][2],4,3) $ 'BAS|VAL')
							MaFisAlt(aRefSc7[nX][2],SC7->(FieldGet(FieldPos(aRefSc7[nX][1]))),nItem)
						ELSE
							MaFisAlt(aRefSc7[nX][2],xMoeda(SC7->(FieldGet(FieldPos(aRefSc7[nX][1]))),SC7->C7_MOEDA,1,M->dDEmissao,,SC7->C7_TXMOEDA,),nItem)
						ENDif
					EndCase
				Next nX
			EndIf
		EndIf		

		If lTColab
			ATriGenCol(nItem)
		EndIf
	EndCase

		//Tratamento do configurador de tributos a partir do CFOP
	if lExistC7CF .And. !Empty(SC7->C7_CF) .And. lTrbGen
		MaFisLoad("IT_CF","",nItem)

		cCodFis := PADR(SC7->C7_CF,nTamCFOP)

		cCodFis := PADR(MaFisCFO(nItem,cCodFis,/*aDados*/),nTamCFOP)

		MaFisAlt("IT_CF",cCodFis,nItem,,,,,,dVencReal)

		If lTColab
			ATriGenCol(nItem)
		EndIf
	endif	

	//Ponto de entrada para tratamentos diversos após o recalculo de
	//impostos carregados a partir da TES correspondente
	If lMT103IP2
		ExecBlock( "MT103IP2", .F., .F.,{nItem})
	EndIf
	
	MaFisToCols(aHeader,aCols,Len(aCols),"MT100")
	aColsD1 := acols //Atualização necessária para que, o Array do Lançamento da Apuração de ICMS tenha o mesmos itens do acols da Nota Fiscal de Entrada.
EndIf

If cPaisLoc == "BRA" .And. Type("lIntermed") == "L" .And. lIntermed
	Eval(bRefresh,10)
Endif

If Type("bRefresh")=="B"
	Eval(bRefresh,6)
EndIf

RestArea(aAreaSB1)
RestArea(aAreaSF4)
RestArea(aAreaSC7)
RestArea(aArea)
Return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfePcReaj ³ Autor ³ Edson Maricate        ³ Data ³28.01.2000 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Esta rotina atualiza o valor unitario do pedido de compra com³±±
±±³          ³base na cotacao da moeda                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1 : Formula de reajuste                                  ³±±
±±³          ³ExpL2 : Indica se a formula de reajuste de ser aplicada      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpN1: valor unitario reajustado                             ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo atualizar o valor unitario do  ³±±
±±³          ³pedido de compra com base na taxa da moeda do dia            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function NfePcReaj(cReajuste,lReajuste)

Local nPreco := 0
Local dBase  := dDataBase

dDataBase := dDEmissao
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza o pedido de compra com base na cotacao da moeda     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nPreco := xMoeda(SC7->C7_PRECO,SC7->C7_MOEDA,1,M->dDEmissao,9,SC7->C7_TXMOEDA)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Aplica a formula de reajuste do pedido de compra             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty(SC7->C7_REAJUST)
	If !Empty(cReajuste) .And. lReajuste
		nPreco := Formula(cReajuste)
	EndIf
EndIf
dDataBase := dBase
Return( nPreco )

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeVldIni ³ Autor ³ Edson Maricate        ³ Data ³07.01.2000 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Esta rotina verifica se o documento de entrada pode ser      ³±±
±±³          ³incluido ou classificado                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1 : Formula de reajuste                                  ³±±
±±³          ³ExpL2 : Indica se a formula de reajuste de ser aplicada      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpN1: valor unitario reajustado                             ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo validar a inclusao ou classifi-³±±
±±³          ³cacao do documento de entrada                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeVLDINI(lClass,lGeraLanc,lClaNfCfDv) 

Local lRet 	   := .F.
Local lRetPE   := .T.
Local dDataFec := MVUlmes()
Local lWmsCRD  := SuperGetMV("MV_WMSCRD",.F.,.F.)

Default lClaNfCfDv := .F.

Do Case
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verificar se a NF ja foi classificada.                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case lClass .And. SF1->F1_STATUS == "A"
	Help("  ",1,"A100CLASSI")
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verificar se a Pre-Nota foi bloqueada.                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case lClass .And. SF1->F1_STATUS == "B" .And. SuperGetMV("MV_RESTCLA",.F.,"2")=="1"
	Help("  ",1,"A103BLCLA")
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verificar data do ultimo fechamento em SX6.                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case dDataFec >= dDataBase
	Help( " ", 1, "FECHTO" )
	If ( Type("l103Auto") <> "U" .And. l103Auto )
		lRet := .F.
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica parametro MV_DATAFIS pela data de digitacao.        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case !FisChkDt(dDatabase)
	lRet := .F.
OtherWise
	lRet := .T.
EndCase

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Validacao para nao permitir a classificacao de pre-notas que possuem |
//| o parametro MV_DATAHOM configurado com o conteudo igual a "2"        |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRet .And. lClass .And. SuperGetMv("MV_DATAHOM",.F.,"1")=="2"
	If !Empty(SF1->F1_RECBMTO)
		If dDataFec >= SF1->F1_RECBMTO
			Help( " ", 1, "FECHTO" )
			lRet := .F.
		EndIf
	EndIf	
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Integracao com o modulo de Armazenagem - SIGAWMS                  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRet .And. lClass .And. (IntWMS() .Or. lWmsCRD) .And. FindFunction("WmsAvalSF1") .And. SF1->F1_TIPO $ "N|D|B" //-- Validação se pode classificar a nota fiscal
	lRet := WmsAvalSF1("1","SF1")
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Se estiver trabalhando com Conferencia Fisica, verifica se esta em processo de conferencia|
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRet .And. lClass .And. SuperGetMV("MV_CONFFIS") == "S"  
	If Len(AllTrim(SF1->F1_STATCON))>0   
		lClaNfCfDv := SuperGetMv("MV_CLACFDV",.F.,.F.)
		If !IsBlind()
			lClaNfCfDv := (SF1->F1_STATCON == "2" .And. lClaNfCfDv .And. MsgYesNo(STR0149,STR0018) ) //"Esta nota está com bloqueio de divergencia na conferencia física do ACD, Deseja classifica-la mesmo assim?"
		EndIf
		If !lClaNfCfDv
			If SF1->F1_STATCON <> "1"
				lRet := .F. 
				Help(' ', 1, 'A103NFCONF')
			EndIf	
		EndIf
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ponto de Entrada MT103INC                 |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRet .And. ExistBlock('MT103INC')
	lRet := If(ValType(lRetPE:=ExecBlock('MT103INC',.F.,.F.,lClass))=='L',lRetPE,.T.)
EndIf
Return(lRet)


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³A103Alert³Autor³Edson Maricate          ³ Data ³15.02.2000³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³ Aviso de que a almoxarifado nao existe                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA103                                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A103Alert(cProduto,cAlmox,lAuto)
Local lRet
Local cLinha1:= STR0011+ cAlmox + STR0012 //"O Armazem "###" nao existe para este produto. "
Local cLinha2:= STR0013 //"Deseja cria-lo agora ? "
Local aSvOrdem:={Alias(),IndexOrd(),Recno()}

DEFAULT lAuto := .F.

dbSelectArea("SB2")
If MsSeek(xFilial("SB2")+cProduto+cAlmox,.F.)
	Return .T.
EndIf
If lAuto
	lRet := .T.
Else
    If ExistBlock("M103XLERT")
		lRet:=ExecBlock("M103XLERT",.F.,.F.)
		If Valtype(lRet) <> "L" .and. lRet == .F.
			lRet:=.T.
		EndIf
  	Else
		TONE(3500,1)
		lRet := (MsgYesNo(OemToAnsi(cLinha1+cLinha2),STR0014+cProduto)) // //"Atencao - " 
	EndIf	
EndIf

If lRet
	CriaSB2(cProduto,cAlmox)
EndIf

dbSelectArea(aSvOrdem[1])
dbSetOrder(aSvOrdem[2])
MsGoto(aSvOrdem[3])

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³A103VldCC³ Autor ³ Edson Maricate         ³ Data ³02.02.2000³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Efetua a validacao do Centro de Custo, Conta Contab. e Item ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA103                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A103VldCC(aMuda)   
Local cVar			:= ReadVar()
Local lMostraHelp   := .F.
Local lRateio		:= .F.
Local nPosCC		:= GetPosSD1("D1_CC" )
Local nPosConta	    := GetPosSD1("D1_CONTA" )
Local nPosItemCta	:= GetPosSD1("D1_ITEMCTA" )
Local nPosRateio	:= GetPosSD1("D1_RATEIO" )
Local nPosCLVL		:= GetPosSD1("D1_CLVL" )
Local nPosPed		:= GetPosSD1("D1_PEDIDO" )
Local nPosItPc		:= GetPosSD1("D1_ITEMPC" )
Local lM103lRat     := SuperGetMv("MV_M103LRA",.F.,.F.)
Default aMuda       :={.T.,.T.,.T.,.T.} // CC,Conta,ItemCta e ClVl

If ExistBlock("MT103VCC")
	aMuda := ExecBlock("MT103VCC",.F.,.F.,aMuda)
	If !(ValType(aMuda) == "A" .And. Valtype(aMuda[1]) == "L" .And. Valtype(aMuda[2]) == "L" .And. Valtype(aMuda[3]) == "L" .And. Valtype(aMuda[4]) == "L")
		aMuda:={.T.,.T.,.T.,.T.} // CC,Conta,ItemCta e ClVl
	EndIf
EndIf

// Verifica se validacao esta partindo da pre-nota MATA140
If FunName() == "MATA140" .And. nPosPed > 0 .And. nPosItPc > 0
	If !Empty(aCols[n][nPosPed]) .And. !Empty(aCols[n][nPosItPc])
		SC7->(DbSetOrder(1))
		If SC7->(MsSeek(xFilial("SC7")+aCols[n][nPosPed]+aCols[n][nPosItPc]))
			If SC7->C7_RATEIO == "1"
				lRateio := .T.
			EndIf
		EndIf
	EndIf
EndIf

If (( nPosRateio > 0 .And. aCols[n][nPosRateio] == '1') .Or. lRateio) .And. lM103lRat 
		If nPosCC > 0 .And. aMuda[1] .and. !Empty(M->D1_CC)
		aCols[n][nPosCC]		:= Space(Len(aCols[n][nPosCC]))          
		If cVar == "M->D1_CC"   
			M->D1_CC		    	:= Space(Len(aCols[n][nPosCC]))
		EndIf
		
		lMostraHelp:= .T.
	Endif
	If nPosConta > 0 .And. aMuda[2] .and. !Empty(M->D1_CONTA)
		aCols[n][nPosConta]	 	:= Space(Len(aCols[n][nPosConta])) 
		If cVar == "M->D1_CONTA"   
			M->D1_CONTA 			:= Space(Len(aCols[n][nPosConta]))
		EndIf   
		
		lMostraHelp:= .T.
	Endif
	If nPosItemCta > 0 .And. aMuda[3] .and. !Empty(M->D1_ITEMCTA)
		aCols[n][nPosItemCta]	:= Space(Len(aCols[n][nPosItemCta]))   
		If cVar == "M->D1_ITEMCTA"  
			M->D1_ITEMCTA			:= Space(Len(aCols[n][nPosItemCta]))
		EndIf
		
		lMostraHelp:= .T.
	Endif
	If nPosCLVL > 0 .And. aMuda[4] .and. !Empty(M->D1_CLVL)
		aCols[n][nPosCLVL]		:= Space(Len(aCols[n][nPosCLVL]))     
		If cVar == "M->D1_CLVL"  
			M->D1_CLVL				:= Space(Len(aCols[n][nPosCLVL]))
		EndIf
		
		lMostraHelp:= .T.
	Endif
	If lMostraHelp
		Help('   ',1,'A103RATEI')	
	EndIf
EndIf

Return .T.

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³A103ITDEV³ Autor ³ Edson Maricate         ³ Data ³07.04.2000³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³ Consiste a Nota Fiscal Origem Digitada                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ MATA103                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A103ItDev(cItemOri)

Local nPosNfOri := GetPosSD1("D1_NFORI" )
Local nPosSerOri:= GetPosSD1("D1_SERIORI" )
Local nPosCfo	:= GetPosSD1("D1_CF" )
Local nPosCod   := GetPosSD1("D1_COD" )
Local nPosIT    := GetPosSD1("D1_ITEM" )
Local nPosITOri := GetPosSD1("D1_ITEMORI" )    
Local nPosFilOri:= GetPosSD1("D1_FILORI")
Local nPosFornec:= GetPosSD1("D1_FORNECE")
Local nPosLoja	:= GetPosSD1("D1_LOJA")
Local nPosTES	:= GetPosSD1("D1_TES")
Local cFilOri	:= xFilial("SD2")
Local aArea		:= GetArea()
Local aAreaSD2	:= SD2->(GetArea())
Local aAreaSD1	:= SD1->(GetArea())
Local lRet 		:= .T.
Local lTrbGen   := IIf(FindFunction("ChkTrbGen"),ChkTrbGen("SD1", "D1_IDTRIB"),.F.) // Verificacao se pode ou nao utilizar tributos genericos
Local lMata143  := FwIsInCallStack("MATA143") .or.  FwIsInCallStack("MATA447") .Or. AllTrim(FunName()) == "MATA143"
Local cForOriDBB:= ""
Local cLojOriDBB:= ""

Default l103Auto := .F.

If nPosNfOri > 0 .And. !Empty(aCols[n][nPosNfOri])
	If nPosFilOri > 0 .And. !Empty(aCols[n][nPosFilOri])
		cFilOri := aCols[n][nPosFilOri]
	Endif
Endif

If cPaisLoc != "BRA"
	cForOriDBB	:= SF1->F1_FORNECE
	cLojOriDBB	:= SF1->F1_LOJA
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ COMPATIBILIZACAO !!Verifica se e utilizado a rotina MATA100  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Type('l100') <> 'U' .And. l100
	If cPaisLoc == "BRA"
		Return A100ItDev()
	Else
		Return A100ItDev( cItemOri)
	EndIf
EndIf   

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Forca passagem pela validacao para Rot.Automática ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If l103Auto .And. Empty(cItemOri) .And. cPaisLoc <> "RUS" //-- Russia ULCD could add or remove items
	cItemOri:="x"
EndIf

If !Empty(cItemOri)
	If cTipo == "D" .Or. (cTipo == "B" .And. !FwIsInCallStack("MATI103A")) .Or. (cTipo == "N" .And. nPosTES > 0 .And. GetAdvFVal("SF4","F4_PODER3",xFilial("SF4") + aCols[n][nPosTES],1) == "D")

		DbSelectArea("SF2")
		DbSetOrder(1)

		If ExistBlock("MT103SF2")
			ExecBlock("MT103SF2",.F.,.F.,{ aCols , nPosNfOri , nPosSerOri, 'MATA103X' })
		Else
			MsSeek(xFilial("SF2",cFilOri) + aCols[n][nPosNfOri] + aCols[n][nPosSerOri] )
		EndIf

		dbSelectArea("SD2")
		dbSetOrder(3)
		If !MsSeek(xFilial('SD2',cFilOri)+aCols[n][nPosNfOri]+aCols[n][nPosSerOri]+SF2->F2_CLIENTE+SF2->F2_LOJA+aCols[n][nPosCod]+cItemOri)
			If MsSeek(xFilial("SD2",cFilOri)+aCols[n][nPosNFOri]+aCols[n][nPosSerOri]+SF2->F2_CLIENTE+SF2->F2_LOJA)
				While SD2->(!Eof()) .And.;										// Encontrou a nota e o item,
					SD2->D2_FILIAL == xFilial("SD2",cFilOri) .And.;					// porem o codigo do produto esta diferente.
					SD2->D2_DOC == aCols[n][nPosNFOri] .And.;					// Neste caso nao deve permitir a devolucao.
					SD2->D2_SERIE == aCols[n][nPosSerOri] .And.;
					SD2->D2_CLIENTE == SF2->F2_CLIENTE .And.;
					SD2->D2_LOJA == SF2->F2_LOJA
					If SD2->D2_ITEM == AllTrim(cItemOri)
						AVISO(STR0018,STR0150,{STR0038})						// Atencao # O codigo do produto para devolucao deve ser igual ao do item da nota original. # Ok
						lRet := .F.
					EndIf
					SD2->(dbSkip())
				EndDo
			EndIf
			If !l103Auto .And. lRet .And. !A103ExsSF8(cNFiscal,cSerie,cA100For,cLoja)
				If SuperGetMV("MV_VLDNFO",.F.,.F.)
					//De acordo com a legislação, não é obrigatório o preenchimento do doc. de origem para os CFOPs 1201,1202,1410,1411,5921 e 6921 em NF devolução
					If (("|"+AllTrim(StrTran(aCols[n][nPosCfo],".",""))+"|") $ "|1201|1202|1410|1411|") .AND. cTipo $ "D"
						lRet := .T.
					ElseIf Aviso(STR0018,STR0096+TRIM(aCols[n][nPosNfOri])+"/"+TRIM(aCols[n][nPosSerOri])+"-"+TRIM(aCols[n][nPosITOri])+"("+aCols[n][nPosIT]+") "+STR0097+CHR(13)+STR0098+" "+STR0099,{STR0016,STR0017}) == 2  
				       lRet := .F.
	    		    Else
	        		   lRet := .T.
		        	ENDIF
		   		EndIf
		  	Else 
				If SuperGetMV("MV_VLDNFO",.F.,.F.) .And. lRet
					//De acordo com a legislação, não é obrigatório o preenchimento do doc. de origem para os CFOPs 1201,1202,1410,1411,5921 e 6921 em NF devolução
					If !((("|"+AllTrim(StrTran(aCols[n][nPosCfo],".",""))+"|") $ "|1201|1202|1410|1411|") .AND. cTipo $ "D")
				  		Help(" ",1,"MT103NFO",,STR0096+TRIM(aCols[n][nPosNfOri])+"/"+TRIM(aCols[n][nPosSerOri])+"-"+aCols[n][nPosIT]+"  "+STR0097,1,0)
				  		lRet:=.F.
			  		EndIf
			 	EndIf
		  	EndIf
		Else
			If !MaFisFound("NF")
				MaFisEnd()
				MaFisIni(SF2->F2_CLIENTE,SF2->F2_LOJA,IIF(SF2->F2_TIPO$'DB',"F","C"),SF2->F2_TIPO,"P",,If(SF2->F2_TIPO=="C",AllTrim(SF2->F2_ORIGLAN),Nil),,,,,,,,,,,,,,,,,,,,,,,,,,lTrbGen)
			EndIf
			If IsInCallStack("A103LINOK")
				lRet := .T.
			Else 
				lRet := NfeNfs2Acols(SD2->(RecNo()),n)
			EndIf
				/* Valida se o cliente da Nota inserida é o mesmo cliente da Nota de Origem			
				-Para a rotina chamada pelo SIGALOJA rotina de Troca e Devolução não validar pois efetuamos troca para clientes diferentes
				-Nao executar validacao quando estiver utilizando sistema TSF - Fonte SPEDFILE03 (tratamento para Lojas CEM) 
				-Integração EAI não valida se usar parametro MV_VLDCDEV = .F. */			
			If SuperGetMV("MV_VLDNFO",.F.,.F.) .And. !IsInCallStack("TSFGrvNF") .And. !IsInCallStack("LOJA720") .And. cTipo != "B" .And. ; 
				!( IsInCallStack("MATI103") .And. !SuperGetMv("MV_VLDCDEV",.F.,.T.)) .And. !IsInCallStack("LOJA600") 
				If SF2->F2_CLIENTE <> cA100For
					Help(" ",1,"F4NAONOTA")
	        	    lRet := .F.
			   	EndIf
			EndIf
		EndIf
	ElseIf cTipo$"CPI" .Or. (cTipo == "B" .And. FwIsInCallStack("MATI103A"))
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Valida se a Nota tem o mesmo numero da Nota de Origem  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !lMata143 .And. Trim(aCols[n][nPosNfOri])==Trim(cNFISCAL) .And. Trim(aCols[n][nPosSerOri])==Trim(cSERIE) .And. CFORMUL=="N"
		    Help(" ",1,"MT103NFIG",,STR0094+CHR(13)+STR0095+" "+aCols[n][nPosIt],1,0)
	    	lRet := .F.
		ElseIf lMata143
			If Trim(aCols[n][nPosNfOri])==Trim(cNFISCAL) .And. Trim(aCols[n][nPosSerOri])==Trim(cSERIE)
				SF1->(DbSetOrder(1)) // F1_FILIAL+F1_DOC+F1_SERIE+F1_FORNECE+F1_LOJA+F1_TIPO
				If SF1->(MsSeek(xFilial("SF1")+aCols[n][nPosNfOri]+aCols[n][nPosSerOri]+aCols[n][nPosFornec]+aCols[n][nPosLoja]))
					Help(" ",1,"MT103NFIG",,STR0094+CHR(13)+STR0095+" "+aCols[n][nPosIt],1,0) // "Documento de Entrada esta con el mismo Numero de Factura / Serie del Documento de Origen" - "Corrija el Numero del Documento de Entrada/Serie o Documento de Origen del item: "
					lRet := .F.
				EndIf
			EndIf
	    Endif      
	    
	    If lRet 
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Notas de Credito e Debito...                                 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			DbSelectArea("SF1")              
			DbSetOrder(1)
			
			if funname()=="MATA447"     
				nPosMx05:=ASCAN(aProvMT447B , {|x| x[1]+x[2]==aCols[n,nPosNfOri] + aCols[n,nPosSerOri]})  
				cA100For :=aProvMT447B[nPosMx05,3] 
				cLoja:=aProvMT447B[nPosMx05,4]
		    endif
			// Verifica se fornecedor esta preenchido para posicionar SF1 por fornecedor
			If ExistBlock("MT103SF1")
				ExecBlock("MT103SF1",.F.,.F.,{ aCols , nPosNfOri , nPosSerOri })
			Else
				If Type("cA100For") == "C" .And. !Empty(cA100For) .And. Type("cLoja") == "C" .And. !lMata143 .And. !FwIsInCallStack("MATI103A")
					MsSeek(xFilial("SF1") + aCols[n][nPosNfOri] + aCols[n][nPosSerOri] + cA100For + cLoja)
				Else
					MsSeek(xFilial("SF1") + aCols[n][nPosNfOri] + aCols[n][nPosSerOri] )
					If !(cPaisLoc == "BRA") .And. FindFunction("buscaRegCH") .And. (AllTrim(SF1->F1_FORNECE+SF1->F1_LOJA) != AllTrim(cForOriDBB+cLojOriDBB))
						buscaRegCH(xFilial("SF1"), aHeader, aCols, n, cForOriDBB, cLojOriDBB, lMata143, DBB->(Recno()))	
					Endif 
				EndIf
			EndIf

			dbSelectArea("SD1")
			dbSetOrder(1)
			If !MsSeek(xFilial('SD1')+aCols[n][nPosNfOri]+aCols[n][nPosSerOri]+SF1->F1_FORNECE+SF1->F1_LOJA+aCols[n][nPosCod]+cItemOri)
				If ( Type('l103Auto') <> 'U' .And. !l103Auto ) .And. !A103ExsSF8(cNFiscal,cSerie,cA100For,cLoja)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Nao e rotina automatica, emite aviso com a pergunta e aguarda  ³
					//³ resposta se deve ou nao aceitar a NF informada.                ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If SuperGetMV("MV_VLDNFO",.F.,.F.) 
						If Aviso(STR0018,STR0096+TRIM(aCols[n][nPosNfOri])+" "+STR0103+TRIM(aCols[n][nPosSerOri])+" "+STR0101+aCols[n][nPosIT]+" "+STR0097+CHR(13)+STR0098+" "+STR0099,{STR0016,STR0017}) != 1
							lRet := .F.
 						Else
							lRet := .T.                                                     
						EndIf
					EndIf
				ElseIf ( Type('l103Auto') <> 'U' .And. l103Auto ) .And. !A103ExsSF8(cNFiscal,cSerie,cA100For,cLoja)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Rotina automatica: se nao existir documento de origem, retorna ³
					//³ falso e nao permite continuar o processo, a menos que a NF de  ³
					//³ origem informada inicie com CIAP.                              ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If Upper(Substr(Trim(aCols[n][nPosNfOri]), 1, 4)) != 'CIAP' ;
						.And. !(Type('aAutoCab') <> 'U' ;
						.And. aScan(aAutoCab, {|x| x[1] == "COLAB" .And. x[2] == "S"}) > 0) //Se for TOTVS COLAB a verificação da nota ja foi feita e nesse ponto o fornecedor ja nao é mais o mesmo
						If SuperGetMV("MV_VLDNFO",.F.,.F.) 
			  				Help(" ",1,"MT103OINV",,STR0096+TRIM(aCols[n][nPosNfOri])+"/"+TRIM(aCols[n][nPosSerOri])+"-"+aCols[n][nPosIT]+"  "+STR0097,1,0)
					  		lRet:=.F.
					 	EndIf
					EndIf
				EndIf 
			ElseIf !FwIsInCallStack("PROCDOCS") .And. !FwIsInCallStack("MATI103A")  //Se documento veio do TOTVS Colaboração não deve passar pela função
				NfeNfe2Acols(SD1->(RecNo()),n)
			EndIf      
		EndIf
	EndIf
EndIf

RestArea(aAreaSD1)
RestArea(aAreaSD2)
RestArea(aArea)

Return lRet

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³A103VldOP ³ Autor ³ Rodrigo de A. Sartorio³ Data ³ 04/02/99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³ Valida a Ordem de Producao digitada na NF                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ MatA103                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A103VldOP()

Local lRet:=.T.,cOP:=&(ReadVar())
Local nPosPc  	:= GetPosSD1("D1_PEDIDO")
Local nPosItPc	:= GetPosSD1("D1_ITEMPC")
Local nPosCod	:= GetPosSD1("D1_COD")
Local nPosQuant	:= GetPosSD1("D1_QUANT")
Local nPosOs	:= GetPosSD1("D1_ORDEM")
//Local cSeek	  := ''	 
Local aAreaAnt:= GetArea()
Local aPosDhn	:= {}

If !Empty(cOp)
	lRet:=ExistCpo("SC2",cOp)
	If lRet
		SC2->(dbSetOrder(1))
		If SC2->(MsSeek(xFilial("SC2")+cOP)) .And. SC2->C2_TPOP == "P"
			Help(" ",1,"NOPPREVIST")
			lRet:=.F.
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//| Analisa se existe PC's amarrado a uma SC'a onde a SC's foi gerada |
	//| pela rotina de solicitacao ao armazem e ja foi informado o numero |
	//| da Ordem de Producao na Solicitacao ao Armazem.					  |	
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nPosPc > 0 .And. nPosItPc > 0
		If lRet .And. !Empty(aCols[n,nPosPC])
			dbSelectArea("SC7")
			dbSetOrder(1) //C7_FILIAL+C7_NUM+C7_ITEM+C7_SEQUEN
			If dbSeek(xFilial("SC7")+aCols[n,nPosPC]+aCols[n,nPosItPC])
			 	If !Empty(SC7->C7_NUMSC)
					//dbSelectArea("SCQ")
					//dbSetOrder(2)//CQ_FILIAL+CQ_NUMSC+CQ_ITSC
					//dbSeek(cSeek:=xFilial("SCQ")+SC7->C7_NUMSC+SC7->C7_ITEMSC)
					aPosDhn := COMPosDHN({3,{'1',xFilial("DHN"),SC7->C7_NUMSC,SC7->C7_ITEMSC}})
					If aPosDhn[1]
						Do While !((aPosDhn[2])->(Eof()))// .And. cSeek == xFilial("SCQ")+SCQ->CQ_NUMSC+SCQ->CQ_ITSC
							SCQ->(DbSetOrder(1))
							If SCQ->(DbSeek((aPosDhn[2])->(DHN_FILORI + DHN_DOCORI +  AllTrim(DHN_ITORI))))
								Do While !(DHN->(EoF())) .And. DHN->(DHN_FILORI + DHN_DOCORI +  AllTrim(DHN_ITORI)) == (aPosDhn[2])->(DHN_FILORI + DHN_DOCORI +  AllTrim(DHN_ITORI)) 
								    If !Empty(SCQ->CQ_OP)
										Aviso(STR0018,STR0044+" "+STR0045,{STR0038},2)						    	
										lRet := .F.  
										Exit
								    EndIf
								 	DHN->(DbSkip())
								EndDo
							EndIf
							(aPosDhn[2])->(dbSkip())
						EndDo
						(aPosDhn[2])->(DbCloseArea())
					EndIf
						
			 	EndIf
			EndIf
		EndIf
	EndIf
	
	//Valida a O.P quando integrado com o módulo de manutenção de ativos
	If nPosCod > 0 .And. nPosQuant > 0 .And. nPosOs > 0 .And. FindFunction("NGAPAGD1OR")
		If !NGAPAGD1OR(aCols[n,nPosOs],cOp,aCols[n,nPosCod],aCols[n,nPosQuant])
			lRet := .F.
		EndIf
	EndIf
	
EndIf

RestArea(aAreaAnt)
Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³ A103DtVld   ³Autor³Rodrigo de A. Sartorio³ Data ³ 05/03/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³ So permite digitar a data de validade do lote apos usuario ³±±
±±³          ³ digitar o Lote de Controle.                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Mata103                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A103DtVld(dDtValid)
Local lRet		 :=.T.
Local aAreaAnt   := GetArea()
Local aAreaSB8   := SB8->(GetArea())
Local nPosCodigo := GetPosSD1('D1_COD')
Local nPosLocal	 := GetPosSD1("D1_LOCAL")
Local nPosLote	 := GetPosSD1("D1_NUMLOTE")
Local nPosLotCTL := GetPosSD1("D1_LOTECTL")
Local nPosDvalid := GetPosSD1("D1_DTVALID")
Local nPosLotFor := GetPosSD1("D1_LOTEFOR")
Local lLoteVenc	 := SuperGetMV("MV_LOTVENC") == "S"

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ POSICIONA A SB1  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DbSelectArea("SB1")
MsSeek(xFilial("SB1")+aCols[n,nPosCodigo])         

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ COMPATIBILIZACAO !!Verifica se e utilizado a rotina MATA100  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Type('l100') <> 'U' .And. l100
	Return A100DtVld()
EndIf

If !( Type('l103Auto') <> 'U' .And. l103Auto ) .And. !Rastro(aCols[n,nPosCodigo]) .And. !Empty(aCols[n,nPosLote]) .And. !Empty(aCols[n,nPosLotCtl]) 
	Help(" ",1,"NAORASTRO")
	lRet:=.F.
EndIf

If lRet .And.  !Empty(dDtValid)
	If Empty(aCols[n,nPosLotFor]) .And. Empty(aCols[n,nPosLote]) .And. Empty(aCols[n,nPosLotCtl]) .And. !Empty(dDtValid) .And. !Rastro(aCols[n,nPosCodigo])
		M->D1_DTVALID := CTOD("  /  /  ")
		lRet:=.T.
	ElseIF lRet .And. dDtValid < dDataBase 
		//-- Verifica se permite a digitacao de datas de validade vencidas.
		If lLoteVenc 
			//-- Avisa ao usuario que a data de validade esta 
			//-- vencida, porem permite a movimentacao.
			If !(Type('l103Auto') <> 'U' .And. l103Auto)
				Help(" ",1,"LOTEVENC")
			EndIf	
		Else
			Help(" ",1,"DTVALIDINV")
			lRet:=.F.
		EndIf	
	EndIf
	
	SB8->(dbSetOrder(3))
	If lRet .And. SB8->(dbSeek(xFilial("SB8")+aCols[n,nPosCodigo]+aCols[n,nPosLocal]+aCols[n,nPosLotCTL]+IF(Rastro(aCols[n,nPosCodigo],"S"),aCols[n,nPosLote],"")))
		If dDtValid # SB8->B8_DTVALID 
			If !( Type('l103Auto') <> 'U' .And. l103Auto )
				Help(" ",1,"A240DTVALI")
			EndIf	
			M->D1_DTVALID := SB8->B8_DTVALID               
			aCols[n,nPosDvalid] := SB8->B8_DTVALID
		EndIf		
	Endif		
Endif
	
RestArea(aAreaSB8)
RestArea(aAreaAnt)                      

Return lRet

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³A103ZERA  ³ Autor ³ Edson Maricate        ³ Data ³03.05.2000³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³ Zera Nota Fiscal de Origem e Serie da Nota                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ MATA103                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A103Zera()
Local aArea			:= GetArea()
Local nPosNFOri
Local nPosSerOri
Local nPosItmOri
Local nPosSub
Local lContinua		:= .T.
Local nPosProd 		:= GetPosSD1("D1_COD")

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ COMPATIBILIZACAO !!Verifica se e utilizado a rotina MATA100  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Type('l100') <> 'U' .And. l100
	Return A100Zera()
EndIf

If cTipo == "D" .And. Iif(nPosProd > 0, Rastro(aCols[n][nPosProd],"S"), .T.)
	nPosNFOri	:= GetPosSD1("D1_NFORI")
	nPosSerOri	:= GetPosSD1("D1_SERIORI")
	nPosItmOri	:= GetPosSD1("D1_ITEMORI")
	nPosSub		:= GetPosSD1("D1_NUMLOTE")

	If !Empty(acols[n][nPosNFOri]) .and. !Empty(acols[n][nPosSerOri]) .and. !Empty(acols[n][nPosItmOri])
		DbSelectArea ('SD2')
		DbSetOrder(3) //D2_FILIAL+D2_DOC+D2_SERIE+D2_CLIENTE+D2_LOJA+D2_COD+D2_ITEM
		If MsSeek(xFilial("SD2")+aCols[n,nPosNFOri]+aCols[n,nPosSerOri]+CA100FOR+CLOJA+aCols[n,nPosProd]+aCols[n,nPosItmOri]) 
			If SD2->D2_NUMLOTE == M->D1_NUMLOTE
				lContinua := .F.
			EndIf
		EndIf
	EndIf

	If lContinua
		aCols[n][nPosNFOri]	:= CriaVar("D1_NFORI")
		aCols[n][nPosSerOri]	:= SerieNfId("SD1",5,"D1_SERIORI") 
		aCols[n][nPosItmori]	:= CriaVar("D1_ITEMORI")
	EndIf
   
	If MaFisFound("NF")     
		MaFisIniLoad(n)
		MaFisLoad("IT_NFORI",aCols[n][nPosNFOri],n)
		MaFisLoad("IT_SERORI",aCols[n][nPosSerOri],n)
		MaFisLoad("IT_RECORI",0,n)
		MaFisEndLoad(n)
	EndIf
EndIf

RestArea(aArea)
Return(.T.)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun??o   ³ A103LotCTL  ³Autor³Rodrigo de A. Sartorio³ Data ³ 22/11/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri??o³ Valida o lote de control digitado pelo usuario.            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Mata103                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function A103LotCTL()

Local cVar			:= ReadVar()
Local cConteudo		:= &(ReadVar())
Local cCod			:= aCols[n][GetPosSD1("D1_COD")]
Local cLocal 		:= aCols[n][GetPosSD1("D1_LOCAL")]
Local nPosLote		:= GetPosSD1("D1_NUMLOTE")
Local nPosLotCTL	:= GetPosSD1("D1_LOTECTL")
Local nPosDvalid	:= GetPosSD1("D1_DTVALID")
Local nPosLocal		:= GetPosSD1("D1_LOCAL")
Local nPosTes		:= GetPosSD1("D1_TES")
Local aAreaAnt		:= GetArea()
Local aAreaSB8		:= {}
Local lRet			:= .T.
Local lRotAuto      := Type("l103Auto") == "L" .And. l103Auto
Local lSublPD3Ok    := .F.
Local cLoteCtlA  	:= ''
Local cBuscaSF4		:= ""
Local cBuscaSB8		:= ""

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ COMPATIBILIZACAO !!Verifica se e utilizado a rotina MATA100  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Type('l100') <> 'U' .And. l100
	Return A100LotCTL()
EndIf

If !(Type('cLoteCtl')=='C')
	cLoteCtlA := CriaVar('D1_LOTECTL')
Else
	cLoteCtlA := cLoteCtl
EndIf

If (!Rastro(cCod) .And. cVar == "M->D1_NUMLOTE" .And. !Empty(cConteudo)) .Or. (!Rastro(cCod) .And. cVar == "M->D1_LOTECTL" .And. !Empty(cConteudo))
	If nPosLote > 0
		aCols[n, nPosLote]   := CriaVar("D1_NUMLOTE")
	EndIf
	aCols[n, nPosLotCTL] := CriaVar("D1_LOTECTL")
	aCols[n, nPosDValid] := CriaVar("D1_DTVALID")
	Help(" ",1,"NAORASTRO")
	lRet     := .F.
ElseIf !A103VlStr()
	lRet := .F.
ElseIf cVar == "M->D1_NUMLOTE" .And. !Empty(cConteudo)
	If cTipo == 'D' //-- NF Devolu??o
		dbSelectArea("SB8")
		aAreaSB8 := GetArea()
		dbSetOrder(2)
		If MsSeek(xFilial("SB8")+cConteudo+aCols[n, nPosLotCTL], .F.) .And. B8_PRODUTO+B8_Local == cCod+cLocal
			aAreaSB8[3]          := Recno()
			M->D1_LOTECTL        := SB8->B8_LOTECTL
			aCols[n, nPosLotCTL] := SB8->B8_LOTECTL
			If nPosLote > 0
				aCols[n, nPosLote]    := cConteudo
				aCols[n, nPosDvalid]  := SB8->B8_DTVALID
			EndIf
		Else
			M->D1_LOTECTL        := CriaVar("D1_LOTECTL")
			M->D1_DTVALID        := CriaVar("D1_DTVALID")
			If nPosLote > 0
				M->D1_NUMLOTE      := CriaVar("D1_NUMLOTE")
				aCols[n, nPosLote] := CriaVar("D1_NUMLOTE")
			EndIf
			aCols[n, nPosLotCTL] := CriaVar("D1_LOTECTL")
			aCols[n, nPosDValid] := CriaVar("D1_DTVALID")
		EndIf
		RestArea(aAreaSB8)
	Else
		// Valida sublote informado na rotina automatica de devolucao de poder de terceiros, se for valido mantem o sublote
		If lRotAuto .And. nPosTes > 0 .And. !Empty(aCols[n, nPosTes])
			cBuscaSF4 := xFilial("SF4") + aCols[n, nPosTes]
			If Posicione("SF4", 1, cBuscaSF4, "F4_PODER3") == "D"
				cBuscaSB8 := xFilial("SB8") + cConteudo + aCols[n, nPosLotCTL] + cCod + aCols[n, nPosLocal]
				If Posicione("SB8", 2, cBuscaSB8, "B8_NUMLOTE") == cConteudo
					lSublPD3Ok := .T.
				EndIf
			EndIf
		EndIf
		If !lSublPD3Ok
			M->D1_DTVALID        := CriaVar("D1_DTVALID")
			If nPosLote > 0
				M->D1_NUMLOTE        := CriaVar("D1_NUMLOTE")
				aCols[n, nPosLote]   := CriaVar("D1_NUMLOTE")
			EndIf
			aCols[n, nPosDValid] := CriaVar("D1_DTVALID")
		EndIf
	EndIf
ElseIf cVar == "M->D1_LOTECTL" .And. !Empty(cConteudo) 
	aAreaSB8 := GetArea()
	SB8->(dbSetOrder(3))
	If SB8->(dbSeek(xFilial("SB8")+cCod+aCols[n,nPosLocal]+cConteudo+IF(Rastro(cCod,"S"),aCols[n,nPosLote],"")))
		If aCols[n, nPosDValid] # SB8->B8_DTVALID
			If Type('lMSErroAuto') <> 'L'
				Help(" ",1,"A240DTVALI")
			EndIf	
			M->D1_DTVALID := SB8->B8_DTVALID
			aCols[n,nPosDvalid] := SB8->B8_DTVALID						
		EndIf			
	Endif		
	RestArea(aAreaSB8)
EndIf

RestArea(aAreaAnt)

Return lRet
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³  A103PC  ³ Prog. ³Edson Maricate         ³Data  ³20.05.2000³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Valida o pedido de compras digitado.                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³A103PC()                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA103,MATA140                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A103PC()

Local nPosItemPC := GetPosSD1("D1_ITEMPC")

aCols[n][nPosItemPC] := CriaVar("D1_ITEMPC")

Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³A103Item³ Prog. ³Edson Maricate           ³Data  ³20.05.2000³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Valida o item do pedido digitado.                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³A103Item()                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA103,MATA140                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A103Item()

Local aArea      := GetArea()
Local aAreaSC7   := SC7->(GetArea())
Local nPosQTD    := GetPosSD1("D1_QUANT" )
Local nPosPrd    := GetPosSD1("D1_COD" )
Local nPosPedido := GetPosSD1("D1_PEDIDO" )
Local nPosItemPC := GetPosSD1("D1_ITEMPC" )
Local nPItem     := GetPosSD1("D1_ITEM" )
Local nX         := 0
Local cItem      := &(ReadVar())
Local nPcToler   := 0
Local lTolerQtd  := .T.
Local lRet		 := .F.
Local lEic       := .F.
Local nFreeQt    := 0
Local lLibQt     := GETNEWPAR("MV_LIBQTEM", .F.)
Local lIs140auto := SuperGetMV("MV_IS140AU",.F.,.F.)
Local lXmlxped   := SuperGetMV("MV_XMLXPED",.F.,.F.)

If !Empty(aCols[n][nPosPedido])
	nRecC7 := A103RECC7(xFilial("SC7"),aCols[n][nPosPedido],cA100For,cLoja,aCols[n][nPosPrd],cItem)
	SC7->(DbGoTo(nRecC7))

	If Empty(SubStr(cItem,3)) .And. !Empty(SC7->C7_SEQUEN)
		lEic := .T.
	EndIf
	If !lEic .And. nRecC7 > 0
		nFreeQT := 0
		If !lEic
			For nx := 1 To Len( aCols )
				If (nx # n) .And. ;
					(aCols[ nx,nPosPrd] == SC7->C7_PRODUTO) .And. ;
					(aCols[ nx,nPosPedido] == SC7->C7_NUM) .And. ;
					(aCols[ nx,nPosItemPC] == SC7->C7_ITEM) .And. ;
					!ATail( aCols[nx] )
					nFreeQT += aCols[nx,nPosQTD]
				EndIf
			Next
		Else
			/*/
			For nx := 1 To Len( aCols )
				If (nx # n) .And. ;
					(aCols[ nx,nPosPrd] == C7_PRODUTO) .And. ;
					(aCols[ nx,nPosPedido] == C7_NUM) .And. ;
					(aCols[ nx,nPosItemPC] == C7_ITEM) .And. ;
					(aCols[ nx,nPITEM] == C7_SEQUEN) .And. ;
					!ATail( aCols[nx] )
					nFreeQT += aCols[nx,nPosQTD]
				EndIf
			Next
			/*/
		EndIf
		IF ValType(SuperGetMV("MV_PCTOLER",.F.,"0")) == "C"
			nPcToler := Val(SuperGetMV("MV_PCTOLER",.F.,"0"))/100
		Else
			nPcToler := SuperGetMV("MV_PCTOLER",.F.,0)/100
		EndIf
		If nPcToler > 0
			If aCols[n][nPosQtd] > (SC7->C7_QUANT+(SC7->C7_QUANT * nPcToler))
				lTolerQtd := .F.
			Endif
		Endif
		
		If ALTERA
			dbSelectArea("SD1")
			dbSetOrder(1)
			dbSeek(xFilial('SD1')+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA+aCols[n][nPosPrd]+aCols[n][nPItem])
			nFreeQT -= SD1->D1_QUANT
		EndIf
		
		dbSelectArea("SC7")
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se nao h  residuos, se possui saldo em abto e   ³
		//³ se esta liberado por alcadas se houver controle.         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ((((nFreeQT:=((SC7->C7_QUANT+(SC7->C7_QUANT * nPcToler)))-SC7->C7_QUJE-SC7->C7_QTDACLA-nFreeQT) > 0) .Or. ((nFreeQT:=((SC7->C7_QUANT+(SC7->C7_QUANT * nPcToler)))-SC7->C7_QUJE-SC7->C7_QTDACLA-nFreeQT) >= 0 .AND. (FunName() == "MATA447")) ) .And. lTolerQtd .And. Empty(SC7->C7_RESIDUO) .And. IIf(SuperGetMV("MV_RESTNFE")=="S", SC7->C7_CONAPRO <> "B", .T.) .And. SC7->C7_TPOP <> "P") .Or. lLibQt	

			If cPaisLoc == "BRA"
				If Type("l140Auto")== "U"
					If IsInCallStack("COMXCOL")
						if !lXmlxped //.T. = Mantém dados provenientes da NF, .F. = Assume dados provenientes do pedido de compra vinculado
							NFEPC2ACOL(SC7->(RecNo()),n,IIf(Empty(aCols[n][nPosQtd]).Or.aCols[n][nPosQtd]>nFreeQt,nFreeQt,aCols[n][nPosQtd]),,,,,,,.T.)
						endif
					else 
						NFEPC2ACOL(SC7->(RecNo()),n,IIf(Empty(aCols[n][nPosQtd]).Or.aCols[n][nPosQtd]>nFreeQt,nFreeQt,aCols[n][nPosQtd]),,,,,,,.F.)
					Endif	
				Else
					NFEPC2ACOL(SC7->(RecNo()),n,IIf(Empty(aCols[n][nPosQtd]).Or.aCols[n][nPosQtd]>nFreeQt,nFreeQt,aCols[n][nPosQtd]),,lIs140auto)
				EndIf
            ElseIf !(FunName() $ "MATA143/MATA447")			// Não executa validação na geração de fatura originária de desembaraço para não sobrepor qtde e valor do pedido ao do desembaraço
	            LxA103SC7ToaCols(SC7->(RecNo()),n,IIf(Empty(aCols[n][nPosQtd]).Or.aCols[n][nPosQtd]>nFreeQt,nFreeQt,aCols[n][nPosQtd]))
            EndIf
			lRet 	:= .T.
		Else
			If FwIsInCallStack("COMXCOL") .and. SuperGetMV("MV_RESTNFE")=="S" .and. SC7->C7_CONAPRO == 'B'
				//-- "O parâmetro MV_RESTNFE está ativo. Não é possível gerar documento com pedido bloqueado. Desvincule ou aprove o pedido " ####
				Help(,, "A103RESTNFE",, STR0237 + SC7->C7_NUM , 1, 0,,,,,,)
			Else
				Help(' ', 1, 'A103PCNSLD')
			EndIf
		EndIf
	Else
		If !lEic
			Help("   ",1,"REGNOIS")
		Else
			lRet := .T.
		EndIf
	EndIf
Else
	Help("   ",1,"REGNOIS")
EndIf

RestArea(aAreaSC7)
RestArea(aArea)

Return lRet


/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³ A103TRAVA ³ Autor ³ Aline Correa do Vale  ³ Data ³07/03/2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³ Tratamento de DEAD-LOCK - Arquivo SB2                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Mata103                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A103Trava() 
Local aTrava    := {}
Local ni        := 0
Local nPosPrd   := GetPosSD1("D1_COD")
Local nPosLoc   := GetPosSD1("D1_LOCAL")
Local nPosTes   := GetPosSD1("D1_TES")
Local lTrava    := .T.
Local lTravaSA1 := .T.
Local lTravaSA2 := .T.
Local lTravaSB2 := .T.
Local cFilSF4   := xFilial("SF4")
Local aAreaAnt	:= GetArea()
Local cM103TRV 	:= SupergetMv("MV_COMTRAV",.F.,"") // Desabilita o MultLock dos registros 1= SA1 2= SA2 3= SB2 4= Todos

Static lMT103TRV := ExistBlock("MT103TRV")

If ( __TTSInUse )
	// Ponto de Entrada MT103TRV utilizado para desligar o Lock das tabelas SA1 / SA2
	If lMT103TRV
		aRetorno  :=  ExecBlock("MT103TRV",.F.,.F.,{cA100For,cLoja,IIf(cTipo$"DB","C","F")})
		If Type('aRetorno') == "A" .And. Len(aRetorno) >= 3
			lTravaSA1 := aRetorno[1]
			lTravaSA2 := aRetorno[2]
			lTravaSB2 := aRetorno[3]
		EndIf
	ElseIf  cM103TRV == "1" 
		lTravaSA1 := .F.
	ElseIf  cM103TRV == "2"
		lTravaSA2 := .F.
	ElseIf  cM103TRV == "3"
		lTravaSB2 := .F.
	ElseIf  cM103TRV == "4"
		lTravaSA1 := .F.
		lTravaSA2 := .F.
		lTravaSB2 := .F.
	EndIf

	SF4->( dbSetOrder(1) )

	For ni := 1 to Len(aCols)
		IF ( Len(aCols[nI]) > Len(aHeader) ) .And. !(aCols[ni][Len(aCols[ni])])
			If nPosTes > 0 .And. SF4->( MsSeek(cFilSF4+aCols[ni,nPosTes]) )
				If SF4->F4_ESTOQUE == "S"
					AADD(aTrava,aCols[ni,nPosPrd]+aCols[ni,nPosLoc])
				Endif
			Else
				AADD(aTrava,aCols[ni,nPosPrd]+aCols[ni,nPosLoc])
			EndIf
		EndIf
	Next
	
	If ( cTipo $ "DB" .Or. A103RtCliRT(cTipo, cTpCompl, cFormul) )
		If lTravaSA1
			lTrava := MultLock("SA1",{cA100For+cLoja},1)
		EndIf	
	Else
		If lTravaSA2
			lTrava := MultLock("SA2",{cA100For+cLoja},1)
		EndIf	
	EndIf

	If lTrava .And. Len(aTrava) > 0
		If lTravaSB2
			lTrava := MultLock("SB2",aTrava,1)
		EndIf	
	EndIf
	
	If ( !lTrava )
		SB2->(MsRUnLock())
		SA1->(MsRUnLock())
		SA2->(MsRUnLock())
	EndIf
	RestArea(aAreaAnt)
	Return ( lTrava )
Else
	DbSelectArea("SB2")
	DbSetOrder(1)
	For ni := 1 to Len(aCols)
		IF ( Len(aCols[nI]) > Len(aHeader) ) .And. !(aCols[ni][Len(aCols[ni])])
			If nPosTes > 0 .And. SF4->( MsSeek(cFilSF4+aCols[ni,nPosTes]) )
				If SF4->F4_ESTOQUE == "S"
					If MsSeek(xFilial("SB2")+aCols[ni,nPosPrd]+aCols[ni,nPosLoc])
						lTrava := SoftLock("SB2")
					EndIf
				Endif
			Else
				If MsSeek(xFilial("SB2")+aCols[ni,nPosPrd]+aCols[ni,nPosLoc])
					lTrava := SoftLock("SB2")
				EndIf
			EndIf
		EndIf
	Next
	RestArea(aAreaAnt)
	Return(lTrava)
EndIf

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³MaCanDelF1³ Autor ³ Edson Maricate        ³ Data ³11.10.2001 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de validacao da exclusao de uma nota fiscal de entrada³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpN1: Numero do Registro do SF1.                       (OPC)³±±
±±³          ³ExpA2: Array com os pedidos de venda gerados a partir da nota³±±
±±³          ³       fiscal de entrada.                               (OPC)³±±
±±³          ³ExpA3: Array com os titulos financeiro gerados          (OPC)³±±
±±³          ³ExpL4: Indica se pode apagar notas de conhec de frete   (OPC)³±±
±±³          ³ExpL5: Indica se pode apagar notas de despesas de import(OPC)³±±
±±³          ³ExpL6: Indica se estou apagando um remito (localizacoes)(OPC)³±±
±±³          ³ExpL7: Indica se se trata de un retorno simbolico automatico,³±±
±±³          ³       no caso de ser, o retorno pode ser apagado.           ³±±
±±³          ³ExpA8: Array contendo os recnos dos titulos no SE1(devolucao)³±±
±±³          ³ExpL9: Indica se a exclusao esta sendo feita pelo SIGAEIC    ³±±
±±³          ³ExpL10:Indica se a exclusao esta sendo feita pelo SIGATMS    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica se a nota pode ser excluida                    ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo validar a exclusao de uma Nota ³±±
±±³          ³fiscal de entrada/Documento de entrada.                      ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/

Function MaCanDelF1(nRecSF1,aRecSC5,aRecSE2,lCanDelFr,lCanDelDp,lRemito,lRSAuto,aRecSe1,lExcViaEIC,lExcViaTMS,l103Exclui)
Local lEofSD3   := .T.
Local aArea		:= GetArea()
Local aAreaSD1	:= SD1->(GetArea())
Local aAreaSF8	:= SF8->(GetArea())
Local aStruSD1  := {}
Local aStruSE2  := {}

Local lQuery    := .F.
Local lRetorno	:= .F.
Local lRetAPO   := .T.
Local l100Del	:= ExistBlock("A100DEL")  
Local lM103APO  := ExistBlock("M103APO")
Local lIntACD	:= SuperGetMV("MV_INTACD",.F.,"0") == "1"
Local lEstNeg   := (SuperGetMv("MV_ESTNEG")=="S")
Local lEECFAT	:= SuperGetMv("MV_EECFAT",.F.,.F.)
Local lForpcnf	:= SuperGetMV("MV_FORPCNF",.F.,.F.)
Local lR103ENEG := .F.
Local dDataFec	:= MVUlmes()
Local dDataVenc
Local dDataIni
Local dDataFim
Local lShowAviso:= (SuperGetMv("MV_AV10925",.T.,"2") == "1")
Local cLocTran  := SuperGetMV("MV_LOCTRAN",.F.,"95")
Local lAviso    := .F.
Local lAvisoISS := .F.
Local lVldRetISS:= .F.
Local lRetISSMes:= 	GetNewPar("MV_MODRISS","1") == "2"
Local dDataBloq	:= GetNewPar("MV_ATFBLQM",CTOD(""))

Local nPosLote	:= 0
Local nX		:= 0
Local nSldTran  := 0
Local nSldLote  := 0
Local aLotes	:= {}
Local cMensagem := ""
Local cPrefixo  := ""
Local cQuery    := ""
Local cAliasSD1 := "SD1"
Local cAliasSE2 := "SE2"
Local nAcICMSAPR:= 0	
Local aAreaSN1  := {}
Local aRetXFin  := {}
Local cTesDR    := SuperGetMV("MV_TESDR",,"")
Local lNumTrib	:= .T.
Local cNumTit	:= ""
Local aAreaSE2IR
Local nRecE2in
Local l103EstAdt:= SuperGetMv("MV_ESTOADT",.F.,.F.) //Permite o estorno de documento de entrada vinculado a PC com PA(somente via execauto).

Local cSepNeg   := If("|"$MV_CPNEG,"|",",")
Local cSepProv  := If("|"$MVPROVIS,"|",",")
Local cSepRec   := If("|"$MVPAGANT,"|",",")

Local nCountSE2 := 0
Local lPriParAdtBx := .F.
Local nValorAdtFR3 := 0


local nTamPref := TamSX3("E2_PREFIXO")[1]
local cPrefPIS := PadR(SuperGetMV("MV_PREFPIS",.F.,"PIS"), nTamPref)
local cPrefCOF := PadR(SuperGetMV("MV_PREFCOF",.F.,"COF"), nTamPref)
local cPrefISS := PadR(SuperGetMv("MV_PREFISS",.F.,"ISS"), nTamPref)
local cPreFase := PadR(SuperGetMv("MV_PREFASE",.F.,"TX"), nTamPref)
local nQtdTit  := 0
local nQtdTot  := 0
Local cNatGilRat := ''
Local aNats		:= {}
Local lIntGC	 := IIf((SuperGetMV("MV_VEICULO",,"N")) == "S",.T.,.F.)
Local cE1Cliente := "" // Quando integrado com DMS, o cliente pode ser outro se utilizado condicao de pagamento TIPO A na venda.
Local cE1Loja    := "" // Quando integrado com DMS, o cliente pode ser outro se utilizado condicao de pagamento TIPO A na venda.
Local cE1NReduz  := "" // Quando integrado com DMS, o cliente pode ser outro se utilizado condicao de pagamento TIPO A na venda.
Local cPrefOri	 := ""
Local cNumOri	 := ""
Local cParcOri	 := ""
Local cTipoOri 	 := ""
Local cCfOri	 := ""
Local cLojaOri	 := ""
Local cQBCod	 := ""
Local cQBLocal   := ""
Local l140Estor  := FwIsInCallStack("A140EstCla")
Local cSeekCIAP	 := " "
Local lPRNFBEN	 := SuperGetMV("MV_PRNFBEN",.F.,.F.)
Local lNEGATBF	 := SuperGETMV("MV_NEGATBF",.F.,.F.)
Local lM103XATF	 := ExistBlock("M103XATF")
Local json 		 as json
Local oObjTitPai as object
Local cTitPai 	 as character
Local cChvOriFk7 as character
Local lUseClass  as logical

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Analisa os parametros da Rotina                              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DEFAULT aRecSC5    := {}
DEFAULT aRecSE1    := {}
DEFAULT aRecSE2    := {}
DEFAULT lCanDelFr  := .F.
DEFAULT lCanDelDp  := .F.
DEFAULT lRemito    := .F.          
DEFAULT lExcViaEIC := .F. 
DEFAULT lExcViaTMS := .F.   
DEFAULT l103Exclui := .F.                       

If Type("cTipo") == "U"
	cTipo:= SF1->F1_TIPO
EndIf

If nRecSF1 <> Nil
	dbSelectArea("SF1")
	MsGoto(nRecSF1)
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ajusta a Pesquisa das Notas de Conhecimento de Frete e D.I.  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
SF8->(dbSetOrder(2))
Do Case
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se a NF possui NF de Conhec. e Desp. de Import.     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case !lCanDelFr .And. ((SF8->(MsSeek(xFilial("SF8")+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA+SF1->F1_TIPO)) .And. SF1->F1_TIPO != "C" );
 		.Or. A103CTECOL(SF1->F1_DOC,SF1->F1_SERIE,SF1->F1_FILIAL,SF1->F1_FORNECE,SF1->F1_LOJA+SF1->F1_TIPO))
	Help(" ", 1, "A103CAGREG")
	lRetorno := .F.
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Nao excluir NF incluida pelo MATA910                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case SF1->F1_ORIGLAN == "LF"
	Help("  ",1,"NAOCOM")
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Nao excluir NF nao classificada                              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case Empty(SF1->F1_STATUS)
	Help(" ",1,"A100NOCLAS")
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verificar data do ultimo fechamento em SX6                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case dDataFec>=dDataBase .Or. dDataFec>=SF1->F1_DTDIGIT
	Help( " ", 1, "FECHTO" )
	lRetorno := .F.
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica ultima data para operacoes fiscais                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case !FisChkExc(SF1->F1_SERIE,SF1->F1_DOC,SF1->F1_FORNECE,SF1->F1_LOJA,,"E",SF1->F1_FORMUL)
	lRetorno := .F.
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Integracao com o ACD		  				  	  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case lIntACD .And. !(CBA100DEL())
	lRetorno := .F.
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Template acionando ponto de entrada                      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case ExistTemplate("A100DEL") .And. !(ExecTemplate("A100DEL",.F.,.F.))				
	lRetorno := .F.
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Ponto de entrada para permitir ou nao a exclusao             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case l100Del .And. !(Execblock("A100DEL",.F.,.F.))
	lRetorno := .F.
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Nao excluir nota de Frete Gerada pela rotina MATA116         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case SF1->F1_TIPO == "C" .And. SF1->F1_ORIGLAN == "F "  .And. !lCanDelFr
	Help(" ",1,"A100NDELFR")
	lRetorno := .F.
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Nao excluir nota de Despesas de Importacao                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case SF1->F1_TIPO == "C" .And. SF1->F1_ORIGLAN == " D"	.And. !lCanDelDp
	Help(" ",1,"A100NDELDP")
	lRetorno := .F.
	//ÚLocalizacoesÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Nao excluir NF (de devolucao ou retorno) que gerou PV se este³
	//³ ainda existe.                                                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case !lRsAuto .And. !Empty(SF1->F1_PEDVEND) .And. (SF1->F1_PEDVEND == "AUTO  " .Or. Eval( {|| SC5->(DbSetORder(1)),SC5->(MsSeek(xFilial("SC5")+SF1->F1_PEDVEND) ) }) )
	If SF1->F1_PEDVEND <> "AUTO  " 
		Help(" ",1,"A103PV" ,,RetTitle("C9_PEDIDO") + "  " + SF1->F1_PEDVEND,04,02)
	Else
		Help(" ",1,"A103CONS" )
	Endif
	lRetorno	:=	.F.
	
	//Função Modulo DMS para permitir ou nao a exclusao
Case lIntGC .and. FindFunction("OA2900035_MaCanDelF1_Valid") .and. !OA2900035_MaCanDelF1_Valid( { SF1->F1_DOC, SF1->F1_SERIE, SF1->F1_FORNECE, SF1->F1_LOJA } )
	lRetorno :=	.F.

OtherWise
	lRetorno := .T. 
EndCase   

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se Documento de Entrada Original está vinculado aos outros Documentos ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRetorno
	lQuery    := .T.
	cAliasSD1 := GetNextAlias()

	If Select(cAliasSD1) > 0 
		dbSelectArea(cAliasSD1)
	    dbCloseArea()
	EndIf

	cQuery    := "SELECT COUNT(D1_DOC) AS NOTAORI "
	cQuery    += "  FROM "+RetSqlName("SD1")+" SD1 "
	cQuery    += " JOIN "+RetSqlName("SF1")+" SF1 "
	cQuery    += " ON SF1.F1_FILIAL = SD1.D1_FILIAL "
	cQuery    += " AND SF1.F1_DOC = SD1.D1_DOC "
	cQuery    += " AND SF1.F1_SERIE = SD1.D1_SERIE "
	cQuery    += " AND SF1.F1_FORNECE = SD1.D1_FORNECE "
	cQuery    += " AND SF1.F1_LOJA = SD1.D1_LOJA "
	cQuery    += " AND SF1.D_E_L_E_T_ = ' ' "
	cQuery    += " AND SF1.F1_TPCOMPL IN ( '1','2') " //Retiro o complemento de frete da validação pois a mesma é efetuada via SF8(A103CAGREG)
	cQuery    += " WHERE SD1.D1_FILIAL  = '"+xFilial("SD1")+"'"
	cQuery    += "   AND SD1.D1_NFORI   = '"+SF1->F1_DOC+"'"
	cQuery    += "   AND SD1.D1_SERIORI = '"+SF1->F1_SERIE+"'"
	cQuery    += "   AND SD1.D1_FORNECE = '"+SF1->F1_FORNECE+"'"
	cQuery    += "   AND SD1.D1_LOJA    = '"+SF1->F1_LOJA+"'"
	cQuery    += "   AND ( SD1.D1_DOC <> '"+SF1->F1_DOC+"' OR SD1.D1_SERIE <> '"+SF1->F1_SERIE+"' OR SD1.D1_FORNECE <> '"+SF1->F1_FORNECE+"' OR SD1.D1_LOJA <> '"+SF1->F1_LOJA+"')"
	cQuery    += "   AND SD1.D1_TIPO IN ('P','I','C') "
	cQuery    += "   AND SD1.D_E_L_E_T_=' ' "
	
	cQuery := ChangeQuery( cQuery )
	dbUseArea( .T., "TOPCONN", TcGenQry(,,cQuery), cAliasSD1, .T., .T. )      
	
	If ctipo != "C"
		If (cAliasSD1)->NOTAORI > 0 
		   	Help(' ',1,'A103NEXCOR') 
		   	lRetorno := .F.
		EndIf
	EndIf
	(cAliasSD1)->(dbCloseArea())
EndIf


//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Analisa os itens da Nota fiscal de Entrada                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SD1")
dbSetOrder(1)

lQuery    := .T.
cAliasSD1 := "MACANDELF1"
aStruSD1  := SD1->(dbStruct())
cQuery    := "SELECT SD1.*,SD1.R_E_C_N_O_ SD1RECNO "
cQuery    += "  FROM "+RetSqlName("SD1")+" SD1 "
cQuery    += " WHERE SD1.D1_FILIAL   = '"+xFilial("SD1")+"'"
cQuery    += "   AND SD1.D1_DOC	     = '"+SF1->F1_DOC+"'"
cQuery    += "   AND SD1.D1_SERIE    = '"+SF1->F1_SERIE+"'"
cQuery    += "   AND SD1.D1_FORNECE  = '"+SF1->F1_FORNECE+"'"
cQuery    += "   AND SD1.D1_LOJA	 = '"+SF1->F1_LOJA+"'"
cQuery    += "   AND SD1.D1_TIPO	 = '"+SF1->F1_TIPO+"'"
cQuery    += "   AND SD1.D_E_L_E_T_	 = ' ' "
cQuery    += "ORDER BY "+SqlOrder(SD1->(IndexKey()))

cQuery := ChangeQuery(cQuery)
dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSD1,.T.,.T.)

For nX := 1 To Len(aStruSD1)
	If aStruSD1[nX][2]<>"C"
		TcSetField(cAliasSD1,aStruSD1[nX][1],aStruSD1[nX][2],aStruSD1[nX][3],aStruSD1[nX][4])
	EndIf
Next nX

While !Eof().And. (cAliasSD1)->D1_FILIAL == xFilial('SD1') .And.;
		(cAliasSD1)->D1_DOC == SF1->F1_DOC .And.;
		(cAliasSD1)->D1_SERIE == SF1->F1_SERIE .And.;
		(cAliasSD1)->D1_FORNECE == SF1->F1_FORNECE .And.;
		(cAliasSD1)->D1_LOJA == SF1->F1_LOJA .And. lRetorno

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se a O.P. vinculada a uma N.F. esta encerrada     ³
	//³ ou se ja possui quantidade apontada.                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    If !lPRNFBEN
		dbSelectArea("SC2")
		dbSetOrder(1)
		If DbSeek(xFilial("SC2")+(cAliasSD1)->D1_OP) .And. !lCanDelFr
			If !Empty(SC2->C2_DATRF)
				Help("",1,"A103ENCERR")
				lRetorno := .F.
			ElseIf QtdComp(SC2->C2_QUJE,.T.) > QtdComp(0,.T.)
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ`¿
				//³Ponto de entrada que permite ou não a validação da exclusão da NF vinculada a uma OP³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ`Ù
				If lM103APO
					lRetAPO := ExecBlock("M103APO",.F.,.F.)										
					If ValType(lRetAPO)<> "L"
						lRetAPO := .T.
					Endif
				EndIf
				If lRetApo .And.(Type('l103Auto') <> 'U' .And. l103Auto) .Or. Aviso(OemToAnsi(STR0018),OemToAnsi(STR0048)+(cAliasSD1)->D1_OP+OemToAnsi(STR0049),{OemToAnsi(STR0016),OemToAnsi(STR0017)},nil,nil,1) == 2
					lRetorno := .F.
				EndIf
			EndIf
		EndIf		
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ AvalMovDiv - Funcao utilizada para avaliar possiveis divergencias de     |
	//|              saldo no estorno do movimento selecionado.                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !(SF1->F1_TIPO$"PIC") .And. AvalMovDiv((cAliasSD1)->D1_COD,(cAliasSD1)->D1_LOCAL,(cAliasSD1)->D1_LOTECTL,(cAliasSD1)->D1_NUMLOTE,(cAliasSD1)->D1_NUMSEQ,(cAliasSD1)->D1_TES)
		lRetorno := .F.
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Posiciona o Arquivo SF4.                                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea('SF4')
	dbSetOrder(1)
	MsSeek(xFilial("SF4")+(cAliasSD1)->D1_TES)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica a posicao do Pedido de Vendas  (Devolucao)          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRetorno .And. !Empty((cAliasSD1)->D1_NUMPV)
		dbSelectArea('SC5')
		If MsSeek(xFilial("SC5")+(cAliasSD1)->D1_NUMPV)
			aAdd(aRecSC5,SC5->(RecNo()))
		EndIf
		dbSelectArea('SC6')
		dbSetOrder(1)
		If MsSeek(xFilial("SC6")+(cAliasSD1)->D1_NUMPV+(cAliasSD1)->D1_ITEMPV)
			If SC6->C6_QTDLIB+SC6->C6_QTDENT <> 0
				If (Type('l103Auto') <> 'U' .And. l103Auto) .Or. Aviso(OemToAnsi(STR0018),OemToAnsi(STR0015),{OemToAnsi(STR0016),OemToAnsi(STR0017)}) == 2 //"O pedido de vendas gerado pelo Docto. de devolucao ja foi liberado ou atendido e nao sera excluido. Deseja continuar ?"###"Continua"###"Abandona"
					lRetorno := .F.
					Exit
				EndIf
			EndIf
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Trava os registros do SC7.                                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRetorno .And. !Empty((cAliasSD1)->D1_PEDIDO)
		nRecC7 := A103RECC7(xFilial("SC7"),(cAliasSD1)->D1_PEDIDO,(cAliasSD1)->D1_FORNECE,(cAliasSD1)->D1_LOJA,(cAliasSD1)->D1_COD,(cAliasSD1)->D1_ITEMPC)
		SC7->(DbGoTo(nRecC7))
		If nRecC7 > 0
			If !SoftLock('SC7')
				lRetorno := .F.
			EndIf
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Trava os registros do SD7 e SD3                              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRetorno .And. !Empty((cAliasSD1)->D1_NUMCQ)
		dbSelectArea("SD7")
		dbSetOrder(1)
		If MsSeek(xFilial("SD7")+(cAliasSD1)->D1_NUMCQ+(cAliasSD1)->D1_COD+(cAliasSD1)->D1_LOCAL)
			While !Eof() .And.lRetorno .And. xFilial("SD7") == SD7->D7_FILIAL .And.;
					(cAliasSD1)->D1_NUMCQ == SD7->D7_NUMERO .And.;
					(cAliasSD1)->D1_COD == SD7->D7_PRODUTO .And.;
					(cAliasSD1)->D1_LOCAL == SD7->D7_LOCAL
				If ((cAliasSD1)->D1_TIPO $ 'NBD' .or. (cAliasSD1)->D1_TIPO == 'C' .and. SF1->F1_TPCOMPL == '2') .And.;
				   (SD7->D7_TIPO==1 .Or. SD7->D7_TIPO==2 ) .And. Empty(SD7->D7_ESTORNO)	
					Help(' ',1,'A100CQ')
					lRetorno := .F.
					Exit
				ElseIf !SoftLock("SD7")
					lRetorno := .F.
					Exit
				Else
					dbSelectArea("SD3")
					dbSetOrder(4)
					If lRetorno .And. MsSeek(xFilial("SD3")+SD7->D7_NUMSEQ)
						While !Eof() .And. lRetorno .And. SD3->D3_FILIAL == xFilial("SD3") .And.;
								SD3->D3_NUMSEQ == SD7->D7_NUMSEQ
							If !SoftLock("SD3")
								lRetorno := .F.
								Exit
							EndIf
							dbSelectArea("SD3")
							dbSkip()
						EndDo
					EndIf
				EndIf
				dbSelectArea("SD7")
				dbSkip()
			EndDo
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica a existencia de Poder de Terceiros                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRetorno .And. SF4->F4_PODER3=="R"
		dbSelectArea("SB6")
		dbSetOrder(3)
		MsSeek(xFilial("SB6")+(cAliasSD1)->D1_NUMSEQ+(cAliasSD1)->D1_COD+'R')
		While ( !Eof() .And. lRetorno .And. xFilial("SB6") == SB6->B6_FILIAL .And.;
				(cAliasSD1)->D1_NUMSEQ==SB6->B6_IDENT .And.;
				(cAliasSD1)->D1_COD==SB6->B6_PRODUTO .And.;
				"R"==SB6->B6_PODER3 )
			If SB6->B6_QUANT<>SB6->B6_SALDO .And. SB6->B6_TIPO=="D"
				Help(' ',1,'A520NPODER')
				lRetorno := .F.
			EndIf
			dbSelectArea("SB6")			
			dbSkip()
		EndDo
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Integracao do Ativo Fixo - Travamento                        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRetorno .And. lM103XATF
		lRetorno	:=	ExecBlock ("M103XATF", .F., .F., {cAliasSD1})
	Else
		If lRetorno .And. !Empty((cAliasSD1)->D1_CBASEAF)
			lRetorno := M103XAFEXC((cAliasSD1)->D1_DOC,(cAliasSD1)->D1_SERIE,(cAliasSD1)->D1_FORNECE,(cAliasSD1)->D1_LOJA,(cAliasSD1)->D1_COD)
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica a existencia do CIAP                                ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lRetorno .And. !Empty((cAliasSD1)->D1_CODCIAP)
			dbSelectArea('SF9')
			dbSetOrder(1)
			If MsSeek(xFilial("SF9")+(cAliasSD1)->D1_CODCIAP)
				If !Empty( SN1->N1_CODCIAP ) .Or. !Empty((cAliasSD1)->D1_CODCIAP)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Este WHILE se deve ao desmabrento no ativo fixo(SN1) pela quantidade.³
					//³A tabela SN1 eh posicionada logo acima                               ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					nAcICMSAPR	:=	0
					aAreaSN1	:=	SN1->(GetArea ())
					
					If Alltrim(SN1->N1_NFESPEC) == ""
						DbSelectArea("SN1")
						DbSetOrder(8)
						If !DbSeek(xFilial("SN1")+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA+ "     " +(cAliasSD1)->D1_DOC+(cAliasSD1)->D1_SERIE+(cAliasSD1)->D1_ITEM)
							RestArea (aAreaSN1)						
						EndIf	
					Else
					 	If (cAliasSD1)->D1_CODCIAP<>SN1->N1_CODCIAP
							DbSelectArea("SN1")
							DbSetOrder(4)
							If !DbSeek(xFilial("SN1")+(cAliasSD1)->D1_CODCIAP)
								RestArea (aAreaSN1)						
							EndIf
						EndIf
					EndIf
					
					cSeekCIAP := ""
					If SN1->(FieldPos("N1_MSFIL")) > 0 .and. FWModeAccess("SN1")=="C" 
						cSeekCIAP += '(cAliasSD1)->D1_FILIAL == SN1->N1_MSFIL .And. '
					EndIf
					cSeekCIAP += '(cAliasSD1)->D1_CODCIAP==SN1->N1_CODCIAP'

					Do While !SN1->(Eof()) .And. &cSeekCIAP
						nAcICMSAPR	+=	SN1->N1_ICMSAPR
						SN1->(DbSkip())
					EndDo
					RestArea (aAreaSN1)
					If  (((!Empty((cAliasSD1)->D1_CBASEAF) .And. SF9->F9_ICMIMOB <> nAcICMSAPR).Or.(Empty((cAliasSD1)->D1_CBASEAF) .And.SF9->F9_ICMIMOB <> 0)).Or.;
							SF9->F9_BXICMS <> 0 .Or. SF9->F9_MOTIVO <> " " .Or. SF9->F9_VLESTOR <> 0)
						Help("  ",1,"A100CIAPDE")
						lRetorno := .F.
					EndIf
				EndIf				
			EndIf
		EndIf
	EndIf
	//Verifica se existe bloqueio contabil - Validacao incluida em 03/08/2015 changeset 320011 release 12
	If lRetorno .And. SF4->F4_ATUATF == "S" .And. !Empty(dDataBloq) .And. (cAliasSD1)->D1_DTDIGIT <= dDataBloq
		Help(" ",1,"ATFCTBBLQ")	// Processo bloqueado pelo Calendario Contabil ou parametro de bloqueio nesta data ou periodo.
		lRetorno := .F.
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se algum produto esta sendo inventariado.           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRetorno .And. BlqInvent((cAliasSD1)->D1_COD,(cAliasSD1)->D1_LOCAL)
		Help("  ",1,"BLQINVENT",,(cAliasSD1)->D1_COD+STR0022+(cAliasSD1)->D1_LOCAL,1,11) //"Armazem: "
		lRetorno := .F.
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se algum produto ja foi distribuido                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Localiza((cAliasSD1)->D1_COD)
		dbSelectArea('SDA')
		dbSetOrder(1)
		If lRetorno .And. MsSeek(xFilial("SDA")+(cAliasSD1)->D1_COD+(cAliasSD1)->D1_LOCAL+(cAliasSD1)->D1_NUMSEQ+(cAliasSD1)->D1_DOC+(cAliasSD1)->D1_SERIE+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA)
			If !(SDA->DA_QTDORI == SDA->DA_SALDO)
				Help(" ",1,"SDAJADISTR")
				lRetorno := .F.
			EndIf
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica a quantidade devolvida.                             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRetorno .And. ((cAliasSD1)->D1_QTDEDEV <> 0 .Or. (cAliasSD1)->D1_VALDEV <> 0)
		Help(' ',1,'NAOEXCL')
		lRetorno := .F.
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica a quantidade clasificada (remitos de localizacoes)  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRetorno .And. lRemito .And. (cAliasSD1)->D1_QTDACLA <> (cAliasSD1)->D1_QUANT
		Help(' ',1,'NAOEXCLREM')
		lRetorno := .F.
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se o remito esta amarrada a alguma nota de Credito  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRetorno .And. lRemito
		SD1->(DbSetOrder(10))
		If SD1->(MsSeek(xFilial("SD1")+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA+(cAliasSD1)->D1_SERIE+(cAliasSD1)->D1_DOC))
			Help(' ',1,'NAOEXCLREM',,SD1->D1_ESPECIE+" "+SerieNfId("SD1",2,"D1_SERIE")+"/"+SD1->D1_DOC,1,11)
			lRetorno := .F.
		Endif
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica o Servico do WMS.                                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRetorno .And. !Empty((cAliasSD1)->D1_SERVIC) .And. IntWMS() .And. cTipo $ "N|D|B" .And. SF4->F4_ESTOQUE == "S"
		lRetorno := WmsAvalSD1("7",cAliasSD1)
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Totaliza no array aLotes para validar a exclusao.            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRetorno .And. Rastro((cAliasSD1)->D1_COD).And. SF4->F4_ESTOQUE=='S'
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ aLotes[nx][1] : Codigo do Produto        ³
		//³ aLotes[nx][2] : Almoxarifado             ³
		//³ aLotes[nx][3] : Lote                     ³
		//³ aLotes[nx][4] : SubLote                  ³
		//³ aLotes[nx][5] : OP                       ³
		//³ aLotes[nx][6] : Numero Sequencial        ³
		//³ aLotes[nx][7] : Quantidade               ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nPosLote :=Ascan(aLotes,{|x| x[1]+x[2]+x[3]+x[4]==(cAliasSD1)->D1_COD+(cAliasSD1)->D1_LOCAL+(cAliasSD1)->D1_LOTECTL+(cAliasSD1)->D1_NUMLOTE+(cAliasSD1)->D1_OP+(cAliasSD1)->D1_NUMSEQ})
		If nPosLote > 0
			aLotes[nPosLote][7] += (cAliasSD1)->D1_QUANT
		Else
			aADD(aLotes,{(cAliasSD1)->D1_COD,(cAliasSD1)->D1_LOCAL,(cAliasSD1)->D1_LOTECTL,(cAliasSD1)->D1_NUMLOTE,(cAliasSD1)->D1_OP,(cAliasSD1)->D1_NUMSEQ,(cAliasSD1)->D1_QUANT})
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se Sld no B2 ficar  Neg. ou Menor que Sld em Reserva³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRetorno .And. SF4->F4_ESTOQUE == "S" .And. (cAliasSD1)->D1_QUANT > 0
		SB2->(dbSetOrder(1))
		If SB2->(DbSeek(xFilial('SB2')+(cAliasSD1)->D1_COD+(cAliasSD1)->D1_LOCAL))
			If (cAliasSD1)->D1_COD <> cQBCod .or. (cAliasSD1)->D1_LOCAL <> cQBLocal
				cQBCod   := (cAliasSD1)->D1_COD
				cQBLocal := (cAliasSD1)->D1_LOCAL
				nSaldoB2 := SB2->B2_QATU
			EndIf
			nSaldoB2 := nSaldoB2-(cAliasSD1)->D1_QUANT
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se existe movimento de requisicao do material para a OP³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !Empty((cAliasSD1)->D1_OP) .OR. (IntePms() .and. PmsExAFN(cAliasSD1))
				SD3->(dbSetOrder(4))
				If SD3->(dbSeek(xFilial("SD3")+(cAliasSD1)->D1_NUMSEQ))
					nSaldoB2 += SD3->D3_QUANT
				EndIf
			EndIf                                                        
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Verifica se existe movimento de material em Transito            ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If (cAliasSD1)->D1_TRANSIT == 'S'
				SD3->(dbSetOrder(4))
				If SD3->(dbSeek(xFilial("SD3")+(cAliasSD1)->D1_NUMSEQ))
					nSaldoB2 += SD3->D3_QUANT
				EndIf
			EndIf                                        

			If !lNEGATBF                                      
			If QtdComp(nSaldoB2)<QtdComp(0)
			    If lEstNeg  //Permite Estoque Negativo
			        If (Rastro((cAliasSD1)->D1_COD) .Or. Localiza((cAliasSD1)->D1_COD))  // MV_ESTNEG = S e Produto com Rastro / Localização, não permite estoque negativo
						If !(Type('l103Auto') <> 'U' .And. l103Auto)
							Aviso(STR0018,STR0019 + AllTrim((cAliasSD1)->D1_COD)+"/"+(cAliasSD1)->D1_LOCAL + STR0023 + AllTrim(Str(nSaldoB2))+") ",{STR0025}) //"Atencao" //"O Saldo do Prod/Loc "###" ficara negativo apos a Exclusao ("###"Aborta"
						EndIf	
						lRetorno := .F.
			    	Else
						If !(Type('l103Auto') <> 'U' .And. l103Auto)
					    	If !(Rastro((cAliasSD1)->D1_COD) .And. Localiza((cAliasSD1)->D1_COD)) .And. !(FunName() $ 'EICDI154')  // MV_ESTNEG = S e Produto sem Rastro / Localização, avisa que o estoque ficara negativo  e nao originado do Recebimento de Importacao
						    	lRetorno := (Aviso(STR0018,STR0019 + AllTrim((cAliasSD1)->D1_COD)+'/'+(cAliasSD1)->D1_LOCAL + STR0023 + AllTrim(Str(nSaldoB2)) + STR0024,{STR0025,STR0016}) == 2) //"Atencao"###"O Saldo do Prod/Loc "###"Continua" //" ficara negativo apos a Exclusao ("###"). Continua?"###"Aborta"
						    EndIf
						EndIf
					EndIf
				Else  // Não Permite Estoque Negativo
					If !(Type('l103Auto') <> 'U' .And. l103Auto)  
					    lR103ENEG:=A103ValEstNeg((cAliasSD1)->D1_COD,cAliasSD1)
					EndIf	
					lRetorno := lR103ENEG	
			    EndIf
			ElseIf QtdComp(nSaldoB2)<QtdComp(SB2->B2_RESERVA)
				If lEstNeg   //Permite Estoque Negativo
				    If (Rastro((cAliasSD1)->D1_COD) .Or. Localiza((cAliasSD1)->D1_COD))  // MV_ESTNEG = S e Produto com Rastro / Localização, não permite estoque negativo
						If !(Type('l103Auto') <> 'U' .And. l103Auto)
							Aviso(STR0018,STR0019 + AllTrim((cAliasSD1)->D1_COD)+"/"+(cAliasSD1)->D1_LOCAL + STR0026 + AllTrim(Str(nSaldoB2))+")",{STR0025}) //"Atencao"###"O Saldo do Prod/Loc " //" ficara Menor que o Saldo em Reserva apos a Exclusao ("###"Aborta"
						EndIf	
						lRetorno := .F.
					Else
						If !(Type('l103Auto') <> 'U' .And. l103Auto)
						    If !(Rastro((cAliasSD1)->D1_COD) .And. Localiza((cAliasSD1)->D1_COD))  .And. !(FunName() $ 'EICDI154')   // MV_ESTNEG = S e Produto sem Rastro / Localização, avisa que o estoque ficara negativo
						    	lRetorno := (Aviso(STR0018,STR0019 + AllTrim((cAliasSD1)->D1_COD)+'/'+(cAliasSD1)->D1_LOCAL + STR0023 + AllTrim(Str(nSaldoB2)) + STR0024,{STR0025,STR0016}) == 2) //"Atencao"###"O Saldo do Prod/Loc "###"Continua" //" ficara negativo apos a Exclusao ("###"). Continua?"###"Aborta"
					    	EndIf
				    	EndIf
			    	EndIf
			  	Else  // Não Permite Estoque Negativo   
				  	If !(Type('l103Auto') <> 'U' .And. l103Auto)
					    lR103ENEG:=A103ValEstNeg((cAliasSD1)->D1_COD,cAliasSD1)
					EndIf	
					lRetorno := lR103ENEG
				EndIf
			EndIf
		EndIf	
	EndIf				
	EndIf				
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se o item de nota originou-se do SIGAEIC                            ³
	//³ Permite a exclusao apenas quando a chamada da exclusao for feita pelo EIC    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRetorno .And. !lExcViaEIC .And. !Empty( ( cAliasSD1 )->D1_TIPO_NF ) 
		Help( "", 1, "A103EXCIMP" )  // "Este documento nao pode ser excluido pois foi criado pelo SIGAEIC. A exclusao devera ser efetuada pelo SIGAEIC."
		lRetorno := .F. 
	EndIf 	

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se o item de nota originou-se do SIGATMS                            ³
	//³ Permite a exclusao apenas quando a chamada da exclusao for feita pelo TMS    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	If nModulo <> 43 //--So valida se não for o modulo TMS
		SF4->(DbSetOrder(1))
		If SF4->(DbSeek(xFilial('SF4')+cTesDR)) .And. SF4->F4_ESTOQUE == 'S'
			dbSelectArea('DTC')
			dbSetOrder(2) //-- DTC_FILIAL+DTC_NUMNFC+DTC_SERNFC+DTC_CLIREM+DTC_LOJREM
			IF MsSeek(xFilial('DTC') + SF1->F1_DOC + SF1->F1_SERIE + SF1->F1_FORNECE + SF1->F1_LOJA, .F.)
				Help('', 1, 'A103EXCTMS') //-- 'Este documento nao pode ser excluido pois foi criado pelo SIGATMS. A exclusao devera ser efetuada pelo SIGATMS.'
				lRetorno := .F.
			EndIf
		EndIf
	EndIf

	dbSelectArea(cAliasSD1)
	dbSkip()

EndDo
If lQuery
	dbSelectArea(cAliasSD1)
	dbCloseArea()
	dbSelectArea("SD1")
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se os Lotes podem ser excluidos                     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//Não há necessidade de validar a exclusão de lote quando se trata de um conhecimento de frete (F1_TIPO = C | F1_TPCOMPL = 3)
If lRetorno .and. SF1->F1_TIPO <> "C" .AND. SF1->F1_TPCOMPL <> "3"
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ aLotes[nx][1] : Codigo do Produto        ³
	//³ aLotes[nx][2] : Almoxarifado             ³
	//³ aLotes[nx][3] : Lote                     ³
	//³ aLotes[nx][4] : SubLote                  ³
	//³ aLotes[nx][5] : OP                       ³
	//³ aLotes[nx][6] : Numero Sequencial        ³
	//³ aLotes[nx][7] : Quantidade               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nX := 1 to Len(aLotes)

		nSldLote := SaldoLote(aLotes[nX][1],aLotes[nX][2],aLotes[nX][3],aLotes[nX][4],,,.T.)
		// Verifica o saldo em transito disponivel
		nSldTran := SaldoLote(aLotes[nX][1],cLocTran,aLotes[nX][3],aLotes[nX][4],,,.T.)
		If (nSldLote+nSldTran) < aLotes[nX][7]
			If !Empty(aLotes[nx,5])
				dbSelectArea("SD3")
				dbSetOrder(4)
				MsSeek(xFilial("SD3")+aLotes[nx,6])
				While !Eof() .And. SD3->D3_CF # "RE5" .And. SD3->D3_NUMSEQ == aLotes[nx,6]
					dbSkip()
				End
				lEofSD3 := IIF(SD3->D3_NUMSEQ # aLotes[nx,6],.T.,.F.)
				If lEofSD3
					Help(" ",1,"A100NOLOTE",,aLotes[nX,1]+"  "+aLotes[nX,2]+"    "+aLotes[nX,3],5,4)
					lRetorno := .F.
					Exit
				EndIf
			Else
				Help(" ",1,"A100NOLOTE",,aLotes[nX,1]+"  "+aLotes[nX,2]+"    "+aLotes[nX,3],5,4)
				lRetorno := .F.
				Exit
			EndIf
		EndIf
	Next
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se as duplicatas podem ser excluidas  SE2           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRetorno .And. (ExistBlock ("M103XFIN"))
	aRetXFin	:= ExecBlock ("M103XFIN", .F., .F. , {lAviso,lAvisoISS})
	If ValType(aRetXFin) == "A" .And. Len(aRetXFin) <= 3 
		lRetorno	:= IIF(ValType(aRetXFin[1]) == "L",aRetXFin[1],lRetorno)
		lAviso		:= IIF(ValType(aRetXFin[2]) == "L",aRetXFin[2],lAviso)
		lAvisoISS	:= IIF(ValType(aRetXFin[3]) == "L",aRetXFin[3],lAvisoISS)
	EndIf	
EndIf

If lRetorno
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica o Prefixo correto da Nota fiscal de Entrada         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cPrefixo	:= IIf(Empty(SF1->F1_PREFIXO),&(SuperGetMV("MV_2DUPREF")),SF1->F1_PREFIXO)	
	dbSelectArea("SE2")
	dbSetOrder(6)

	lQuery    := .T.
	aStruSE2  := SE2->(dbStruct())
	cAliasSE2 := "MACANDELF1"
	cQuery    := "SELECT SE2.*,SE2.R_E_C_N_O_ SE2RECNO "
	cQuery    += "  FROM "+RetSqlName("SE2")+" SE2 "
	cQuery    += " WHERE SE2.E2_FILIAL   = '"+xFilial("SE2")+"'"
	cQuery    += "   AND SE2.E2_FORNECE  = '"+SF1->F1_FORNECE+"'"
	cQuery    += "   AND SE2.E2_LOJA	 = '"+SF1->F1_LOJA+"'"
	cQuery    += "   AND SE2.E2_PREFIXO  = '"+cPrefixo+"'"
	cQuery    += "   AND SE2.E2_NUM		 = '"+SF1->F1_DUPL+"'"
	cQuery    += "   AND SE2.D_E_L_E_T_  = ' ' "
	cQuery    += "ORDER BY "+SqlOrder(SE2->(IndexKey()))

	cQuery := ChangeQuery(cQuery)
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSE2,.T.,.T.)
	
	For nX := 1 To Len(aStruSE2)
		If aStruSE2[nX][2]<>"C"
			TcSetField(cAliasSE2,aStruSE2[nX][1],aStruSE2[nX][2],aStruSE2[nX][3],aStruSE2[nX][4])
		EndIf
	Next nX
		
	If cPaisLoc $ "BRA|MEX" .and. !(SF1->F1_TIPO$"D|5|6") .and. (cAliasSE2)->(!Eof())
		If lRetorno .and. A120UsaAdi(SF1->F1_COND) 
			If !Empty((cAliasSE2)->E2_BAIXA) .and. (cAliasSE2)->E2_VALOR != (cAliasSE2)->E2_SALDO
				cQ := "SELECT SUM(FR3_VALOR) AS FR3_VALOR "
				cQ += "  FROM "+RetSqlName("FR3")
				cQ += " WHERE FR3_FILIAL = '"+xFilial("FR3")+"' "
				cQ += "   AND FR3_CART   = 'P' "
				cQ += "   AND FR3_TIPO   IN "+FormatIn(MVPAGANT,"/")+" "
				If lForpcnf .And. ( SC7->C7_FORNECE <> SF1->F1_FORNECE .Or. SC7->C7_LOJA <> SF1->F1_LOJA )
					cQ += "   AND FR3_FORNEC = '"+SC7->C7_FORNECE+"' "
					cQ += "   AND FR3_LOJA   = '"+SC7->C7_LOJA+"' "
				Else
					cQ += "   AND FR3_FORNEC = '"+SF1->F1_FORNECE+"' "
					cQ += "   AND FR3_LOJA   = '"+SF1->F1_LOJA+"' "
				EndIf
				cQ += "   AND FR3_DOC    = '"+SF1->F1_DOC+"' "
				cQ += "   AND FR3_SERIE  = '"+SF1->F1_SERIE+"' "
				cQ += "   AND D_E_L_E_T_ = ' ' "
            	
				cQ := ChangeQuery(cQ)
				dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQ),"TRBFR3",.T.,.T.)
					
				TcSetField("TRBFR3","FR3_VALOR","N",TamSX3("FR3_VALOR")[1],TamSX3("FR3_VALOR")[2])						
				   
			   nValorAdtFR3 := TRBFR3->FR3_VALOR           
				   
			   TRBFR3->(dbCloseArea())
			   //Tratamento para bloquear o estorno e exclusão do documento caso a data base seja menor que a data de emissão
			   If lRetorno .And. dDataBase < SF1->F1_DTDIGIT .And. nValorAdtFR3 != 0
			   		If l140Estor 
						Help(,,"A140ESTORN",, STR0226, 1, 0,,,,,,{STR0227})
						lRetorno := .F.
					Elseif l103Exclui
						Help(,,"A103NFISCAL",, STR0228, 1, 0,,,,,,{STR0227})
						lRetorno := .F.
					EndIf					
			   EndIf
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ compara o valor baixado para o titulo ( E2_VALOR - E2_SALDO ), com o valor dos adiantamentos. Se o valor for igual, continua a exclusao   ³
				//³ do documento, se o valor for diferente eh porque houveram outras baixas para o titulo, neste caso, nao eh possivel excluir o documento,   ³
				//³ primeiro deve-se excluir estas outras baixas no Financeiro.  												                                           ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÀÄÄÄÄÄÄÄÄÄÄÙ
				If (cAliasSE2)->(E2_VALOR-E2_SALDO) = nValorAdtFR3 .And. lRetorno
					If !(Type('l103Auto') <> 'U' .And. l103Auto)
						If !ApMsgYesNo(STR0106 + CRLF+ STR0107) //"Por tratar-se de condição de pagamento com Adiantamento, a exclusão do Documento de Entrada também irá excluir a compensação do(s) título(s) de adiantamento associado(s) a este Documento de Entrada no momento da sua geração."#CRLF#"Deseja continuar?"
							lRetorno := .F.
						Endif
					Else
						// .T. - permite excl de docto de entrada com PC vinculado a PA.
						// .F. - não permite a exclusão.
						If !l103EstAdt
							lRetorno := .F.
							Help('',1,'103ESTADT',,STR0229,1,0)//"Sistema está configurado para não permitir a exclusão do documento de entrada via rotina automática quando houver vinculo com pedido de compra e pagamento antecipado. Verifique o parâmetro MV_ESTOADT"
						Endif
					Endif  
			   	Endif				   
			Endif 
		Endif	
	Endif	
	
	dbSelectArea(cAliasSE2)
		
	While ( !Eof() .And. lRetorno .And.;
			xFilial("SE2")  == (cAliasSE2)->E2_FILIAL  .And.;
			SF1->F1_FORNECE == (cAliasSE2)->E2_FORNECE .And.;
			SF1->F1_LOJA    == (cAliasSE2)->E2_LOJA    .And.;
			cPrefixo	    == (cAliasSE2)->E2_PREFIXO .And.;
			SF1->F1_DUPL	== (cAliasSE2)->E2_NUM )
		If (cAliasSE2)->E2_TIPO == MVNOTAFIS
			aadd(aRecSE2,If(lQuery,(cAliasSE2)->SE2RECNO,(cAliasSE2)->(RecNo())))

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ se for nota fiscal com adiantamento compensado, valida se a nota fiscal tem somente uma parcela no contas a pagar                                        ³
			//³ se for somente 1 parcela, segue o cancelamento e nao valida se o titulo estah baixado, pois a compensacao desta parcela vai ser desfeita na rotina       ³
			//³ A103Grava                                                                                                                                                ³
			//³ se for mais de uma parcela, valida as parcelas a partir da segunda, para checar se hah alguma parcela baixada                                            ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cPaisLoc $ "BRA|MEX"
				If !(SF1->F1_TIPO$"D|5|6")
					If nCountSE2 = 0
						If A120UsaAdi(SF1->F1_COND)
		   					If !Empty((cAliasSE2)->E2_BAIXA) .and. (cAliasSE2)->E2_VALOR != (cAliasSE2)->E2_SALDO .And. !A103BXADT((cAliasSE2)->E2_PREFIXO,(cAliasSE2)->E2_NUM,(cAliasSE2)->E2_PARCELA,(cAliasSE2)->E2_TIPO,(cAliasSE2)->E2_FORNECE,(cAliasSE2)->E2_LOJA,(cAliasSE2)->E2_FILORIG) //tem baixa para o adiantamento
		   						lPriParAdtBx := .T.
		   					Endif
				   		Endif
				   	Endif
			   	Endif
		   	Endif	
			
			If IIf((cPaisLoc == "BRA" .And. lPriParAdtBx),.F., !FaCanDelCP(cAliasSE2,"MATA100|PLSMPAG"))
				lRetorno := .F.
				Exit
			EndIf  
			
			If cPaisLoc <> "RUS"
			// Verifica se titulo foi conciliado por DDA
				If VldConcDda((cAliasSE2)->E2_FILIAL, (cAliasSE2)->E2_FORNECE, (cAliasSE2)->E2_LOJA, (cAliasSE2)->E2_CODBAR, (cAliasSE2)->E2_FILIAL+ "|" + (cAliasSE2)->E2_PREFIXO+"|" + (cAliasSE2)->E2_NUM+"|" +;
								(cAliasSE2)->E2_PARCELA+"|" + (cAliasSE2)->E2_TIPO+"|" + (cAliasSE2)->E2_FORNECE+"|" + (cAliasSE2)->E2_LOJA + "|")
					lRetorno := .F.
					Help('',1,'FIN050DDA',,STR0166,1,0)
					Exit
				EndIf
			EndIf      

			If lRetISSMes
				dDataVenc := (cAliasSE2)->E2_VENCREA
			EndIf
			
			If ((cAliasSE2)->E2_PRETPIS == "2" .Or. (cAliasSE2)->E2_PRETCOF == "2" .Or. (cAliasSE2)->E2_PRETCSL == "2") .And.;
				((cAliasSE2)->E2_VRETPIS == 0 .Or. (cAliasSE2)->E2_VRETCOF == 0 .Or. (cAliasSE2)->E2_VRETCSL == 0)
				lAviso   := .T.
			Endif	

			If (cAliasSE2)->E2_ISS > 0 .Or. (cAliasSE2)->E2_VRETISS > 0
				lVldRetISS := .T.
		EndIf
		lPriParAdtBx := .F.
		nCountSE2++
		
		EndIf
		dbSelectArea(cAliasSE2)
		dbSkip()
	EndDo
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Apaga tambem os registro de impostos	   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aAreaSE2IR := GetArea()
	dbSelectArea("SE2")
	dbSetOrder(6)
	dbSeek(xFilial("SE2")+SF1->F1_FORNECE+SF1->F1_LOJA+cPrefixo+SF1->F1_DUPL) //xFilial("SE2")+cPrefixo+SF1->F1_DUPL )

    If (SE2->E2_FILIAL+SE2->E2_FORNECE+SE2->E2_LOJA+SE2->E2_PREFIXO+SE2->E2_NUM == ;
		(xFilial("SE2")+SF1->F1_FORNECE+SF1->F1_LOJA+cPrefixo+SF1->F1_DUPL))
		nRecE2in:=SE2->(RecNo())
		dbSetOrder(0)
		SE2->(MsGoto(nRecE2in))
		
		// Quantidade de titulos gerados PIS, COF ou ISS
		// Como a ordenação está de acordo com o recno, verifico a quantidade total que foi gerado de titulo ( PIS, COF ou ISS)
		nQtdTit := 0
		nQtdTot := 0

		cPrefOri  := SE2->E2_PREFIXO
		cNumOri   := SE2->E2_NUM
		cParcOri  := SE2->E2_PARCELA
		cTipoOri  := SE2->E2_TIPO
		cCfOri    := SE2->E2_FORNECE
		cLojaOri  := SE2->E2_LOJA
		cEmiOri   := SE2->E2_EMISSAO
		
		if SF1->F1_ISS > 0 
			nQtdTot += 1
		endif

		if SF1->F1_VALIMP5 > 0
			nQtdTot += 1
		endif

		if SF1->F1_VALIMP6 > 0
			nQtdTot += 1
		endif

		if SF1->F1_VALFASE > 0
			nQtdTot += 1
		endif

		//Natureza para Contribuição Seguridade Social.
 		IF ExistBlock("NTFUNR")
			cNatGilRat   := ExecBlock("NTFUNR",.f.,.f.,{SE2->E2_ORIGEM,SE2->E2_PREFIXO})
		Else
			cNatGilRat := SuperGetMv("MV_CSS",.F.,Criavar('ED_CODIGO'))
		Endif

		cNatGilRat := PadR(cNatGilRat,TamSX3('ED_CODIGO')[1]) 
		aNats := {&(SuperGetMv("MV_IRF")),;
					SuperGetMv("MV_PISIMP",.F.,""),;
					SuperGetMv("MV_COFIMP",.F.,""),;
					SuperGetMv("MV_ISSIMP",.F.,""),;
					SuperGetMv("MV_FASEIMP",.F.,""),; 
					cNatGilRat }

		lUseClass := FindClass('totvs.protheus.backoffice.fin.bills.related.BillRelated')
		If lUseClass
			oObjTitPai := totvs.protheus.backoffice.fin.bills.related.BillRelated():New()
			lUseClass := oObjTitPai:canUseRelatedBill()
		Endif

		If lUseClass
			//Chave FK7 do Titulo Original
			cChvOriFk7 := FINBuscaFK7(xFilial("SE2")+"|"+cPrefOri+"|"+cNumOri+"|"+cParcOri+"|"+cTipoOri+"|"+cCfOri+"|"+cLojaOri, "SE2")
		Endif

		While (!EOF() .And. ( ( SE2->E2_FILIAL+SE2->E2_PREFIXO+SE2->E2_NUM == (xFilial("SE2")+cPrefixo+SF1->F1_DUPL) ) ) .Or. ;
		(SE2->E2_FILIAL+SE2->E2_PREFIXO+SE2->E2_NUM == (xFilial("SE2")+(cPrefPIS+SF1->F1_DUPL))) .Or.;
		(SE2->E2_FILIAL+SE2->E2_PREFIXO+SE2->E2_NUM == (xFilial("SE2")+(cPrefCOF+SF1->F1_DUPL))) .Or.;
		(SE2->E2_FILIAL+SE2->E2_PREFIXO+SE2->E2_NUM == (xFilial("SE2")+(cPrefISS+SF1->F1_DUPL))) .Or.;
		(SE2->E2_FILIAL+SE2->E2_PREFIXO+SE2->E2_NUM == (xFilial("SE2")+(cPreFase+SF1->F1_DUPL))) .Or.;
		GetDelTitImp( cPrefPIS, cPrefCOF, cPrefISS, cPreFase, @nQtdTit, nQtdTot ) )

		 	if SE2->E2_PREFIXO == cPrefPIS .or. SE2->E2_PREFIXO == cPrefCOF .or. SE2->E2_PREFIXO == cPrefISS
		 		nQtdTit += 1
		 	endif

			If !Empty(SE2->E2_IDDARF) 
				lRetorno := .F.
				Help(" ",1,"NAOEXCNFS","NAOEXCNFS","Ja foi gerado DARF, ID "+SE2->E2_IDDARF+", verifique na rotina FINA373",1,0)
				Exit
			EndIf

			If !Empty(SE2->E2_TITPAI)
				If lUseClass
					json := oObjTitPai:getRelatedBills('SE2', .T.)
					if !Empty(json['document']) .And. Len(json['document']) > 0
						cTitPai := json['document'][1]['FK7_IDDOC']
					endif

					If cTitPai = cChvOriFk7 
						aadd(aRecSE2,SE2->(RecNo()))	
					Endif
				Else
					If Alltrim(SE2->E2_TITPAI) == Alltrim(cPrefOri + cNumOri + cParcOri + cTipoOri + cCfOri + cLojaOri)
						aadd(aRecSE2,SE2->(RecNo()))			
					Endif
				Endif
			Else	
				If (SE2->E2_FORNECE+SE2->E2_LOJA <> SF1->F1_FORNECE+SF1->F1_LOJA) .And. E2_TIPO <> "CID" .And. E2_TIPO <> "ISS"
					DbSkip()
					Loop			
				ElseIf Ascan(aNats,Alltrim(SE2->E2_NATUREZ)) > 0 .And. SE2->E2_SALDO != 0 .And. aScan(aRecSE2,SE2->(RecNo())) == 0
					aadd(aRecSE2,SE2->(RecNo()))			
				EndIf	
			Endif	
			//Acrescentado comparação com E2_TITPAI, pois esta é a forma mais segura de se identificar os titulos filhos no momento da exclusão da nota de entrada.
			//Caso o campo esteja vazio foi alterado a comparação para que seja rodado todo o loop de notas iguais para que caso seja identificado alguma com o mesmo 
			//fornecedor a mesma possa ser excluida e não apenas dar um EXIT como era anteriormente. 

			dbSkip()
		EndDo
		FreeObj(oObjTitPai)
  	EndIf
	RestArea(aAreaSE2IR)
	If lQuery
		dbSelectArea(cAliasSE2)
		dbCloseArea()
		dbSelectArea("SE2")
	EndIf
EndIf

If lRetorno .And. lRetISSMes .And. !Empty(dDataVenc) .And. lVldRetISS
	dDataIni:= FirstDay(dDataVenc)
	dDataFim:= LastDay(dDataVenc)
	
	lQuery    := .T.
 	cAliasSE2 := GetNextAlias()

	cQuery := "SELECT E2_PREFIXO, E2_NUM, E2_ISS, E2_VRETISS, SE2.R_E_C_N_O_ SE2RECNO "
	cQuery += "  FROM "+RetSqlName( "SE2" ) + " SE2 "
	cQuery += " WHERE E2_FILIAL   = '"+xFilial("SE2")+"'"
	cQuery += "   AND E2_FORNECE  = '"+SF1->F1_FORNECE	+ "'"
	cQuery += "   AND E2_LOJA     = '"+SF1->F1_LOJA+"'"
	cQuery += "   AND E2_VENCREA  >= '"+DToS(dDataIni)+"'"
	cQuery += "   AND E2_VENCREA  <= '"+DToS(dDataFim)+"'"
	cQuery += "   AND (E2_ISS > 0 OR E2_VRETISS > 0)"
	cQuery += "   AND E2_TIPO NOT IN " + FormatIn(MVABATIM,"|")
	cQuery += "   AND E2_TIPO NOT IN " + FormatIn(MV_CPNEG,cSepNeg)
	cQuery += "   AND E2_TIPO NOT IN " + FormatIn(MVPROVIS,cSepProv)
	cQuery += "   AND E2_TIPO NOT IN " + FormatIn(MVPAGANT,cSepRec)
	cQuery += "   AND D_E_L_E_T_=' '"

	cQuery := ChangeQuery( cQuery )
	dbUseArea( .T., "TOPCONN", TcGenQry(,,cQuery), cAliasSE2, .F., .T. )
	
    TcSetField(cAliasSE2,"E2_ISS","N",TamSX3("E2_ISS")[1],TamSX3("E2_ISS")[2])
    TcSetField(cAliasSE2,"E2_VRETISS","N",TamSX3("E2_VRETISS")[1],TamSX3("E2_VRETISS")[2])
	
	While !(cAliasSE2)->(Eof())
		If cPrefixo == (cAliasSE2)->E2_PREFIXO .And.;
	       SF1->F1_DUPL == (cAliasSE2)->E2_NUM
			(cAliasSE2)->(dbSkip())
			If (cAliasSE2)->(Eof())
				lAvisoISS:= .F.			
				lRetorno := .T.
			ElseIf (cAliasSE2)->E2_ISS > 0
				lAvisoISS:= .T.
				lRetorno := .F.
				Exit
			EndIf
		Else
			If (cAliasSE2)->E2_ISS > 0
				lAvisoISS:= .T.
				lRetorno := .F.
			End
			(cAliasSE2)->(dbSkip())
		EndIf
	EndDo
	If lQuery
		dbSelectArea(cAliasSE2)
		dbCloseArea()
		dbSelectArea("SE2")
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se as duplicatas podem ser excluidas  SE1           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRetorno .And. SF1->F1_TIPO == 'D'
	cE1Cliente := SF1->F1_FORNECE // Quando integrado com DMS, o cliente pode ser outro se utilizado condicao de pagamento TIPO A na venda.
	cE1Loja    := SF1->F1_LOJA    // Quando integrado com DMS, o cliente pode ser outro se utilizado condicao de pagamento TIPO A na venda.
	cE1NReduz  := "" 			  // Quando integrado com DMS, o cliente pode ser outro se utilizado condicao de pagamento TIPO A na venda.

	If lIntGC .and. ExistFunc("FMX_NCCCliente")
		FMX_NCCCliente(SF1->F1_DOC, SF1->F1_SERIE, SF1->F1_FORNECE, SF1->F1_LOJA, @cE1Cliente, @cE1Loja, @cE1NReduz)
	EndIf

	dbSelectArea('SE1')
	dbSetOrder(2)
	If MsSeek(xFilial("SE1")+cE1Cliente+cE1Loja+cPrefixo+SF1->F1_DOC)
		While !Eof().And. lRetorno .And. xFilial()+cE1Cliente+cE1Loja+cPrefixo+SF1->F1_DOC==;
				E1_FILIAL+E1_CLIENTE+E1_LOJA+E1_PREFIXO+E1_NUM
			If !(SE1->E1_TIPO$ MV_CRNEG)
				dbSelectArea('SE1')
				dbSkip()
				Loop
			EndIf
			aadd(aRecSE1,SE1->(RecNo())) 
			If SE1->E1_SALDO <> SE1->E1_VALOR 
				Help(' ',1,'A100FINBX')
				lRetorno := .F.
			ElseIf !SoftLock('SE1')
				lRetorno := .F.
			EndIf
			dbSelectArea('SE1')
			dbSkip() 
		EndDo
	EndIf
EndIf

//Nota de devolução Totvs Mais Negocios
If lRetorno .And. FindFunction( "RskIsActive" ) .And. RskIsActive() .And. SF1->F1_TIPO == 'D'
	RskDelNcc()
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿                  
//³ Verifica se a NFE gerou Imposto ICMS ANTECIPACAO no SE2 CAPag³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

If cPaisLoc == "BRA"
	If!Empty(SF1->F1_NUMTRIB)
		If AllTrim(SF1->F1_NUMTRIB) == "N"
			lNumTrib := .F.
		EndIf
		cNumTit := SF1->F1_NUMTRIB
	EndIf
Else
	cNumTit := SF1->F1_DOC
EndIf

If lRetorno .And. cPaisloc=="BRA" .And. lNumTrib
	dbSelectArea("SE2")
	SE2->(dbsetOrder(1))
	If dbSeek(xFilial("SE2") + "ICM" + cNumTit)
		Do While SE2->(!Eof()) .And. SE2->E2_PREFIXO+SE2->E2_NUM == "ICM" + cNumTit
			//Se o titulo sofreu pagamento nao permitir excluir a NFE
			If !Empty(SE2->E2_BAIXA).And. SE2->E2_SALDO<>SE2->E2_VALOR .And. ;
				ALLTRIM(SE2->E2_TIPO)=="TX" .And. ALLTRIM(SE2->E2_ORIGEM) == "MATA103"

				cMensagem:=" Não é possível excluir esse documento por "+CHR(10)
				cMensagem+="estar vinculado a um título a pagar de imposto "+CHR(10)
				cMensagem+="( "+SE2->E2_NUM+"/"+SE2->E2_PREFIXO+") baixado total ou parcialmente."+CHR(10)
				cMensagem+="Para excluir esse documento, será necessário "+CHR(10)
				cMensagem+="primeiramente estornar esse título através "+CHR(10)
				cMensagem+="do módulo financeiro."

				Help(" ",1,"NAOEXCNFS","NAOEXCNFS",cMensagem,1,0)
				lRetorno := .F.
			Endif
			SE2->(DbSkip())
		EndDo
	Endif
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Integracao com o EEC     											|
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRetorno .And. lEECFAT
	lRetorno := EECFAT3("VLD",.T.)
EndIf

If lAviso .And. lShowAviso
	If !(Type('l103Auto') <> 'U' .And. l103Auto)
		Aviso(OemToAnsi(STR0018),OemToAnsi(STR0039),{OemToAnsi(STR0038)},2)
	EndIf	
ElseIf lAvisoISS
	If !(Type('l103Auto') <> 'U' .And. l103Auto)
		Aviso(OemToAnsi(STR0018),OemToAnsi(STR0041),{OemToAnsi(STR0038)},2)
	EndIf	
Endif

//-----------------------------------------------------------------------------------------
//Verifica abaixo se existem títulos de recolhimento gerados pelo motor Fiscal/Financeiro
//-----------------------------------------------------------------------------------------
If lRetorno .And. cPaisloc == "BRA" .And. AliasInDic("F2F") .And. AliasInDic("FK7") .AND. FindFunction("xFisDelTit") .And. SF1->(FieldPos('F1_IDNF')) > 0 
	// Opcao = 1 p/ somente validar a exclusão.
	lRetorno := xFisDelTit(SF1->F1_IDNF, "SF1", "MATA100", 1)
EndIf

If !lRetorno .And. lExcViaEIC
	lMsErroAuto := .T.
EndIf

RestArea(aAreaSD1)
RestArea(aAreaSF8)
RestArea(aArea)

Return lRetorno

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³ A103Potenc  ³Autor³Rodrigo de A. Sartorio³ Data ³ 17/06/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³ Validacao para digitar a potencia do Lote corretamente     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Mata103                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A103Potenc()
LOCAL lRet      := .T.
LOCAL cCod		:= aCols[n][GetPosSD1("D1_COD")]
LOCAL cLocal    := aCols[n][GetPosSD1("D1_LOCAL")]
LOCAL nPosLote  := GetPosSD1("D1_NUMLOTE")
LOCAL nPosLotCTL:= GetPosSD1("D1_LOTECTL")
LOCAL nPotencia := &(ReadVar())
LOCAL aAreaSB8  := SB8->(GetArea())
LOCAL cAlias    := Alias()
If nPotencia <> 0
	If !Rastro(cCod)
		Help(" ",1,"NAORASTRO")
		lRet:=.F.
	Else
		If !PotencLote(cCod)
			Help(" ",1,"NAOCPOTENC")
			lRet:=.F.
		EndIf	
		If lRet .And. ((nPosLotCTL > 0 .And. !Empty(aCols[n,nPosLotCTL])) .Or. (nPosLote > 0 .And. !Empty(aCols[n,nPosLote])))
			// Verifica se a data de validade pode ser utilizada
			dbSelectArea("SB8")
			dbSetOrder(3)	
			If MsSeek(xFilial("SB8")+cCod+cLocal+aCols[n,nPosLotCTL]+IF(Rastro(cCod,"S"),+aCols[n,nPosLote],"")) .And. nPotencia # SB8->B8_POTENCI
				Help(" ",1,"POTENCORI")
				&(ReadVar()):=SB8->B8_POTENCI
			EndIf
			RestArea(aAreaSB8)
		EndIf
	EndIf
EndIf

dbSelectArea(cAlias)
Return lRet


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³MaAvalSF1 ³ Autor ³ Eduardo Riera         ³ Data ³30.09.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de complemento de atualizacao dos dados do documento  ³±±
±±³          ³de entrada                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpN1: Codigo do evento                                      ³±±
±±³          ³       [1] Implantacao do pre-documento de Entrada           ³±±
±±³          ³       [2] Estorno do pre-documento de Entrada               ³±±
±±³          ³       [3] Exclusao do pre-documento de entrada              ³±±
±±³          ³       [4] Implantacao do documento de Entrada               ³±±
±±³          ³       [5] Estorno do documento de Entrada                   ³±±
±±³          ³       [6] Exclusao do documento de Entrada                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo complementar a atualizacao dos ³±±
±±³          ³dados do documento de entrada e seus anexos                  ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaAvalSF1(nOpcao,cAliasSF1)

Local aArea       := GetArea()
Local aAreaSF1    := SF1->(GetArea())
Local lHomologado := .F.
Local lAtuSA2     := .T.
Local cSF1PKey    := xFilial("SF1")+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA
Local nMCusto	  := Val(SuperGetMV("MV_MCUSTO"))
Local lMT103TRV   := ExistBlock("MT103TRV")

Default cAliasSF1 := "SF1"

Do Case
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Implantacao do Pre documento de entrada                             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nOpcao == 1

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Estorno do Pre documento de entrada                                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nOpcao == 2

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Exclusao do Pre documento de entrada                                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nOpcao == 3
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza os acumulados do fornecedor                                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If (cAliasSF1)->F1_TIPO=="N"
		// Ponto de Entrada MT103TRV utilizado para desligar a atualizacao da tabela SA2
		If lMT103TRV 
			lAtuSA2 := ExecBlock("MT103TRV",.F.,.F.,{SF1->F1_FORNECE,SF1->F1_LOJA,"F"})[2]
		EndIf
		// Atualiza dados da SA2 com base no documento incluido		
		If lAtuSA2 
			RecLock("SA2",.F.)
			SA2->A2_MCOMPRA := Max(xMoeda(SF1->F1_VALBRUT,1,Val(SuperGetMV("MV_MCUSTO")),SF1->F1_EMISSAO),SA2->A2_MCOMPRA)
			SA2->A2_MNOTA   := Max(SA2->A2_MNOTA,Round(NoRound(xMoeda(SF1->F1_VALBRUT,1,nMCusto,SF1->F1_EMISSAO,3),3),2) )
			SA2->(MsUnLock())
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Reabre o Aviso de Recebimento se Houver                             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("DB2")
	dbSetOrder(1)
	If MsSeek(xFilial("DB2")+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA)
		dbSelectArea("DB1")
		dbSetOrder(1)
		If MsSeek(xFilial("DB1")+DB2->DB2_NRAVRC)
			dbSelectArea("DB2")
			dbSetOrder(1)
			While !Eof() .And. xFilial("DB2") == DB2->DB2_FILIAL .And.;
				DB2->DB2_NRAVRC == DB1->DB1_NRAVRC
				If xFilial("SF1")+DB2->DB2_DOC+DB2->DB2_SERIE+DB2->DB2_CLIFOR+DB2->DB2_LOJA <>  cSF1PKey 
					dbSelectArea("SF1")
					dbSetOrder(1)
					If MsSeek(xFilial("SF1")+DB2->DB2_DOC+DB2->DB2_SERIE+DB2->DB2_CLIFOR+DB2->DB2_LOJA) 
						lHomologado := .T.
						Exit
					EndIf
				EndIf
				dbSelectArea("DB2")
				dbSkip()
			EndDo
			RecLock("DB1",.F.,.T.)			
			DB1->DB1_HOMOLO := IIf(lHomologado,"2","1")	 // Reabre o Aviso de Recebimento como parcialmente atendido
			MsUnLock()
		EndIf		
    EndIf
	RestArea(aAreaSF1)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Implantacao do documento de entrada                                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nOpcao == 4
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza os acumulados do fornecedor                                ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If (cAliasSF1)->F1_TIPO=="N"
		//Nao realizado por falta de informacao
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Estorno do documento de entrada                                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nOpcao == 5

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Exclusao do documento de entrada                                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nOpcao == 6
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Reabre o Aviso de Recebimento se Houver                             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("DB2")
	dbSetOrder(1)
	If MsSeek(xFilial("DB2")+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA)
		dbSelectArea("DB1")
		dbSetOrder(1)
		If MsSeek(xFilial("DB1")+DB2->DB2_NRAVRC)
			dbSelectArea("DB2")
			dbSetOrder(1)
			While !Eof() .And. xFilial("DB2") == DB2->DB2_FILIAL .And.;
				DB2->DB2_NRAVRC == DB1->DB1_NRAVRC
				If xFilial("SF1")+DB2->DB2_DOC+DB2->DB2_SERIE+DB2->DB2_CLIFOR+DB2->DB2_LOJA <>  cSF1PKey 
					dbSelectArea("SF1")
					dbSetOrder(1)
					If MsSeek(xFilial("SF1")+DB2->DB2_DOC+DB2->DB2_SERIE+DB2->DB2_CLIFOR+DB2->DB2_LOJA) 
						lHomologado := .T.
						Exit
					EndIf
				EndIf
				dbSelectArea("DB2")
				dbSkip()
			EndDo
			RecLock("DB1",.F.,.T.)			
			DB1->DB1_HOMOLO := IIf(lHomologado,"2","1")	 // Reabre o Aviso de Recebimento como parcialmente atendido
			MsUnLock()
		EndIf		
    EndIf
EndCase
RestArea(aAreaSF1)
RestArea(aArea)
Return(.T.)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³MaAvalSD1 ³ Autor ³ Eduardo Riera         ³ Data ³01.10.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de complemento de atualizacao dos dados do item do    ³±±
±±³          ³documento de entrada                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpN1: Codigo do evento                                      ³±±
±±³          ³       [1] Implantacao de pre-documento de entrada           ³±±
±±³          ³       [2] Estorno do pre-documento de entrada               ³±±
±±³          ³       [3] Exclusao fisica do pre-documento de entrada       ³±±
±±³          ³       [4] Implantacao do documento de entrada               ³±±
±±³          ³       [5] Estorno do documento de entrada                   ³±±
±±³          ³       [6] Exclusao fisica do documento de entrada           ³±±
±±³          ³ExpC2: Alias do SD1                                     (OPC)³±±
±±³          ³ExpL3:Indica se o SA5 deve ser Incluido                 (OPC)³±±
±±³          ³ExpL4:Indica se a data da ultima compra sera dt.digitacao ou ³±±
±±³          ³      emissao.                                               ³±±
±±³          ³ExpL5:Indica se o custo atualizado no SA5 deve ser liquido   ³±±
±±³          ³      (OPC)                                                  ³±±
±±³          ³ExpL6:Indica se o SA5 deve ser atualizado               (OPC)³±±
±±³          ³ExpA7:Array com os recnos do documentos de entrada de origem ³±±
±±³          ³      (OPC)                                                  ³±±
±±³          ³ExpA8:Array com os numeros dos contratos deste docto de      ³±±
±±³          ³  entrada - gestao de contratos (OPC)                        ³±±
±±³          ³ExpL9: Indica de grava SA5 pelo codigo do produto ou pela    ³±±
±±³          ³       referencia de grade                                   ³±±
±±³          ³lEstNfClass - indica se eh estorno da classificacao          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo complementar a atualizacao dos ³±±
±±³          ³dados do item do documento de entrada e seus anexos          ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MaAvalSD1(nOpcao,cAliasSD1,lIncSA5,lDataUcom,lPrecoDes,lAtuSA5,aRecSF1Ori,aContratos,lIncRef,aCIAP,lEstNfClass,aCompFutur,lAgregaOri,aParamSX1,nIdxSD1)

Local aArea      	:= SD1->(GetArea())
Local aAreaSD1   	:= {}
Local aAreaSF1   	:= {}
Local aAreaSA2   	:= {}
Local aCustoEnt  	:= {}
Local aEnvCele   	:= {}
Local aRetQIE    	:= {}
Local aMov       	:= {}
Local aLote      	:= {"",""}
Local aSD3       	:= {}
Local cCursorSD7 	:= "SD7"
Local cLocOrig   	:= SD1->D1_LOCAL
Local nAtraso    	:= 0
Local nX         	:= 0
Local lEnviaCQ   	:= .F.
Local lEnvCQPE   	:= .F.
Local lQuery     	:= .F.
Local aBaixa     	:= {}
Local nQtdBaixa  	:= 0
Local lAjNfCompl 	:= SuperGetMV("MV_AJUSNFC",.F.,.F.)
Local lCusFifo   	:= SuperGetMV("MV_CUSFIFO",.F.)
Local lCusLifo   	:= SuperGetMV("MV_CUSLIFO",.F.,.F.)
Local lEECFAT    	:= SuperGetMv("MV_EECFAT",.F.,.F.)
Local cFTCiap    	:= SuperGetMv("MV_FTCIAP",.F.,"N") //Utilizado para calc. ICMS no CIAP. Se S= Considera valor de ICMS FRETE se N= Nao considera ICMS FRETE.
Local lVldNFO    	:= SuperGetMV("MV_VLDNFO",.F.,.F.)

Local nVlrCompl  	:= 0
Local cDoc       	:= ""
Local cSerie     	:= ""
Local cFornec    	:= ""
Local cLoja      	:= ""
Local cCod       	:= ""
Local cItem      	:= ""
Local cUsoD1_TRT 	:= GetSx3Cache("D1_TRT","X3_USADO")

Local cProdRef   	:= " "
Local lAchou    	:= .F.     
Local lReferencia 	:= .F.
Local lTemSDC    	:= .F.
Local lRetEnd    	:= .T.
Local lComplQtd  	:= Type("cTpCompl") == "C" 
Local cLocaliz   	:= ""
Local nSldRE5 	 	:= 0
Local nQtdBxa    	:= 0
Local nQtdSDC  	 	:= 0
Local nQtdSD4    	:= 0
Local nPcoCompra 	:=0
Local nQtdOriFr  	:= 0
Local nValOriFr  	:= 0
Local nVlDescFr  	:= 0
Local lTpNFQie 	 	:= iif(ExistBlock("MT103QIETP"),ExecBlock("MT103QIETP",.F.,.F.),.F.) 		// permite mudar o tipo do documento ao legado (NF)									
Local cFabric  		:= ""
Local cFabLoja 		:= ""
Local nMcusto		:= SuperGetMV("MV_MCUSTO")
Local cSimpNac   	:= ""
Local nF1Origem  	:= 0
Local nFilCiap   	:= 0
Local nCodCiap   	:= 0
static lInspec  	:= iif(ExistBlock("Q103INSP"),ExecBlock("Q103INSP",.F.,.F.),.F.) 		// Permite gerar inspeção de entrada em produto tipo CQ = M

Local aStruSD7  	:= {}
Local cQuery    	:= ""	

Local lIntWMSAtu	:= ""
Local lWmsNew 		:= SuperGetMv("MV_WMSNEW",.F.,.F.)
Local lD1FilOri		:= SD1->(FieldPos("D1_FILORI")> 0)
Local cD1FilOri		:= ""
Local cSF2Fil 		:= ""
Local lProcLoja		:= FwIsInCallStack("LOJA720")
Local lDHQInDic 	:= FwAliasInDic("DHQ") .And. SF4->(FieldPos("F4_EFUTUR") > 0)
Local lMt103Com 	:= FindFunction("A103FutFat") .And. FindFunction("A103FutRem")
Local ld3kLimp		:= Findfunction('MatLimpD3K')
Local lFornece  	:= SD3->(FieldPos("D3_FORNDOC")) > 0 .And. SD3->(FieldPos("D3_LOJADOC")) > 0
Local lCTeCiap		:= FwIsInCallStack("MATA116") .Or. (FwIsInCallStack("MATA103") .And. SF1->F1_TIPO == "C" .And. SF1->F1_TPCOMPL = "3")
Local lCpoSGO   	:= A103ChSGO()
Local aF1Area		:= {}
Local aF8Area		:= {}

Local nTamLocal  	:= 0
Local nTamLocFis 	:= 0
Local nTamNumSer 	:= 0
Local nTamCPOs   	:= 0
Local nTamContX6 	:= 0
Local nForTimes  	:= 0
Local nPos		 	:= 0
Local aDistAut	 	:= {}
Local cDistAut	 	:= ""
Local cEndAut	 	:= ""
Local cNumSerie	 	:= ""
Local cDtCTE	 	:= ""
Local dMVULMES	 	:= SUPERGETMV('MV_ULMES',.F.,.F.)
Local lPe103Upc 	:= ExistBlock("MT103UPC")
Local cEspDoc		:= Iif(FwIsInCallStack("MATA116") .Or. FwIsInCallStack("MATA103"),SF1->F1_ESPECIE,"")
Local oTribGen      := Nil
Local cCrIcmTrib    := ""
Local cICMCompl     := ""

Static _oQrySW7 

DEFAULT cAliasSD1 := "SD1"
DEFAULT lIncSA5   := .F.
DEFAULT lAtuSA5   := .F.
DEFAULT lDataUcom := .F.
DEFAULT lPrecoDes := .F.
DEFAULT aCIAP     := {{(cAliasSD1)->D1_CODCIAP}}
DEFAULT lEstNfClass := .F.
DEFAULT lIncRef   := .F. 
DEFAULT aCompFutur := {}
DEFAULT lAgregaOri := .F.
DEFAULT aParamSX1  := {}
DEFAULT nIdxSD1    := 1

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Funcao utilizada para verificar a ultima versao dos fontes      ³
//³ SIGACUS.PRW, SIGACUSA.PRX e SIGACUSB.PRX, aplicados no rpo do   |
//| cliente, assim verificando a necessidade de uma atualizacao     |
//| nestes fontes. NAO REMOVER !!!							        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

If (SF4->F4_ATUATF == "N" .And. SF4->F4_CIAP == "S") .Or. (SF4->F4_ATUATF == "S" .And. SF4->F4_CIAP == "S")
	aCIAP := {{(cAliasSD1)->D1_CODCIAP}}
EndIf                                              
        
cProdRef	:= (cAliasSD1)->D1_COD
lReferencia	:= MatGrdPrrf(@cProdRef,.T.)
		
Do Case
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Implantacao de um pre-documento de entrada                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nOpcao == 1
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza a quantidade nao classificada nos saldos fisicos           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SB2")
	dbSetOrder(1)
	If !(xFilial("SB2")==SB2->B2_FILIAL .And. (cAliasSD1)->D1_COD==SB2->B2_COD .And. (cAliasSD1)->D1_LOCAL==SB2->B2_LOCAL)
		If !MsSeek(xFilial("SB2")+(cAliasSD1)->D1_COD+(cAliasSD1)->D1_LOCAL) .and. !Empty((cAliasSD1)->D1_LOCAL)
			CriaSB2((cAliasSD1)->D1_COD,(cAliasSD1)->D1_LOCAL)
		EndIf
	EndIf
	If !Empty((cAliasSD1)->D1_LOCAL)
		RecLock("SB2",.F.)
		SB2->B2_NAOCLAS += (cAliasSD1)->D1_QUANT
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza a quantidade nao classificada do pedido de Compra          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	MaAvalPC("SC7",6)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Tratamento da gravacao do SD1 na Integridade Referencial            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	SD1->(FkCommit())
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Integracao com PMS                                                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If IntePms()
		If !IsIntegTop(,.T.)
			PmsWriteNF(1,cAliasSD1,.T.)
		Else
			If !Empty(SD1->D1_PEDIDO)
				If !PMSNFSA(SD1->D1_PEDIDO,SD1->D1_ITEMPC)[1] //Não é S.A
					PmsWriteNF(1,cAliasSD1,.T.)
				Endif
			Else
				PmsWriteNF(1,cAliasSD1,.T.)
			Endif
		Endif
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica complementos de integracao                                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Type("bTTSSD1")=="B"
		Eval(bTTSSD1,nOpcao)
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Estorno de um pre-documento de entrada                              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ		
Case nOpcao == 2
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Integracao com PMS                                                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If IntePms()
		If !IsIntegTop(,.T.)
			PmsWriteNF(2,cAliasSD1,.T.)
		Else
			If !Empty(SD1->D1_PEDIDO)
				If !PMSNFSA(SD1->D1_PEDIDO,SD1->D1_ITEMPC)[1] //Não é S.A
					PmsWriteNF(2,cAliasSD1,.T.)
				Endif
			Else
				PmsWriteNF(2,cAliasSD1,.T.)
			Endif
		Endif
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza a quantidade nao classificada do pedido de Compra          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	MaAvalPC("SC7",7)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza a quantidade nao classificada nos saldos fisicos           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SB2")
	dbSetOrder(1)
	If !(xFilial("SB2")==SB2->B2_FILIAL .And. (cAliasSD1)->D1_COD==SB2->B2_COD .And. (cAliasSD1)->D1_LOCAL==SB2->B2_LOCAL)
		If !MsSeek(xFilial("SB2")+(cAliasSD1)->D1_COD+(cAliasSD1)->D1_LOCAL)
			CriaSB2((cAliasSD1)->D1_COD,(cAliasSD1)->D1_LOCAL)
		EndIf
	EndIf
	RecLock("SB2",.F.)
	SB2->B2_NAOCLAS -= (cAliasSD1)->D1_QUANT	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica complementos de integracao                                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Type("bTTSSD1")=="B"
		Eval(bTTSSD1,nOpcao)
	EndIf	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Exclusao fisica de um pre-documento de entrada                      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ		
Case nOpcao == 3
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Integracao com PMS                                                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If IntePms()
		If !IsIntegTop(,.T.)
			PmsWriteNF(3,cAliasSD1,.T.)
		Else
			If !Empty(SD1->D1_PEDIDO)
				If !PMSNFSA(SD1->D1_PEDIDO,SD1->D1_ITEMPC)[1] //Não é S.A
					PmsWriteNF(3,cAliasSD1,.T.)
				Endif
			Else
				PmsWriteNF(3,cAliasSD1,.T.)
			Endif
		Endif
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica complementos de integracao                                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Type("bTTSSD1")=="B"
		Eval(bTTSSD1,nOpcao)
	EndIf	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Implantacao de um documento de entrada                              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Case nOpcao == 4
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Posiciona registros                                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SB1")
	dbSetOrder(1)
	MsSeek(xFilial("SB1")+(cAliasSD1)->D1_COD)

	dbSelectArea("SF4")
	dbSetOrder(1)
	MsSeek(xFilial("SF4")+(cAliasSD1)->D1_TES)	

	dbSelectArea("SA2")
	dbSetOrder(1)
	MsSeek(xFilial("SA2")+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA)


	dbSelectArea("SB2")
	dbSetOrder(1)
	If SF4->F4_ESTOQUE == "S" .And. !(xFilial("SB2")==SB2->B2_FILIAL .And. (cAliasSD1)->D1_COD==SB2->B2_COD .And. (cAliasSD1)->D1_LOCAL==SB2->B2_LOCAL)
		If !MsSeek(xFilial("SB2")+(cAliasSD1)->D1_COD+(cAliasSD1)->D1_LOCAL)
			CriaSB2((cAliasSD1)->D1_COD,(cAliasSD1)->D1_LOCAL)
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Pedido de Compra                                                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Empty((cAliasSD1)->D1_PEDIDO)
		nRecC7 := A103RECC7(xFilial("SC7"),(cAliasSD1)->D1_PEDIDO,(cAliasSD1)->D1_FORNECE,(cAliasSD1)->D1_LOJA,(cAliasSD1)->D1_COD,(cAliasSD1)->D1_ITEMPC,@aParamSX1)
		SC7->(DbGoTo(nRecC7))
		If nRecC7 > 0
			nAtraso := (cAliasSD1)->D1_DTDIGIT-SC7->C7_DATPRF			
			If	MA103CkAIC(SC7->C7_FORNECE,SC7->C7_LOJA,SC7->C7_PRODUTO)	
				(cAliasSD1)->D1_QTDPEDI	:= (cAliasSD1)->D1_QUANT
			Else
				(cAliasSD1)->D1_QTDPEDI	:= Min(SC7->C7_QUANT-SC7->C7_QUJE,(cAliasSD1)->D1_QUANT)
			EndIf
			MaAvalPC("SC7",8)
			
			If A103GcDisp() 
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Baixa o saldo a receber da planilha                                    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				CtaAvalGCT(1,aContratos,SC7->C7_CONTRA,SC7->C7_PLANILH,SC7->C7_ITEMED,SD1->D1_QUANT,,SC7->C7_MEDICAO,SD1->D1_TOTAL)
			EndIf 				
			
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Amarracao Fornecedor/Produto                                           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lIncSA5 .And. (cAliasSD1)->D1_TIPO $ "N|5|6" 
	    cRefGrd := AtuSA5((cAliasSD1)->D1_FORNECE,(cAliasSD1)->D1_LOJA,(cAliasSD1)->D1_COD,lIncRef)
		If !Empty(SB1->B1_GRUPO)
			dbSelectArea("SBM")
			dbSetOrder( 1 )
			If MsSeek(xFilial("SBM")+SB1->B1_GRUPO)
				dbSelectArea("SAD")
				dbSetOrder(1)
				If !MsSeek(xFilial("SAD")+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA+SB1->B1_GRUPO,.F.)
					RecLock("SAD",.T.)
					SAD->AD_FILIAL	:= xFilial("SAD")
					SAD->AD_FORNECE := (cAliasSD1)->D1_FORNECE
					SAD->AD_LOJA    := (cAliasSD1)->D1_LOJA
					SAD->AD_NOMEFOR := SA2->A2_NOME
					SAD->AD_GRUPO   := SB1->B1_GRUPO
					SAD->AD_NOMGRUP := SBM->BM_DESC
					MsUnlock()
				EndIf
			EndIf
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Analise do CQ                                                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ	
	If SF4->F4_ESTOQUE == "S"
		lEnviaCQ := .F.
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³                  CONDICOES DE ENVIO AO CQ                              ³
		//³                                                                        ³
		//³1) Documentos de entrada de complemento de preco, despesa de importacao,³
		//³   conhecimento de frete e entrada serao enviados ao CQ se o almoxarifa-³
		//³   do de destino for o MV_CQ                                            ³
		//³2) Documentos de complemento serao enviados ao CQ se o documento de ori-³
		//³   gem foi enviado para o CQ.                                           ³
		//³3) Para o Controle de CQ Microsiga os documentos de entrada tipo Normal ³
		//³   serao enviados caso:                                                 ³
		//³   a)A nota do fornecedor ( A5_NOTA ) for inferior a nota minima do pro-³
		//³   duto ( B1_NOTAMIN ).                                                 ³
		//³   b)O documento de entrada for escolhido pelo criterio de SKIP-LOTE    ³
		//³4) Produtos com controle de CQ pelo Quality                             ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			
		Do Case
		Case (cAliasSD1)->D1_TIPO == "C" .And. (cAliasSD1)->D1_ORIGLAN $"FR,DP" .And. alltrim((cAliasSD1)->D1_LOCAL) == SuperGetMV("MV_CQ")
			lEnviaCQ := .T.
		Case (cAliasSD1)->D1_TIPO $ "CIP" .And.!Empty((cAliasSD1)->D1_ITEMORI)
			aAreaSD1 := (cAliasSD1)->(GetArea())
			dbSelectArea("SD1")
			dbSetOrder(1)
			If MsSeek(xFilial("SD1")+(cAliasSD1)->D1_NFORI+(cAliasSD1)->D1_SERIORI+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA+(cAliasSD1)->D1_COD+(cAliasSD1)->D1_ITEMORI,.F.)
				If alltrim((cAliasSD1)->D1_LOCAL) == alltrim(SuperGetMV("MV_CQ"))
					lEnviaCQ := .T.
				EndIf
			EndIf
			RestArea(aAreaSD1)
		Case (cAliasSD1)->D1_TIPO == "N" .And. !((cAliasSD1)->D1_QUANT > 0)	// Nota Normal com quantidade zero nao gera movimentacao de CQ (SD7) e nao deve direcionar para o armazem CQ caso contrario o custo fica perdido no CQ nao sendo possivel liberar
			lEnviaCQ := .F.
		Case !(cAliasSD1)->D1_TIPO $ "CIP56" .And. alltrim((cAliasSD1)->D1_LOCAL) == alltrim(SuperGetMV("MV_CQ"))
			lEnviaCQ := .T.
		Case (cAliasSD1)->D1_TIPO == "N" .And. RetFldProd(SB1->B1_COD,"B1_TIPOCQ") $ " ,M"
			If !Empty((cAliasSD1)->D1_CONHEC)
				dbSelectArea("SW7")
				dbSetOrder(1)
				If _oQrySW7 == nil 
					cQuery := "SELECT W7_FABR, W7_FABLOJ FROM "
					cQuery += RetSqlName("SW7")
					cQuery += " WHERE W7_FILIAL = ?"
					cQuery += " AND W7_HAWB     = ?"
					cQuery += " AND W7_COD_I    = ?"
					cQuery += " AND W7_FORN     = ?"
					cQuery += " AND W7_POSICAO  = ?"
					cQuery += " AND D_E_L_E_T_  = ?"
					If __lVLib
						_oQrySW7 := FwExecStatement():New(cQuery)
					Else
						_oQrySW7 := FWPreparedStatement():New(cQuery)
					EndIf
				EndIf
				_oQrySW7:SetString(1, xFilial('SW7'))
				_oQrySW7:SetString(2, PadR(Alltrim((cAliasSD1)->D1_CONHEC),TamSX3("W7_HAWB")[1]))
				_oQrySW7:SetString(3, (cAliasSD1)->D1_COD)
				_oQrySW7:SetString(4, SF1->F1_FORNECE)
				_oQrySW7:SetString(5, (cAliasSD1)->D1_ITEM)
				_oQrySW7:SetString(6, Space(1))

				If __lVLib
					_oQrySW7:OpenAlias('_QrySW7')
				Else
					cQuery := _oQrySW7:GetFixQuery()
					MpSysOpenQuery(cQuery,'_QrySW7')
				EndIf
				If _QrySW7->(!Eof())
					cFabric  := _QrySW7->W7_FABR
					cFabLoja := _QrySW7->W7_FABLOJ
				EndIf 
				_QrySW7->(dbCloseArea())
			EndIf			
			dbSelectArea("SA5")
			dbSetOrder(1)
			If !Empty(cFabric) .And. !Empty(cFabLoja)
				lAchou := MsSeek(xFilial("SA5")+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA+(cAliasSD1)->D1_COD+cFabric+cFabLoja,.F.)
			Else
				lAchou := MsSeek(xFilial("SA5")+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA+(cAliasSD1)->D1_COD,.F.)
			EndIf
			If !lAchou .And. lReferencia
				dbSelectArea("SA5")
				dbSetOrder(9)
				If !Empty(cFabric) .And. !Empty(cFabLoja)
					lAchou := MsSeek(xFilial("SA5")+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA+cProdRef+cFabric+cFabLoja,.F.)
				Else
					lAchou := MsSeek(xFilial("SA5")+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA+cProdRef,.F.)
				EndIf
			Endif
			If lAchou
				If SA5->A5_NOTA<SB1->B1_NOTAMIN .Or. SA5->A5_SKIPLOT>0
					If  SA5->A5_NOTA<SB1->B1_NOTAMIN .Or.  Mod(SA5->A5_ENTREGA,SA5->A5_SKIPLOT)==0
						lEnviaCQ := .T.
					EndIf
					If SA5->A5_SKIPLOT > 0
						RecLock("SA5",.F.)
						SA5->A5_ENTREGA += 1
						MsUnlock()
					EndIf
				EndIf
			EndIf
		Case RetFldProd(SB1->B1_COD,"B1_TIPOCQ") == "Q"
			DbSelectArea("SA5")
			DbSetOrder(1)
			lAchou := MsSeek(xFilial("SA5")+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA+(cAliasSD1)->D1_COD,.F.)
			If !lAchou .And. lReferencia
				DbSelectArea("SA5")
				DbSetOrder(9)
				lAchou := MsSeek(xFilial("SA5")+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA+cProdRef,.F.)
			Endif
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Quando houver integracao com o Quality as NFs referentes a Beneficia-  ³
			//³ mento e Devolucao poderao ser Inspecionadas conforme parametrizacao.   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If QieTipoNF(SD1->D1_TIPO,SD1->D1_TES)
				lEnviaCQ := .F.
			Else
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Ponto de Entrada para critica do Envio do Material para  ³
				//³ Inspecao no Quality, para Inspecao no Quality o mesmo de ³
				//³ vera estar igual a .T.									 ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If ExistBlock("ENVCQQUA")
					lEnviaCQ := ExecBlock("ENVCQQUA",.F.,.F.)										
				Else
					lEnviaCQ := .T.
				EndIf
			EndIf
		EndCase
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Ponto de Entrada para critica do Envio do Material para  ³
		//³ C.Q.                                                     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ExistBlock("ENVCQMAT")
			lEnvCQPE := ExecBlock("ENVCQMAT",.F.,.F.,{lEnviaCQ})										
			If ValType(lEnvCQPE) == "L"
				lEnviaCQ := lEnvCQPE
			Endif
		EndIf
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualizacao do CQ                                                      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lEnviaCQ
			If allTRIM((cAliasSD1)->D1_LOCAL)  <> alltrim(SuperGetMV("MV_CQ"))
				(cAliasSD1)->D1_LOCAL := SuperGetMV("MV_CQ")
			EndIf
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza Poder de Terceiro                                             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SF4->F4_PODER3<>"N"
		aCustoEnt := MaAtuSB6("SD1",1)
		(cAliasSD1)->D1_CUSTO	:= aCustoEnt[1]
		(cAliasSD1)->D1_CUSTO2	:= aCustoEnt[2]
		(cAliasSD1)->D1_CUSTO3	:= aCustoEnt[3]
		(cAliasSD1)->D1_CUSTO4	:= aCustoEnt[4]
		(cAliasSD1)->D1_CUSTO5	:= aCustoEnt[5]	
	EndIf

	// Compra com entrega futura.
	If lDHQInDic .And. lMt103Com
		// F4_EFUTUR -> 1-Simples faturamento de compra futura / 2-Remessa de compra futura.
		If SF4->F4_EFUTUR = "1" .And. (cAliasSD1)->D1_QUANT > 0 .And. (cAliasSD1)->D1_VUNIT > 0
			A103FutFat(.F.)
		ElseIf SF4->F4_EFUTUR = "2" .And. Len(aCompFutur) > 0  // Nota de remessa de compra futura.
			A103FutRem(.F., aCompFutur)
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ CIAP                                                                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aAreaSA2 := SA2->(GetArea())
	If SA2->(MsSeek(xFilial("SA2")+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA))
		cSimpNac := Iif(cPaisLoc == "BRA",SA2->A2_SIMPNAC,"")
	Endif
	RestArea(aAreaSA2)

	//Aciona a classe de tributos genéricos do compras
	if oTribGen == Nil .And. FindClass('backoffice.com.generictaxes.generictaxes')
		oTribGen := backoffice.com.generictaxes.generictaxes():New()
	endif

	if oTribGen != Nil  .And. oTribGen:lConfiguratorenabled 
		cCrIcmTrib :=  oTribGen:isIcmsCreditedForCost((cAliasSD1)->D1_IDTRIB) //Credita ou não o ICMS para cálculo do custo
		cICMCompl  :=  oTribGen:isIcmsDifalFromCFG(nIdxSD1) //Complemento de ICMS (Difal)
	else 
		cCrIcmTrib := SF4->F4_CREDICM
		cICMCompl  := SF4->F4_COMPL 
	endif
	
	If ((SF4->F4_CIAP=="S" .Or. lCTeCiap) .And. ((((cAliasSD1)->D1_VALICM  > 0 .Or. cCrIcmTrib == "S") .Or. ((cAliasSD1)->D1_ICMNDES > 0) .Or. ;	
	(cICMCompl == "S" .And. cSimpNac == "1"))))
	
		If Type('l103Auto')=='L'
			If l103Auto
				nF1Origem  := aScan(aAutoCab, {|x| x[1] == "F1_ORIGEM"}) 
		        nFilCiap   := aScan(aAutoItens[1], {|x| x[1] == "FIL_CIAP"})
		        nCodCiap   := aScan(aAutoItens[1], {|x| x[1] == "COD_CIAP"})
		    EndIf
		EndIf

		If Len(aRecSF1Ori) == 0 
			aF1Area := SF1->(GetArea())
			aF8Area := SF8->(GetArea()) 

			SF1->(DbSetOrder(1))
			SF8->(DbSetOrder(3))
			If SF8->(DbSeek(xFilial("SF8") + (cAliasSD1)->D1_DOC + (cAliasSD1)->D1_SERIE + (cAliasSD1)->D1_FORNECE + (cAliasSD1)->D1_LOJA ))
				If SF1->(DbSeek(xFilial("SF1") + SF8->F8_NFORIG + SF8->F8_SERORIG + SF8->F8_FORNECE + SF8->F8_LOJA ))
					aAdd(aRecSF1Ori,SF1->(Recno()))    
				Endif
			Endif

			RestArea(aF1Area)
			RestArea(aF8Area)
		Endif

		(cAliasSD1)->D1_CODCIAP := A103CIAP(1, cAliasSD1, , "MATA103", nF1Origem, nFilCiap, nCodCiap, aRecSF1Ori)

	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Amarracao Fornecedor/Produto                                           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lAtuSA5
		dbSelectArea("SA5")
		If !( xFilial("SA5") == SA5->A5_FILIAL .And.;
				(cAliasSD1)->D1_FORNECE == SA5->A5_FORNECE .And.;
				(cAliasSD1)->D1_LOJA == SA5->A5_LOJA .And.;
				(cAliasSD1)->D1_COD == SA5->A5_PRODUTO )
			dbSetOrder(1)				
			lAchou := MsSeek(xFilial("SA5")+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA+(cAliasSD1)->D1_COD,.F.)
			If !lAchou .And. lReferencia
				dbSelectArea("SA5")
				dbSetOrder(9)
				lAchou := MsSeek(xFilial("SA5")+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA+cProdRef,.F.)
			Endif
		EndIf
		If lAchou    
			lIncSA5 := .T.
			RecLock("SA5",.F.)
			For nX := 1 To 12
				If ( FieldGet(FieldPos("A5_DTCOM"+StrZero(nX,2))) == (cAliasSD1)->D1_EMISSAO .And.;
						FieldGet(FieldPos("A5_PRECO" +StrZero(nX,2))) == IIF(nMcusto=="1",(cAliasSD1)->D1_CUSTO/(cAliasSD1)->D1_QUANT,(cAliasSD1)->(FieldGet(FieldPos("D1_CUSTO"+nMcusto)))/(cAliasSD1)->D1_QUANT) .And.;
						FieldGet(FieldPos("A5_QUANT" +StrZero(nX,2))) == (cAliasSD1)->D1_QUANT .And.;
						FieldGet(FieldPos("A5_COND"  +StrZero(nX,2))) == SF1->F1_COND )
					lIncSA5 := .F.
					nX := 13
				EndIf
			Next nX
			If lIncSA5
				If ( SA5->A5_PRECO12 <> 0 )
					For nX := 1 To 11					
						FieldPut(FieldPos("A5_DTCOM"+StrZero(nX,2)),FieldGet(FieldPos("A5_DTCOM"+StrZero(nX+1,2))))
						FieldPut(FieldPos("A5_PRECO"+StrZero(nX,2)),FieldGet(FieldPos("A5_PRECO"+StrZero(nX+1,2))))
						FieldPut(FieldPos("A5_QUANT"+StrZero(nX,2)),FieldGet(FieldPos("A5_QUANT"+StrZero(nX+1,2))))
						FieldPut(FieldPos("A5_COND" +StrZero(nX,2)),FieldGet(FieldPos("A5_COND"+StrZero(nX+1,2))))
					Next nX
					SA5->A5_PRECO12 := 0
				EndIf
				For nX := 1 To 12
					If ( FieldGet(FieldPos("A5_PRECO"+StrZero(nX,2))) == 0 )
						FieldPut(FieldPos("A5_DTCOM"+StrZero(nX,2)),(cAliasSD1)->D1_EMISSAO)
						FieldPut(FieldPos("A5_PRECO"+StrZero(nX,2)),IIF(nMcusto=="1",(cAliasSD1)->D1_CUSTO/(cAliasSD1)->D1_QUANT,(cAliasSD1)->(FieldGet(FieldPos("D1_CUSTO"+nMcusto)))/(cAliasSD1)->D1_QUANT))
						FieldPut(FieldPos("A5_QUANT"+StrZero(nX,2)),(cAliasSD1)->D1_QUANT)
						FieldPut(FieldPos("A5_COND"+StrZero(nX,2)),SF1->F1_COND)
						nX := 13
					EndIf
				Next nX
			EndIf
			MsUnlock()
		EndIf
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza Produto                                                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If (cAliasSD1)->D1_TIPO $ "N|5|6" .And. SF4->F4_UPRC$" S"
		If dDataBase >= RetFldProd(SB1->B1_COD,"B1_UCOM")
			If RetArqProd(SB1->B1_COD)
				RecLock("SB1",.F.)
				SB1->B1_UCOM := IIf(lDataUcom,(cAliasSD1)->D1_DTDIGIT,(cAliasSD1)->D1_EMISSAO)
				
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ PE: MT103UPC - Permite customizar gravacao do ultimo preco de compra   |
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If ExistBlock("MT103UPC")
					nPcoCompra := ExecBlock("MT103UPC",.F.,.F.)
					If ValType(nPcoCompra)=="N"    
						SB1->B1_UPRC :=nPcoCompra
					endif
				Else
					SB1->B1_UPRC := IIf(lPrecoDes,(cAliasSD1)->D1_VUNIT-((cAliasSD1)->D1_VALDESC/(cAliasSD1)->D1_QUANT),(cAliasSD1)->D1_VUNIT)
				EndIf
			Else
				RecLock("SBZ",.F.)
				SBZ->BZ_UCOM := IIf(lDataUcom,(cAliasSD1)->D1_DTDIGIT,(cAliasSD1)->D1_EMISSAO)
				
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ PE: MT103UPC - Permite customizar gravacao do ultimo preco de compra   |
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If ExistBlock("MT103UPC")
					nPcoCompra := ExecBlock("MT103UPC",.F.,.F.)
					If ValType(nPcoCompra)=="N"    
						SBZ->BZ_UPRC :=nPcoCompra
					endif
				Else
					SBZ->BZ_UPRC := IIf(lPrecoDes,(cAliasSD1)->D1_VUNIT-((cAliasSD1)->D1_VALDESC/(cAliasSD1)->D1_QUANT),(cAliasSD1)->D1_VUNIT)
				EndIf              
				
				dbSelectArea("SB1")
			Endif	
		EndIf
	Else                    
		If (cAliasSD1)->D1_TIPO == "C" .And. SF4->F4_UPRC$" S"	
 			If dDataBase >= RetFldProd(SB1->B1_COD,"B1_UCOM")
 				aAreaSF1  := SF1->(GetArea()) 
				aAreaSD1  := SD1->(GetArea()) 
		   		nVlrCompl := (cAliasSD1)->D1_VUNIT 
		   		cDoc	  := (cAliasSD1)->D1_NFORI 
		   		cSerie	  := (cAliasSD1)->D1_SERIORI
		   		cFornec	  := (cAliasSD1)->D1_FORNECE
		   		cLoja	  := (cAliasSD1)->D1_LOJA
		   		cCod	  := (cAliasSD1)->D1_COD 
		   		cItem	  := AllTrim((cAliasSD1)->D1_ITEMORI)
		   		If !Empty(cItem)
					dbSelectArea("SD1")
					dbSetOrder(1)
					If MsSeek(xFilial("SD1")+cDoc+cSerie+cFornec+cLoja+cCod+cItem)	
						nQtdOriFr := (cAliasSD1)->D1_QUANT
						nValOriFr := (cAliasSD1)->D1_VUNIT
						nVlDescFr := (cAliasSD1)->D1_VALDESC
						
						If nQtdOriFr > 0 .And. nValOriFr > 0
							If RetArqProd(SB1->B1_COD)
								RecLock("SB1",.F.)
								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³ PE: MT103UPC - Permite customizar gravacao do ultimo preco de compra   |
								//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								If ExistBlock("MT103UPC")
									nPcoCompra := ExecBlock("MT103UPC",.F.,.F.)
									If ValType(nPcoCompra)=="N"    
										SB1->B1_UPRC :=nPcoCompra
									endif
								Else
									SB1->B1_UPRC := IIf(lPrecoDes,nValOriFr-(nVlDescFr/nQtdOriFr)+ (nVlrCompl/nQtdOriFr) ,nVlrCompl/nQtdOriFr+nValOriFr)	    
								EndIf
							Else
								RecLock("SBZ",.F.)									
								//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
								//³ PE: MT103UPC - Permite customizar gravacao do ultimo preco de compra   |
				   				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
								If ExistBlock("MT103UPC")
									nPcoCompra := ExecBlock("MT103UPC",.F.,.F.,)
									If ValType(nPcoCompra)=="N"    
										SBZ->BZ_UPRC :=nPcoCompra
									endif
								Else
									SBZ->BZ_UPRC := IIf(lPrecoDes,nValOriFr-(nVlDescFr/nQtdOriFr)+ (nVlrCompl/nQtdOriFr) ,nVlrCompl/nQtdOriFr+nValOriFr)	    
								EndIf
							EndIf 
						EndIf
					EndIf             
				ElseIf AllTrim((cAliasSD1)->D1_ORIGLAN) == "FR"	// Nota gerada via MATA116
					For nX := 1 to Len(aRecSF1Ori)
						dbSelectArea("SF1")
						MsGoto(aRecSF1Ori[nX])
						dbSelectArea("SD1")
						dbSetOrder(1)
						If MsSeek(xFilial("SD1") + SF1->(F1_DOC + F1_SERIE + F1_FORNECE + F1_LOJA) + cCod)
							While SD1->(!Eof()) .And. SD1->(D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA) == SF1->(F1_DOC + F1_SERIE + F1_FORNECE + F1_LOJA) .And. SD1->D1_COD == cCod
								nQtdOriFr := SD1->D1_QUANT
								nValOriFr := SD1->D1_VUNIT
								nVlDescFr := SD1->D1_VALDESC
								
								If nQtdOriFr > 0 .And. nValOriFr > 0
									If RetArqProd(SB1->B1_COD)
										RecLock("SB1",.F.)
										//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
										//³ PE: MT103UPC - Permite customizar gravacao do ultimo preco de compra   |
						   				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
										If lPe103Upc
											nPcoCompra := ExecBlock("MT103UPC",.F.,.F.)
											If ValType(nPcoCompra)=="N"    
												SB1->B1_UPRC :=nPcoCompra
											endif
										Else
											SB1->B1_UPRC := IIf(lPrecoDes,nValOriFr-(nVlDescFr/nQtdOriFr)+ (nVlrCompl/nQtdOriFr) ,nVlrCompl/nQtdOriFr+nValOriFr)	    
										EndIf
									Else
										RecLock("SBZ",.F.)
											
										//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
										//³ PE: MT103UPC - Permite customizar gravacao do ultimo preco de compra   |
						   				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
										If lPe103Upc
											nPcoCompra := ExecBlock("MT103UPC",.F.,.F.,)
											If ValType(nPcoCompra)=="N"    
												SBZ->BZ_UPRC :=nPcoCompra
											endif
										Else
											SBZ->BZ_UPRC := IIf(lPrecoDes,nValOriFr-(nVlDescFr/nQtdOriFr)+ (nVlrCompl/nQtdOriFr) ,nVlrCompl/nQtdOriFr+nValOriFr)	    
										EndIf
									EndIf 
								EndIf
				
								SD1->(DbSkip())
							End
						EndIf
					Next nX						
				EndIf
				      
				RestArea(aAreaSF1)
				RestArea(aAreaSD1)
			EndIf
		EndIf					
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza saldo fisico e financeiro                                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SF4->F4_ESTOQUE=="S"
	
		If Type("l103CteSub") == 'L' .And. l103CteSub .And. ((cAliasSD1)->D1_TIPO == 'C' .Or. ((cAliasSD1)->D1_TIPO == 'N' .And. AllTrim(cEspDoc) $ "CTE|CTEOS"))
			aAreaSF1  := SF1->(GetArea()) 
			aAreaSD1  := SD1->(GetArea()) 
			cDtCTE	  := SD1->D1_DTDIGIT
			SF8->(dbSetOrder(3))
			SF8->(dbSeek(xFilial("SF8")+(cAliasSD1)->(D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA)))			
			WHILE SF8->(!EOF()) .And. SF8->(F8_FILIAL+F8_NFDIFRE+F8_SEDIFRE+F8_TRANSP+F8_LOJTRAN) = ;
							   xFilial("SF8")+(cAliasSD1)->(D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA)
				If SF8->F8_TIPO == 'S'
					SD1->(dbSetOrder(1)) 
					SD1->(DBSeek(xFilial('SD1')+SF8->(F8_NFORIG+F8_SERORIG+F8_FORNECE+F8_LOJA)+(cAliasSD1)->(D1_COD+D1_ITEM)))
					RecLock("SD3",.T.)
					SD3->D3_FILIAL	:= xFilial("SD3") 
					SD3->D3_COD		:= SD1->D1_COD
					SD3->D3_QUANT	:= SD1->D1_QUANT
					SD3->D3_TM		:= "999"
					SD3->D3_OP		:= SD1->D1_OP
					SD3->D3_LOCAL	:= SD1->D1_LOCAL
					SD3->D3_DOC		:= SD1->D1_DOC
					SD3->D3_EMISSAO	:= cDtCTE
					SD3->D3_NUMSEQ	:= Proxnum() //SD1->D1_NUMSEQ
					SD3->D3_UM		:= SD1->D1_UM
					SD3->D3_GRUPO	:= SD1->D1_GRUPO
					SD3->D3_TIPO	:= SD1->D1_TP
					SD3->D3_SEGUM	:= SD1->D1_SEGUM
					SD3->D3_CONTA	:= SD1->D1_CONTA
					SD3->D3_CF		:= "DEB"
					SD3->D3_QTSEGUM	:= SD1->D1_QTSEGUM
					SD3->D3_USUARIO	:= CUSERNAME
					SD3->D3_CUSTO1	:= SD1->D1_CUSTO 
					SD3->D3_CUSTO2	:= SD1->D1_CUSTO2  
					SD3->D3_CUSTO3	:= SD1->D1_CUSTO3 
					SD3->D3_CUSTO4	:= SD1->D1_CUSTO4 
					SD3->D3_CUSTO5	:= SD1->D1_CUSTO5 
					SD3->D3_NUMLOTE	:= SD1->D1_NUMLOTE
					SD3->D3_LOTECTL	:= SD1->D1_LOTECTL
					SD3->D3_DTVALID	:= SD1->D1_DTVALID
					SD3->D3_POTENCI := SD1->D1_POTENCI
					SD3->D3_CHAVEF1	:= SD1->(D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA)
					dbSelectArea("SB2")
					If SD1->D1_DTDIGIT <= dMVULMES
						B2AtuComD1(-1,Nil,Nil,Nil,lAgregaOri)	
					Else
						B2AtuComD3({SD3->D3_CUSTO1,SD3->D3_CUSTO2,SD3->D3_CUSTO3,SD3->D3_CUSTO4,SD3->D3_CUSTO5})
					EndIf				
					MsUnlock()	
				EndIf
				SF8->(DBSKIP())
			EndDo
			RestArea(aAreaSF1)
			RestArea(aAreaSD1)
		EndIf
		B2AtuComD1(Nil,Nil,Nil,Nil,lAgregaOri)
		If lEnviaCQ
			cDistAut	:= SuperGetMV("MV_DISTAUT")
			If Localiza((cAliasSD1)->D1_COD) .And. !Empty(cDistAut)
				A100Distri((cAliasSD1)->D1_COD,(cAliasSD1)->D1_LOCAL,(cAliasSD1)->D1_NUMSEQ,(cAliasSD1)->D1_DOC, (cAliasSD1)->D1_SERIE, (cAliasSD1)->D1_FORNECE,(cAliasSD1)->D1_LOJA,Nil,Nil,(cAliasSD1)->D1_QUANT,(cAliasSD1)->D1_LOTECTL,(cAliasSD1)->D1_NUMLOTE)
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Atualizacao do CQ - Tipo 0 (Zero) - Saldo Original                     ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !(cAliasSD1)->D1_TIPO$"CIP56" .Or. (lComplQtd .And. cTpCompl == "2")
				If fGeraCQ0("SD1",(cAliasSD1)->D1_COD,"CP",cLocOrig)
					If (cAliasSD1)->D1_NUMCQ <> SD7->D7_NUMERO
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Esta verificacao eh efetuada para otimizar a performance, evitando     ³
						//³ o "flush" em ambiente TOPCONNECT                                       ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If !__TTSINUSE
							RecLock("SD1")
						EndIf
						(cAliasSD1)->D1_NUMCQ := SD7->D7_NUMERO
					EndIf
					If RetFldProd(SB1->B1_COD,"B1_TIPOCQ") == "Q" .or. lInspec
						If Rastro(SB1->B1_COD)
							dbSelectArea("SD5")
							dbSetOrder(3)
							If MsSeek(xFilial("SD5")+(cAliasSD1)->D1_NUMSEQ+(cAliasSD1)->D1_COD+(cAliasSD1)->D1_LOCAL+(cAliasSD1)->D1_LOTECTL,.F.)
								aLote := {SD5->D5_LOTECTL,; //Numero do Lote
									SD5->D5_NUMLOTE}    //Sequencia do Sub-Lote
							Else
								aLote := {"",""}
							EndIf						
						EndIf
						aEnvCele := {(cAliasSD1)->D1_DOC,; //Numero da Nota Fiscal
							(cAliasSD1)->D1_SERIE,;        //Serie da Nota Fiscal
							(cAliasSD1)->D1_TIPO,;         //Tipo da Nota Fiscal
							(cAliasSD1)->D1_EMISSAO,;      //Data de Emissao da Nota Fiscal
							(cAliasSD1)->D1_DTDIGIT,;      //Data de Entrada da Nota Fiscal
							iif (lTpNFQie,SF1->F1_ESPECIE,"NF"),;  //Tipo de Documento 
							(cAliasSD1)->D1_ITEM,;         //Item da Nota Fiscal
							" ",;                  		    //Numero do Remito (Localizacoes)
							(cAliasSD1)->D1_PEDIDO,;       //Numero do Pedido de Compra
							(cAliasSD1)->D1_ITEMPC,;       //Item do Pedido de Compra
							(cAliasSD1)->D1_FORNECE,;      //Codigo Fornecedor/Cliente
							(cAliasSD1)->D1_LOJA,;         //Loja Fornecedor/Cliente
							(cAliasSD1)->D1_LOTEFOR,;      //Numero do Lote do Fornecedor
							Space(6),;         			    //Codigo do Solicitante
							(cAliasSD1)->D1_COD,;          //Codigo do Produto
							(cAliasSD1)->D1_LOCAL,;        //Local Origem
							aLote[1],;             			//Numero do Lote
							aLote[2],;             			//Sequencia do Sub-Lote
							(cAliasSD1)->D1_NUMSEQ,;       //Numero Sequencial
							SD7->D7_NUMERO,;       		    //Numero do CQ
							(cAliasSD1)->D1_QUANT,;        //Quantidade
							(cAliasSD1)->D1_TOTAL,;        //Preco
							nAtraso,;              			//Dias de atraso
							(cAliasSD1)->D1_TES,;          //TES
							AllTrim(FunName()),;   			//Origem						
							" ",;                  			//Origem TXT	
							0}                     			//Quantidade do Lote Original									
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Realiza a integracao Materiais x Inspecao de Entradas		           ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						aRetQIE := QAtuMatQie(aEnvCele,1,,IIf(Type('l103Auto') <> 'U', l103Auto, .F.) )
						If aRetQIE[1] $ "C,L"
							//Informa variael WMS para controle de skip lote
							If IntWMS(SD7->D7_PRODUTO)
								WmsSkipCQ(.T.)
							EndIf
							
							lIntWMSAtu 	:= ( IntWMS((cAliasSD1)->D1_COD) .And. !lWmsNew )
							//--Se for WMSAtual e não usar o MV_DISTAUT, aciona rotina 
							//--para endereçamento em armazem de CQ durante processo de skip lote
							If lIntWMSAtu .And. Empty(cDistAut)
								A100Distri((cAliasSD1)->D1_COD,;
								(cAliasSD1)->D1_LOCAL,;
								(cAliasSD1)->D1_NUMSEQ,;
								(cAliasSD1)->D1_DOC,;
								(cAliasSD1)->D1_SERIE,;
								(cAliasSD1)->D1_FORNECE,;
								(cAliasSD1)->D1_LOJA,;
								(cAliasSD1)->D1_ENDER,;
								Nil,;
								(cAliasSD1)->D1_QUANT,;
								(cAliasSD1)->D1_LOTECTL,;
								(cAliasSD1)->D1_NUMLOTE)
							EndIf

							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³ Realiza automaticamente a libercao do CQ qdo nao ha inspecao no Quality³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							aMov := {}
							aadd(aMov, {})
							aadd(aMov[Len(aMov)], 1)                 //-- Tipo da Movimentação (1=Libera/2=Rejeita)
							aadd(aMov[Len(aMov)], SD7->D7_SALDO)     //-- Quantidade a ser Movimentada
							aadd(aMov[Len(aMov)], SD7->D7_LOCDEST)   //-- Local de Destino da Movimentacao
							aadd(aMov[Len(aMov)], SD7->D7_DATA)      //-- Data da Movimentacao
							aadd(aMov[Len(aMov)], "")                //-- X=Estornado
							aadd(aMov[Len(aMov)], "")                //-- Motivo da Rejeicao
							aadd(aMov[Len(aMov)], aRetQIE[2])        //-- Observacao
							aadd(aMov[Len(aMov)], SD7->D7_SALDO2)   //-- Quantidade na 2a Unidade de Medida
							If IntWMS(SD7->D7_PRODUTO)

								If !lWmsNew .And. !Empty(cDistAut)
									//-- Calcula o Tamanho dos Segmentos contendo Local/Localizacao/Num serie
									//-- e o numero de ocorrencias destes segmentos cadastrados no SX6.
									nTamLocal  := TamSX3('DB_LOCAL')[1]
									nTamLocFis := TamSX3('DB_LOCALIZ')[1]
									nTamNumSer := TamSX3('DB_NUMSERI')[1]
									nTamCPOs   := (nTamLocal+nTamLocFis+nTamNumSer)
									nTamContX6 := Len(SX6->X6_CONTEUD)
									nForTimes  := Max(Int(nTamContX6/nTamCPOs)*nTamCPOs,1)

									//-- Formato do Array aDistAut:
									//-- [n, 1] = Local
									//-- [n, 2] = LocalizaÆo Fisica
									//-- [n, 3] = Numero de Srie
									For nX := 1 to nForTimes Step nTamCPOs
										aAdd(aDistAut, {})
										aAdd(aDistAut[Len(aDistAut)], SubStr(cDistAut, nX, nTamLocal))
										aAdd(aDistAut[Len(aDistAut)], SubStr(cDistAut, nX+nTamLocal, nTamLocFis))
										aAdd(aDistAut[Len(aDistAut)], SubStr(cDistAut, nX+nTamLocal+nTamLocFis, nTamNumSer ))
									Next nX

									//-- Encontra a localizacao e num serie de acordo com o movimento de CQ
									If (nPos:=aScan(aDistAut, {|x| x[1] == SD7->D7_LOCAL})) > 0
										cEndAut  	:= Padr( aDistAut[nPos, 2], TamSX3('DB_LOCALIZ')[1] )
										cNumSerie	:= Padr( aDistAut[nPos, 3], TamSX3('DB_NUMSERI')[1] )
									EndIf
								EndIf

								aadd(aMov[Len(aMov)],IIF(!lWmsNew .And. !Empty(cEndAut), cEndAut, (cAliasSD1)->D1_ENDER)) 	// Endereço
								aadd(aMov[Len(aMov)],IIF(!lWmsNew .And. !Empty(cNumSerie), cNumSerie, SD7->D7_NUMSERI))	// Numero Série
								aadd(aMov[Len(aMov)],(cAliasSD1)->D1_SERVIC)// Serviço WMS
							EndIf							

							fGravaCQ(SD7->D7_PRODUTO, SD7->D7_NUMERO, .F.,aMov,PegaCMD1(),,,,(cAliasSD1)->D1_QUANT)	
						EndIf		
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ Execblock QIEA210T apos gravacao da movim. do CQ Celerina              ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If ExistBlock("QIEA210T")
							ExecBlock("QIEA210T",.F.,.F.,{"EST"})
						EndIf
					EndIf
				EndIf
			Else
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Atualizacao do CQ - Tipo 8 (Oito) - Documentos de Complemento          ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If fGeraCQ8((cAliasSD1)->D1_DOC,(cAliasSD1)->D1_SERIE,(cAliasSD1)->D1_FORNECE,(cAliasSD1)->D1_LOJA,(cAliasSD1)->D1_COD,(cAliasSD1)->D1_ITEM,"CP",(cAliasSD1)->D1_LOCAL,aRecSF1Ori)
					If (cAliasSD1)->D1_NUMCQ <> SD7->D7_NUMERO
						(cAliasSD1)->D1_NUMCQ := SD7->D7_NUMERO
					EndIf
				EndIf
			EndIf
		EndIf		
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza requisicao direta a Ordem de Producao                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SF4->F4_ESTOQUE == "S" .And. !Empty((cAliasSD1)->D1_OP) .And. !lEnviaCQ
		If Localiza((cAliasSD1)->D1_COD)
			dbSelectArea("SBE")
			dbSetOrder(1)
			SBE->(MsSeek(xFilial("SBE")+(cAliasSD1)->D1_LOCAL))
			cLocaliz := SBE->BE_LOCALIZ
			
			dbSelectArea("SDC")
			dbSetOrder(2)
			If MsSeek(xFilial("SDC")+(cAliasSD1)->D1_COD+(cAliasSD1)->D1_LOCAL+(cAliasSD1)->D1_OP)
				While !Eof() .And. xFilial("SDC")+(cAliasSD1)->D1_COD+(cAliasSD1)->D1_LOCAL+(cAliasSD1)->D1_OP == xFilial("SDC")+SDC->DC_PRODUTO+SDC->DC_LOCAL+SDC->DC_OP
					If QtdComp(SDC->DC_QUANT) > QtdComp(0)
						lRetEnd  := A100Distri((cAliasSD1)->D1_COD,(cAliasSD1)->D1_LOCAL,(cAliasSD1)->D1_NUMSEQ,(cAliasSD1)->D1_DOC,(cAliasSD1)->D1_SERIE,(cAliasSD1)->D1_FORNECE,(cAliasSD1)->D1_LOJA,SDC->DC_LOCALIZ,Nil,(cAliasSD1)->D1_QUANT,(cAliasSD1)->D1_LOTECTL,(cAliasSD1)->D1_NUMLOTE)
						lTemSDC  := .T.
						cLocaliz := SDC->DC_LOCALIZ
						Exit
					Endif	
					dbSelectArea("SDC")
					dbSkip()
				EndDo
			Endif                                         
			// Notas de Complemento: Icms, IPI, Precos não será considerada, não possui quantidade.
			If !lTemSDC .And. (cAliasSD1)->D1_QUANT >0
				lRetEnd  := A100Distri((cAliasSD1)->D1_COD,(cAliasSD1)->D1_LOCAL,(cAliasSD1)->D1_NUMSEQ,(cAliasSD1)->D1_DOC,(cAliasSD1)->D1_SERIE,(cAliasSD1)->D1_FORNECE,(cAliasSD1)->D1_LOJA,cLocaliz,Nil,(cAliasSD1)->D1_QUANT,(cAliasSD1)->D1_LOTECTL,(cAliasSD1)->D1_NUMLOTE)
			Endif				
		EndIf
		If lRetEnd  
			nSldRE5 := (cAliasSD1)->D1_QUANT
			dbSelectArea("SD3")
			RecLock("SD3",.T.)
			SD3->D3_FILIAL	:= xFilial("SD3")
			SD3->D3_COD		:= (cAliasSD1)->D1_COD
			SD3->D3_QUANT	:= (cAliasSD1)->D1_QUANT
			SD3->D3_TM		:= "999"
			SD3->D3_OP		:= (cAliasSD1)->D1_OP
			SD3->D3_LOCAL	:= (cAliasSD1)->D1_LOCAL
			SD3->D3_DOC		:= (cAliasSD1)->D1_DOC
			SD3->D3_EMISSAO	:= (cAliasSD1)->D1_DTDIGIT
			SD3->D3_NUMSEQ	:= (cAliasSD1)->D1_NUMSEQ
			SD3->D3_UM		:= (cAliasSD1)->D1_UM
			SD3->D3_GRUPO	:= (cAliasSD1)->D1_GRUPO
			SD3->D3_TIPO	:= (cAliasSD1)->D1_TP
			SD3->D3_SEGUM	:= (cAliasSD1)->D1_SEGUM
			SD3->D3_CONTA	:= (cAliasSD1)->D1_CONTA
			SD3->D3_CF		:= "RE5"
			SD3->D3_QTSEGUM	:= (cAliasSD1)->D1_QTSEGUM
			SD3->D3_USUARIO	:= CUSERNAME
			SD3->D3_CUSTO1	:= (cAliasSD1)->D1_CUSTO
			SD3->D3_CUSTO2	:= (cAliasSD1)->D1_CUSTO2
			SD3->D3_CUSTO3	:= (cAliasSD1)->D1_CUSTO3
			SD3->D3_CUSTO4	:= (cAliasSD1)->D1_CUSTO4
			SD3->D3_CUSTO5	:= (cAliasSD1)->D1_CUSTO5
			SD3->D3_NUMLOTE	:= (cAliasSD1)->D1_NUMLOTE
			SD3->D3_LOTECTL	:= (cAliasSD1)->D1_LOTECTL
			SD3->D3_DTVALID	:= (cAliasSD1)->D1_DTVALID
	        SD3->D3_LOCALIZ := cLocaliz
			SD3->D3_POTENCI := (cAliasSD1)->D1_POTENCI
			If X3Uso(cUsoD1_TRT)
				SD3->D3_TRT	    := (cAliasSD1)->D1_TRT
			EndIf
			If lFornece
				SD3->D3_FORNDOC	:= (cAliasSD1)->D1_FORNECE
				SD3->D3_LOJADOC	:= (cAliasSD1)->D1_LOJA
			EndIf
			
			//Verifica integração do Manutenção de Ativos X Estoque
			If AllTrim(SuperGetMV("MV_NGMNTES",.F.,'N')) == 'S'			
				If SubStr((cAliasSD1)->D1_OP,7,5) == "OS001"
					SD3->D3_ORDEM := SubStr((cAliasSD1)->D1_OP,1,6)
				EndIf
			EndIf
			
			//trecho que verifica se deve baixar algum SDC quando a qtd da nf e maior que a diferenca d4-dc
			//Em Notas de Complemento, nSLDRE5 = 0 
			If Localiza((cAliasSD1)->D1_COD,.T.) .And. nSldRE5>0
				dbSelectArea("SD4")
				dbSetOrder(1)
				If MsSeek(xFilial("SD4")+(cAliasSD1)->D1_COD+(cAliasSD1)->D1_OP)
					While !EOF() .And. SD4->(D4_FILIAL+D4_COD+D4_OP) == xFilial("SD4")+(cAliasSD1)->(D1_COD+D1_OP)
						nQtdSD4 += SD4->D4_QUANT
						dbSkip()
					End
				EndIf
				dbSelectArea("SDC")
				dbSetOrder(2)
				If MsSeek(xFilial("SDC")+(cAliasSD1)->D1_COD+(cAliasSD1)->D1_LOCAL+(cAliasSD1)->D1_OP)
					While !EOF() .And. SDC->(DC_FILIAL+DC_PRODUTO+DC_LOCAL+DC_OP) == xFilial("SDC")+(cAliasSD1)->(D1_COD+D1_LOCAL+D1_OP)
						nQtdSDC += SDC->DC_QUANT
						dbSkip()
					End
				EndIf
				
				nQtdSDC := nQtdSD4 - nQtdSDC
				If (cAliasSD1)->D1_QUANT > nQtdSDC
					nQtdSDC := (cAliasSD1)->D1_QUANT - nQtdSDC
				Else
					nQtdSDC := 0
				EndIf
	
			 	If	MsSeek(xFilial("SDC")+(cAliasSD1)->D1_COD+(cAliasSD1)->D1_LOCAL+(cAliasSD1)->D1_OP)	
					While nQtdSDC > 0 .And. !EOF() .And.SDC->(DC_FILIAL+DC_PRODUTO+DC_LOCAL+DC_OP) ==;
														 xFilial("SDC")+(cAliasSD1)->(D1_COD+D1_LOCAL+D1_OP)
						If !lWmsNew
							dbSelectArea("SBF")
							dbSetOrder(1)
							If MsSeek(xFilial("SBF")+SDC->(DC_LOCAL+DC_LOCALIZ+DC_PRODUTO),.F.)
								RecLock("SBF",.F.)
								SBF->BF_EMPEN2 -= ConvUM(SBF->BF_PRODUTO,Min(SBF->BF_EMPENHO,nQtdSDC),SDC->DC_QTSEGUM,2)
								SBF->BF_EMPENHO -= Min(SBF->BF_EMPENHO,nQtdSDC)
								MsUnlock()
							EndIf
						EndIf
						nQtdBxa := Min(SDC->DC_QUANT,nQtdSDC)
						RecLock("SDC",.F.)
						SDC->DC_QTSEGUM -= ConvUM(SDC->DC_PRODUTO,Min(SDC->DC_QUANT,nQtdSDC),SDC->DC_QTSEGUM,2)
						SDC->DC_QUANT -= Min(SDC->DC_QUANT,nQtdSDC)
						MsUnlock()
						
						nQtdSDC -= nQtdBxa
						SDC->(dbSkip())				
					End
				EndIf 
			EndIf
	
			dbSelectArea("SD4")
			dbSetOrder(1)
			If MsSeek(xFilial("SD4")+(cAliasSD1)->D1_COD+(cAliasSD1)->D1_OP)
				While nSldRE5 > 0
					If SD4->(D4_FILIAL+D4_COD+D4_OP) == xFilial("SD4")+(cAliasSD1)->(D1_COD+D1_OP)
						If SD4->D4_QUANT > 0 .And. ;
						   ((lCpoSGO .And. !SD4->(A103ChkBN(D4_OP,D4_COD,D4_LOCAL,SD4->(Recno()),D4_TRT,D4_LOTECTL,D4_NUMLOTE,D4_ORDEM,D4_OPORIG,D4_SEQ))) .or.;
						   (!lCpoSGO .And. !SD4->(A103ChkBN(D4_OP, D4_COD, D4_LOCAL, Recno()))))

							dbSelectArea("SB2")
							If MsSeek(xFilial("SB2")+(cAliasSD1)->D1_COD+(cAliasSD1)->D1_LOCAL,.F.)
								RecLock("SB2",.F.)
								SB2->B2_QEMP2 -= ConvUM(SB2->B2_COD,Min(SB2->B2_QEMP,Min(SD4->D4_QUANT,nSldRE5)),SD4->D4_QTSEGUM,2)
								SB2->B2_QEMP  -= Min(SB2->B2_QEMP,Min(SD4->D4_QUANT,nSldRE5))
								MsUnlock()
							EndIf
							RecLock("SD4",.F.)
							nQtdBxa := Min(Min(SD4->D4_QUANT,nSldRE5),(cAliasSD1)->D1_QUANT)
							SD4->D4_QTSEGUM	-= ConvUM(SD4->D4_COD,nQtdBxa,(cAliasSD1)->D1_QTSEGUM,2)
							SD4->D4_QUANT	-= nQtdBxa
							MsUnlock()
							nSldRE5 -= nQtdBxa
						Endif
						SD4->(dbSkip())
					Else
						nSldRe5 := 0
					EndIf
				End
			EndIf
			dbSelectArea("SC2")
			dbSetOrder(1)
			If MsSeek(xFilial("SC2")+(cAliasSD1)->D1_OP)
				SD3->D3_CC      := SC2->C2_CC
				SD3->D3_ITEMCTA	:= SC2->C2_ITEMCTA
				SD3->D3_CLVL    := SC2->C2_CLVL
			EndIf
			B2AtuComD3({SD3->D3_CUSTO1,SD3->D3_CUSTO2,SD3->D3_CUSTO3,SD3->D3_CUSTO4,SD3->D3_CUSTO5})
			C2AtuComD3({SD3->D3_CUSTO1,SD3->D3_CUSTO2,SD3->D3_CUSTO3,SD3->D3_CUSTO4,SD3->D3_CUSTO5})
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza requisicao valorizada para nota complementar com Custo Fifo     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lEnviaCQ .And. (lCusFifo .Or. lCusLifo) .And. lAjNfCompl
		NfeComplFF(cAliasSD1,(lCusFifo .Or. lCusLifo),1)
	EndIf	
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Devolucao de produtos                                                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	If ((cAliasSD1)->D1_TIPO == "D" .OR. ;
	((cAliasSD1)->D1_TIPO =="N" .And. GetAdvFVal("SF4","F4_PODER3",xFilial("SF4") + (cAliasSD1)->D1_TES,1) == "N" .And. !(AllTrim(cEspDoc) $ "CTE|CTEOS"))) .And. ;
	 !Empty((cAliasSD1)->D1_ITEMORI)

		If (lProcLoja .Or. !lVldNFO) .And. lD1FilOri .And. !Empty((cAliasSD1)->D1_FILORI)
			cD1FilOri := SD1->D1_FILORI
			cSF2Fil   := cD1FilOri
		Else
			cD1FilOri := xFilial("SD2")
			cSF2Fil   := xFilial("SF2")
		EndIf

		DbSelectArea("SF2")
		DbSetOrder(1)
		MsSeek(cSF2Fil + (cAliasSD1)->D1_NFORI + (cAliasSD1)->D1_SERIORI)
		
		If !(cD1FilOri == SD2->D2_FILIAL .And.;
				(cAliasSD1)->D1_NFORI   == SD2->D2_DOC    .And.;
				(cAliasSD1)->D1_SERIORI == SD2->D2_SERIE  .And.;
				SF2->F2_CLIENTE 		== SD2->D2_CLIENTE .And.;
				SF2->F2_LOJA 			== SD2->D2_LOJA    .And.;
				(cAliasSD1)->D1_COD 	== SD2->D2_COD     .And.;
				Alltrim((cAliasSD1)->D1_ITEMORI) == AllTrim(SD2->D2_ITEM))
			dbSelectArea("SD2")
			dbSetOrder(3)
			MsSeek(cSF2Fil+(cAliasSD1)->D1_NFORI+(cAliasSD1)->D1_SERIORI+SF2->F2_CLIENTE+SF2->F2_LOJA+(cAliasSD1)->D1_COD+(cAliasSD1)->D1_ITEMORI )
		EndIf

		If AllTrim(SF2->F2_CLIENTE)+AllTrim(SF2->F2_LOJA) == AllTrim((cAliasSD1)->D1_FORNECE)+AllTrim((cAliasSD1)->D1_LOJA)
			If (SD2->(!Eof()))
				RecLock("SD2",.F.)
				SD2->D2_QTDEDEV	+= (cAliasSD1)->D1_QUANT
				SD2->D2_VALDEV	+= (cAliasSD1)->D1_TOTAL
			EndIf
		Endif
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Tratamento da gravacao do SD1 na Integridade Referencial            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	SD1->(FkCommit())
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Integracao com o modulo de projetos                                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If IntePms()
		If !IsIntegTop(,.T.)
			PmsWriteNF(1,cAliasSD1)
		Else
			If !Empty(SD1->D1_PEDIDO)
				If !PMSNFSA(SD1->D1_PEDIDO,SD1->D1_ITEMPC)[1] //Não é S.A
					PmsWriteNF(1,cAliasSD1)
				Endif
			Else
				PmsWriteNF(1,cAliasSD1)
			Endif
		Endif
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Integracao com o EEC     											|
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lEECFAT
		EECFAT3("GRV",.F.)
    EndIf	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica complementos de integracao                                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Type("bTTSSD1")=="B"
		Eval(bTTSSD1,nOpcao)
	EndIf	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Estorno de um documento de entrada                                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	FreeObj(oTribGen)
Case nOpcao == 5
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Posiciona registros                                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SB1")
	dbSetOrder(1)
	MsSeek(xFilial("SB1")+(cAliasSD1)->D1_COD)

	dbSelectArea("SF4")
	dbSetOrder(1)
	MsSeek(xFilial("SF4")+(cAliasSD1)->D1_TES)

	dbSelectArea("SA2")
	dbSetOrder(1)
	MsSeek(xFilial("SA2")+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Integracao com o EEC     											|
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lEECFAT
   		EECFAT3("GRV",.T.)
	EndIf
   	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Retorna o pergunte da MATA103                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    Pergunte("MTA103", .F.)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Integracao com o modulo de projetos                                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If IntePms()
		PmsWriteNF(2,cAliasSD1)
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Devolucao de produtos                                                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ((cAliasSD1)->D1_TIPO == "D" .Or. ((cAliasSD1)->D1_TIPO =="N" .And. GetAdvFVal("SF4","F4_PODER3",xFilial("SF4") + (cAliasSD1)->D1_TES,1) == "N")) .And. !Empty((cAliasSD1)->D1_ITEMORI)

		If (Alltrim(SD1->D1_ORIGLAN) = 'LO' .Or. !lVldNFO) .And. lD1FilOri .And. !Empty((cAliasSD1)->D1_FILORI) //Issue: DVARLOJ4-1309-Validação se Origem for LOJA Utilizar FilOri.
			cD1FilOri := SD1->D1_FILORI
			cSF2Fil   := cD1FilOri
		Else
			cD1FilOri := xFilial("SD2")
			cSF2Fil   := xFilial("SF2")
		EndIf

		DbSelectArea("SF2")
		DbSetOrder(1)
		MsSeek(cSF2Fil + (cAliasSD1)->D1_NFORI + (cAliasSD1)->D1_SERIORI)
		
		If !(cD1FilOri == SD2->D2_FILIAL .And.;
				(cAliasSD1)->D1_NFORI   == SD2->D2_DOC 	.And.;
				(cAliasSD1)->D1_SERIORI == SD2->D2_SERIE   .And.;
				SF2->F2_CLIENTE         == SD2->D2_CLIENTE .And.;
				SF2->F2_LOJA 	        == SD2->D2_LOJA 	.And.;
				(cAliasSD1)->D1_COD     == SD2->D2_COD 	.And.;
				Alltrim((cAliasSD1)->D1_ITEMORI) == AllTrim(SD2->D2_ITEM))
			dbSelectArea("SD2")
			dbSetOrder(3)
			MsSeek(cD1FilOri+(cAliasSD1)->D1_NFORI+(cAliasSD1)->D1_SERIORI+SF2->F2_CLIENTE+SF2->F2_LOJA+(cAliasSD1)->D1_COD+(cAliasSD1)->D1_ITEMORI )
		EndIf
		If (SD2->(!Eof()))
			RecLock("SD2",.F.)
			SD2->D2_QTDEDEV	-= (cAliasSD1)->D1_QUANT
			SD2->D2_VALDEV	-= (cAliasSD1)->D1_TOTAL
			
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Se a devolução veio de uma troca/devolução da loja, altera o status do ³
	        //³ do item da venda.                                                      ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If SD2->D2_ORIGLAN == "LO"
				LJ020AltStatus(SD2->D2_FILIAL, SD2->D2_SERIE, SD2->D2_DOC, SD2->D2_COD, SD2->D2_ITEMPV)
			EndIf
		EndIf
	EndIf

	If FindFunction( "RskIsActive" ) .And. RskIsActive() .And. SF1->F1_TIPO == 'D'
		RskIntNcc()
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza requisicao direta a Ordem de Producao                         ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Empty((cAliasSD1)->D1_OP)
		dbSelectArea("SD3")
		dbSetOrder(4)
		nSldRe5 := (cAliasSD1)->D1_QUANT
		If MsSeek(xFilial("SD3")+(cAliasSD1)->D1_NUMSEQ, .F.)
			While !Eof() .And. xFilial("SD3") == SD3->D3_FILIAL .And.;
					SD3->D3_NUMSEQ == (cAliasSD1)->D1_NUMSEQ .And.;
					SD3->D3_CF <> "RE5"
				dbSelectArea("SD3")
				dbSkip()
			EndDo
			If SD3->D3_ESTORNO # "S" .And. !SD3->D3_NUMSEQ <> (cAliasSD1)->D1_NUMSEQ .And. Empty(SD3->D3_PROJPMS)
				RecLock("SD3",.F.)
				SD3->D3_ESTORNO := "S"
				For nX := 1 To FCount()
					aadd(aSD3,FieldGet(nX))
				Next nX
				RecLock("SD3",.T.)
				For nX := 1 To FCount()
					FieldPut(nX,aSD3[nX])
				Next nX
				SD3->D3_TM      := "499"
				SD3->D3_CF      := "DE5"
				SD3->D3_USUARIO := CUSERNAME
				
				//Estorna Amarracao com producoes de terceiros MATA037
				If ld3kLimp
					MatLimpD3K(SD3->D3_COD,SD3->D3_NUMSEQ)
				EndIf
				dbSelectArea("SD4")
				dbSetOrder(1)
				MsSeek(xFilial("SD4")+(cAliasSD1)->D1_COD+(cAliasSD1)->D1_OP)
				While nSldRE5 > 0
					If SD4->(D4_FILIAL+D4_COD+D4_OP) == xFilial("SD4")+(cAliasSD1)->(D1_COD+D1_OP)
						If (lCpoSGO .And. !SD4->(A103ChkBN(D4_OP,D4_COD,D4_LOCAL,SD4->(Recno()),D4_TRT,D4_LOTECTL,D4_NUMLOTE,D4_ORDEM,D4_OPORIG,D4_SEQ))) .or.;
						   (!lCpoSGO .And. !SD4->(A103ChkBN(D4_OP, D4_COD, D4_LOCAL, Recno())))

													RecLock("SD4",.F.)
							aBaixa:={Min(SD4->D4_QTDEORI-SD4->D4_QUANT,(cAliasSD1)->D1_QUANT),ConvUM(SD4->D4_COD, Min(SD4->D4_QTDEORI-SD4->D4_QUANT,(cAliasSD1)->D1_QUANT),0,2)}

							SD4->D4_QUANT   += aBaixa[1]
							SD4->D4_QTSEGUM += aBaixa[2]

							dbSelectArea("SB2")
							If MsSeek(xFilial("SB2")+(cAliasSD1)->D1_COD+(cAliasSD1)->D1_LOCAL,.F.)
								RecLock("SB2",.F.)
								SB2->B2_QEMP  += aBaixa[1]
								SB2->B2_QEMP2 += aBaixa[2]
								MsUnlock()
							EndIf

							nSldRE5 -= SD4->D4_QUANT
						EndIf
						SD4->(dbSkip())
					Else
						nSldRE5 := 0
					EndIf
				End
				B2AtuComD3({SD3->D3_CUSTO1,SD3->D3_CUSTO2,SD3->D3_CUSTO3,SD3->D3_CUSTO4,SD3->D3_CUSTO5})
				C2AtuComD3({SD3->D3_CUSTO1,SD3->D3_CUSTO2,SD3->D3_CUSTO3,SD3->D3_CUSTO4,SD3->D3_CUSTO5})
			EndIf
		EndIf	
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Estorna requisicao valorizada para nota complementar com Custo Fifo    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If (lCusFifo .Or. lCusLifo) .And. lAjNfCompl .And. (cAliasSD1)->D1_TIPO == 'C'
		dbSelectArea("SD3")
		dbSetOrder(4)
		If MsSeek(xFilial("SD3")+(cAliasSD1)->D1_NUMSEQ, .F.)
			While !Eof() .And. xFilial("SD3") == SD3->D3_FILIAL .And.;
					SD3->D3_NUMSEQ == (cAliasSD1)->D1_NUMSEQ .And.	SD3->D3_CF <> "RE6"
				dbSelectArea("SD3")
				dbSkip()
			EndDo
			If SD3->D3_ESTORNO # "S" .And. !SD3->D3_NUMSEQ <> (cAliasSD1)->D1_NUMSEQ .And. Empty(SD3->D3_PROJPMS)
				RecLock("SD3",.F.)
				SD3->D3_ESTORNO := "S"
				aSD3 := {}
				For nX := 1 To FCount()
					aadd(aSD3,FieldGet(nX))
				Next nX
				RecLock("SD3",.T.)
				For nX := 1 To FCount()
					FieldPut(nX,aSD3[nX])
				Next nX
				SD3->D3_TM      := "499"
				SD3->D3_CF      := "DE6"
				SD3->D3_USUARIO := CUSERNAME
				
				//Estorna Amarracao com producoes de terceiros MATA037
				If ld3kLimp
					MatLimpD3K(SD3->D3_COD,SD3->D3_NUMSEQ)
				EndIf

				B2AtuComD3({SD3->D3_CUSTO1,SD3->D3_CUSTO2,SD3->D3_CUSTO3,SD3->D3_CUSTO4,SD3->D3_CUSTO5})
			EndIf
		EndIf	
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Estorno do CQ                                                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SF4->F4_ESTOQUE == "S" .AND. !Empty((cAliasSD1)->D1_NUMCQ) .AND. (cAliasSD1)->D1_ORIGLAN <> "LO"

		If !(lComplQtd .And. cTpCompl == "2")	// Nota de Complemento de Quantidade nao gera movimentacao de CQ do tipo 8 portanto nao deve chamar a funcao abaixo, caso contrario sera exibido Help indevidamente. O estorno da mov. de CQ sera tratado o bloco seguinte.
			fEstoCQ8((cAliasSD1)->D1_NUMCQ,(cAliasSD1)->D1_COD,(cAliasSD1)->D1_LOCAL,IIF((cAliasSD1)->D1_TIPO$"CIP",{(cAliasSD1)->D1_DOC, (cAliasSD1)->D1_SERIE, (cAliasSD1)->D1_FORNECE, (cAliasSD1)->D1_LOJA},Nil))
		EndIf

		If !(cAliasSD1)->D1_TIPO $ "CIP56" .Or. (lComplQtd .And. cTpCompl == "2")
			dbSelectArea("SD7")
			dbSetOrder(1)

			If RetFldProd(SB1->B1_COD,"B1_TIPOCQ")=="Q"
				lQuery := .T.
				cCursorSD7 := GetNextAlias()

				cQuery := "SELECT SD7.*,SD7.R_E_C_N_O_ SD7RECNO "
				cQuery += "  FROM "+RetSqlName("SD7")+" SD7 "
				cQuery += " WHERE SD7.D7_FILIAL  = '"+xFilial("SD7")+"'"
				cQuery += "   AND SD7.D7_NUMERO  = '"+(cAliasSD1)->D1_NUMCQ+"'"
				cQuery += "   AND SD7.D7_LOCAL   = '"+(cAliasSD1)->D1_LOCAL+"'"
				cQuery += "   AND SD7.D7_PRODUTO = '"+(cAliasSD1)->D1_COD+"'"
				cQuery += "   AND SD7.D_E_L_E_T_ = ' ' "
				cQuery += "ORDER BY "+SqlOrder(SD7->(IndexKey()))

				cQuery := ChangeQuery(cQuery)
				dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cCursorSD7)

				For nX := 1 To Len(aStruSD7)
					If aStruSD7[nX][2]<>"C"
						TcSetField(cCursorSD7,aStruSD7[nX][1],aStruSD7[nX][2],aStruSD7[nX][3],aStruSD7[nX][4])
					EndIf
				Next nX

			Else
				lQuery := .T.
				cQuery := "UPDATE "+RetSqlName("SD7")+" "
				cQuery += "   SET D_E_L_E_T_ = '*' "
				cQuery += " WHERE D7_FILIAL  = '"+xFilial("SD7")+"'"
				cQuery += "   AND D7_NUMERO  = '"+(cAliasSD1)->D1_NUMCQ+"'"
				cQuery += "   AND D7_PRODUTO = '"+(cAliasSD1)->D1_COD+"'"
				cQuery += "   AND D7_LOCAL   = '"+(cAliasSD1)->D1_LOCAL+"'"
				cQuery += "   AND D_E_L_E_T_ = ' ' "

				TcSqlExec(cQuery)
				SD7->(MsGoto(0))
			EndIf

			If !lQuery .Or. RetFldProd(SB1->B1_COD,"B1_TIPOCQ")=="Q"
				While !(cCursorSD7)->(Eof()) .And. xFilial("SD7") == (cCursorSD7)->D7_FILIAL .And.;
						(cAliasSD1)->D1_NUMCQ == (cCursorSD7)->D7_NUMERO  .And.;
						(cAliasSD1)->D1_COD   == (cCursorSD7)->D7_PRODUTO .And.;
						(cAliasSD1)->D1_LOCAL == (cCursorSD7)->D7_LOCAL
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Estorno do CQ no Quality                                               ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If (cCursorSD7)->D7_TIPO==0 .And. (cCursorSD7)->D7_ORIGLAN=="CP" .And. RetFldProd(SB1->B1_COD,"B1_TIPOCQ")=="Q"
						If Rastro(SB1->B1_COD)
							dbSelectArea("SD5")
							dbSetOrder(3)
							If MsSeek(xFilial("SD5")+(cAliasSD1)->D1_NUMSEQ+(cAliasSD1)->D1_COD+(cAliasSD1)->D1_LOCAL+(cAliasSD1)->D1_LOTECTL,.F.)
								aLote := {SD5->D5_LOTECTL,SD5->D5_NUMLOTE}
							Else
								aLote := {"",""}
							EndIf
						EndIf
						aEnvCele := {(cAliasSD1)->D1_DOC,; //Numero da Nota Fiscal
							(cAliasSD1)->D1_SERIE,;        //Serie da Nota Fiscal
							(cAliasSD1)->D1_TIPO,;         //Tipo da Nota Fiscal
							(cAliasSD1)->D1_EMISSAO,;      //Data de Emissao da Nota Fiscal
							(cAliasSD1)->D1_DTDIGIT,;      //Data de Entrada da Nota Fiscal
							"NF",; 	  		                //Tipo de Documento
							(cAliasSD1)->D1_ITEM,; 	        //Item da Nota Fiscal
							(cAliasSD1)->D1_REMITO,;       //Numero do Remito (Localizacoes)
							(cAliasSD1)->D1_PEDIDO,;       //Numero do Pedido de Compra
							(cAliasSD1)->D1_ITEMPC,;       //Item do Pedido de Compra
							(cAliasSD1)->D1_FORNECE,;      //Codigo Fornecedor/Cliente
							(cAliasSD1)->D1_LOJA,;         //Loja Fornecedor/Cliente
							(cAliasSD1)->D1_LOTEFOR,;      //Numero do Lote do Fornecedor
							Space(6),;                     //Codigo do Solicitante
							(cAliasSD1)->D1_COD,;          //Codigo do Produto
							(cAliasSD1)->D1_LOCAL,;        //Local Origem
							aLote[1],;                     //Numero do Lote
							aLote[2],;                     //Sequencia do Sub-Lote
							(cAliasSD1)->D1_NUMSEQ,;       //Numero Sequencial
							(cCursorSD7)->D7_NUMERO,;      //Numero do CQ
							(cAliasSD1)->D1_QUANT,;        //Quantidade
							(cAliasSD1)->D1_TOTAL,;        //Preco
							0,;                            //Dias de atraso
							(cAliasSD1)->D1_TES,;          //TES
							AllTrim(FunName()),;           //Origem						
							" ",;                          //Origem TXT	
							0}                             //Quantidade do Lote Original
						aRecCele := QAtuMatQie(aEnvCele,2,,IIf(Type('l103Auto') <> 'U', l103Auto, .F. ))
					EndIf

					If lQuery
						SD7->( MsGoto( ( cCursorSD7 )->SD7RECNO ) )
					EndIf

					RecLock("SD7", .F.)
					SD7->( dbDelete() )
					( cCursorSD7 )->( dbSkip() )
				EndDo			
			EndIf
			If lQuery
				dbSelectArea(cCursorSD7)
				dbCloseArea()
				dbSelectArea("SD7")
			EndIf
		EndIf	
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza saldo fisico e financeiro                                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	RecLock("SD1",.F.)
	If SF4->F4_ESTOQUE=="S"
		B2AtuComD1(-1,(cAliasSD1)->D1_SKIPLOT, cAliasSD1, .T.)
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Amarracao Fornecedor/Produto                                           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SA5")
	dbSetOrder(1)
	lAchou := MsSeek(xFilial("SA5")+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA+(cAliasSD1)->D1_COD)
	If !lAchou .And. lReferencia	
		dbSelectArea("SA5")
		dbSetOrder(1)
		lAchou := MsSeek(xFilial("SA5")+(cAliasSD1)->D1_FORNECE+(cAliasSD1)->D1_LOJA+cProdRef)
	Endif
	If lAchou	
		RecLock("SA5",.F.)
		For nX := 1 To 12
			If ( FieldGet(FieldPos("A5_DTCOM"+StrZero(nX,2))) == (cAliasSD1)->D1_EMISSAO .And.;
					FieldGet(FieldPos("A5_PRECO" +StrZero(nX,2))) == IIF(nMcusto=="1",(cAliasSD1)->D1_CUSTO/(cAliasSD1)->D1_QUANT,(cAliasSD1)->(FieldGet(FieldPos("D1_CUSTO"+nMcusto)))/(cAliasSD1)->D1_QUANT) .And.;
					FieldGet(FieldPos("A5_QUANT" +StrZero(nX,2))) == (cAliasSD1)->D1_QUANT .And.;
					FieldGet(FieldPos("A5_COND"  +StrZero(nX,2))) == SF1->F1_COND )

				FieldPut(FieldPos("A5_DTCOM"+StrZero(nX,2)),Ctod(""))
				FieldPut(FieldPos("A5_PRECO" +StrZero(nX,2)),0)
				FieldPut(FieldPos("A5_QUANT" +StrZero(nX,2)),0)
				FieldPut(FieldPos("A5_COND"  +StrZero(nX,2)),"")

			EndIf
		Next nX
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualiza quantidade de entregas do produto  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If SA5->A5_SKIPLOT > 0
			SA5->A5_ENTREGA -= 1 
		EndIf
   		MsUnlock()

	EndIf
	//CIAP
	If ( !Empty((cAliasSD1)->D1_CODCIAP) ) .Or. (cFTCiap=="S" .And. lCTeCiap);
			 .OR. ( lCTeCiap .and. !Inclui .and. !Altera .and. SF4->F4_CIAP == "S" )
		A103CIAP(2, cAliasSD1, , "MATA103")         
	EndIf 
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Pedido de Compra                                                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Empty((cAliasSD1)->D1_PEDIDO)
		nRecC7 := A103RECC7(xFilial("SC7"),(cAliasSD1)->D1_PEDIDO,(cAliasSD1)->D1_FORNECE,(cAliasSD1)->D1_LOJA,(cAliasSD1)->D1_COD,(cAliasSD1)->D1_ITEMPC)
		SC7->(DbGoTo(nRecC7))
		If nRecC7 > 0
			MaAvalPC("SC7",9)
			
			If A103GCDisp()
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Retorna o saldo a receber da planilha                                  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				CtaAvalGCT(2,aContratos,SC7->C7_CONTRA,SC7->C7_PLANILH,SC7->C7_ITEMED,SD1->D1_QUANT,,SC7->C7_MEDICAO,SD1->D1_TOTAL)
			EndIf 
		EndIf
	EndIf		
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza Poder de Terceiro                                             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SF4->F4_PODER3<>"N"
		MaAtuSB6("SD1",2)
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica os documentos de cobertura                                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SDH")
	dbSetOrder(1)
	If MsSeek(xFilial("SDH")+SD1->D1_NUMSEQ)
		nQtdBaixa := SDH->DH_QUANT
		RecLock("SDH")
		SDH->(dbDelete())
		MsUnLock()
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualiza o documento de cobertura original                             ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If SDH->DH_TPMOV == "2"
			dbSelectArea("SDH")
			dbSetOrder(2)
			If MsSeek(xFilial("SDH")+"1"+SDH->DH_SERIE+SDH->DH_DOC+SDH->DH_ITEM+SDH->DH_CLIENTE+SDH->DH_LOJACLI+SDH->DH_FORNECE+SDH->DH_LOJAFOR+SDH->DH_OPER)
				RecLock("SDH")
				SDH->DH_SALDO += nQtdBaixa
				MsUnLock()
			EndIf
		EndIf
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica complementos de integracao                                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Type("bTTSSD1")=="B"
		Eval(bTTSSD1,nOpcao)
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Integracao com o modulo de projetos                                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If IntePms()
		PmsWriteNF(3,cAliasSD1,,,lEstNfClass)
	EndIf

	// Exclui consumo e saldo de compra de entrega futura
	If lDHQInDic .And. lMt103Com
		A103FutRem(.T.)
		A103FutFat(.T.)
	EndIf

EndCase
RestArea(aArea)

Return(.T.)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeRatCC  ³ Autor ³ Eduardo Riera         ³ Data ³15.10.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Interface com o usuario para o rateio de centro de custo dos ³±±
±±³          ³itens do documento de entrada                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpA1: aHeader do alias SDE                                  ³±±
±±³          ³ExpA2: aCols do alias SDE com a seguinte estrutura:          ³±±
±±³          ³       [1] Item do documento de entrada                      ³±±
±±³          ³       [2] aCols do SDE                                      ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo controlar a interface com o usu³±±
±±³          ³ario do rateio dos itens do documento de entrada             ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A103RatCC()
Local bSavKeyF9   := SetKey(VK_F9,Nil)

If !l103Auto .And. !IsInCallStack ('MATA140')
	If M->D1_RATEIO =="1"
		Eval(bSavKeyF9,.T.)
	Endif
EndIf
SetKey(VK_F9 ,bSavKeyF9)            

Return(.T.)

Function NfeRatCC(aHeadSDE,aColsSDE,lAltera,lValidX3)

Local aArea       := GetArea()
Local aSavaRotina := aClone(aRotina)
Local aColsCC     := {}
Local aButtons	  := {}
Local aButtonUsr  := {}
Local aHeadSD1    := {}
Local aColsSD1    := {}
Local aBkpSDE     := {}
Local aNoFields   := {"DE_CUSTO1","DE_CUSTO2","DE_CUSTO3","DE_CUSTO4","DE_CUSTO5"}
Local aCTBEnt     := CTBEntArr()
Local bSavKeyF4   := SetKey(VK_F4 ,Nil)
Local bSavKeyF5   := SetKey(VK_F5 ,Nil)
Local bSavKeyF6   := SetKey(VK_F6 ,Nil)
Local bSavKeyF7   := SetKey(VK_F7 ,Nil)
Local bSavKeyF8   := SetKey(VK_F8 ,Nil)
Local bSavKeyF9   := SetKey(VK_F9 ,Nil)
Local bSavKeyF10  := SetKey(VK_F10,Nil)
Local bSavKeyF11  := SetKey(VK_F11,Nil)
Local nPItemNF	  := GetPosSD1("D1_ITEM" )
Local nPCC	      := GetPosSD1("D1_CC" )
Local nPConta	  := GetPosSD1("D1_CONTA" )
Local nPItemCta   := GetPosSD1("D1_ITEMCTA" )
Local nPCLVL	  := GetPosSD1("D1_CLVL" )
Local nPCtbEnt    := 0
Local nPDECC	  := 0
Local nPDEConta	  := 0
Local nPDEItemCta := 0
Local nPDECLVL	  := 0
Local nPRateio    := GetPosSD1("D1_RATEIO" )
Local nColTotal   := GetPosSD1("D1_TOTAL" )
Local nItem  	   := aScan(aColsSDE,{|x| x[1] == aCols[n][nPItemNF]})
Local nY          := 0
Local nX          := 0
Local nZ          := 0
Local nSavN       := N
Local nPPercSDE   := 0
Local nTotPerc    := 0
Local nOpcA       := 0
Local nNewTam     := 0
Local nLinDoc     := 0
Local lContinua   := .T.
Local lRet        := .T.
Local lMT103LRAT  := .T.
Local lRetPCO     := .T.
Local oDlg
Local cCampo      := ReadVar()
Local nAviso      := 0  
Local oSize
Local lMA103REPRAT:=ExistBlock("MA103REPRAT")
Local aColsSDEcpy
Local aHeadAux    := {}
Local lMV103lRat  := SuperGetMv("MV_M103LRA",.F.,.F.)

DEFAULT aHeadSDE  := {}
DEFAULT aColsSDE  := {}
DEFAULT lAltera   := .T.
DEFAULT lValidX3  := .F.

Private aOrigHeader := aClone(aHeader)
Private aOrigAcols  := aClone(aCols)
Private oGetMan
Private nOrigN      := N 
Private nPercRat    := 0
Private nPercARat	  := 100
Private oPercRat
Private oPercARat
Private cItNfEntr  := aCols[n, nPItemNF] //utilizado pela funcao PcoVldLan() modulo PCO
Private nVlrTotal  := aCols[n, nColTotal] //utilizado pela funcao PcoVldLan() modulo PCO
Private oGetDad
           
dbSelectArea("SX3")
	dbSetOrder(1)
	MsSeek("SDE")
	While !EOF() .And. (SX3->X3_ARQUIVO == "SDE")
		IF X3USO(SX3->X3_USADO) .AND. cNivel >= SX3->X3_NIVEL .And. !"DE_CUSTO"$SX3->X3_CAMPO
			AADD(aHeadAux,{ TRIM(x3Titulo()),;
				SX3->X3_CAMPO,;
				SX3->X3_PICTURE,;
				SX3->X3_TAMANHO,;
				SX3->X3_DECIMAL,;
				SX3->X3_VALID,;
				SX3->X3_USADO,;
				SX3->X3_TIPO,;
				SX3->X3_F3,;
				SX3->X3_CONTEXT,;
				SX3->X3_PROPRI } )
		EndIf
		dbSelectArea("SX3")
		dbSkip()
	EndDo

If Type("aColsD1")=="A"
	aColSD1 := aCols
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ponto de Entrada para inibir o Rateio do item por    	 ³
//³ Centro de Custo                           			     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock("NFEINICC")
	lRet := Execblock("NFEINICC",.F.,.F.)
	If ValType(lRet) <> "L"
		lRet := .T.
	EndIf
EndIf      

If lRet
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Ativa os botoes da toolbar                                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If (!l103Visual)
		If !__lPyme	
			aadd(aButtons,{'AUTOM',{||  a103RatPCnf(aHeadSde,oGetDad) },STR0021,OemToAnsi(STR0029)}) //'Escolha de Rateio Pre-Configurado'
		EndIF	
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Ponto de Entrada Padrao                               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ExistBlock("A103BRCC")  
		aButtonUsr := ExecBlock("A103BRCC",.F.,.F.,{{|x|aHeadSde}})
	  	If ValType(aButtonUsr) == "A"
			For nX   := 1  To  Len(aButtonUsr)
		  		aadd(aButtons,aClone(aButtonUsr[nX]))
			Next nX
		EndIf  
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Impede de executar a rotina quando a tecla F3 estiver ativa		   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Type("InConPad") == "L"
		lContinua := !InConPad
	EndIf
	If lContinua
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Montagem do aHeader do SDE                                          ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Empty(aHeadSDE)
			dbSelectArea("SX3")
			dbSetOrder(1)
			MsSeek("SDE")
			While !EOF() .And. (SX3->X3_ARQUIVO == "SDE")
				IF X3USO(SX3->X3_USADO) .AND. cNivel >= SX3->X3_NIVEL .And. !"DE_CUSTO"$SX3->X3_CAMPO
					AADD(aHeadSDE,{ TRIM(x3Titulo()),;
						SX3->X3_CAMPO,;
						SX3->X3_PICTURE,;
						SX3->X3_TAMANHO,;
						SX3->X3_DECIMAL,;
						SX3->X3_VALID,;
						SX3->X3_USADO,;
						SX3->X3_TIPO,;
						SX3->X3_F3,;
						SX3->X3_CONTEXT } )
				EndIf
				dbSelectArea("SX3")
				dbSkip()
			EndDo
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Adiciona os campos de Alias e Recno ao aHeader para WalkThru.³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			ADHeadRec("SDE",aHeadSDE)
		EndIf
	
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³A rotina a seguir limpa o rateio digitado no item quando o mesmo for ³
		//³acionado pela validacao do campo D1_RATEIO com conteudo igual a NAO. ³
		//³Quando o rateio e disparado pela tecla F9, o D1_RATEIO sempre sera   ³
		//³igual a SIM e o lValidX3 assume o default .F., porem quando o rateio ³
		//³for acionado pela validacao do D1_RATEIO o lValidX3 sera .T. e aciona³
		//³a rotina a seguir para confirmar ou nao a exclusao do rateio no item.³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ       	
		If nItem > 0 .And. lValidX3    
			If M->D1_RATEIO == "2"
				If Aviso(STR0018,STR0030,{STR0008,STR0007})==1
					nNewTam   := Len(aColsSDE)-1
					aColsSDE  := aSize(aDel(aColsSDE,nItem), nNewTam)
					nItem := aScan(aColsSDE,{|x| x[1] == aCols[n][nPItemNF]})
		        EndIF 
		    EndIf
	    EndIf
	    
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Montagem do aCols do SDE                                            ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nItem > 0 
			aColsCC := aClone(aColsSDE[nItem][2])
			
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Totaliza o % ja Rateado ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nPercRat := 0 
			
			For nX   := 1  To  Len(aColsCC)
			If aColsCC[nX][aScan(aHeadSDE,{|x| AllTrim(x[2])=="DE_PERC"})] <> NIL
				nPercRat += aColsCC[nX][aScan(aHeadSDE,{|x| AllTrim(x[2])=="DE_PERC"})]
			EndIf						 
		
			For nY   := 1  To  Len(aHeadAux)
				IF !(aHeadAux[nY][2] $ "DE_REC_WT")  .and. !(aHeadAux[nY][2] $ "DE_ALI_WT") 
					IF aHeadAux[nY][11] == "U" 
						Do Case
							Case (aHeadAux[nY][8] == "C" .or.  aHeadAux[nY][8] == "M") .and. Empty(aColsCC[nX][nY]) 
								 aColsCC[nX][nY] := Space(aHeadAux[nY][4])
							Case aHeadAux[nY][8] == "N" .and. Empty(aColsCC[nX][nY]) 
								aColsCC[nX][nY] := 0
						EndCase 
					EndIf
				EndIf
			Next nY  
		Next nX 
			
			nPercARat := 100 - nPercRat
		Else
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ aHeader e aCols do SD1 devem ser salvos pois a FillGetDados destroe ³
			//³ ambos por serem PRIVATE, independente da construcao do aColsCC.     ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ	
			aHeadSD1 := aClone(aHeader)
			aColsSD1 := aClone(aCols)
	        aHeadSDE := {}
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Sintaxe da FillGetDados(nOpcX,Alias,nOrdem,cSeek,bSeekWhile,uSeekFor,aNoFields,aYesFields,lOnlyYes,cQuery,bMontCols,lEmpty,aHeaderAux,aColsAux,bAfterCols,bBeforeCols,bAfterHeader,cAliasQry |
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			FillGetDados(IIf(lAltera,3,2),"SDE",1,,,,aNoFields,,,,,.T.,aHeadSDE,aColsCC,,,)
			aColsCC[1][aScan(aHeadSDE,{|x| Trim(x[2])=="DE_ITEM"})] := StrZero(1,Len(SDE->DE_ITEM))

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Ponto de Entrada para açterar array de rateio por CC       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ	                          
			If ExistBlock("MT100RTX") .And. ( !lValidX3 .Or. (lValidX3 .And. M->D1_RATEIO == "1") )
				If ValType(aColsCC) == "A"
					aColsCC:= ExecBlock("MT100RTX",.F.,.F.,{aHeadSDE,aColsCC})
				Endif
			Endif
	
	        aHeader := aHeadSD1
	        aCols   := aColsSD1
	
		EndIf
		If !(Type('l103Auto') <> 'U' .And. l103Auto)   		
			aHeadSD1 := aClone(aHeader)
			aColsSD1 := aClone(aCols)
			DEFINE MSDIALOG oDlg FROM 100,100 TO 350,740 TITLE STR0020 Of oMainWnd PIXEL //"Rateio por Centro de Custo"
			
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Calcula dimensões                                            ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			oSize := FwDefSize():New(.T.,,,oDlg)
			oSize:aWorkArea := {000, 035, 320, 120 }
			oSize:AddObject( "CABECALHO",  100, 10, .T., .T. ) // Totalmente dimensionavel
			oSize:AddObject( "GETDADOS" ,  100, 80, .T., .T. ) // Totalmente dimensionavel 
			oSize:AddObject( "RODAPE"   ,  100, 10, .T., .T. ) // Totalmente dimensionavel
			
			oSize:lProp 	:= .T. // Proporcional             
			oSize:aMargins 	:= { 3, 3, 3, 3 } // Espaco ao lado dos objetos 0, entre eles 3 
		
			oSize:Process() 	   // Dispara os calculos   
						
			@ oSize:GetDimension("CABECALHO","LININI") ,oSize:GetDimension("CABECALHO","COLINI") SAY RetTitle("F1_DOC")  OF oDlg PIXEL SIZE 20,09
			@ oSize:GetDimension("CABECALHO","LININI") ,oSize:GetDimension("CABECALHO","COLINI")+30 SAY Substr(cSerie,1,3)+"/"+cNFiscal OF oDlg PIXEL SIZE 50,09
			@ oSize:GetDimension("CABECALHO","LININI") ,oSize:GetDimension("CABECALHO","COLINI")+93 SAY RetTitle("D1_ITEM") OF oDlg PIXEL SIZE 20,09
			@ oSize:GetDimension("CABECALHO","LININI") ,oSize:GetDimension("CABECALHO","COLINI")+112 SAY aCols[N][nPItemNF]  OF oDlg PIXEL SIZE 20,09
			
		    oGetDad := MsNewGetDados():New(oSize:GetDimension("GETDADOS","LININI"),oSize:GetDimension("GETDADOS","COLINI"),;
					   oSize:GetDimension("GETDADOS","LINEND"),oSize:GetDimension("GETDADOS","COLEND"),;
     			       IIF(lAltera,GD_INSERT+GD_UPDATE+GD_DELETE,0),"NfeRatLOk","NfeRatTOk","+DE_ITEM",,,999,/*fieldok*/,/*superdel*/,/*delok*/,oDlg,aHeadSDE,aColsCC)		
			oGetMan := oGetDad
			
			@ oSize:GetDimension("RODAPE","LININI"),oSize:GetDimension("RODAPE","COLINI") Say OemToAnsi(STR0042) FONT oDlg:oFont OF oDlg PIXEL	 // "% Rateada: "
			@ oSize:GetDimension("RODAPE","LININI"),oSize:GetDimension("RODAPE","COLINI")+30  Say oPercRat VAR nPercRat Picture PesqPict("SDE","DE_PERC") FONT oDlg:oFont COLOR CLR_HBLUE OF oDlg PIXEL
			@ oSize:GetDimension("RODAPE","LININI"),oSize:GetDimension("RODAPE","COLINI")+180 Say OemToAnsi(STR0043) FONT oDlg:oFont OF oDlg PIXEL	 // "% A Ratear: "
	 		@ oSize:GetDimension("RODAPE","LININI"),oSize:GetDimension("RODAPE","COLINI")+214 Say oPercARat VAR nPercARat Picture PesqPict("SDE","DE_PERC") FONT oDlg:oFont COLOR CLR_HBLUE OF oDlg PIXEL		
			ACTIVATE MSDIALOG oDlg CENTERED ON INIT EnchoiceBar(oDlg,{||IIF(oGetDad:TudoOk(),(nOpcA:=1,oDlg:End()),(nOpcA:=0))},{||oDlg:End()},,aButtons)
			
			If lAltera
				aColsCC := Aclone(oGetDad:aCols)
			Else
		        aHeader := aHeadSD1
		        aCols   := aColsSD1
			EndIf
		Else
			nOpcA := 1
		EndIf
		nPPercSDE := aScan(aHeadSDE,{|x| AllTrim(x[2])=="DE_PERC"})
		nTotPerc := 0
		
		aColsPar :={}
		AEval( aColsCC, { |x| If( !x[ Len(aHeadSDE) + 1], AAdd( aColsPar, x ), ) } ) 
		aColsCC := aClone( aColsPar )   
		
		For nX := 1 To Len(aColsCC)
			nTotPerc += aColsCC[nX][nPPercSDE]
		Next nX			
	
		nPDECC	      := aScan(aHeadsde,{|x| AllTrim(x[2]) == "DE_CC"} )
		nPDEConta	  := aScan(aHeadsde,{|x| AllTrim(x[2]) == "DE_CONTA"} )
		nPDEItemCta   := aScan(aHeadsde,{|x| AllTrim(x[2]) == "DE_ITEMCTA"} )
		nPDECLVL	  := Ascan(aHeadsde,{|x| AllTrim(x[2]) == "DE_CLVL"} )
	
		If nOpcA == 1 .And. lAltera
			If nTotPerc > 0
				If nItem > 0
					aColsSDE[nItem][2]	:= aClone(aColsCC)
				Else
					aadd(aColsSDE,{aCols[N][nPItemNF],aClone(aColsCC)})
				EndIf
		
				aCols[N][nPRateio] := "1"
				               
				//Ponto de Entrada que irá indicar se o aCOLS continuará
				//preenchido quando houver rateio por Centro de Cust0
				If ExistBlock("MT103LRAT")
			   		lMT103LRAT := ExecBlock("MT103LRAT",.F.,.F.,{aHeadSDE,aColsSDE})
	   				If ValType(lMT103LRAT)<>"L"
		   				lMT103LRAT:=.T.
		   			EndIf
			 	EndIf

				//Parametro MV_M103LRA indica se o aCols continuara preenchido
				//quando houver rateio por centro de custo.
				If !lMT103LRAT .Or. !lMV103lRat
					lMT103LRAT := .F.
				Endif

				If lMT103LRAT
					If nPCC <> 0 .And. nPDECC <> 0
						aCols[N][nPCC]     := Space(Len(aCols[N][nPCC]))
					EndIf
					If nPConta <> 0 .And. nPDEConta <> 0
						aCols[N][nPConta]  := Space(Len(aCols[N][nPConta]))
					EndIf
					If nPItemCta <> 0 .And. nPDEItemCta <> 0
						aCols[N][nPItemCta]:= Space(Len(aCols[N][nPItemCta]))
					EndIf
					If nPCLVL <> 0 .And. nPDECLVL <> 0
						aCols[N][nPCLVL]   := Space(Len(aCols[N][nPCLVL]))
					EndIf

					For nZ := 1 To Len(aCTBEnt)
						If ( nPCtbEnt := GetPosSD1("D1_EC"+aCTBEnt[nZ]+"DB" ) ) > 0
							aCols[N][nPCtbEnt] := Space(Len(aCols[N][nPCtbEnt]))
						EndIf
						If ( nPCtbEnt := GetPosSD1("D1_EC"+aCTBEnt[nZ]+"CR" ) ) > 0
							aCols[N][nPCtbEnt] := Space(Len(aCols[N][nPCtbEnt]))
						EndIf
					Next nZ
				EndIf
							
			    If Len(aCols)>1
					cMsg := CRLF + CRLF
					cMsg += STR0167 + StrZero(n,TamSx3("D1_ITEM")[1]) + CRLF //"Sim - Replica TODAS informações a partir do item do documento posicionado:"
					cMsg += STR0168 //"Todos - Replica TODAS informações para todos os itens do documento"
				
					nAviso := Aviso(STR0018,STR0046+cMsg,{STR0008,STR0007,STR0047}) //"Atenção"###"Replicar informações para os demais itens do documento?"###"Sim"###"Não"###"Todos"
					aBkpSDE := aClone(aColsSDE)
					If nAviso == 3
						aColsSDE := {}
						nAux := 1
					Else
						nAux := n
					EndIf
					If nAviso <> 2
						For nX := nAux To Len(aCols)
							nItem  	  := aScan(aColsSDE,{|x| x[1] == aCols[nX][nPItemNF]})
							If nItem == 0
								aadd(aColsSDE,{aCols[nX][nPItemNF],aClone(aColsCC)})
	
								aCols[nX][nPRateio] := "1"
	                             
								If lMT103LRAT	
									If nPCC <> 0 .And. nPDECC <> 0
										aCols[NX][nPCC]     := Space(Len(aCols[NX][nPCC]))
									EndIf
									If nPConta <> 0 .And. nPDEConta <> 0
										aCols[NX][nPConta]  := Space(Len(aCols[NX][nPConta]))
									EndIf
									If nPItemCta <> 0 .And. nPDEItemCta <> 0
										aCols[NX][nPItemCta]:= Space(Len(aCols[NX][nPItemCta]))
									EndIf
									If nPCLVL <> 0 .And. nPDECLVL <> 0
										aCols[NX][nPCLVL]   := Space(Len(aCols[NX][nPCLVL]))
									EndIf

									For nZ := 1 To Len(aCTBEnt)
										If ( nPCtbEnt := GetPosSD1("D1_EC"+aCTBEnt[nZ]+"DB" ) ) > 0
											aCols[N][nPCtbEnt] := Space(Len(aCols[N][nPCtbEnt]))
										EndIf
										If ( nPCtbEnt := GetPosSD1("D1_EC"+aCTBEnt[nZ]+"CR" ) ) > 0
											aCols[N][nPCtbEnt] := Space(Len(aCols[N][nPCtbEnt]))
										EndIf
									Next nZ

								EndIf	
								If nAviso == 3 .And. lMA103REPRAT
									aColsSDEcpy:=ExecBlock("MA103REPRAT",.F.,.F.,{aHeadSDE,aColsSDE})
									If ValType(aColsSDEcpy) == 'A'
									   aColsSDE:= aColsSDEcpy
									EndIf
								EndIf
							Else
								aColsSDE[nItem,2] := aClone(aColsCC)
							EndIf
							// Executa validacao de bloqueio no SIGAPCO para todos os itens do documento
							// quando for selecionada opcao para replicar rateio para os demais itens
							If aCols[nX][nPItemNF] != cItNfEntr	// Nao executa validacao para a linha da nota que esta posicionada, pois ja foi validada pela funcao NfeRatLok
								cItNfEntr := aCols[nX][nPItemNF]
								nVlrTotal := aCols[nX][nColTotal]
								nLinDoc := aScan(aColsSDE,{|x| x[1] == aCols[nX][nPItemNF]})
								lRetPCO := NfeRatTok(aHeadSDE,aColsCC,nLinDoc,.T.)
								If !lRetPCO
									aColsSDE := aBkpSDE
									Exit
								EndIf
							EndIf
						Next nX			
					EndIf
				EndIf
			Else
				If nItem > 0
					aColsSDE[nItem][2]	:= aClone(aColsCC)
				Else
					aadd(aColsSDE,{aCols[N][nPItemNF],aClone(aColsCC)})
				EndIf
				aCols[nSavN][nPRateio] := "2"
				M->D1_RATEIO := "2"
			EndIf
		ElseIf !l103Visual
			If nTotPerc > 0 .And. nItem > 0
				If "D1_RATEIO" $ cCampo
					&cCampo := "1"
				EndIf
				aCols[nSavN][nPRateio] := "1"
			Else
				If "D1_RATEIO" $ cCampo
					&cCampo := "2"
				EndIf
				aCols[nSavN][nPRateio] := "2"
			EndIf
		EndIf
	EndIf                                                                    
EndIf

If nOpcA == 0
	If nTotPerc <= 0
		aCols[nSavN][nPRateio] := "2"
		M->D1_RATEIO := "2"	
	Endif		
EndIf

If Type("aAuxColSDE") == "U"
	PRIVATE aAuxColSDE := {}
EndIf

aAuxColSDE := aColsSDE

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Restaura a integridade da rotina                                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aRotina	:= aClone(aSavaRotina)
N := nSavN
SetKey(VK_F4 ,bSavKeyF4)
SetKey(VK_F5 ,bSavKeyF5)
SetKey(VK_F6 ,bSavKeyF6)
SetKey(VK_F7 ,bSavKeyF7)
SetKey(VK_F8 ,bSavKeyF8)
SetKey(VK_F9 ,bSavKeyF9)
SetKey(VK_F10,bSavKeyF10)
SetKey(VK_F11,bSavKeyF11)
RestArea(aArea)
Return(.T.)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeCarCC ³ Autor ³ Wagner Mobile Costa    ³ Data ³21.10.2002³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Carrega as definicoes de rateio externo                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ MATA103                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function NfeCarCC(aCols, aHeader, cItem, lPrimeiro, lRatBlq)

Local lCusto		:= CtbMovSaldo("CTT")
Local lItem	 		:= CtbMovSaldo("CTD")
Local lCLVL	 		:= CtbMovSaldo("CTH")
Local lMT103PRE     := ExistBlock("MT103PRE")
Local lBloqCTJ      := .F.
Local nPosPerc		:= aScan(aHeader,{|x| AllTrim(x[2]) == "DE_PERC" } )
Local nPosItem		:= aScan(aHeader,{|x| AllTrim(x[2]) == "DE_ITEM" } )
Local nPosCC		:= aScan(aHeader,{|x| AllTrim(x[2]) == "DE_CC"} )
Local nPosConta		:= aScan(aHeader,{|x| AllTrim(x[2]) == "DE_CONTA"} )
Local nPosItemCta	:= aScan(aHeader,{|x| AllTrim(x[2]) == "DE_ITEMCTA"} )
Local nPosCLVL		:= aScan(aHeader,{|x| AllTrim(x[2]) == "DE_CLVL"} )
Local nHeader       := 0
Local aMT103PRE     := {}
Local aEntidades	:= {}
Local nEnt			:= 0
Local nDeb			:= 0

cItem := StrZero(Val(cItem), tamSX3("DE_ITEM")[1])
If lPrimeiro
	//-- Se ja foi informado algum rateio, limpar o aCols
	If aCols[Len(aCols)][nPosPerc] <> 0
		aCols := {}
		Aadd(aCols, Array(Len(aHeader) + 1))
		For nHeader := 1 To Len(aHeader)
			If Trim(aHeader[nHeader][2]) <> "DE_ALI_WT" .And. Trim(aHeader[nHeader][2]) <> "DE_REC_WT"
				aCols[Len(aCols)][nHeader] := CriaVar(aHeader[nHeader][2])
			Endif
		Next
	EndIf
	cItem := Soma1(cItem)
	aCols[Len(aCols)][nPosItem]  := cItem
	aCols[Len(aCols)][Len(aHeader)+1] := .F.
Else
	If CTJ->(FieldPos('CTJ_MSBLQL'))>0
		lBloqCTJ:=IIF(CTJ->CTJ_MSBLQL=="1",.T.,.F.)
	EndIf
	
	If !lBloqCTJ
		If aCols[Len(aCols)][nPosPerc] = 0
			nCols := Len(aCols)
			cItem := aCols[nCols][nPosItem]
		Else
			If Len(aCols) > 0
				cItem := aCols[Len(aCols)][nPosItem]
			Endif
			Aadd(aCols, Array(Len(aHeader) + 1))
			cItem := Soma1(cItem)
		EndIf
		
		For nHeader := 1 To Len(aHeader)
			If Trim(aHeader[nHeader][2]) <> "DE_ALI_WT" .And. Trim(aHeader[nHeader][2]) <> "DE_REC_WT"
				aCols[Len(aCols)][nHeader] := CriaVar(aHeader[nHeader][2])
			EndIf
		Next
		
		aCols[Len(aCols)][nPosItem] := cItem
		
		// Interpreto os campos incluida possibilidade de variaveis de memoria
		If !Empty(CTJ->CTJ_DEBITO)
			aCols[Len(aCols)][nPosConta]	:= CTJ->CTJ_DEBITO
		Else
			aCols[Len(aCols)][nPosConta]	:= CTJ->CTJ_CREDIT
		Endif
		
		If lCusto
			If ! Empty(CTJ->CTJ_CCD)
				aCols[Len(aCols)][nPosCc]	:= CTJ->CTJ_CCD
			Else
				aCols[Len(aCols)][nPosCc]	:= CTJ->CTJ_CCC
			Endif
		EndIf
		
		If lItem
			If ! Empty(CTJ->CTJ_ITEMD)
				aCols[Len(aCols)][nPosItemCta]	:= CTJ->CTJ_ITEMD
			Else
				aCols[Len(aCols)][nPosItemCta]	:= CTJ->CTJ_ITEMC
			Endif
		EndIf
		
		If lClVl
			If ! Empty(CTJ->CTJ_CLVLDB)
				aCols[Len(aCols)][nPosClVl]	:= CTJ->CTJ_CLVLDB
			Else
				aCols[Len(aCols)][nPosClVl]	:= CTJ->CTJ_CLVLCR
			Endif
		EndIf
		aCols[Len(aCols)][nPosPerc] := CTJ->CTJ_PERCEN
		aCols[Len(aCols)][Len(aHeader) + 1] := .F.
		
		aEntidades := CtbEntArr()
		For nEnt := 1 to Len(aEntidades)
			For nDeb := 1 to 2
				cCpo := "DE_EC"+aEntidades[nEnt]
				cCTJ := "CTJ_EC"+aEntidades[nEnt]
				
				If nDeb == 1 
					cCpo += "DB"
					cCTJ += "DB"
				Else
					cCpo += "CR"
					cCTJ += "CR"
				EndIf
				
				nPosHead := aScan(aHeader,{|x| AllTrim(x[2]) == Alltrim(cCpo) } )
				
				If nPosHead > 0
			   		aCols[Len(aCols)][nPosHead] := CTJ->(&(cCTJ))
				EndIf
				
			Next nDeb
		Next nEnt
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Ponto de Entrada que retorna dados dos campos personalizados   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lMT103PRE
			aMT103PRE := ExecBlock( "MT103PRE", .F., .F.,{aHeader,aCols})
			If ( ValType(aMT103PRE) == 'A' )
				aCols := AClone(aMT103PRE)
			EndIf
		EndIf
	Else
		If !lRatBlq
			Aviso("A103NFECARCC",STR0191,{"Ok"})
			lRatBlq := .T.
		EndIf
	EndIf
EndIf

Return .T.
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeRatLok ³ Autor ³ Eduardo Riera         ³ Data ³15.10.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Validacao da linhaok dos itens do rateio dos itens do documen³±±
±±³          ³to de entrada                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica se a linha esta valida                         ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo validar a linhaok do rateio dos³±±
±±³          ³itens do documento de entrada                                ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeRatLOk()

Local nPPerc    := aScan(aHeader,{|x| AllTrim(x[2]) == "DE_PERC"} )
Local nPCC	    := aScan(aHeader,{|x| AllTrim(x[2]) == "DE_CC"} )
Local nPConta	:= aScan(aHeader,{|x| AllTrim(x[2]) == "DE_CONTA"} )
Local nPItemCta := aScan(aHeader,{|x| AllTrim(x[2]) == "DE_ITEMCTA"} )
Local nPCLVL	:= Ascan(aHeader,{|x| AllTrim(x[2]) == "DE_CLVL"} )

Local nEc05Db	:= Ascan(aHeader,{|x| AllTrim(x[2]) == "DE_EC05DB"} )
Local nEc06Db	:= Ascan(aHeader,{|x| AllTrim(x[2]) == "DE_EC06DB"} )
Local nEc07Db	:= Ascan(aHeader,{|x| AllTrim(x[2]) == "DE_EC07DB"} )
Local nEc08Db	:= Ascan(aHeader,{|x| AllTrim(x[2]) == "DE_EC08DB"} )
Local nEc09Db	:= Ascan(aHeader,{|x| AllTrim(x[2]) == "DE_EC09DB"} )
Local nPosEC05CR    := aScan(aHeader,{|x| Alltrim(x[2]) == "DE_EC05CR"})
Local nPosEC06CR    := aScan(aHeader,{|x| Alltrim(x[2]) == "DE_EC06CR"}) 
Local nPosEC07CR    := aScan(aHeader,{|x| Alltrim(x[2]) == "DE_EC07CR"})
Local nPosEC08CR    := aScan(aHeader,{|x| Alltrim(x[2]) == "DE_EC08CR"})
Local nPosEC09CR    := aScan(aHeader,{|x| Alltrim(x[2]) == "DE_EC09CR"}) 
Local aEntid  := {}
Local aEntid2 := {}

Local lRetorno  := .T.       
Local lMt103LOk := Existblock("MT103LOK")
Local nX        := 0  
Local nAscan	:= 0
Local lDAmarCt	:= SuperGetMV( "MV_DAMARCT",.F.,.F. )
Local lRatDupl	:= GetNewPar("MV_RATDUPL",.F.)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se valida ou nao o aCols a partir das validacoes do aHeader ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Iif( nPConta	> 0, aAdd(aEntid, aCols[n,nPConta])	 , aAdd(aEntid, " ") )
Iif( nPCC		> 0, aAdd(aEntid, aCols[n,nPCC])	 , aAdd(aEntid, " ") )
Iif( nPItemCta	> 0, aAdd(aEntid, aCols[n,nPItemCta]), aAdd(aEntid, " ") )
Iif( nPClVl		> 0, aAdd(aEntid, aCols[n,nPClVl])	 , aAdd(aEntid, " ") )
Iif( nEc05Db	> 0, aAdd(aEntid, aCols[n,nEc05Db])	 , aAdd(aEntid, " ") )
Iif( nEc06Db	> 0, aAdd(aEntid, aCols[n,nEc06Db])	 , aAdd(aEntid, " ") )
Iif( nEc07Db	> 0, aAdd(aEntid, aCols[n,nEc07Db])	 , aAdd(aEntid, " ") )
Iif( nEc08Db	> 0, aAdd(aEntid, aCols[n,nEc08Db])	 , aAdd(aEntid, " ") )
Iif( nEc09Db	> 0, aAdd(aEntid, aCols[n,nEc09Db])	 , aAdd(aEntid, " ") )

Iif( nPConta	> 0, aAdd(aEntid2, aCols[n,nPConta])   , aAdd(aEntid2, " ") )
Iif( nPCC		> 0, aAdd(aEntid2, aCols[n,nPCC])	   , aAdd(aEntid2, " ") )
Iif( nPItemCta	> 0, aAdd(aEntid2, aCols[n,nPItemCta]) , aAdd(aEntid2, " ") )
Iif( nPClVl		> 0, aAdd(aEntid2, aCols[n,nPClVl])    , aAdd(aEntid2, " ") )
Iif( nPosEC05CR > 0, aAdd(aEntid2, aCols[n,nPosEC05CR]), aAdd(aEntid2, " ") )
Iif( nPosEC06CR > 0, aAdd(aEntid2, aCols[n,nPosEC06CR]), aAdd(aEntid2, " ") )
Iif( nPosEC07CR > 0, aAdd(aEntid2, aCols[n,nPosEC07CR]), aAdd(aEntid2, " ") )
Iif( nPosEC08CR > 0, aAdd(aEntid2, aCols[n,nPosEC08CR]), aAdd(aEntid2, " ") )
Iif( nPosEC09CR > 0, aAdd(aEntid2, aCols[n,nPosEC09CR]), aAdd(aEntid2, " ") )

If lMt103Lok
	lRetorno := Execblock("MT103LOK",.F.,.F.)
Endif   

If lRetorno .And. !lRatDupl
	If nEc05Db = 0
		nAscan := Ascan( aCols, { |e| 	e[nPCC] == aCols[n][nPCC] .And. e[nPConta] == aCols[n][nPConta] .And. e[nPItemCta] == aCols[n][nPItemCta] .And.;
												 	e[nPCLVL] == aCols[n][nPCLVL] .And. !e[len(e)] } )
	Elseif nEc09Db > 0
		nAscan := Ascan( aCols, { |e| 	e[nPCC] == aCols[n][nPCC] .And. e[nPConta] == aCols[n][nPConta] .And. e[nPItemCta] == aCols[n][nPItemCta] .And.;
												 	e[nPCLVL] == aCols[n][nPCLVL] .And. !e[len(e)] .And. ;
												 	e[nEc09Db] == aCols[n][nEc09Db] .And. e[nEc08Db] == aCols[n][nEc08Db] .And. e[nEc07Db] == aCols[n][nEc07Db] .And. ;
												 	e[nEc06Db] == aCols[n][nEc06Db] .And. e[nEc05Db] == aCols[n][nEc05Db]} )
	Elseif nEc08Db > 0
		nAscan := Ascan( aCols, { |e| 	e[nPCC] == aCols[n][nPCC] .And. e[nPConta] == aCols[n][nPConta] .And. e[nPItemCta] == aCols[n][nPItemCta] .And.;
												 	e[nPCLVL] == aCols[n][nPCLVL] .And. !e[len(e)] .And. ;
												 	e[nEc08Db] == aCols[n][nEc08Db] .And. e[nEc07Db] == aCols[n][nEc07Db] .And. ;
												 	e[nEc06Db] == aCols[n][nEc06Db] .And. e[nEc05Db] == aCols[n][nEc05Db]} )
	Elseif nEc07Db > 0
		nAscan := Ascan( aCols, { |e| 	e[nPCC] == aCols[n][nPCC] .And. e[nPConta] == aCols[n][nPConta] .And. e[nPItemCta] == aCols[n][nPItemCta] .And.;
												 	e[nPCLVL] == aCols[n][nPCLVL] .And. !e[len(e)] .And. ;
												 	e[nEc07Db] == aCols[n][nEc07Db] .And. ;
												 	e[nEc06Db] == aCols[n][nEc06Db] .And. e[nEc05Db] == aCols[n][nEc05Db]} )
	Elseif nEc06Db > 0
		nAscan := Ascan( aCols, { |e| 	e[nPCC] == aCols[n][nPCC] .And. e[nPConta] == aCols[n][nPConta] .And. e[nPItemCta] == aCols[n][nPItemCta] .And.;
												 	e[nPCLVL] == aCols[n][nPCLVL] .And. !e[len(e)] .And. ;
												 	e[nEc06Db] == aCols[n][nEc06Db] .And. e[nEc05Db] == aCols[n][nEc05Db]} )
	Elseif nEc05Db > 0
		nAscan := Ascan( aCols, { |e| 	e[nPCC] == aCols[n][nPCC] .And. e[nPConta] == aCols[n][nPConta] .And. e[nPItemCta] == aCols[n][nPItemCta] .And.;
												 	e[nPCLVL] == aCols[n][nPCLVL] .And. !e[len(e)] .And. ;
												 	e[nEc05Db] == aCols[n][nEc05Db]} )
	Endif
	
	If nAscan > 0 .And. n != nAscan
		Help(" ",1,"CCEXIST")// Centro de Custo ja Cadastrado
		lRetorno := .F.	
	Endif                                    
Endif

If !aCols[N][Len(aCols[N])]
	If aCols[N][nPPerc] == 0
		Help(" ",1,"A103PERC")
		lRetorno := .F.
	EndIf
EndIf

//Consiste amarração da Conta Contábil X Centro de Custo
If lRetorno .And. !lDAmarCt
	If nPConta <> 0 .And. nPCC>0 .And. nPItemCta <> 0 .And. nPClVl <> 0 .And.;
 	   (!CtbAmarra(aCols[n,nPConta],aCols[n,nPCC],aCols[n,nPItemCta],aCols[n,nPClVl],/*lPosiciona*/,/*lHelp*/,/*lValidLinOk*/,aEntid) .Or.;
		!CtbAmarra(aCols[n,nPConta],aCols[n,nPCC],aCols[n,nPItemCta],aCols[n,nPClVl],/*lPosiciona*/,/*lHelp*/,/*lValidLinOk*/,aEntid2))
	   lRetorno:=.F.
	EndIf
EndIf

If lRetorno .And. empty(aCols[N][nPCC]) // O Centro de Custo SEMPRE devera ser obrigatorio, Conta Contabil, Item Contabil e Classe Valor nao tem esta necessidade
	Help('   ',1,'A103RATEI')
	lRetorno:=.F.	
EndIf

If lRetorno .And. CTT->CTT_BLOQ == "1"
	Help('   ',1,"CTA_BLOQ")
	lRetorno:=.F.
Endif

If lRetorno
	nPercRat := 0
	nPercARat:= 0
	For nX	:= 1 To Len(aCols)
		If !aCols[nX][Len(aCols[nX])]
			nPercRat += aCols[nX][nPPerc]
		EndIf
	Next
	nPercARat := 100 - nPercRat
	If Type("oPercRat")=="O"
		oPercRat:Refresh()
		oPercARat:Refresh()
	Endif
EndIf  

If lRetorno
	Do Case
	Case cTipo == "B"
		lRetorno :=	PcoVldLan("000054","11","MATA103",/*lUsaLote*/,/*lDeleta*/, .T./*lVldLinGrade*/)
	Case cTipo == "D"
		lRetorno :=	PcoVldLan("000054","10","MATA103",/*lUsaLote*/,/*lDeleta*/, .T./*lVldLinGrade*/)
	OtherWise
		lRetorno :=	PcoVldLan("000054","09","MATA103",/*lUsaLote*/,/*lDeleta*/, .T./*lVldLinGrade*/)
	EndCase
Endif

Return(lRetorno)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeRatTok ³ Autor ³ Eduardo Riera         ³ Data ³15.10.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Validacao da TudoOk dos itens do rateio dos itens do documen-³±±
±±³          ³to de entrada                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: Indica se a todas as linhas estao validas             ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo validar a tudook do rateio dos ³±±
±±³          ³itens do documento de entrada                                ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeRatTok(aHeadSDE,aColsSDE,nLinDoc,lReplica)

Local nPPerc     	:= aScan(aHeader,{|x| AllTrim(x[2]) == "DE_PERC"})
Local nPCC	     	:= aScan(aHeader,{|x| AllTrim(x[2]) == "DE_CC"})
Local nPConta	 	:= aScan(aHeader,{|x| AllTrim(x[2]) == "DE_CONTA"})
Local nPItemCta  	:= aScan(aHeader,{|x| AllTrim(x[2]) == "DE_ITEMCTA"})
Local nPCLVL	 	:= Ascan(aHeader,{|x| AllTrim(x[2]) == "DE_CLVL"})
Local nPosEC05DB 	:= aScan(aHeader,{|x| Alltrim(x[2]) == "DE_EC05DB"}) 
Local nPosEC05CR    := aScan(aHeader,{|x| Alltrim(x[2]) == "DE_EC05CR"})
Local nPosEC06DB    := aScan(aHeader,{|x| Alltrim(x[2]) == "DE_EC06DB"}) 
Local nPosEC06CR    := aScan(aHeader,{|x| Alltrim(x[2]) == "DE_EC06CR"})
Local nPosEC07DB    := aScan(aHeader,{|x| Alltrim(x[2]) == "DE_EC07DB"}) 
Local nPosEC07CR    := aScan(aHeader,{|x| Alltrim(x[2]) == "DE_EC07CR"})
Local nPosEC08DB    := aScan(aHeader,{|x| Alltrim(x[2]) == "DE_EC08DB"}) 
Local nPosEC08CR    := aScan(aHeader,{|x| Alltrim(x[2]) == "DE_EC08CR"})
Local nPosEC09DB    := aScan(aHeader,{|x| Alltrim(x[2]) == "DE_EC09DB"}) 
Local nPosEC09CR    := aScan(aHeader,{|x| Alltrim(x[2]) == "DE_EC09CR"}) 
Local aEntid	 	:= {}
Local aEntid2	 	:= {}  

Local nTotal   := 0   
Local nX       := 0 
Local nK	   := 0
Local lRetorno := .T.
Local lMt103ROk := Existblock("MT103ROK")
Local n_SaveLin 
Local lDAmarCt	:= SuperGetMV( "MV_DAMARCT",.F.,.F. )
Local aBkpHead := {}
Local aBkpCols := {}
Local aEntCtb  := CtbEntArr()
Local cVarAuxDB:= ""
Local cVarAuxCR:= ""
Local cCmpAuxDB:= ""
Local cCmpAuxCR:= ""


Default aHeadSDE := {}
Default aColsSDE := {}
Default nLinDoc  := 0
Default lReplica := .F.

If Type("l103Class") <> "L"
	l103Class := .F.
Endif

If lMt103Rok .And. !lReplica
	lRetorno := Execblock("MT103ROK",.F.,.F.)
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se valida ou nao o aCols a partir das validacoes do aHeader ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Iif( nPConta	> 0, aAdd(aEntid, aCols[n,nPConta])	  , aAdd(aEntid, " ") )
Iif( nPCC		> 0, aAdd(aEntid, aCols[n,nPCC])	  , aAdd(aEntid, " ") )
Iif( nPItemCta	> 0, aAdd(aEntid, aCols[n,nPItemCta]) , aAdd(aEntid, " ") )
Iif( nPClVl		> 0, aAdd(aEntid, aCols[n,nPClVl])	  , aAdd(aEntid, " ") )
Iif( nPosEC05DB > 0, aAdd(aEntid, aCols[n,nPosEC05DB]), aAdd(aEntid, " ") )
Iif( nPosEC06DB > 0, aAdd(aEntid, aCols[n,nPosEC06DB]), aAdd(aEntid, " ") )
Iif( nPosEC07DB > 0, aAdd(aEntid, aCols[n,nPosEC07DB]), aAdd(aEntid, " ") )
Iif( nPosEC08DB > 0, aAdd(aEntid, aCols[n,nPosEC08DB]), aAdd(aEntid, " ") )
Iif( nPosEC09DB > 0, aAdd(aEntid, aCols[n,nPosEC09DB]), aAdd(aEntid, " ") )

Iif( nPConta	> 0, aAdd(aEntid2, aCols[n,nPConta])   , aAdd(aEntid2, " ") )
Iif( nPCC		> 0, aAdd(aEntid2, aCols[n,nPCC])      , aAdd(aEntid2, " ") )
Iif( nPItemCta	> 0, aAdd(aEntid2, aCols[n,nPItemCta]) , aAdd(aEntid2, " ") )
Iif( nPClVl		> 0, aAdd(aEntid2, aCols[n,nPClVl])	   , aAdd(aEntid2, " ") )
Iif( nPosEC05CR > 0, aAdd(aEntid2, aCols[n,nPosEC05CR]), aAdd(aEntid2, " ") )
Iif( nPosEC06CR > 0, aAdd(aEntid2, aCols[n,nPosEC06CR]), aAdd(aEntid2, " ") )
Iif( nPosEC07CR > 0, aAdd(aEntid2, aCols[n,nPosEC07CR]), aAdd(aEntid2, " ") )
Iif( nPosEC08CR > 0, aAdd(aEntid2, aCols[n,nPosEC08CR]), aAdd(aEntid2, " ") )
Iif( nPosEC09CR > 0, aAdd(aEntid2, aCols[n,nPosEC09CR]), aAdd(aEntid2, " ") )

If !lReplica
	For nX	:= 1 To Len(aCols)
		If !aCols[nX][Len(aCols[nX])]
			If !lDAmarCt
				//Consiste amarração da Conta Contábil X Centro de Custo
				If (!CtbAmarra(aCols[n,nPConta],aCols[n,nPCC],aCols[n,nPItemCta],aCols[n,nPClVl],/*lPosiciona*/,/*lHelp*/,/*lValidLinOk*/,aEntid) .Or.;
					!CtbAmarra(aCols[n,nPConta],aCols[n,nPCC],aCols[n,nPItemCta],aCols[n,nPClVl],/*lPosiciona*/,/*lHelp*/,/*lValidLinOk*/,aEntid2))
					lRetorno:=.F.
					Aviso("NfeRatTok",STR0120+" "+aCols[nX,1],{"Ok"})
					Exit 
				EndIf
			Endif 
			nTotal := nTotal + aCols[nX][nPPerc]
		
			//-- Verifica se existe alguma Entidade Contábil bloqueada.
			If lRetorno .And. (l103Class .Or. INCLUI) 
				
				//-- Centro de Custo
				If nPCC > 0 .And. !Empty(aCols[nX,nPCC]) .And. !ValidaBloq(aCols[nX,nPCC], dDataBase, "CTT")		
					lRetorno:= .F.
					Exit
				EndI
				//-- Conta Contábil
				If nPConta > 0 .And. !Empty(aCols[nX,nPConta]) .And. !ValidaBloq(aCols[nX,nPConta], dDataBase, "CT1")		
					lRetorno:= .F.
					Exit
				EndIf
				//-- Item Contábil
				If nPItemCta > 0 .And. !Empty(aCols[nX,nPItemCta]) .And. !ValidaBloq(aCols[nX,nPItemCta], dDataBase, "CTD")		
					lRetorno:= .F.
					Exit
				EndIf
				//-- Classe de Valor
				If nPClVl > 0 .And. !Empty(aCols[nX,nPClVl]) .And. !ValidaBloq(aCols[nX,nPClVl], dDataBase, "CTH")		
					lRetorno:= .F.
					Exit
				EndI
				For nK := 1 To Len(aEntCtb)
					//-- Entidade Contabil Adicional DB
					cVarAuxDB := "nPosEC" + aEntCtb[nK] + "DB"
					cCmpAuxDB := "DE_EC" + aEntCtb[nK] + "DB"
					If &(cVarAuxDB) > 0 .And. !Empty(aCols[nX,&(cVarAuxDB)]) .And. !ValidaBloq(aCols[nX,&(cVarAuxDB)], dDataBase, "CV0",,, aEntCtb[nK])
						lRetorno := .F.
						Exit
					EndI
					//-- Entidade Contabil Adicional CR
					cVarAuxCR := "nPosEC" + aEntCtb[nK] + "CR"
					cCmpAuxCR := "DE_EC" + aEntCtb[nK] + "CR"
					If &(cVarAuxCR) > 0 .And. !Empty(aCols[nX,&(cVarAuxCR)]) .And. !ValidaBloq(aCols[nX,&(cVarAuxCR)], dDataBase, "CV0",,, aEntCtb[nK])
						lRetorno := .F.
						Exit
					EndI
				Next nK

				If !lRetorno
					Exit
				EndIf
			Endif
		EndIf

	Next
EndIf

If lRetorno .And. nTotal > 0 .And. nTotal <> 100 .And. !lReplica 
	Help(" ",1,"A103TOTRAT")
	lRetorno := .F.
EndIf  

// Executa validacao de bloqueio no SIGAPCO para todos os itens do documento
// quando for selecionada opcao para replicar rateio para os demais itens
If lReplica
	aBkpHead := aHeader
	aBkpCols := aCols
	aHeader  := aHeadSDE
	aCols    := aColsSDE
	nOrigN   := nLinDoc
EndIf

If lRetorno
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se ha bloqueio em algum item do pco qdo valida for por grade ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If PcoBlqFim({{"000054","09"},{"000054","10"},{"000054","11"}}) .Or. lReplica
		n_SaveLin := n
		For nx:=1 to len(aCols)
			If !aCols[nx][Len(aCols[nx])]
			    n := nX
				If lRetorno
					Do Case
					Case cTipo == "B"
						lRetorno	:=	PcoVldLan("000054","11","MATA103",/*lUsaLote*/,/*lDeleta*/, .F./*lVldLinGrade*/)
					Case cTipo == "D"
						lRetorno	:=	PcoVldLan("000054","10","MATA103",/*lUsaLote*/,/*lDeleta*/, .F./*lVldLinGrade*/)
					OtherWise
						lRetorno	:=	PcoVldLan("000054","09","MATA103",/*lUsaLote*/,/*lDeleta*/, .F./*lVldLinGrade*/)
					EndCase
	            Endif
	            If !lRetorno
	            	Exit
	            EndIf	
			EndIf
		Next
		n := n_SaveLin
    EndIf
EndIf

// Retorna aHeader e Acols ao estado original
If lReplica
	aHeader := aBkpHead
	aCols   := aBkpCols
EndIf

Return(lRetorno)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeViewPrd³ Autor ³ Eduardo Riera         ³ Data ³17.12.2002 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Visualizacao da consulta ao historico de compras             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum                                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo executar a visualizacao do his-³±±
±±³          ³torico de compra do produto da linha da getdados             ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeViewPrd()

Local nPosCod	:= GetPosSD1("D1_COD")

If nPosCod <> 0
	MaFisSave()
	MaFisEnd()
	If !AtIsRotina("MACOMVIEW")
		If !Empty(aCols[n][nPosCod])
			MaComView(aCols[n][nPosCod])
		EndIf
	EndIf
	MaFisRestore()
EndIf
Return
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeTotFin ³ Autor ³ Eduardo Riera         ³ Data ³18.07.2003 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Totalizacao do array financeiro                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpA1: aHeader do array de duplicatas                        ³±±
±±³          ³ExpA2: aCols do array de duplicatas                          ³±±
±±³          ³ExpL3: Habilita o Help (DEFAULT .T.)                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: O Documento de entrada esta coerente com as parcelas  ³±±
±±³          ³       financeiras                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo verificar se o somatorio das   ³±±
±±³          ³parcelas eh total de duplicatas do documento de Entrada      ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeTotFin(aHeader,aCols,lHelp,lRecalc,nColsSE2,aColTrbGen)

Local aArea    := GetArea()
Local lRetorno := .T.
Local nTotDup  := 0
Local nIRRF    := 0
Local nISS     := 0
Local nINSS    := 0
Local nPIS     := 0
Local nCOFINS  := 0
Local nCSLL    := 0
Local nFethab  := 0 
Local nFabov   := 0 
Local nFacs    := 0
Local nIMA	   := 0
Local nFAMAD   := 0 
Local nPValor  := aScan(aHeader,{|x| AllTrim(x[2])=="E2_VALOR"})
Local nPIRRF   := aScan(aHeader,{|x| AllTrim(x[2])=="E2_IRRF"})
Local nPISS    := aScan(aHeader,{|x| AllTrim(x[2])=="E2_ISS"})
Local nPINSS   := aScan(aHeader,{|x| AllTrim(x[2])=="E2_INSS"})
Local nPPIS    := aScan(aHeader,{|x| AllTrim(x[2])=="E2_PIS"})
Local nPCOFINS := aScan(aHeader,{|x| AllTrim(x[2])=="E2_COFINS"})
Local nPCSLL   := aScan(aHeader,{|x| AllTrim(x[2])=="E2_CSLL"})
Local nPFETHAB := aScan(aHeader,{|x| AllTrim(x[2])=="E2_FETHAB"})
Local nPFABOV  := aScan(aHeader,{|x| AllTrim(x[2])=="E2_FABOV"})
Local nPFACS   := aScan(aHeader,{|x| AllTrim(x[2])=="E2_FACS"})
Local nPIMA    := aScan(aHeader,{|x| AllTrim(x[2])=="E2_IMA"})
Local nPFAMAD  := aScan(aHeader,{|x| AllTrim(x[2])=="E2_FAMAD"})
Local nX       := 0 
Local lISSNat  := .T.
Local cNatNF   := ""
Local lISSTes	:= SuperGetMv("MV_ISSRETD",.F.,.F.)
Local cINSSAd	:= "0"
Local nLIMPAG	:= SuperGetMV("MV_LIMPAG")
Local lMT103FIN	:= ExistBlock("MT103FIN")
Local aTribGen := {}
Local lTrbGen  := IIf(FindFunction("ChkTrbGen"),ChkTrbGen("SD1", "D1_IDTRIB"),.F.) .And. FindFunction("FinGrvFK7") .And. FindFunction("FINCalImp") .And. FindFunction("A103TrbGen") .And. FindFunction("A103AtuTrG") // Verifica se o sistema esta preparado para utilizar o motor de tributos genericos
Local nY       := 0
Local nTribGen := 0
Local nTotTrbGen:= 0
Local nPosValTrb:= 0
Local cIdsTrGen := ""

If Type("aBaseDup")=="U" .Or. aBaseDup==Nil
	aBaseDup := {0,0}
EndIf

DEFAULT aHeader		:= {}
DEFAULT aCols		:= {}
DEFAULT lHelp      	:= .T.
DEFAULT lRecalc    	:= .T.
DEFAULT nColsSE2   	:= 0
DEFAULT aColTrbGen 	:= {}

cINSSAd	:=	MaFisScan("NF_VALINA",.F.)

If MaFisFound("NF")
	cNatNF := MaFisRet(,"NF_NATUREZA")
	If lTrbGen .And. !Empty(cNatNF)
		aTribGen := MaFisRet(,"NF_TRIBGEN")	// Retorna os valores calculados pelo motor	
		If Len(aTribGen) > 0 .And. Len(aColTrbGen) > 0	// Armazena no array aColTrbGen as colunas que serao exibidas na aba Duplicatas referentes ao motor de tributos genericos
			For nY := 1 To Len(aTribGen)
				If aScan(aColTrbGen,{|x| AllTrim(x[1]) == AllTrim(aTribGen[nY][1])}) > 0	// Verifica se o tributo e exibido nas Duplicatas pois nem todos os tributos calculados na nota sao passiveis de retencao
					nTotTrbGen += aTribGen[nY][3]	// Guarda o valor total de tributos genericos passiveis de rentecao
				EndIf
			Next nY
			//Retorna a lista de IDs para a variável cIdsTrGen
			A103TrbGen(aCols,aTribGen,aColTrbGen,,,@cIdsTrGen)
		EndIf
	EndIf

	//Verifica se deve existir o calculo do ISS pela natureza do titulo, TES ou Conf. Tributos
	If FindFunction("A103FinIss")
		lISSNat := A103FinIss(cNatNF, cIdsTrGen, @__lIssMR)
	Else
		dbSelectArea("SED")
		If SED->(dbSeek(xFilial("SED")+cNatNF))
			lISSNat := SED->ED_CALCISS <> "N" .Or. lISSTes
		Endif            
	EndIf

EndIf

//Verifica o valor total das duplicatas com o total da NFE
If (INCLUI .Or. ALTERA) .And. lRetorno .And. !Empty(cCondicao) .And. cTipo <> "D" .And. MaFisFound("NF")
	dbSelectArea("SE4")
	dbSetOrder(1)
	MsSeek(xFilial("SE4")+cCondicao)
	If SE4->E4_TIPO <> "A"
		For nX := 1 To Len(aCols)
			nTotDup += aCols[nX][nPValor]
			If nPIRRF > 0
				nIRRF += aCols[nX][nPIRRF]
			EndIf
			If nPISS > 0
				nISS += aCols[nX][nPISS]
			EndIf
			If nPINSS > 0
				nINSS += aCols[nX][nPINSS]
			EndIf
			If nPPIS > 0
				nPIS += aCols[nX][nPPIS]
			EndIf                       	
			If nPCOFINS > 0
				nCOFINS += aCols[nX][nPCOFINS]
			EndIf
			If nPCSLL> 0
				nCSLL += aCols[nX][nPCSLL]
			EndIf
			If nPFETHAB > 0
				nFETHAB += aCols[nX][nPFETHAB]
			EndIf 
			If nPFABOV > 0
				nFABOV += aCols[nX][nPFABOV]
			EndIf 
			If nPFACS > 0
				nFACS += aCols[nX][nPFACS]
			EndIf
			If nPIMA > 0
				nIMA += aCols[nX][nPIMA]
			EndIf
			If nPFAMAD > 0
				nFAMAD += aCols[nX][nPFAMAD]
			EndIf
			If lTrbGen .And. !Empty(cNatNF)
				For nY := 1 To Len(aTribGen)
					If (nPosValTrb := aScan(aColTrbGen,{|x| x[1] == aTribGen[nY][1]}) ) > 0	// Encontra a coluna da duplicata referente ao tributo generico
						nTribGen += aCols[nX][nColsSE2+nPosValTrb]
					EndIf
				Next nY
			EndIf

			If nPValor > 0 .And. nPIRRF > 0 .And. nPISS > 0 .And. nPCOFINS > 0 .And. nPCSLL > 0 .And. nPPIS > 0 .And. nPINSS > 0
				If xMoeda(nTotDup,nMoedaCor,1,dDEmissao,Nil,MaFisRet(,"NF_TXMOEDA")) > 0 .And. (aCols[nX][nPIRRF]+aCols[nX][nPISS]+aCols[nX][nPINSS]+aCols[nX][nPPIS]+aCols[nX][nPCOFINS]+aCols[nX][nPCSLL]+IIf(nPFETHAB>0,aCols[nX][nPFETHAB],0)+IIf(nPFACS>0,aCols[nX][nPFACS],0)+IIf(nPFABOV>0,aCols[nX][nPFABOV],0)+IIf(nPIMA>0,aCols[nX][nPIMA],0)+IIf(nPFAMAD>0,aCols[nX][nPFAMAD],0) + nTribGen) > (xMoeda(nTotDup,nMoedaCor,1,dDEmissao,Nil,MaFisRet(,"NF_TXMOEDA"))-0.01)
					Help(" ",1,"A100VALP",,,3,0)	//Valor da somatoria dos impostos superior ao valor da parcela.
					lRetorno := .F.
					Exit
				EndIf
			EndIf			
		Next nX
		If nTotDup > 0  .Or. !IsInCallStack("MATA103") //caso contrario o sistema calcula o valor automaticamente
			If Abs(xMoeda(MaFisRet(,"NF_BASEDUP")+aBaseDup[2],1,nMoedaCor,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA")) - nTotDup) > nLIMPAG
				If lHelp .Or. ExistBlock("MT103DUP")
					Help(" ",1,"A100VALDUP",,SuperGetMV("MV_SIMB"+AllTrim(Str(nMoedaCor)))+" "+Str((xMoeda(MaFisRet(,"NF_BASEDUP"),1,nMoedaCor,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA")) - nTotDup)),3,0)
				EndIf  
				lRetorno := .F.
			ElseIf  Abs(MaFisRet(,"NF_BASEDUP")-NoRound(xMoeda(nTotDup,nMoedaCor,1,dDEmissao,Nil,MaFisRet(,"NF_TXMOEDA")),2))>0.01
					aBaseDup := {MaFisRet(,"NF_BASEDUP"),0}
				If nMoedaCor<=1
					MaFisAlt("NF_BASEDUP",NoRound(xMoeda(nTotDup,nMoedaCor,1,dDEmissao,Nil,MaFisRet(,"NF_TXMOEDA")),2))
				EndIf
				aBaseDup[2] := aBaseDup[1]-MaFisRet(,"NF_BASEDUP")
			EndIf
			
			If nPIRRF > 0
				If Abs(QtdComp(nIRRF) - qtdcomp(MaFisRet(,"NF_VALIRR")))>0
					If lHelp
						Help(" ",1,"A100VALDUP",,"IRF "+SuperGetMV("MV_SIMB"+AllTrim(Str(nMoedaCor)))+" "+Str((xMoeda(MaFisRet(,"NF_VALIRR"),1,nMoedaCor,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA")) - nIRRF)),3,0)
					EndIf
					lRetorno := .F.
				EndIf
			EndIf
			If nPISS > 0
				If Abs(QtdComp(nISS) - IIf((MaFisRet(,"NF_RECISS")=="2".And.lISSNat) .Or. __lIssMR,QtdComp(MaFisRet(,"NF_VALISS")),0))>0
					If lHelp
						Help(" ",1,"A100VALDUP",,"ISS "+SuperGetMV("MV_SIMB"+AllTrim(Str(nMoedaCor)))+" "+Str((xMoeda(A103CalIss(lISSNat, __lIssMR),1,nMoedaCor,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA")) - nISS)),3,0)
					EndIf
					lRetorno := .F.
				EndIf
			EndIf
			If nPINSS > 0
				If Abs(QtdComp(nINSS)- (QtdComp(MaFisRet(,"NF_VALINS"))+Iif(cINSSAd<>"0",QtdComp(MaFisRet(,"NF_VALINA")),0)))>0
					If lHelp
						Help(" ",1,"A100VALDUP",,"INSS "+SuperGetMV("MV_SIMB"+AllTrim(Str(nMoedaCor)))+" "+Str((xMoeda(MaFisRet(,"NF_VALINS")+Iif(cINSSAd<>"0",MaFisRet(,"NF_VALINA"),0),1,nMoedaCor,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA")) - nINSS)),3,0)
					EndIf
					lRetorno := .F.
				EndIf
			EndIf
			If nPPIS > 0
				If Abs(QtdComp(nPIS) - QtdComp(MaFisRet(,"NF_VALPIS")))>0
					If lHelp
						Help(" ",1,"A100VALDUP",,"PIS "+SuperGetMV("MV_SIMB"+AllTrim(Str(nMoedaCor)))+" "+Str((xMoeda(MaFisRet(,"NF_VALPIS"),1,nMoedaCor,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA")) - nPIS)),3,0)
					EndIf
					lRetorno := .F.
				EndIf
			EndIf
			If nPCOFINS > 0
				If Abs(QtdComp(nCOFINS) - QtdComp(MaFisRet(,"NF_VALCOF")))>0
					If lHelp
						Help(" ",1,"A100VALDUP",,"COFINS "+SuperGetMV("MV_SIMB"+AllTrim(Str(nMoedaCor)))+" "+Str((xMoeda(MaFisRet(,"NF_VALCOF"),1,nMoedaCor,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA")) - nCOFINS)),3,0)
					EndIf
					lRetorno := .F.
				EndIf
			EndIf
			If nPCSLL > 0
				If NoRound(Abs(QtdComp(nCSLL) - QtdComp(MaFisRet(,"NF_VALCSL"))),2)>0
					If lHelp
						Help(" ",1,"A100VALDUP",,"CSLL "+SuperGetMV("MV_SIMB"+AllTrim(Str(nMoedaCor)))+" "+Str((xMoeda(MaFisRet(,"NF_VALCSL"),1,nMoedaCor,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA")) - nCSLL)),3,0)
					EndIf
					lRetorno := .F.
				EndIf
			EndIf
			If nPFETHAB > 0
				If Abs(nFETHAB - IIf(MaFisRet(,"NF_RECFET")=="2",MaFisRet(,"NF_VALFET"),0))>0
					If lHelp
						Help(" ",1,"A100VALDUP",,"FETHAB "+SuperGetMV("MV_SIMB"+AllTrim(Str(nMoedaCor)))+" "+Str((xMoeda(IIf(MaFisRet(,"NF_RECFET")=="2",MaFisRet(,"NF_VALFET"),0),1,nMoedaCor,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA")) - nFETHAB)),3,0)
					EndIf
					lRetorno := .F.
				EndIf
			EndIf
			If nPFACS > 0
				If Abs(nFACS - IIf(MaFisRet(,"NF_RECFAC")=="2",MaFisRet(,"NF_VALFAC"),0))>0
					If lHelp
						Help(" ",1,"A100VALDUP",,"FACS "+SuperGetMV("MV_SIMB"+AllTrim(Str(nMoedaCor)))+" "+Str((xMoeda(IIf(MaFisRet(,"NF_RECFAC")=="2",MaFisRet(,"NF_VALFAC"),0),1,nMoedaCor,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA")) - nFACS)),3,0)
					EndIf
					lRetorno := .F.
				EndIf
			EndIf
			If nPFABOV > 0
				If Abs(nFabov - IIf(MaFisRet(,"NF_RECFAB")=="2",MaFisRet(,"NF_VALFAB"),0))>0
					If lHelp
						Help(" ",1,"A100VALDUP",,"FABOV "+SuperGetMV("MV_SIMB"+AllTrim(Str(nMoedaCor)))+" "+Str((xMoeda(IIf(MaFisRet(,"NF_RECFAB")=="2",MaFisRet(,"NF_VALFAB"),0),1,nMoedaCor,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA")) - nFabov)),3,0)
					EndIf
					lRetorno := .F.
				EndIf
			EndIf
			If nPIMA > 0
				If Abs(nIMA - IIf(MaFisRet(,"NF_RECIMA")=="2",MaFisRet(,"NF_VALIMA"),0))>0
					If lHelp
						Help(" ",1,"A100VALDUP",,"IMA "+SuperGetMV("MV_SIMB"+AllTrim(Str(nMoedaCor)))+" "+Str((xMoeda(IIf(MaFisRet(,"NF_RECIMA")=="2",MaFisRet(,"NF_VALIMA"),0),1,nMoedaCor,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA")) - nIMA)),3,0)
					EndIf
					lRetorno := .F.
				EndIf
			EndIf
			If nPFAMAD > 0
				If Abs(nFAMAD - IIf(MaFisRet(,"NF_RECFMD")=="2",MaFisRet(,"NF_VALFMD"),0))>0
					If lHelp
						Help(" ",1,"A100VALDUP",,"FAMAD "+SuperGetMV("MV_SIMB"+AllTrim(Str(nMoedaCor)))+" "+Str((xMoeda(IIf(MaFisRet(,"NF_RECFMD")=="2",MaFisRet(,"NF_VALFMD"),0),1,nMoedaCor,dDEmissao,Nil,Nil,MaFisRet(,"NF_TXMOEDA")) - nFAMAD)),3,0)
					EndIf
					lRetorno := .F.
				EndIf
			EndIf
			If lTrbGen .And. !Empty(cNatNF)
				If Abs(nTribGen - nTotTrbGen) > 0
					If lHelp
						Help(" ",1,"A100VALDUP",,SuperGetMV("MV_SIMB"+AllTrim(Str(nMoedaCor)))+" "+Str((nTotTrbGen - nTribGen))+STR0209,3,0)
					EndIf
					lRetorno := .F.
				EndIf
			EndIf

			If lRetorno .And. nPIRRF*nPISS*nPINSS*nPPIS*nPCOFINS*nPCSLL*IIf(Empty(nPFETHAB),1,nPFETHAB)*IIf(Empty(nPFABOV),1,nPFABOV)*IIf(Empty(nPFACS),1,nPFACS)*IIf(Empty(nPIMA),1,nPIMA)*IIf(Empty(nPFAMAD),1,nPFAMAD) > 0
				If Abs(nIRRF+nINSS+nISS+nPIS+nCOFINS+nCSLL+nFETHAB+nFabov+nFacs+nIMA+nFAMAD)>xMoeda(nTotDup,nMoedaCor,1,dDEmissao,Nil,MaFisRet(,"NF_TXMOEDA"))
					If lHelp
						Help(" ",1,"A100VALDUP",,"IRRF/ISS/INSS/PIS/COFINS/CSLL"+IIf(nPFETHAB>0,"/FETHAB","")+IIf(nPFABOV>0,"/FABOV","")+IIf(nPFACS>0,"/FACS","")+IIf(nPIMA>0,"/IMA","")+IIf(nPFAMAD>0,"/FAMAD",""),3,0)
					EndIf
		    		lRetorno := .F.
				EndIf		
			Else
				If lRetorno .And. nPIRRF*nPISS*nPINSS>0
					If Abs(nIRRF+nINSS+nISS)>xMoeda(nTotDup,nMoedaCor,1,dDEmissao,Nil,MaFisRet(,"NF_TXMOEDA"))
						If lHelp
							Help(" ",1,"A100VALDUP",,"IRRF/ISS/INSS",3,0)
						EndIf
						lRetorno := .F.
					EndIf		
				EndIf
			EndIf
		EndIf
	EndIf
    //Pontos de Entrada
	If lMT103FIN
		lRetorno := ExecBlock("MT103FIN",.F.,.F.,{aHeader,aCols,lRetorno})	
	EndIf
EndIf

If !lRetorno
	lRecalc := .F.
EndIf

RestArea(aArea)
Return(lRetorno)

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³A103CalcRt³ Autor ³ Sergio Silveira       ³ Data ³17/08/2004 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Totalizacao do array financeiro                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpA1: aHeader do array de duplicatas                        ³±±
±±³          ³ExpA2: aCols do array de duplicatas                          ³±±
±±³          ³ExpL3: Habilita o Help (DEFAULT .T.)                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1: O Documento de entrada esta coerente com as parcelas  ³±±
±±³          ³       financeiras                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo verificar se o somatorio das   ³±±
±±³          ³parcelas eh total de duplicatas do documento de Entrada      ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Static Function A103CalcRt(aColsSE2,aHeadSE2,cModRetPIS,lPccBaixa)
                                  
Local aListBox := {}
Local cAnoMes    := ""   
Local cAcessRad  := GetNewPar( "MV_AC10925", "1" ) 
Local nRadio     := Val( cModRetPIS ) 
Local nOpca      := 0 
Local nPosVenc   := GdFieldPos( "E2_VENCTO", aHeadSE2 )  
Local nLoop      := 0 
Local nTamAnoMes := 0                                
Local nPPIS      := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_PIS"})
Local nPCOFINS   := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_COFINS"})
Local nPCSLL     := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_CSLL"})
Local lProcessa  := .F.
Local oOk        := LoadBitmap( GetResources(), "LBOK" )
Local oNOk       := LoadBitmap( GetResources(), "LBNO" )
Local oDlgRet  
Local oList           
Local oRadio         
Local oBold 
Local oBmp        
Local oBut1
Local oBut2
Local lMT103RET := ExistBlock( "MT103RET" )

//Obtem os valores por ano/mes para as parcelas desta nota  
For nLoop := 1 to Len( aColsSE2 ) 

	If aColsSE2[ nLoop, nPPIS ] > 0 .Or. aColsSE2[ nLoop, nPCOFINS ] > 0 .Or. aColsSE2[ nLoop, nPCSLL ] > 0 

		lProcessa := .T.

		nTamAnoMes := Len( DToC( aColsSE2[ nLoop, nPosVenc ] ) ) - 3 
		cAnoMes := DToS( aColsSE2[ nLoop, nPosVenc ] )

		If Empty( nScanMes := AScan( aListBox, { |x| Left( x[2], 6 ) == Left( cAnoMes, 6 ) } ) )	
			AAdd( aListBox, { .T., cAnoMes } ) 
		EndIf 
		
	Endif
Next nLoop     

If lProcessa

	ASort( aListBox, , , { |x,y| y[2] > x[2] } )   
	
	//Converte os valores para exibicao em tela  
	AEval( aListBox, { |x| x[2] := Right( DToC( SToD( x[2] ) ), nTamAnoMes ) } ) 
	
	DEFINE MSDIALOG oDlgRet TITLE STR0031 FROM 09,0 TO 33.8,60 OF oMainWnd // "Calculo de retencao" 
	
	DEFINE FONT oBold NAME "Arial" SIZE 0, -13 BOLD
	
	@  0, -25 BITMAP oBmp RESNAME "PROJETOAP" oF oDlgRet SIZE 55, 1000 NOBORDER WHEN .F. PIXEL
	
	@ 03, 40 SAY STR0032 FONT oBold PIXEL // "Modalidade de retencao do PIS/COFINS/CSLL"
	
	@ 14, 30 TO 16 ,400 LABEL '' OF oDlgRet   PIXEL
	
	@ 25, 40 RADIO oRadio VAR nRadio 3D SIZE 70, 11 PROMPT STR0033,STR0034,STR0035 of oDlgRet PIXEL // "Calculado pelo sistema","Efetua retencao", "Nao efetua retencao"
	
	oRadio:SetEnable( cAcessRad == "1" .And. !lPccBaixa )	
	oList := TWBrowse():New( 65, 40, 190, 96,,{ STR0036, STR0037 },,oDlgRet,,,,,,,,,,,,.F.,,.T.,,.F.,,,) // "Retencao", "Mes / Ano"
	
	oList:SetArray(aListBox)
	oList:bLine := { || { If( aListBox[oList:nAT,1], oOk, oNOK ), aListBox[oList:nAT,2] } } 
		                                                                                        
	DEFINE SBUTTON oBut1 FROM 168, 169 TYPE 1 ACTION ( nOpca := 1, oDlgRet:End() )  ENABLE of oDlgRet		 
	DEFINE SBUTTON oBut2 FROM 168, 202 TYPE 2 ACTION ( nOpca := 0, oDlgRet:End() )  ENABLE of oDlgRet
	
	oRadio:bChange := { || A103Radio( aColsSE2,aHeadSE2,@oList,@aListBox,nRadio ) } 
	Eval( oRadio:bChange ) 
	
	ACTIVATE MSDIALOG oDlgRet CENTERED  
	
	If nOpca == 1 
		cModRetPIS := Str( nRadio, 1 ) 
	EndIf 
	
	// Ponto de Entrada para identificar a opção de retenção marcada pelo usuário no momento de inclusão da nota
	If lMT103RET
		ExecBlock("MT103RET", , ,{nRadio,nOpca}) 
	EndIf

Endif
	
Return( .T. ) 


/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³A103Radio ³ Autor ³ Sergio Silveira       ³ Data ³17/08/2004 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Controle do radio button                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpA1: aHeader do array de duplicatas                        ³±±
±±³          ³ExpA2: aCols do array de duplicatas                          ³±±
±±³          ³ExpO1: Habilita o Help (DEFAULT .T.)                         ³±±
±±³          ³ExpA3: Habilita o Help (DEFAULT .T.)                         ³±±
±±³          ³ExpN1: Habilita o Help (DEFAULT .T.)                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T.                                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Esta rotina tem como objetivo verificar se o somatorio das   ³±±
±±³          ³parcelas eh total de duplicatas do documento de Entrada      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Static Function A103Radio( aColsSE2,aHeadSE2,oList,aListBox,nRadio )

Do Case 
Case nRadio == 1  
	A103Recal(aColsSE2,aHeadSE2,@oList,@aListBox)
Case nRadio == 2 
	AEval( aListBox, { |x| x[1] := .T. } ) 
	bLine := oList:bLine
	oList:SetArray(aListBox)
	oList:bLine := bLine 
Case nRadio == 3 
	AEval( aListBox, { |x| x[1] := .F. } ) 
	bLine := oList:bLine
	oList:SetArray(aListBox)
	oList:bLine := bLine 
EndCase                                

oList:Refresh() 

Return( .T. ) 

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³A103Recal ³ Autor ³Sergio Silveira        ³ Data ³05/08/2004³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Efetua o calculo do valor de titulos financeiros que        ³±±
±±³          ³calcularam a retencao do PIS / COGINS / CSLL e nao          ³±±
±±³          ³criaram os titulos de abatimento                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Logico    - .T. item do pedido sera faturado, .F. nao sera  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpD1 - Data de referencia                                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Static Function A103Recal( aColsSE2, aHeadSE2, oList, aList ) 

Local aAreaSE2  := SE2->( GetArea() ) 
Local aDadosMes := {}
Local aStruct   := {} 
Local aCampos   := {}                         
Local aProp     := {}     
Local aFil10925 := {} 

Local cQuery    := ""
Local cAliasQry := "" 
Local cSepNeg   := If("|"$MV_CPNEG,"|",",")
Local cSepProv  := If("|"$MVPROVIS,"|",",")
Local cSepRec   := If("|"$MVPAGANT,"|",",")
Local cAnoMes   := "" 
Local cModTot   := GetNewPar( "MV_MT10925", "1" )
Local cQryFil   := "" 

Local dDataIni  := CToD( "" )
Local dDataFim  := CToD( "" )

Local nLoop     := 0
Local nLoop2    := 0
Local nPosVenc  := GdFieldPos( "E2_VENCTO", aHeadSE2 )  
Local nPosValor := GdFieldPos( "E2_VALOR" , aHeadSE2 )  
Local nPosParc	:= 0
Local nMinRet   := GetNewPar( "MV_VL10925", 5000 ) 
Local nScanMes  := 0 
Local nAdic     := 0
Local nValTot   := 0
Local nBasePis  := MaFisRet(,"NF_BASEPIS")
Local nBaseCof  := MaFisRet(,"NF_BASECOF")
Local nBaseCsl  := MaFisRet(,"NF_BASECSL")
Local nProp     := 0
Local nSaldoProp:= 0
Local nPropPis  := 0
Local nPropCof  := 0
Local nPropCsl  := 0  
Local nX        := 0
Local nPPIS     := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_PIS"})
Local nPCOFINS  := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_COFINS"})
Local nPCSLL    := aScan(aHeadSE2,{|x| AllTrim(x[2])=="E2_CSLL"})

//Chamado SDFPWW
Local cAglutFil := SuperGetMV("MV_PCCAGLU",,"1")
Local aAreaSM0  := {}
Local cCGCSM0   := ""
Local cEmpAtu   := ""
Local lMT103FRT := ExistBlock( "MT103FRT" )

//Verifica valor total das duplicatas  
For nX := 1 to Len(aColsSE2)
	nValTot += aColsSE2[ nX, nPosValor ]
Next

//Calcula proporcao  
nSaldoProp := 1 

For nX := 1 to Len(aColsSE2)
	If nX == Len(aColsSE2)  
		nProp := nSaldoProp
	Else 			
		nProp := Round( aColsSE2[ nX, nPosValor ] / nValTot,6)
		nSaldoProp -= nProp
	EndIf	
   AAdd( aProp, nProp )
Next nX

//Obtem os valores por ano/mes para as parcelas desta nota  
For nLoop := 1 to Len( aColsSE2 ) 

	cAnoMes	:= Left( DToS( aColsSE2[ nLoop, nPosVenc ] ), 6 ) 	
	nScanMes := AScan( aDadosMes, { |x| x[1] == cAnoMes } ) 

   //Caso as parcelas sejam do mesmo mes, deve somar o valor das parcelas para aplicar ou nao a cumulatividade
	If aColsSE2[ nLoop, nPPIS ] > 0 .Or. aColsSE2[ nLoop, nPCOFINS ] > 0 .Or. aColsSE2[ nLoop, nPCSLL ] > 0 .Or. nScanMes > 0
		
		If nScanMes == 0
			AAdd( aDadosMes, { cAnoMes, 0,0,0,0 } ) 
			nScanMes := Len( aDadosMes ) 	
		EndIf 
	
		nPropPis := NoRound(nBasePis * aProp[nLoop],6)
		nPropCof := NoRound(nBaseCof * aProp[nLoop],6)
		nPropCsl := NoRound(nBaseCsl * aProp[nLoop],6)		
		
		aDadosMes[ nScanMes, 2 ] += aColsSE2[ nLoop, nPosValor ]
		aDadosMes[ nScanMes, 3 ] += nPropPis
		aDadosMes[ nScanMes, 4 ] += nPropCof
		aDadosMes[ nScanMes, 5 ] += nPropCsl
	    
    EndIf
    	
Next nLoop 

//Ordena o array de ano / mes  
ASort( aDadosMes, , , { |x,y| y[1] > x[1] } ) 

dDataIni := CToD( "01/" + Right( aDadosMes[ 1, 1 ], 2 ) + "/" + Left( aDadosMes[ 1, 1 ], 4 ) ) 
dDataFim := LastDay( CToD( "15/" + Right( aDadosMes[ Len( aDadosMes ), 1 ], 2 ) + "/" + Left( aDadosMes[ Len( aDadosMes ), 1 ], 4 ) ) )

//Ponto de Entrada MT103FRT para tratamento de Filiais com o mesmo CNPJ
aFil10925 := {}
aAreaSM0  := SM0->(GetArea())
cEmpAtu   := SM0->M0_CODIGO
cCGCSM0   := SM0->M0_CGC
SM0->(DbSetOrder(1))
SM0->(MsSeek(cEmpAnt))                                           

//Se parametro "MV_PCCAGLU" existe com conteudo diferente de 1
If cAglutFil == "2" .Or. cAglutFil == "3"
	Do While !SM0->(Eof()) .And. SM0->M0_CODIGO == cEmpAtu
		//Verifica se a filial tem o mesmo CGC/Raiz de CGC
		If (cAglutFil == "2" .And. cCGCSM0 == SM0->M0_CGC) .Or. (cAglutFil == "3" .And. Left(cCGCSM0,8) == Left(SM0->M0_CGC,8))
			AAdd(aFil10925,FWGETCODFILIAL)
		EndIf
		SM0->(DbSkip())
	EndDo

ElseIf lMT103FRT
	aFil10925 := ExecBlock( "MT103FRT", .F., .F. ) 
Else 
	aFil10925 := { xFilial( "SE2" ) }  				     
EndIf
SM0->(RestArea(aAreaSM0))
        
aCampos := { "E2_VALOR","E2_VENCREA","E2_PIS","E2_COFINS","E2_CSLL","E2_ISS","E2_INSS","E2_IRRF","E2_VRETPIS","E2_VRETCOF","E2_VRETCSL" } 
aStruct := SE2->( dbStruct() ) 	

SE2->( dbCommit() ) 
   
cAliasQry := GetNextAlias()

cQuery := "SELECT E2_VALOR,E2_VENCREA,E2_PIS,E2_COFINS,E2_CSLL,E2_ISS,E2_INSS,E2_IRRF,E2_PRETPIS,E2_PRETCOF,E2_PRETCSL,E2_VRETPIS,E2_VRETCOF,E2_VRETCSL,R_E_C_N_O_ RECNO "

cQuery += ",E2_BASEPIS,E2_BASECOF,E2_BASECSL "	                                                                    
Aadd(aCampos,"E2_BASEPIS")
Aadd(aCampos,"E2_BASECOF")
Aadd(aCampos,"E2_BASECSL")		
                   
cQuery += ",E2_PRETIRF,E2_VRETIRF " 
AAdd(aCampos,"E2_PRETIRF") 
AAdd(aCampos,"E2_VRETIRF") 

cQuery += " FROM "+ RetSqlName( "SE2" ) + " SE2 " 
cQuery += "WHERE "                     

//Carrega as filiais do filtro
cQryFil := "("

For nLoop := 1 to Len( aFil10925 ) 
	cQryFil += "E2_FILIAL='" + aFil10925[ nLoop ] + "' OR "
Next nLoop 						                                

cQryFil := Left( cQryFil, Len( cQryFil ) - 3 ) 

cQryFil  += ") AND " 

cQuery += cQryFil 

cQuery += "E2_FORNECE='"  + cA100For            + "' AND " 	
cQuery += "E2_LOJA='"     + cLoja               + "' AND "
cQuery += "E2_VENCREA>='" + DToS( dDataIni )     + "' AND "		
cQuery += "E2_VENCREA<='" + DToS( dDataFim )     + "' AND "
cQuery += "E2_TIPO NOT IN " + FormatIn(MVABATIM,"|") + " AND "	                    
cQuery += "E2_TIPO NOT IN " + FormatIn(MV_CPNEG,cSepNeg)  + " AND "
cQuery += "E2_TIPO NOT IN " + FormatIn(MVPROVIS,cSepProv) + " AND "
cQuery += "E2_TIPO NOT IN " + FormatIn(MVPAGANT,cSepRec)  + " AND "

//Verifica o modo de totalizacao  
If cModTot == "2" 
	cQuery += "(E2_PIS<>0 OR E2_COFINS<>0 OR E2_CSLL<>0 ) AND "
EndIf 			

cQuery += "D_E_L_E_T_=' '"                                             

cQuery := ChangeQuery( cQuery ) 

dbUseArea( .T., "TOPCONN", TcGenQry(,,cQuery), cAliasQry, .F., .T. )

For nLoop2 := 1 To Len( aStruct ) 
	If !Empty( AScan( aCampos, AllTrim( aStruct[nLoop2,1] ) ) ) 
		TcSetField( cAliasQry, aStruct[nLoop2,1], aStruct[nLoop2,2],aStruct[nLoop2,3],aStruct[nLoop2,4])
	EndIf 			
Next nLoop2 

//Obtem os valores por ano/mes para as parcelas desta nota  
While !( cAliasQRY )->( Eof()) 

	cAnoMes := Left( DToS( ( cAliasQRY )->E2_VENCREA ), 6 ) 	
	
	If Empty( nScanMes := AScan( aDadosMes, { |x| x[1] == cAnoMes } ) )
		AAdd( aDadosMes, { cAnoMes, 0, 0, 0, 0 } ) 
		nScanMes := Len( aDadosMes ) 	
	EndIf 

	nAdic := 0
	
      nAdic += ( ( cAliasQRY )->E2_VALOR + ( cAliasQRY )->E2_ISS + ( cAliasQRY )->E2_INSS  ) 
      
	nAdic += If( Empty( ( cAliasQRY )->E2_VRETIRF ), ( cAliasQRY )->E2_IRRF, ( cAliasQRY )->E2_VRETIRF )
	
	If Empty( ( cAliasQRY )->E2_PRETPIS )
		nAdic += If( Empty( ( cAliasQRY )->E2_VRETPIS ), ( cAliasQRY )->E2_PIS, ( cAliasQRY )->E2_VRETPIS ) 
	EndIf 								

	If Empty( ( cAliasQRY )->E2_PRETCOF )
		nAdic += If( Empty( ( cAliasQRY )->E2_VRETCOF ), ( cAliasQRY )->E2_COFINS, ( cAliasQRY )->E2_VRETCOF )
	EndIf 								

	If Empty( ( cAliasQRY )->E2_PRETCSL )
		nAdic += If( Empty( ( cAliasQRY )->E2_VRETCSL ), ( cAliasQRY )->E2_CSLL, ( cAliasQRY )->E2_VRETCSL ) 
	EndIf

	aDadosMes[ nScanMes, 2 ] += nAdic

	If ( cAliasQRY )->E2_BASEPIS > 0 .Or. ( cAliasQRY )->E2_BASECOF > 0 .Or. ( cAliasQRY )->E2_BASECSL > 0
		aDadosMes[nScanMes, 3] += ( cAliasQRY )->E2_BASEPIS 
		aDadosMes[nScanMes, 4] += ( cAliasQRY )->E2_BASECOF 
		aDadosMes[nScanMes, 5] += ( cAliasQRY )->E2_BASECSL 
	Else
		aDadosMes[nScanMes, 3] += nAdic
		aDadosMes[nScanMes, 4] += nAdic
		aDadosMes[nScanMes, 5] += nAdic
	EndIf 
		
	( cAliasQRY )->( dbSkip()) 
	
   EndDo 
   
// Fecha a area de trabalho da query 
   
   ( cAliasQRY )->( dbCloseArea() ) 
   dbSelectArea( "SE2" ) 

ASort( aDadosMes, , , { |x,y| y[1] > x[1] } ) 

//Verifica se supera o valor para retencao  
For nLoop := 1 To Len( aDadosMes )

	//------------------------------------------------------------------------------------
	// Obtem a posicao do aList desta forma devido a query poder incluir um periodo
	// diferente dos gerados pelas parcelas do documento de entrada (ex. mes 04, 05 e 07)
	//-------------------------------------------------------------------------------------
	nPosParc := AScan(aList, { |x| x[2] == Right(aDadosMes[nLoop,1],2)+"/"+Left(aDadosMes[nLoop,1],4) } )

	If nPosParc > 0
		aList[ nPosParc, 1 ] := ( aDadosMes[ nLoop, 3 ] > nMinRet .Or.aDadosMes[ nLoop, 4 ] > nMinRet .Or. aDadosMes[ nLoop, 5 ] > nMinRet   ) 
	EndIf

Next nLoop              

bLine := oList:bLine
oList:SetArray(aList)
oList:bLine := bLine 

SE2->( RestArea( aAreaSE2 ) ) 

Return( .T. ) 

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³NfeComplFF ³ Autor ³Marcos V. Ferreira    ³ Data ³24/10/2005³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³ Rotina utilizada para gerar requisicao valorizada 'RE6'    ³±±
±±³          ³ sempre que for incluida  uma nota complementar com o custo ³±±
±±³          ³ Fifo ativado, onde a nota origem esta no periodo anterior. ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1 - Alias do arquivo SD1                                ³±±
±±³          ³ExpL1 - Informa se esta utilizando Custo Fifo				  |±±
±±³          ³ExpN1 - nTipo = 1 - Gera requisicao valorizada			  |±±
±±³          ³        nTipo = 2 - Pesquisa Lote Original        		  |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Logico - .T. se localizou o lote original nota complementar ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function NfeComplFF(cAlias,lCusFifo,nTipo)
Local lAjNfCompl:= SuperGetMV("MV_AJUSNFC",.F.,.F.)
Local dDtLimite	:= SuperGetMV("MV_ULMES",.F.)+1
Local aAreaAnt	:= GetArea()
Local aAreaSF4  := SF4->(GetArea())
Local aQtdLote	:= {}	
Local lGrava	:= .F.
Local lRet		:= .F.
Local nProporc  := 0
Local lM103NFC	:= ExistBlock("M103NFC")
Local cUsoD1_TRT:= GetSx3Cache("D1_TRT","X3_USADO")

Default cAlias  := "SD1"
Default lCusFifo:= .F.
Default nTipo   := 1

dbSelectArea("SF4")
dbSetOrder(1)
MsSeek(xFilial("SF4")+(cAlias)->D1_TES)	

If lAjNfCompl .And. lCusFifo .And. (cAlias)->D1_TIPO == 'C' .And. SF4->F4_ESTOQUE == 'S'
	dbSelectArea("SD8")
	dbSetOrder(3)
		If MsSeek(xFilial("SD8")+(cAlias)->D1_NFORI+(cAlias)->D1_SERIORI+(cAlias)->D1_ITEMORI) .And. SD8->D8_DTPROC < dDtLimite
		dbSelectArea("SBD")
		dbSetOrder(2)
		If MsSeek(xFilial("SBD")+SD8->D8_SEQ)
			//BD_STATUS == ' ' Lote Fifo Aberto
			//BD_STATUS == 'Z' Lote Fifo Encerrado
			If nTipo == 1 .And. SBD->BD_STATUS == ' '
				aQtdLote := CalcEstFF( (cAlias)->D1_COD,(cAlias)->D1_LOCAL,dDtLimite,Nil,Nil,SBD->BD_SEQ)
				If aQtdLote[1] == SBD->BD_QUANT
                      lGrava := .F. //Qtde do Lote Fifo ainda nao utilizada
				Else
					//Formula: Qtde Inicial do Lote - Qtde Atual do Lote / Qtde Inicial do Lote
					nProporc := (SBD->BD_QUANT-aQtdLote[1])/SBD->BD_QUANT 
					lGrava   := .T.
				EndIf	
			ElseIf nTipo == 1 .And. SBD->BD_STATUS == 'Z'
				nProporc := 1
				lGrava   := .T.
			ElseIf nTipo == 2
				lRet := .T.
			EndIf	
		EndIf	
	EndIf

	//Ponto de Entrada para validar a gravacao da requisicao valorizada
	If lM103NFC
		lGrava := ExecBlock("M103NFC",.F.,.F.,{lGrava .And. nTipo == 1,nProporc})
	EndIf

EndIf

//Gravacao da requisicao valorizada para consumir o custo da nota de complemento de preco
If lGrava .And. nTipo == 1
	RecLock("SD3",.T.)
	SD3->D3_FILIAL	:= xFilial("SD3")
	SD3->D3_COD		:= (cAlias)->D1_COD
	SD3->D3_QUANT	:= (cAlias)->D1_QUANT
	SD3->D3_TM		:= "999"
	SD3->D3_OP		:= (cAlias)->D1_OP
	SD3->D3_LOCAL	:= (cAlias)->D1_LOCAL
	SD3->D3_DOC		:= (cAlias)->D1_DOC
	SD3->D3_EMISSAO	:= (cAlias)->D1_DTDIGIT
	SD3->D3_NUMSEQ	:= (cAlias)->D1_NUMSEQ
	SD3->D3_UM		:= (cAlias)->D1_UM
	SD3->D3_GRUPO	:= (cAlias)->D1_GRUPO
	SD3->D3_TIPO	:= (cAlias)->D1_TP
	SD3->D3_SEGUM	:= (cAlias)->D1_SEGUM
	SD3->D3_CONTA	:= (cAlias)->D1_CONTA
	SD3->D3_CF		:= "RE6"
	SD3->D3_QTSEGUM	:= (cAlias)->D1_QTSEGUM
	SD3->D3_USUARIO	:= CUSERNAME
	SD3->D3_CUSTO1	:= (cAlias)->D1_CUSTO  * nProporc
	SD3->D3_CUSTO2	:= (cAlias)->D1_CUSTO2 * nProporc
	SD3->D3_CUSTO3	:= (cAlias)->D1_CUSTO3 * nProporc
	SD3->D3_CUSTO4	:= (cAlias)->D1_CUSTO4 * nProporc
	SD3->D3_CUSTO5	:= (cAlias)->D1_CUSTO5 * nProporc
	SD3->D3_NUMLOTE	:= (cAlias)->D1_NUMLOTE
	SD3->D3_LOTECTL	:= (cAlias)->D1_LOTECTL
	SD3->D3_DTVALID	:= (cAlias)->D1_DTVALID
	SD3->D3_POTENCI := (cAlias)->D1_POTENCI
	If X3Uso(cUsoD1_TRT)
		SD3->D3_TRT	:= (cAlias)->D1_TRT
	EndIf
	dbSelectArea("SB2")
	B2AtuComD3({SD3->D3_CUSTO1,SD3->D3_CUSTO2,SD3->D3_CUSTO3,SD3->D3_CUSTO4,SD3->D3_CUSTO5})
EndIf

RestArea(aAreaSF4)
RestArea(aAreaAnt)
Return lRet       

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³A103GCDisp³ Autor ³ Sergio Silveira       ³ Data ³ 03/03/2006 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³ Indica se o produto gestao de contratos esta disponivel      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ ExpL1 -> Indicao disponibilidade                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ ATUALIZACOES SOFRIDAS DESDE A CONSTRUCAO INICIAL.                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ PROGRAMADOR  ³ DATA   ³ BOPS ³  MOTIVO DA ALTERACAO                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³              ³        ³      ³                                          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/                                                                         

Function A103GCDisp() 

Local lRet := .F. 

//Verifica se possui um registro na tabela de contratos
lRet := !Empty( CN9->( LastRec() ) )

Return( lRet ) 

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³A103ChWhen³ Autor ³Rodrigo de A Sartorio  ³ Data ³ 12/06/2006 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³ Checa when dos campos de cabecalho da Pre-Nota e Nota        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/                                                                         
Function A103ChWhen(cCampo,cConteudo,lClassif)
LOCAL lRet:=.T.
LOCAL lExistBlock:=ExistBlock("MT103CWH")
// Ponto de Entrada que permite alterar o WHEN
If lExistBlock
	lRet:=Execblock("MT103CWH",.F.,.F.,{cCampo,cConteudo,lClassif})
	If ValType(lRet) # "L"
		lRet:=.T.
	EndIf
EndIf
RETURN lRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeFldNfe ³Autor  ³ Mary Hergert          ³ Data ³10/07/2006 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de tratamento do folder da nota fiscal eletronica     ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpO1: Objeto da Janela que sera disponibilizado os Get      ³±±
±±³          ³ExpA2: Array com os gets da NF-e                             ³±±
±±³          ³ExpA3: Array com as posicoes dos gets da NF-e                ³±±
±±³          ³Expb4: Codeblock para atualizaco dos dados do Folder         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeFldNfe(oDlg,aNFEletr,aPosGet,bRefresh)

Local aObjetos	:= Array(Len(aNFEletr))                     
Local nHRes     := oMainWnd:nClientWidth
Local lfndVldCpo := FindFunction("COMXVLDCPO")

If cPaisLoc == "BRA"
	If !(lfndVldCpo .and.  Empty(COMXVLDCPO({"F1_NFELETR"},1))) //verifica se o campo esta como usado.
		@ 09,aPosGet[1,1] SAY STR0258 Of oDlg PIXEL SIZE 48,12 //"Numero NF Eletr"
		@ 08,aPosGet[1,2] MSGET aObjetos[01] VAR aNFEletr[01] ;
			PICTURE PesqPict("SF1","F1_NFELETR") ;
			OF oDlg PIXEL ;
			WHEN !l103Visual .And. VisualSX3("F1_NFELETR");     
			VALID CheckSX3("F1_NFELETR",aNFEletr[01]);
			SIZE 80,09 HASBUTTON
		aObjetos[01]:cSX1Hlp := "F1_NFELETR"	
	EndIf

	@ 26,aPosGet[1,1] SAY OemToAnsi(STR0058) Of oDlg PIXEL SIZE 48,12
	@ 25,aPosGet[1,2] MSGET aObjetos[03] VAR aNFEletr[03] ;
		PICTURE PesqPict("SF1","F1_EMINFE") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_EMINFE");
		VALID A103NFe('EMINFE',aNFEletr) .And. CheckSX3("F1_EMINFE",aNFEletr[03]);
		SIZE 80,09 HASBUTTON
	aObjetos[03]:cSX1Hlp := "F1_EMINFE"	
	
	@ 26,IIF(nHRes <= 800, aPosGet[1,3]+10, aPosGet[1,3]) SAY OemToAnsi(STR0059) Of oDlg PIXEL SIZE 48,12
	@ 25,IIF(nHRes <= 800, aPosGet[1,4]+15, aPosGet[1,4]) MSGET aObjetos[04] VAR aNFEletr[04] ;
		PICTURE PesqPict("SF1","F1_HORNFE") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_HORNFE");
		VALID CheckSX3("F1_HORNFE",aNFEletr[04]);
		SIZE 80,9	HASBUTTON
	aObjetos[04]:cSX1Hlp := "F1_HORNFE"
	
	@ 43,aPosGet[1,1] SAY OemToAnsi(STR0061) Of oDlg PIXEL SIZE 48,12
	@ 42,aPosGet[1,2] MSGET aObjetos[05] VAR aNFEletr[05] ;
		PICTURE PesqPict("SF1","F1_CREDNFE") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_CREDNFE");
		VALID A103NFe('CREDNFE',aNFEletr) .And. CheckSX3("F1_CREDNFE",aNFEletr[05]);
		SIZE 80,09 HASBUTTON
	aObjetos[05]:cSX1Hlp := "F1_CREDNFE"	
	
	@ 43,IIF(nHRes <= 800, aPosGet[1,3]+10, aPosGet[1,3]) SAY OemToAnsi(STR0063) Of oDlg PIXEL SIZE 48,12
	@ 42,IIF(nHRes <= 800, aPosGet[1,4]+15, aPosGet[1,4]) MSGET aObjetos[06] VAR aNFEletr[06] ;
		PICTURE PesqPict("SF1","F1_NUMRPS") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_NUMRPS");
		VALID CheckSX3("F1_NUMRPS",aNFEletr[06]);
		SIZE 80,09 HASBUTTON
	aObjetos[06]:cSX1Hlp := "F1_NUMRPS"	
	             
	@ 43,IIF(nHRes <= 800, aPosGet[1,3]+10, aPosGet[1,5]) SAY OemToAnsi(STR0060) Of oDlg PIXEL SIZE 48,12
   	@ 42,IIF(nHRes <= 800, aPosGet[1,4]+15, aPosGet[1,6]) MSGET aObjetos[02] VAR aNFEletr[02] ;
		PICTURE PesqPict("SF1","F1_CODNFE") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_CODNFE");       
		VALID CheckSX3("F1_CODNFE",aNFEletr[02]) .And. ( If(A103CONNFS(aNFEletr[02]), ,( aNFEletr[02] := Space(50),M->F1_CODNFE := Space(50),aObjetos[02]:refresh() ) ),.T. );
		SIZE IIF(nHRes <= 800, 95, 185),09 HASBUTTON
	aObjetos[02]:cSX1Hlp := "F1_CODNFE"

	   If !(lfndVldCpo .and.  Empty(COMXVLDCPO({"F1_MENNOTA"},1))) //verifica se o campo esta como usado.          
			@ 09,IIF(nHRes <= 800, aPosGet[1,5]+30, aPosGet[1,5]) SAY OemToAnsi(STR0104) Of oDlg PIXEL SIZE 48,12
			@ 08,IIF(nHRes <= 800, aPosGet[1,6]+30, aPosGet[1,6]) MSGET aObjetos[07] VAR aNFEletr[07] ;
				PICTURE PesqPict("SF1","F1_MENNOTA") ;
				OF oDlg PIXEL ;
				WHEN !l103Visual .And. VisualSX3("F1_MENNOTA");
				SIZE IIF(nHRes <= 800, 95, 185),09 HASBUTTON
				aObjetos[07]:cSX1Hlp := "F1_MENNOTA"	 
		EndIf
		If !(lfndVldCpo .and.  Empty(COMXVLDCPO({"F1_MENPAD"},1))) //verifica se o campo esta como usado.          
			@ 26,IIF(nHRes <= 800, aPosGet[1,5]+30, aPosGet[1,5]) SAY OemToAnsi(STR0105) Of oDlg PIXEL SIZE 48,12
			@ 25,IIF(nHRes <= 800, aPosGet[1,6]+30, aPosGet[1,6]) MSGET aObjetos[08] VAR aNFEletr[08] ;
				PICTURE PesqPict("SF1","F1_MENPAD") ;
				OF oDlg PIXEL ;
				WHEN !l103Visual .And. VisualSX3("F1_MENPAD");
				VALID VALIDSM4(aNFEletr);
				F3 "SM4";
				SIZE 20,09 HASBUTTON
			aObjetos[08]:cSX1Hlp := "F1_MENPAD"	 
		EndIf
Endif

Return(.T.)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³A103NFe   ³ Autor ³Mary C. Hergert        ³ Data ³29/06/2006³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Valida campos da Nota Fiscal Eletronica de Sao Paulo        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³A103NFe(cExp01,aExp01)                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cExp01: Campo a ser validado                                ³±±
±±³          ³aExp01: Array com as variaveis de memoria                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T.                                                         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A103NFe(cCampo,aNFEletr)

Local lRet := .T.

If cPaisLoc == "BRA"
	If cCampo == "EMINFE"    
		If !Empty(aNFEletr[03]) .And. aNFEletr[03] < dDEmissao
			Help("",1,"A100NFEDT")	
			lRet := .F.
		Endif
	ElseIf cCampo == "CREDNFE"
		If aNFEletr[05] < 0
			Help("",1,"A100NFECR")	
			lRet := .F.
		Endif
	Endif
Endif

Return lRet
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³a103xLAICMS³ Autor ³ Gustavo G. Rueda      ³ Data ³05/12/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Funcao para montagem do GETDADOS do folder de lancamentos   ³±±
±±³          ³ fiscais.                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³oLancApICMS -> Objeto criado pelo MSNEWGETDADOS             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³oDlg -> Objeto pai onde o GETDADOS serah criado.            ³±±
±±³          ³aPos -> posicoes de criacao do objeto.                      ³±±
±±³          ³aHeadCDA -> array com o HEADER da tabela CDA                ³±±
±±³          ³aColsCDA -> array com o ACOLS da tabela CDA                 ³±±
±±³          ³lVisual -> Flag de visualizacao                             ³±±
±±³          ³lInclui -> Flag de inclusao                                 ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function a103xLAICMS(oDlg,aPos,aHeadCDA,aColsCDA,lVisual,lInclui)
Local	oLancApICMS
Local	bCond		:=	{||.T.}
Local	bSkip		:=	{|| CDA->CDA_TPREG == "NA" }
Local	cVisual		:=	Iif(lVisual,"'1'","'2'")
Local	cFormulBkp	:=	cFormul
Local	aCmpsCDA	:=	{"CDA_NUMITE","CDA_CODLAN","CDA_BASE","CDA_ALIQ","CDA_VALOR"}
Local aArea		:= GetArea()
Local cSerieId  := SerieNfId("SD1",4,"D1_SERIE",dDEmissao,cEspecie,cSerie)
Local lCalcCDV  := Type("oLancCDV")=="O" 
Local nbtnCDV	:= Iif(lCalcCDV, 45,0)

//Campo criado pelo compatibilizador UPDFIS
aAdd(aCmpsCDA,"CDA_IFCOMP")
//Campo complemento para registro 0460 campo 3
If cPaisLoc == "BRA"
	aAdd(aCmpsCDA,"CDA_CLANC")
EndIf

If CDA->(FieldPos("CDA_VLOUTR")) > 0 .And. CDA->(FieldPos("CDA_TXTDSC")) > 0 .And. CDA->(FieldPos("CDA_CODCPL")) > 0 .And. CDA->(FieldPos("CDA_CODMSG")) > 0
	aAdd(aCmpsCDA,"CDA_VLOUTR")
	 aAdd(aCmpsCDA,"CDA_TXTDSC")
	aAdd(aCmpsCDA,"CDA_CODCPL")
	aAdd(aCmpsCDA,"CDA_CODMSG")
Endif	

aMHead("CDA","CDA_TPMOVI/CDA_ESPECI/CDA_FORMUL/CDA_NUMERO/CDA_SERIE/CDA_CLIFOR/CDA_LOJA/CDA_GUIA",@aHeadCDA)
If lVisual
	dbSelectArea("CDA")
	CDA->(dbSetOrder(1))
	If !CDA->(MsSeek(xFilial("CDA")+"E"+cEspecie+cFormul+cNFiscal+cSerieId+cA100For+cLoja)) .And. cFormul=="N"	//tratamento implementado devido ao default do mata103 para o cformul ser "N", porem as tabelas para N podem gravar branco ou N.
		cFormul	:=	" "
	CDA->(MsSeek(xFilial("CDA")+"E"+cEspecie+cFormul+cNFiscal+cSerieId+cA100For+cLoja))
	EndIf
	bCond	:=	{||xFilial("CDA")+"E"+cEspecie+cFormul+cNFiscal+cSerieId+cA100For+cLoja==CDA->(CDA_FILIAL+CDA_TPMOVI+CDA_ESPECI+CDA_FORMUL+CDA_NUMERO+CDA_SERIE+CDA_CLIFOR+CDA_LOJA)}
EndIf
aMAcols(lVisual,"CDA",@aColsCDA,aHeadCDA,bCond,bSkip)

oLancApICMS	:=	MsNewGetDados():New(aPos[1],aPos[2],aPos[4],aPos[3]-nbtnCDV,Iif(lVisual,0,GD_UPDATE+GD_INSERT+GD_DELETE),"a103xLOk","a103xLOk","+CDA_SEQ",aCmpsCDA,/*freeze*/,9999,/*fieldok*/,/*superdel*/,"LancDel("+cVisual+")",oDlg,@aHeadCDA,@aColsCDA)

If lCalcCDV
	@ aPos[1]+12,aPos[3]-nbtnCDV BUTTON STR0208 SIZE 45,11 FONT oDlg:oFont ;
	ACTION MT103CDV(.T.) OF oDlg PIXEL		   
Endif

cFormul	:=	cFormulBkp

RestArea(aArea)

Return oLancApICMS
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³aMHead    ³ Autor ³ Gustavo G. Rueda      ³ Data ³05/12/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³ Funcao para montagem do HEADER do GETDADOS                 ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T.                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cAlias -> Alias da tabela base para montagem do HEADER      ³±±
±±³          ³cNCmps -> Campos que nao serao considerados no HEADER       ³±±
±±³          ³aH -> array no qual o HEADER serah montado                  ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function aMHead(cAlias,cNCmps,aH)
Local	lRet	:=	.T.
Local	cValid	:=	""

//Salva a Integridade dos campos de Bancos de Dados
dbSelectArea("SX3")
dbSetOrder(1)
dbSeek(cAlias)
While !Eof() .And. (X3_ARQUIVO==cAlias)
	IF X3USO(X3_USADO) .And. cNivel >= X3_NIVEL .and. !(AllTrim(X3_CAMPO)+"/"$cNCmps)
		
		If AllTrim(X3_CAMPO)=="CDA_NUMITE"
			cValid	:=	"LancCpIt().And.LancCps()"
		Else
			cValid	:=	AllTrim(X3_VALID)+Iif(Empty(AllTrim(X3_VALID)),"",".And.")+"LancCps()"
		EndIf	
	
		AADD(aH,{ Trim(X3Titulo()), ;
			AllTrim(X3_CAMPO),;
			X3_PICTURE,;
			X3_TAMANHO,;
			X3_DECIMAL,;
			cValid,;
			X3_USADO,;
			X3_TIPO,;
			X3_F3,;
			X3_CONTEXT,;
			X3_CBOX,;
			X3_RELACAO})
	Endif
	dbSkip()
Enddo
Return lRet
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³aMAcols   ³ Autor ³ Gustavo G. Rueda      ³ Data ³05/12/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³ Funcao para montagem do ACOLS do GETDADOS                  ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T.                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³nOpc -> Opcao do AROTINA                                    ³±±
±±³          ³cAlias -> Alias da tabela base para montagem do HEADER      ³±±
±±³          ³aC -> array no qual o ACOLS serah montado                   ³±±
±±³          ³aH -> array no qual o HEADER serah montado                  ³±±
±±³          ³bCond -> Condicao de loop do while                          ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function aMAcols(lVisual,cAlias,aC,aH,bCond,bSkip)
Local	lRet	:=	.T.
Local	nI		:=	0

DEFAULT bSkip 	:= {|| .F. }

dbSelectArea(cAlias)
dbSetOrder(1)
If lVisual .And. !Eof()
	//Monta o array aCols com os itens
	aC	:=	{}
	While !Eof() .And. Eval(bCond)
		IF Eval(bSkip)
			dbSkip()
			Loop
		EndIf
		aAdd(aC,Array(Len(aH)+1))
		For nI := 1 To Len(aH)
			aC[Len(aC),nI] := FieldGet(FieldPos(aH[nI,2]))
		Next
		aC[Len(aC),Len(aH)+1] := .F.
		dbSkip()
	End	
Else
	aC				:=	{Array(Len(aH)+1)}
	aC[1,Len(aH)+1]	:=	.F.
	For nI := 1 To Len(aH)
		If aH[nI,10]#"V"
			aC[1,nI]	:=	CriaVar(aH[nI,2])
		EndIf

		If "_SEQ"$aH[nI,2]
			aC[1,nI]	:=	StrZero(1,aH[nI,4])
		EndIf
	Next	
EndIf
Return lRet
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³LancDel   ³ Autor ³ Gustavo G. Rueda      ³ Data ³13/12/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Funcao para validar a delecao do lancamento fiscal do docu- ³±±
±±³          ³ mento criado pelo sistema.                                 ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T. ou .F.                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cVisual -> indica se a nota esta sendo visualizada. 1=Sim,  ³±±
±±³          ³ 2=Nao                                                      ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function LancDel(cVisual)
Local	lRet	:=	.T.
Local	nPosCalc:=	0
Local	nPosIt	:=	0
Local 	nPosItD1:= 	0
Local	nPos	:=	0

If Type("oLancApICMS")=="O" .And. cVisual=="2"
	nPosCalc:=	aScan(oLancApICMS:aHeader,{|aX|aX[2]=="CDA_CALPRO"})
	nPosIt	:=	aScan(oLancApICMS:aHeader,{|aX|aX[2]=="CDA_NUMITE"})
	
	If nPosCalc>0 .And. oLancApICMS:aCols[oLancApICMS:nAT,nPosCalc]=="1"
		//Registros calculados pelo sistema não poderão ser excluídos, pois serão utilizados como log da rotina.
		//Caso seja necessário alterar este cálculo, basta inserir novos itens nesta opção de ajuste ou utitlizar a funcionalidade de Gerenciamento dos Lançamentos Fiscais de ICMS. Vale ressaltar que na Apuração de ICMS será considerada a sequência maior de cada lançamento fiscal do documento.
		Help("  ",1,"LAICMSDEL1")	
		lRet	:=	.F.
	
	ElseIf nPosCalc>0 .And. oLancApICMS:aCols[oLancApICMS:nAT,nPosCalc]=="2" .And. Type("aColsD1")=="A" .And. Type("aHeadD1")="A"
		nPosItD1:= 	GetPosSD1("D1_ITEM")	
		
		If nPosItD1>0 .And. nPosIt>0
			nPos	:=	aScan(aColsD1,{|aX|PadR(aX[nPosItD1],TamSx3("CDA_NUMITE")[1])==oLancApICMS:aCols[oLancApICMS:nAT,nPosIt].And.!aX[Len(aColsD1[1])]})
			If nPos==0
				//Este registro não pode ser recuperado, pois o mesmo encontra-se excluído juntamente com seu respectivo item do documento fiscal.
				//Para se recuperar este registro é necessário que se tenha o respectivo item deste documento fiscal ativado.
				Help("  ",1,"LAICMSDEL2")
				lRet	:=	.F.
			EndIf
		EndIf
	EndIf
EndIf
Return lRet
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³LancCpIt  ³ Autor ³ Gustavo G. Rueda      ³ Data ³13/12/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Funcao para validar o item digitado no lancamento fiscal com³±±
±±³          ³ os itens do documento fiscal.                              ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T. ou .F.                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum                                                      ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function LancCpIt()
Local	lRet	:=	.T.
Local	nPosCalc:=	0
Local	nPosItD1:=	0

If Type("oLancApICMS")=="O"

	nPosCalc:=	aScan(oLancApICMS:aHeader,{|aX|aX[2]=="CDA_CALPRO"})

	If nPosCalc>0 .And. oLancApICMS:aCols[oLancApICMS:nAT,nPosCalc]=="2" .And. Type("aColsD1")=="A" .And. Type("aHeadD1")="A"
		nPosItD1:= 	GetPosSD1("D1_ITEM")
		If nPosItD1>0
			nPos	:=	aScan(aColsD1,{|aX|aX[nPosItD1]==M->CDA_NUMITE.And.!aX[Len(aColsD1[1])]})
			If nPos==0
				//Número do item é inválido para este lançamento fiscal.
				//Deve-se informar um número de item existente no respectivo documento fiscal.
				Help("  ",1,"LAICMSCMP1")
				lRet	:=	.F.
			EndIf
		EndIf
	EndIf
EndIf
Return lRet
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³LancCps   ³ Autor ³ Gustavo G. Rueda      ³ Data ³13/12/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Funcao para validar os campos alimentados pelo sistema que  ³±±
±±³          ³ nao poderao ser alterados.                                 ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T. ou .F.                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum                                                      ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function LancCps()
Local	lRet	:=	.T.
Local	nPosCalc:=	0

If Type("oLancApICMS")=="O"
	nPosCalc:=	aScan(oLancApICMS:aHeader,{|aX|aX[2]=="CDA_CALPRO"})
	If nPosCalc>0 .And. oLancApICMS:aCols[oLancApICMS:nAT,nPosCalc]=="1"
		//Registros calculados pelo sistema não poderão ser alterados, pois serão utilizados como log da rotina.
		//Caso seja necessário alterar este cálculo, basta inserir novos itens nesta opção de ajuste ou utitlizar a funcionalidade de Gerenciamento dos Lançamentos Fiscais de ICMS. Vale ressaltar que na Apuração de ICMS será considerada a sequência maior de cada lançamento fiscal do documento.
		Help("  ",1,"LAICMSCMP2")
		lRet	:=	.F.
	EndIf
EndIf

Return lRet
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³a103xLOk  ³ Autor ³ Gustavo G. Rueda      ³ Data ³13/12/2007³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Funcao para validar a linha do acols de lancamentos         ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T. ou .F.                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum                                                      ³±±
±±³          ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³   DATA   ³ Programador   ³Manutencao efetuada                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³               ³                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function a103xLOk()
Local	lRet	:=	.T.
Local	nPosLanc:=	0
Local	nPosVlr	:=	0
Local	nNumIte	:=	0
Local	nPosCal	:=	0
Local	lCalPro	:=	.T.

If Type("oLancApICMS")=="O"
	nPosLanc:=	aScan(oLancApICMS:aHeader,{|aX|aX[2]=="CDA_CODLAN"})
	nPosVlr:=	aScan(oLancApICMS:aHeader,{|aX|aX[2]=="CDA_VALOR"})
	nNumIte:=	aScan(oLancApICMS:aHeader,{|aX|aX[2]=="CDA_NUMITE"})
	nPosCal:=	aScan(oLancApICMS:aHeader,{|aX|aX[2]=="CDA_CALPRO"})

	If !oLancApICMS:aCols[oLancApICMS:nAT,Len(oLancApICMS:aCols[oLancApICMS:nAT])] .And.;
		!Empty(oLancApICMS:aCols[oLancApICMS:nAT,nNumIte])

		If nPosLanc>0 .And. Empty(oLancApICMS:aCols[oLancApICMS:nAT,nPosLanc])
			Help(1," ","OBRIGAT",,"CDA_CODLAN"+Space(30),3,0)
			lRet	:=	.F.
		EndIf

		If nPosCal > 0
			lCalPro:= oLancApICMS:aCols[oLancApICMS:nAT,nPosCal] =='2' //Calc pelo usuario
		Endif

		If lRet .And. nPosLanc > 0 .And. nPosVlr > 0 .And. Empty(oLancApICMS:aCols[oLancApICMS:nAT,nPosVlr]) .And. lCalPro
			Help(1," ","OBRIGAT",,"CDA_VALOR"+Space(30),3,0)
			lRet	:=	.F.
		EndIf
	EndIf
			
	If nPosLanc > 0 .And. nNumIte > 0 .And. !Empty(oLancApICMS:aCols[oLancApICMS:nAT,nPosLanc]) .And. Empty(oLancApICMS:aCols[oLancApICMS:nAT,nNumIte])
		Help(1," ","OBRIGAT",,"CDA_NUMITE"+Space(30),3,0)
		lRet	:=	.F.
	EndIf

EndIf
Return lRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeFlddIV ³Autor  ³ Microsiga S/A         ³ Data ³09/09/2008 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de tratamento do folder para informacoes diversas     ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpO1: Objeto da Janela que sera disponibilizado os Get      ³±±
±±³          ³ExpA1: Array com as posicoes dos gets da NF-e                ³±±
±±³          ³ExpB1: Codeblock para atualizaco dos dados do Folder         ³±± 
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeFldDiv(oDlg,aPosGet,bRefresh)
Local lDigChv := GetNewPar("MV_DCHVNFE",.F.)
Local aObjetos	:= Array(Len(aNFEDanfe))   
Local nrFolder  := 9		//posicao do folder       
Local nTamGetFor:= (TamSX3("A2_COD")[1])
Local aCombo	:= CarregaTipoFrete()    
Local aComboCTE := {}
Local aComboMod := {}
Local aComboMne := {}
Local cCar      := "QWERTYUIOPASDFGHJKLZXCVBNM0123456789"
Local nPosLojaRet := 0
Local nPsTpcTe  := 0
Local nPsTpFrt	:= 0
Local nPsModal	:= 0
Local cChvEspe  := ""
Local cCompara  := "|SPED|CTE|"
Local lMT103DCF := ExistBlock("MT103DCF")
Local lfndVldCpo := FindFunction("COMXVLDCPO")

If lDigChv
	cChvEspe := SuperGetMV( "MV_CHVESPE" , .F. , "" )
	cChvEspe := StrTran(cChvEspe,",","|")
	cChvEspe := StrTran(cChvEspe,";","|")
	
	If !Empty( cChvEspe )
		cCompara += cChvEspe + "|"
	EndIf
EndIF

// Caso a aba "Lançamentos da Apuração de ICMS" esteja ativa a posição da aba Danfe e modificada para 10
If cPaisLoc == "BRA" .And. Type('l103Class')=="L" .And.;
   l103Class .And. AliasInDic("CDA")
	nrFolder  := 10
EndIf
			
If TamSX3("A2_COD")[1]< 9 
	nTamGetFor:=(6*TamSX3("A2_COD")[1])
ElseIf TamSX3("A2_COD")[1]< 15
	nTamGetFor:=(4.8*TamSX3("A2_COD")[1])
Else
	nTamGetFor:=(4*TamSX3("A2_COD")[1])
EndIf

aComboCte := LoadX3Arr("F1_TPCTE")
If !Empty(aNFEDanfe[18])
	If l103Visual .Or. (Type('l103Class')=="L" .And. l103Class)
		nPsTpcTe := aScan(aComboCte ,{|x| AllTrim(Substr(x,1)) == AllTrim(aNFEDanfe[18])})
	Else
		nPsTpcTe := aScan(aComboCte ,{|x| AllTrim(Substr(x,1,1)) == AllTrim(aNFEDanfe[18])})
	Endif 		            
EndIf	
nPsTpcTe := Max(1,nPsTpcTe)

If !Empty(aNFEDanfe[14])
	nPsTpFrt := aScan(aCombo ,{|x| Substr(x,1,1) == Substr(aNFEDanfe[14],1,1)})		            
EndIf
nPsTpFrt := Max(1, nPsTpFrt)

aComboMod := LoadX3Arr("F1_MODAL")
If !Empty(aNFEDanfe[23])
	nPsModal := ascan(aComboMod ,{|x| Substr(x,1,2) == Substr(aNFEDanfe[23],1,2)})
Endif
nPsModal := Max(1, nPsModal)

aComboMne := LoadX3Arr("F1_DEVMERC", {|x| SubStr(x,5,3)})

If Type("aNFEDanfe") == "A"       

	@ 05,aPosGet[1,1] SAY STR0074 Of oDlg PIXEL SIZE 32,12    // Cod. Transp
	@ 04,aPosGet[1,2] MSGET aObjetos[01] VAR aNFEDanfe[01] ;
		PICTURE X3Picture("F1_TRANSP") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_TRANSP");  
	   	VALID IIF(Len(Trim(aNFEDanfe[01]))>0,CheckSX3("F1_TRANSP",aNFEDanfe[01]),.T.);
	   	F3 "SA4";
		SIZE 50,08 HASBUTTON
	aObjetos[01]:cSX1Hlp    := "F1_TRANSP"	   
	aObjetos[01]:bLostFocus := { || IIf( Len(Trim(aNFEDanfe[01]))>0 .And. CheckSX3("F1_TRANSP",aNFEDanfe[01]),{oFolder:nOption := nrFolder},"")}
	If !(lfndVldCpo .and.  Empty(COMXVLDCPO({"F1_PLACA"},1))) //verifica se o campo esta como usado.
		@ 05,aPosGet[1,3] SAY STR0075 Of oDlg PIXEL SIZE 30,12   // Placa
		@ 04,aPosGet[1,4] MSGET aObjetos[12] VAR aNFEDanfe[12] ;
			PICTURE X3Picture("F1_PLACA") ;
			OF oDlg PIXEL ;
			WHEN !l103Visual .And. VisualSX3("F1_PLACA") ;
			VALID CheckSX3("F1_PLACA",aNFEDanfe[12]) .And. A103VldCpo(aNFEDanfe[12],cCar,1);
			SIZE 30,08 HASBUTTON
		aObjetos[12]:cSX1Hlp := "F1_PLACA"  
		aObjetos[12]:bLostFocus := { || IIf(!A103VldCpo(aNFEDanfe[12],cCar,1),{oFolder:nOption := nrFolder},"")}
	Endif
	If !(lfndVldCpo .and.  Empty(COMXVLDCPO({"F1_ESPECI1"},1))) //verifica se o campo esta como usado.
		@ 17,aPosGet[1,1] SAY STR0078 Of oDlg PIXEL SIZE 32,12  // Especie 1
		@ 16,aPosGet[1,2] MSGET aObjetos[04] VAR aNFEDanfe[04] ;
			PICTURE X3Picture("F1_ESPECI1") ;
			OF oDlg PIXEL ;
			WHEN !l103Visual .And. VisualSX3("F1_ESPECI1");
			VALID CheckSX3("F1_ESPECI1",aNFEDanfe[04]);
			SIZE 50,08 HASBUTTON
		aObjetos[04]:cSX1Hlp := "F1_ESPECI1"
	Endif

	If !(lfndVldCpo .and.  Empty(COMXVLDCPO({"F1_VOLUME1"},1))) //verifica se o campo esta como usado.
		@ 17,aPosGet[1,3] SAY STR0082 Of oDlg PIXEL SIZE 32,12   // Volume 1
		@ 16,aPosGet[1,4] MSGET aObjetos[05] VAR aNFEDanfe[05] ;
			PICTURE X3Picture("F1_VOLUME1") ;
			OF oDlg PIXEL ;
			WHEN !l103Visual .And. VisualSX3("F1_VOLUME1");
			VALID CheckSX3("F1_VOLUME1",aNFEDanfe[05]);
			SIZE 50,08 HASBUTTON
		aObjetos[05]:cSX1Hlp := "F1_VOLUME1"
	EndIf
	If !(lfndVldCpo .and.  Empty(COMXVLDCPO({"F1_ESPECI2"},1))) //verifica se o campo esta como usado.
		@ 29,aPosGet[1,1] SAY STR0079 Of oDlg PIXEL SIZE 32,12  // Especie 2
		@ 28,aPosGet[1,2] MSGET aObjetos[06] VAR aNFEDanfe[06] ;
			PICTURE X3Picture("F1_ESPECI2") ;
			OF oDlg PIXEL ;
			WHEN !l103Visual .And. VisualSX3("F1_ESPECI2");
			VALID CheckSX3("F1_ESPECI2",aNFEDanfe[06]);
			SIZE 50,08 HASBUTTON
		aObjetos[06]:cSX1Hlp := "F1_ESPECI2"
	EndIf
	If !(lfndVldCpo .and.  Empty(COMXVLDCPO({"F1_VOLUME2"},1))) //verifica se o campo esta como usado.
		@ 29,aPosGet[1,3] SAY STR0083 Of oDlg PIXEL SIZE 32,12  // Volume 2
		@ 28,aPosGet[1,4] MSGET aObjetos[07] VAR aNFEDanfe[07] ;
			PICTURE X3Picture("F1_VOLUME2") ;
			OF oDlg PIXEL ;
			WHEN !l103Visual .And. VisualSX3("F1_VOLUME2");
			VALID CheckSX3("F1_VOLUME2",aNFEDanfe[07]);
			SIZE 50,08 HASBUTTON
		aObjetos[07]:cSX1Hlp := "F1_VOLUME2"	
	EndIf
	If !(lfndVldCpo .and.  Empty(COMXVLDCPO({"F1_ESPECI3"},1))) //verifica se o campo esta como usado.
		@ 41,aPosGet[1,1] SAY STR0080 Of oDlg PIXEL SIZE 32,12  // Especie 3
		@ 40,aPosGet[1,2] MSGET aObjetos[08] VAR aNFEDanfe[08] ;
			PICTURE X3Picture("F1_ESPECI3") ;
			OF oDlg PIXEL ;
			WHEN !l103Visual .And. VisualSX3("F1_ESPECI3");
			VALID CheckSX3("F1_ESPECI3",aNFEDanfe[08]);
			SIZE 50,08 HASBUTTON
		aObjetos[08]:cSX1Hlp := "F1_ESPECI3"
	EndIf
	If !(lfndVldCpo .and.  Empty(COMXVLDCPO({"F1_VOLUME3"},1))) //verifica se o campo esta como usado.
		@ 41,aPosGet[1,3] SAY STR0084 Of oDlg PIXEL SIZE 32,12  // Volume 3
		@ 40,aPosGet[1,4] MSGET aObjetos[09] VAR aNFEDanfe[09] ;
			PICTURE X3Picture("F1_VOLUME3") ;
			OF oDlg PIXEL ;
			WHEN !l103Visual .And. VisualSX3("F1_VOLUME3");
			VALID CheckSX3("F1_VOLUME3",aNFEDanfe[09]);
			SIZE 50,08 HASBUTTON
		aObjetos[09]:cSX1Hlp := "F1_VOLUME3"
	EndIf
	If !(lfndVldCpo .and.  Empty(COMXVLDCPO({"F1_ESPECI4"},1))) //verifica se o campo esta como usado.

	@ 53,aPosGet[1,1] SAY STR0081 Of oDlg PIXEL SIZE 32,12   // Especie 4
	@ 52,aPosGet[1,2] MSGET aObjetos[10] VAR aNFEDanfe[10] ;
		PICTURE X3Picture("F1_ESPECI4") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_ESPECI4");
		VALID CheckSX3("F1_ESPECI4",aNFEDanfe[10]);
		SIZE 50,08 HASBUTTON
	aObjetos[10]:cSX1Hlp := "F1_ESPECI4"
	EndIf
	If !(lfndVldCpo .and.  Empty(COMXVLDCPO({"F1_VOLUME4"},1))) //verifica se o campo esta como usado.
	@ 53,aPosGet[1,3] SAY STR0085 Of oDlg PIXEL SIZE 32,12  // Volume 4
	@ 52,aPosGet[1,4] MSGET aObjetos[11] VAR aNFEDanfe[11] ;
		PICTURE X3Picture("F1_VOLUME4") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_VOLUME4");
		VALID CheckSX3("F1_VOLUME4",aNFEDanfe[11]);
		SIZE 50,08 HASBUTTON
	aObjetos[11]:cSX1Hlp := "F1_VOLUME4"
	EndIf
	@ 05,aPosGet[1,5] SAY STR0111 Of oDlg PIXEL SIZE 32,12  // Chave NFE
	@ 04,aPosGet[1,6] MSGET aObjetos[13] VAR aNFEDanfe[13] ;
		PICTURE "@!" ;
		OF oDlg PIXEL ;
		WHEN !l103Visual.And. VisualSX3("F1_CHVNFE") .And. BloqCpNFE(Alltrim(cEspecie)) .And. IIF(lDigChv, (cFormul == "N" .And. ("|" + AllTrim(cEspecie) + "|" $ cCompara)) ,.T.) ;
		VALID (If(A103ConsNfeSef(),,(aNFEDanfe[13] := Space(44),M->F1_CHVNFE := Space(44),aObjetos[13]:refresh())),.T.);
		SIZE 195,08 HASBUTTON
	aObjetos[13]:cSX1Hlp := "F1_CHVNFE"
	If(lLGPD,OfuscaLGPD(aObjetos[13],"F1_CHVNFE"),.F.)   

	@ 17,aPosGet[1,5] SAY STR0077 Of oDlg PIXEL SIZE 32,12  // Peso Bruto
	@ 16,aPosGet[1,6] MSGET aObjetos[03] VAR aNFEDanfe[03] ;
		PICTURE X3Picture("F1_PBRUTO") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_PBRUTO");
		VALID CheckSX3("F1_PBRUTO",aNFEDanfe[03]);
		SIZE 50,08 HASBUTTON
	aObjetos[03]:cSX1Hlp := "F1_PBRUTO"	

	@ 29,aPosGet[1,5] SAY STR0076 Of oDlg PIXEL SIZE 32,12    // Peso Liquido
	@ 28,aPosGet[1,6] MSGET aObjetos[02] VAR aNFEDanfe[02] ;
		PICTURE X3Picture("F1_PLIQUI") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_PLIQUI");       
		VALID CheckSX3("F1_PLIQUI",aNFEDanfe[02]);
		SIZE 50,08 HASBUTTON
	aObjetos[02]:cSX1Hlp := "F1_PLIQUI"


	If !(lfndVldCpo .and. Empty(COMXVLDCPO({"F1_FORRET"},1))) //verifica se o campo esta como usado.
		@ 41,aPosGet[1,5] SAY OemToAnsi(IIF((cTipo$"DB" .Or. A103RtCliRT(cTipo, cTpCompl, cFormul)),STR0163,STR0115)) Of oDlg PIXEL SIZE 40,12          
		@ 40,aPosGet[1,6] MSGET aObjetos[16] VAR aNFEDanfe[16] ;
			PICTURE X3Picture("F1_FORRET") ;
			OF oDlg PIXEL ;
			WHEN !l103Visual .And. VisualSX3("F1_FORRET");       
			VALID CheckSX3("F1_FORRET",aNFEDanfe[16]) .And. NfeFornece(cTipo,@aNFEDanfe[16],@aNFEDanfe[17]);
			F3 CpoRetF3("F1_FORRET");
			SIZE nTamGetFor,08 HASBUTTON
		aObjetos[16]:cSX1Hlp := "F1_FORRET"
	Endif

	If !(lfndVldCpo .and.  Empty(COMXVLDCPO({"F1_LOJARET"},1))) //verifica se o campo esta como usado.
		nPosLojaRet := aPosGet[1,6] + nTamGetFor
		@ 40,nPosLojaRet MSGET aObjetos[17] VAR aNFEDanfe[17] ;
			PICTURE X3Picture("F1_LOJARET") ;
			OF oDlg PIXEL ;
			WHEN !l103Visual .And. VisualSX3("F1_LOJARET");       
			VALID CheckSX3("F1_LOJARET",aNFEDanfe[17]) .And. NfeFornece(cTipo,@ aNFEDanfe[16],@ aNFEDanfe[17]);
			F3 CpoRetF3("F1_LOJARET");
			SIZE 02,08 HASBUTTON
		aObjetos[17]:cSX1Hlp := "F1_LOJARET"
	Endif

	If !(lfndVldCpo .and.  Empty(COMXVLDCPO({"F1_FORENT"},1))) //verifica se o campo esta como usado.
		@ 53,aPosGet[1,5] SAY OemToAnsi(IIF((cTipo$"DB" .Or. A103RtCliRT(cTipo, cTpCompl, cFormul) ),STR0164,STR0123)) Of oDlg PIXEL SIZE 40,12                   
		@ 52,aPosGet[1,6] MSGET aObjetos[19] VAR aNFEDanfe[19] ;
			PICTURE X3Picture("F1_FORENT") ;
			OF oDlg PIXEL ;
			WHEN !l103Visual .And. VisualSX3("F1_FORENT");       
			VALID CheckSX3("F1_FORENT",aNFEDanfe[19]) .And. NfeFornece(cTipo,@aNFEDanfe[19],@aNFEDanfe[20]);
			F3 CpoRetF3("F1_FORENT");
			SIZE nTamGetFor,08 HASBUTTON
		aObjetos[19]:cSX1Hlp := "F1_FORENT"
	Endif	

	If !(lfndVldCpo .and.  Empty(COMXVLDCPO({"F1_LOJAENT"},1))) //verifica se o campo esta como usado.
		nPosLojaRet := aPosGet[1,6] + nTamGetFor
		@ 52,nPosLojaRet MSGET aObjetos[20] VAR aNFEDanfe[20] ;
			PICTURE X3Picture("F1_LOJAENT") ;
			OF oDlg PIXEL ;
			WHEN !l103Visual .And. VisualSX3("F1_LOJAENT");       
			VALID CheckSX3("F1_LOJAENT",aNFEDanfe[20]) .And. NfeFornece(cTipo,@ aNFEDanfe[19],@ aNFEDanfe[20]);
			F3 CpoRetF3("F1_LOJAENT");
			SIZE 02,08 HASBUTTON
		aObjetos[20]:cSX1Hlp := "F1_LOJAENT"
	Endif
	
	@ 17,aPosGet[1,7] SAY STR0114 Of oDlg PIXEL SIZE 40,12   // Valor do Pedagio     
	@ 16,aPosGet[1,8] MSGET aObjetos[15] VAR aNFEDanfe[15] ;
		PICTURE X3Picture("F1_VALPEDG") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_VALPEDG");       
		VALID CheckSX3("F1_VALPEDG",aNFEDanfe[15]);
		SIZE 62,08 HASBUTTON
	aObjetos[15]:cSX1Hlp := "F1_VALPEDG"

	@ 29,aPosGet[1,7] SAY STR0113 OF oDlg PIXEL SIZE 035,008 // "Tp. Frete"
	@ 28,aPosGet[1,8] MSCOMBOBOX aObjetos[14] VAR aNFEDanfe[14] ITEMS aCombo WHEN !l103Visual SIZE 075,028 OF oDlg PIXEL
	aObjetos[14]:NAT := nPsTpFrt
	aObjetos[14]:refresh()
	oTpFrete := @aObjetos[14]

	@ 41,aPosGet[1,7] SAY STR0116 OF oDlg PIXEL SIZE 035,008 // "Tipo Ct-e"
	@ 40,aPosGet[1,8] MSCOMBOBOX aObjetos[18] VAR aNFEDanfe[18] ITEMS aComboCTE;
  	WHEN !l103Visual .And. VisualSX3("F1_TPCTE") .And. If("CTE" $ Upper(Trim(cEspecie)),.T.,.F.);
	VALID A103ConsCTE(aNFeDanfe[18]);
	SIZE 075,028 OF oDlg PIXEL
	aObjetos[18]:NAT := nPsTpcTe
	aObjetos[18]:refresh()
	If !(lfndVldCpo .and.  Empty(COMXVLDCPO({"F1_MODAL"},1))) //verifica se o campo esta como usado.
		@ 53,aPosGet[1,7] SAY "Modalidade" Of oDlg PIXEL SIZE 035,008
		@ 52,aPosGet[1,8] MSCOMBOBOX aObjetos[23] VAR aNFEDanfe[23] ITEMS aComboMod;
			WHEN !l103Visual .And. VisualSX3("F1_MODAL") .And. If("CTE" $ Upper(Trim(cEspecie)),.T.,(aNFEDanfe[23]:=aComboMod[1],aObjetos[23]:refresh(),.F.));
			VALID A103VldMod(aNFeDanfe[23]);
			SIZE 075,028 OF oDlg PIXEL
			aObjetos[23]:NAT := nPsModal
			aObjetos[23]:refresh()
	EndIf
	@ 05,aPosGet[1,9] SAY STR0124 Of oDlg PIXEL SIZE 40,12        
	@ 04,aPosGet[1,10] MSGET aObjetos[21] VAR aNFEDanfe[21] ;
		PICTURE X3Picture("F1_NUMAIDF") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_NUMAIDF");
		F3 CpoRetF3("F1_NUMAIDF");
		SIZE nTamGetFor-3,08 HASBUTTON
	aObjetos[21]:cSX1Hlp := "F1_NUMAIDF"

	@ 17,aPosGet[1,9] SAY STR0125 Of oDlg PIXEL SIZE 40,12        
	@ 16,aPosGet[1,10] MSGET aObjetos[22] VAR aNFEDanfe[22] ;
		PICTURE X3Picture("F1_ANOAIDF") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_ANOAIDF");
		F3 CpoRetF3("F1_ANOAIDF");
		SIZE 02,08 HASBUTTON
	aObjetos[22]:cSX1Hlp := "F1_ANOAIDF"

	@ 29,aPosGet[1,9] SAY STR0169 Of oDlg PIXEL SIZE 50,12  // Merc. não entreg.
	@ 28,aPosGet[1,10] MSCOMBOBOX aObjetos[24] VAR aNFEDanfe[24] ITEMS aComboMne;
	WHEN !l103Visual .And. VisualSX3("F1_DEVMERC") .And. If(cTipo $ "DBN" .And. cFormul=="S",.T.,(aNFEDanfe[24]:=aComboMne[1],aObjetos[24]:Refresh(),.F.));
	SIZE 25,08 OF oDlg PIXEL
	aObjetos[24]:cSX1Hlp := "F1_DEVMERC"

	//Ponto de Entrada utilizado para habilitar o botão Mais Info. na aba DANFE
	If lMT103DCF
		@ 42,aPosGet[1,9] BUTTON STR0009 SIZE 30 ,11 FONT oDlg:oFont ACTION A103CompDanfe() OF oDlg PIXEL
	EndIf
EndIf
Return(.T.)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³A103DescMun |Autor ³João Victor Pellegrini³ Data ³06/12/2013³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³ Preenche a descricao do Municipio                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cCodMun  = Codigo do Municipio                              ³±±
±±³          ³oDescMun = Objeto da descricao ddo Municipio                ³±±
±±³          ³cDescMun = Descricao do Municipio                           ³±±
±±³          ³cUF      = UF do Municipio                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A103DescMun(cCodMun,oDescMun,cDescMun,cUF,nOpc)

Local lRet := .T.
Local aAreaSA2 := SA2->(GetArea())

DEFAULT cUF := ""
Default nOpc	:= 0

If nOpc == 0
	If Empty(cUF) .And. (Type("cA100For")== "C" .And. !Empty(cA100For)) .And. (Type("cLoja")== "C" .And. !Empty(cLoja))
		cUF := Posicione("SA2",1, xFilial("SA2") + cA100For + cLoja , "A2_EST" )	
	EndIf
Endif

If !Empty(cCodMun) .And. cPaisLoc $ "ANG|AUS|BRA|CHI|COL|COS|DOM|EQU|HAI|MEX|PER|PTG|VEN"
	If cUf == ""
		CC2->(dbSetOrder(3))
		lRet := CC2->(MsSeek(xFilial("CC2")+cCodMun))
	Else
		CC2->(dbSetOrder(1))
		lRet := CC2->(MsSeek(xFilial("CC2")+cUF+cCodMun))
	EndIf
	
	If lRet .And. cPaisLoc $ "ANG|AUS|BRA|CHI|COL|COS|DOM|EQU|HAI|MEX|PER|PTG|VEN"
		cDescMun:= CC2->CC2_MUN
		oDescMun:Refresh()
	Else
	   If nOpc == 0
	   		If !Empty(cCodMun) 
				Help( " " , 1 , "ISSINV" )
				cDescMun := ""
			EndIf
		Else
			If !l103Visual
				Help("",1,"NOTEXISTMUN",,"Municipio não existe",1,0)
				cDescMun := ""
			Endif
		EndIf
	Endif
Else
	If nOpc == 1
		cDescMun := ""
		oDescMun:Refresh()
	Endif
EndIf
RestArea(aAreaSA2)
Return lRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeFldAdic³Autor  ³ João Victor Pellegrini³ Data ³05/12/2013 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Rotina de tratamento do folder para informacoes adicionais   ³±±
±±³          ³do documento                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³oDlg: Objeto da Janela que sera disponibilizado os Get       ³±±
±±³          ³aPosGet: Array com as posicoes dos gets das Infos. Adicionais³±±
±±³          ³aInfAdic: Array com as informacoes adicionais do docto.      ³±±
±±³          ³oDescMun: Objeto da Descrição do Município                   ³±±
±±³          ³cDescMun: Descricao do Municipio                             ³±± 
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeFldAdic(oDlg,aPosGet,aInfAdic,oDescMun,cDescMun,l103Visual,lMT116,bRefresh,lMT140,lMT119)   

Local aObjetos 		:= Array(Len(aInfAdic))
Local cMotRet  		:= CriaVar("DHI_CODIGO",.F.)
Local cDescRet 		:= CriaVar("DHI_DESCRI",.F.)
Local cHistRet 		:= CriaVar("F1_HISTRET",.F.)
Local oMemoRet
Local nTamGetFor	:=TamSX3("A1_COD")[1]
Local nTamLoja 		:=TamSX3("A1_LOJA")[1]
Local nPosLoja 		:= 0
Local aCombo 		:= {"","1=Sim","2=Não"}
Local lCteOriDest	:= SF1->(ColumnPos("F1_UFORITR")) > 0 .And. SF1->(ColumnPos("F1_MUORITR")) > 0 .And. SF1->(ColumnPos("F1_UFDESTR")) > 0 .And. SF1->(ColumnPos("F1_MUDESTR")) > 0
Local cMunOri		:= ""
Local oMunOri
Local cMunDest		:= ""
Local oMunDest
Local aPos			:= {}
Local aPos140		:= {}
Local aPosAdic		:= {}
Local aIndPres		:= {}
Local nF1IndPres 	:= 0
Local lDevRetorna 	:= FwIsInCallStack("A103ProcDv")
Local lClas			:= .F.
Local lMT103		:= FwIsInCallStack("MATA103")
Local lfndVldCpo 	:= FindFunction("COMXVLDCPO")
Local lBrasil		:= cPaisLoc == "BRA"
Local lCmpGovern	:= A103CmpGovernamental() 
Local oCmbCPGOV		:= Nil
Local lFieldGov		:= iif(lCmpGovern, (aInfAdic[21] == "1"), .F.)
Local oTpoNFGOV		:= Nil
Local lMVGSENTGV	:= SuperGetMV("MV_GSENTGV", .F., "") $ "1/2/3/4"

Default lMT116 		:= .F.
Default l103Visual 	:= .F.
Default lMT140		:= .F.
Default lMT119		:= .F.

If Type("l103Class") <> "L"
	l103Class := .F.
Endif

If !lMT140 .And. !lMT116 .And. !lMT119
	lClas := l103Class
Endif

If l103Visual .And. !lMT140 
	cMotRet  := SF1->F1_MOTRET
	cDescRet := Posicione("DHI",1,xFilial("DHI")+cMotRet,"DHI_DESCRI") 
	cHistRet := SF1->F1_HISTRET
EndIf
  
If lBrasil .And. !lMT140
    @ aPosGet[1,1],aPosGet[1,2]    SAY "UF. Incid. ISS:" OF oDlg PIXEL SIZE 100,100 //"UF Incid. ISS:"
	@ aPosGet[1,1] -1,aPosGet[1,2]+ 35 MSGET aObjetos[18] VAR aInfAdic[18] PICTURE X3Picture("CC2_EST") ; 
		WHEN !l103Visual .And. !SuperGetMV("MV_ISSXMUN",.F.,.F.) ;
		VALID Vazio(aInfAdic[18]) .or. (ExistCpo("SX5","12" + aInfAdic[18]) .And. Eval( {|| M->F1_ESTPRES := aInfAdic[18] , lEditMun:= .T. } ) .And. ;
		MaFisAlt("NF_UFPREISS",aInfAdic[18],));
		F3 "12" OF oDlg PIXEL SIZE 10,08 HASBUTTON 

	@ aPosGet[1,1],aPosGet[1,2] + 65 SAY STR0151 Of oDlg PIXEL SIZE 48,12 //"Descrição Municipio"
	@ aPosGet[1,1] - 1,aPosGet[1,2] + 110 MSGET aObjetos[01] VAR aInfAdic[01] ;
		PICTURE PesqPict("SF1","F1_INCISS") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_INCISS") .And. !SuperGetMV("MV_ISSXMUN",.F.,.F.) ;
		F3 "CC2SF1" ;  
		VALID A103DescMun(@aInfAdic[01], @oDescMun, @cDescMun, aInfAdic[18]);
		SIZE 40,09 HASBUTTON
	aObjetos[01]:cSX1Hlp := "F1_INCISS"
	
	@ aPosGet[1,1] - 1,aPosGet[1,2] + 150 MSGET oDescMun VAR cDescMun WHEN .F. OF oDlg PIXEL SIZE 130,006		

	If !lMT119 .And. !lMT116
		If !(lfndVldCpo .and.  Empty(COMXVLDCPO({"F1_VEICUL1"},1))) //verifica se o campo esta como usado.
			@ aPosGet[1,1], aPosGet[1,2] + 290 SAY STR0156 Of oDlg PIXEL SIZE 32,12    // Veiculo 1
			@ aPosGet[1,1] - 1,aPosGet[1,2] + 320 MSGET aObjetos[02] VAR aInfAdic[02] ;                   
				PICTURE X3Picture("F1_VEICUL1") ;
				OF oDlg PIXEL ;
				WHEN !l103Visual .And. VisualSX3("F1_VEICUL1");  
				F3 CpoRetF3("F1_VEICUL1");
				VALID CheckSX3("F1_VEICUL1",aInfAdic[02]) .And. (Vazio() .Or. ExistCpo("DA3"));
				SIZE 50,08 HASBUTTON
			aObjetos[02]:cSX1Hlp    := "F1_VEICUL1"	   
		Endif
		If !(lfndVldCpo .and.  Empty(COMXVLDCPO({"F1_VEICUL2"},1))) //verifica se o campo esta como usado.
			@ aPosGet[1,1], aPosGet[1,2] + 390 SAY STR0157 Of oDlg PIXEL SIZE 32,12    // Veiculo 2
			@ aPosGet[1,1] - 1,aPosGet[1,2] + 420 MSGET aObjetos[03] VAR aInfAdic[03] ;
				PICTURE X3Picture("F1_VEICUL2") ;
				OF oDlg PIXEL ;
				WHEN !l103Visual .And. VisualSX3("F1_VEICUL2");
				F3 CpoRetF3("F1_VEICUL2");
				VALID CheckSX3("F1_VEICUL2",aInfAdic[03]) .And. (Vazio() .Or. ExistCpo("DA3"));
				SIZE 50,08 HASBUTTON
			aObjetos[03]:cSX1Hlp    := "F1_VEICUL2"
		ENDIF
		If !(lfndVldCpo .and.  Empty(COMXVLDCPO({"F1_VEICUL3"},1))) //verifica se o campo esta como usado.
			@ aPosGet[1,1], aPosGet[1,2] + 490 SAY STR0158 Of oDlg PIXEL SIZE 32,12    // Veiculo 3
			@ aPosGet[1,1] - 1,aPosGet[1,2] + 520 MSGET aObjetos[04] VAR aInfAdic[04] ;
				PICTURE X3Picture("F1_VEICUL3") ;
				OF oDlg PIXEL ;
				WHEN !l103Visual .And. VisualSX3("F1_VEICUL3");
				F3 CpoRetF3("F1_VEICUL3");
				VALID CheckSX3("F1_VEICUL3",aInfAdic[04]) .And. (Vazio() .Or. ExistCpo("DA3"));
				SIZE 50,08 HASBUTTON
			aObjetos[04]:cSX1Hlp    := "F1_VEICUL3"
		Endif
		@ aPosGet[1,1] +15,aPosGet[1,2] + 120 SAY "Data de Competência" Of oDlg PIXEL SIZE 80,12
		@ aPosGet[1,1] +14,aPosGet[1,2] + 200 MSGET aObjetos[05] VAR aInfAdic[05] ;
			PICTURE "" ;
			OF oDlg PIXEL ; 
			WHEN !l103Visual .And. VisualSX3("F1_DTCPISS") ;
			SIZE 80,09 HASBUTTON
		aObjetos[05]:cSX1Hlp := "F1_DTCPISS"

		If SuperGetMV("MV_MT103SN",.F.,.F.)
			@ aPosGet[1,1], aPosGet[1,2] + 520 SAY "Opt Simp Nac" Of oDlg PIXEL SIZE 35,20   // Simples Nacional
			@ aPosGet[1,1] - 1,aPosGet[1,2] + 560 MSCOMBOBOX aObjetos[06] VAR aInfAdic[06] ITEMS aCombo ;	
			WHEN !l103Visual .And. VisualSX3("F1_SIMPNAC") ;//criar parametro
			VALID CheckSX3("F1_SIMPNAC",aInfAdic[06]);
			SIZE 055,08 OF oDlg PIXEL
			aObjetos[06]:cSX1Hlp    := "F1_SIMPNAC"
		EndIf
	
		@ aPosGet[1,1]+15, aPosGet[1,2] + 310 SAY "Cliente de Entrega" Of oDlg PIXEL SIZE 80,12
		@ aPosGet[1,1] +14,aPosGet[1,2] + 360 MSGET aObjetos[07] VAR aInfAdic[07] ;	
			PICTURE X3Picture("F1_CLIDEST") ;
			OF oDlg PIXEL ;
			WHEN !l103Visual .And. VisualSX3("F1_CLIDEST") .And. (AllTrim(cEspecie) $ "CTR/CTE/CTA/CA/CTF" .Or. "NFST"$AllTrim(cEspecie));
			F3 CpoRetF3("F1_CLIDEST");
			VALID CheckSX3("F1_CLIDEST",aInfAdic[07]) .And. (existcpo("SA1") .Or. Vazio());
			SIZE nTamGetFor,08 HASBUTTON
		aObjetos[07]:cSX1Hlp := "F1_CLIDEST"

		nPosLoja := aPosGet[1,2] + 400 	
		@ aPosGet[1,1] +14,nPosLoja MSGET aObjetos[08] VAR aInfAdic[08] ;
			PICTURE X3Picture("F1_LOJDEST") ;
			OF oDlg PIXEL ;
			WHEN !l103Visual .And. VisualSX3("F1_LOJDEST") .And. (AllTrim(cEspecie) $ "CTR/CTE/CTA/CA/CTF" .Or. "NFST"$AllTrim(cEspecie));
			F3 CpoRetF3("F1_LOJDEST");
			VALID CheckSX3("F1_LOJDEST",aInfAdic[08]) .And. IIf(bGdRefresh <> NIL, Eval( bGdRefresh ), .T.);		
			SIZE nTamLoja,08 HASBUTTON
		aObjetos[08]:cSX1Hlp := "F1_LOJDEST"

		If SF1->(ColumnPos("F1_CLIPROP")) > 0 .And. SF1->(ColumnPos("F1_LJCLIPR")) > 0 .and.;
		   !(lfndVldCpo .and.  Empty(COMXVLDCPO({"F1_CLIPROP"},1)) .and.Empty(COMXVLDCPO({"F1_LJCLIPR"},1)) ) //verifica se o campo esta como usado.

			@ aPosGet[1,1] + 15, aPosGet[1,2]  SAY 'Cliente Proprietario' Of oDlg PIXEL SIZE 80,12    
			@ aPosGet[1,1] + 14,aPosGet[1,2] + 50 MSGET aObjetos[14] VAR aInfAdic[14] ;
				PICTURE X3Picture("F1_CLIPROP") ;
				OF oDlg PIXEL ;
				WHEN !l103Visual .And. VisualSX3("F1_CLIPROP") .and. cTipo $ "B";
				F3 CpoRetF3("F1_CLIPROP");
				VALID CheckSX3("F1_CLIPROP",aInfAdic[14]) .And. (existcpo("SA1") .Or. Vazio());
				SIZE nTamGetFor,08 HASBUTTON
			aObjetos[14]:cSX1Hlp := "F1_CLIPROP" 

			nPosLoja := aPosGet[1,2] + 90	
			@ aPosGet[1,1] +14,nPosLoja MSGET aObjetos[15] VAR aInfAdic[15] ;
				PICTURE X3Picture("F1_LJCLIPR") ;
				OF oDlg PIXEL ;
				WHEN !l103Visual .And. VisualSX3("F1_LJCLIPR") .and. cTipo $ "B";
				F3 CpoRetF3("F1_LJCLIPR");
				VALID CheckSX3("F1_LJCLIPR",aInfAdic[15]) .And. IIf(bGdRefresh <> NIL, Eval( bGdRefresh ), .T.);		
				SIZE nTamLoja,08 HASBUTTON
			aObjetos[15]:cSX1Hlp := "F1_LJCLIPR"

		EndIf 
	EndIf
EndIf

If SF1->(FieldPos("F1_MOTRET")) > 0 .And. l103Visual .And. !lMT116 .And. !lMT140 .And. !lMT119

	If !Empty(cMotRet)
		@ aPosGet[1,1]+15,aPosGet[1,2]+330  SAY RetTitle("F1_MOTRET")   Of oDlg PIXEL
		@ aPosGet[1,1]+14,aPosGet[1,2]+360  MSGET cMotRet  SIZE  60, 10 Of oDlg PIXEL When .F. 
		
		@ aPosGet[1,1]+15,aPosGet[1,2]+430  SAY RetTitle("DHI_DESCRI")   Of oDlg PIXEL
		@ aPosGet[1,1]+14,aPosGet[1,2]+470  MSGET cDescRet SIZE 180, 10 Of oDlg PIXEL When .F.
	
		@ aPosGet[1,1]+45,aPosGet[1,2]+490 SAY RetTitle("F1_HISTRET")  Of oDlg PIXEL
		@ aPosGet[1,1]+30,aPosGet[1,2]+520 GET oMemoRet VAR cHistRet   Of oDlg MEMO  When .F. size 140,30 PIXEL
	EndIf
	
EndIf

If lCteOriDest .And. !lMT140 .And. !lMT119

		aAdd(aPos,{30,29,45,44})
	
	//Origem
	@ aPosGet[1,1]+aPos[1,1],aPosGet[1,2] SAY STR0175 Of oDlg PIXEL SIZE 80,12 //"UF Origem transporte"
	@ aPosGet[1,1]+aPos[1,2],aPosGet[1,2]+80 MSGET aObjetos[10] VAR aInfAdic[10] ;
			PICTURE X3Picture("F1_UFORITR")	OF oDlg PIXEL ;
			WHEN !l103Visual .And. VisualSX3("F1_UFORITR") ;
			F3 CpoRetF3("F1_UFORITR");
			VALID CheckSX3("F1_UFORITR",aInfAdic[10]) .And. A103UFREF() .And. IIf(bGdRefresh <> NIL, Eval( bGdRefresh ), .T.)  ;		
			SIZE 20,08 HASBUTTON
		aObjetos[10]:cSX1Hlp := "F1_UFORITR"
		
	@ aPosGet[1,1]+aPos[1,1],aPosGet[1,2]+120 SAY STR0176 Of oDlg PIXEL SIZE 80,12 //"Municipio Origem transporte"
	@ aPosGet[1,1]+aPos[1,2],aPosGet[1,2]+190 MSGET aObjetos[11] VAR aInfAdic[11] ;
			PICTURE X3Picture("F1_MUORITR")	OF oDlg PIXEL ;
			WHEN !l103Visual .And. VisualSX3("F1_MUORITR").And. If(!Empty(ALLTRIM(aInfAdic[10])),.T.,.F.) ;
			F3 CpoRetF3("F1_MUORITR");
			VALID CheckSX3("F1_MUORITR",aInfAdic[11]) .And. A103DescMun(aInfAdic[11],@oMunOri,@cMunOri,AllTrim(aInfAdic[10]),1) .And. IIf(bGdRefresh <> NIL, Eval( bGdRefresh ), .T.)  ;		
			SIZE 40,08 HASBUTTON
		aObjetos[11]:cSX1Hlp := "F1_MUORITR"
		
	@ aPosGet[1,1]+aPos[1,2],aPosGet[1,2]+ 240 MSGET oMunOri VAR cMunOri WHEN .F. OF oDlg PIXEL SIZE 130,006
	If l103Visual .Or. !Empty(SF1->F1_UFORITR)
		A103DescMun(aInfAdic[11],@oMunOri,@cMunOri,AllTrim(aInfAdic[10]),1)
	Endif
	
	//Destino
	@ aPosGet[1,1]+aPos[1,3],aPosGet[1,2] SAY STR0177 Of oDlg PIXEL SIZE 80,12 //"UF Destino transporte"
	@ aPosGet[1,1]+aPos[1,4],aPosGet[1,2]+80 MSGET aObjetos[12] VAR aInfAdic[12] ;
			PICTURE X3Picture("F1_UFDESTR")	OF oDlg PIXEL ;
			WHEN !l103Visual .And. VisualSX3("F1_UFDESTR") ;
			F3 CpoRetF3("F1_UFDESTR");
			VALID CheckSX3("F1_UFDESTR",aInfAdic[12]) .And. A103UFDEST() .And. IIf(bGdRefresh <> NIL, Eval( bGdRefresh ), .T.)  ;		
			SIZE 20,08 HASBUTTON
		aObjetos[12]:cSX1Hlp := "F1_UFDESTR"
		
	@ aPosGet[1,1]+aPos[1,3],aPosGet[1,2]+120 SAY STR0178 Of oDlg PIXEL SIZE 80,12 //"Municipio Destino transporte"
	@ aPosGet[1,1]+aPos[1,4],aPosGet[1,2]+190 MSGET aObjetos[13] VAR aInfAdic[13] ;
			PICTURE X3Picture("F1_MUDESTR")	OF oDlg PIXEL ;
			WHEN !l103Visual .And. VisualSX3("F1_MUDESTR") .And. If(!Empty(ALLTRIM(aInfAdic[12])),.T.,.F.) ;
			F3 CpoRetF3("F1_MUDESTR");
			VALID CheckSX3("F1_MUDESTR",aInfAdic[13]) .And. A103DescMun(aInfAdic[13],@oMunDest,@cMunDest,AllTrim(aInfAdic[12]),1) .And. IIf(bGdRefresh <> NIL, Eval( bGdRefresh ), .T.)  ;		
			SIZE 40,08 HASBUTTON
		aObjetos[13]:cSX1Hlp := "F1_MUDESTR"

	@ aPosGet[1,1]+aPos[1,4],aPosGet[1,2] + 240 MSGET oMunDest VAR cMunDest WHEN .F. OF oDlg PIXEL SIZE 130,006
	If l103Visual .Or. !Empty(SF1->F1_UFDESTR)
		A103DescMun(aInfAdic[13],@oMunDest,@cMunDest,AllTrim(aInfAdic[12]),1)
	Endif
Endif 

If lBrasil .And. Type("lIntermed") == "L" .And. lIntermed .And. !lMT119
	If lMT140 
		aAdd(aPos140,{0,-1,15,14,0,50})
	Elseif lMT116
		aAdd(aPos140,{30,29,45,44,660,710})
	Else
		aAdd(aPos140,{30,29,45,44,380,430}) 
	Endif

	aIndPres := LoadX3Arr("F1_INDPRES")
	If !Empty(aInfAdic[16])
		If l103Visual .Or. lDevRetorna .Or. lMT116 .Or. lMT140 .Or. l103Class .Or. ( lMT103 .and. INCLUI )
			nF1IndPres := aScan(aIndPres ,{|x| AllTrim(Substr(x,1,1)) == AllTrim(aInfAdic[16])})
			If nF1IndPres == 0
				nF1IndPres := aScan(aIndPres ,{|x| AllTrim(Substr(x,1)) == AllTrim(aInfAdic[16])})
			Endif  
		Endif		 		            
	EndIf	
	nF1IndPres := Max(1,nF1IndPres)
	If !(lfndVldCpo .and.  Empty(COMXVLDCPO({"F1_INDPRES"},1))) //verifica se o campo esta como usado.
		@ aPosGet[1,1]+aPos140[1,1],aPosGet[1,2]+aPos140[1,5] SAY RetTitle("F1_INDPRES") OF oDlg PIXEL SIZE 40,09
		@ aPosGet[1,1]+aPos140[1,2],aPosGet[1,2]+aPos140[1,6] MSCOMBOBOX aObjetos[16] VAR aInfAdic[16] ITEMS aIndPres ;
			WHEN (!l103Visual) .And. VisualSX3("F1_INDPRES") ;
			VALID A103VldPres() SIZE 80 ,9 OF oDlg PIXEL  
		aObjetos[16]:bChange := {|| A103ChgPres()}      
		aObjetos[16]:NAT := nF1IndPres    
	EndIf
	If !(lfndVldCpo .and.  Empty(COMXVLDCPO({"F1_CODA1U"},1))) //verifica se o campo esta como usado.
		@ aPosGet[1,1]+aPos140[1,3],aPosGet[1,2]+aPos140[1,5] SAY RetTitle("F1_CODA1U") Of oDlg PIXEL SIZE 40,12
		@ aPosGet[1,1]+aPos140[1,4],aPosGet[1,2]+aPos140[1,6] MSGET aObjetos[17] VAR aInfAdic[17] ;
				PICTURE X3Picture("F1_CODA1U")	OF oDlg PIXEL ;   
				WHEN !l103Visual .And. VisualSX3("F1_CODA1U");
				F3 CpoRetF3("F1_CODA1U");
				VALID A103VldA1U() ;		
				SIZE 50,08 HASBUTTON   
	EndIf
Endif

If !lMT140 .And. !lMT119 .And. SF1->(ColumnPos("F1_OBSFTIT")) > 0 .And. SF1->(ColumnPos("F1_OBSFISC")) > 0 .and.;
	!(lfndVldCpo .and.  Empty(COMXVLDCPO({"F1_OBSFTIT"},1)) .and.Empty(COMXVLDCPO({"F1_OBSFISC"},1)) )

	if lMT116
		aAdd(aPosAdic,{-30,45,45,400,435,400,435})
	Else
		aAdd(aPosAdic,{1,15,14,590,625,525,560}) 
	Endif 
	If lMT116
		@ aPosGet[1,1] + 30, aPosGet[1,2] + aPosAdic[1,4] SAY STR0238 Of oDlg PIXEL SIZE 32,12
	Else
		@ aPosGet[1,1] , aPosGet[1,2] + aPosAdic[1,4] SAY STR0238 Of oDlg PIXEL SIZE 32,12
	Endif
	@ aPosGet[1,1] - aPosAdic[1,1] , aPosGet[1,2] + aPosAdic[1,5] MSGET aObjetos[19] VAR aInfAdic[19] ;
		PICTURE X3Picture("F1_OBSFTIT") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_OBSFTIT");
		VALID CheckSX3("F1_OBSFTIT",aInfAdic[19]);
		SIZE 80,08 HASBUTTON
	aObjetos[19]:cSX1Hlp    := "F1_OBSFTIT"

	@ aPosGet[1,1] + aPosAdic[1,2] , aPosGet[1,2] + aPosAdic[1,6] SAY STR0239 Of oDlg PIXEL SIZE 80,12
	@ aPosGet[1,1] + aPosAdic[1,3] , aPosGet[1,2] + aPosAdic[1,7] MSGET aObjetos[20] VAR aInfAdic[20] ;
		PICTURE X3Picture("F1_OBSFISC") ;
		OF oDlg PIXEL ;
		WHEN !l103Visual .And. VisualSX3("F1_OBSFISC");
		VALID CheckSX3("F1_OBSFISC",aInfAdic[20]);
		SIZE 200,08 HASBUTTON
	aObjetos[20]:cSX1Hlp    := "F1_OBSFISC"

endif

if lCmpGovern .And. lBrasil .And. !lMT140 .And. !lMT119
	aPos140 := {}
	aAdd(aPos140, {30, 29, 520, 558, 585, 623, 45, 44}) 

	@ aPosGet[1,1] + aPos140[1,1], aPosGet[1,2] + aPos140[1,3] SAY RetTitle("F1_CPGOVE") Of oDlg PIXEL SIZE 63 ,9 // Compra Governamental
	@ aPosGet[1,1] + aPos140[1,1], aPosGet[1,2] + aPos140[1,4] CHECKBOX oCmbCPGOV VAR lFieldGov PROMPT "" SIZE 010,010 ON CLICK( VldCmpGovDlg(@oCmbCPGOV, @lFieldGov, @aInfAdic) ) WHEN (!l103Visual .AND. lMVGSENTGV) OF oDlg PIXEL

	@ aPosGet[1,1] + aPos140[1,7], aPosGet[1,2] + aPos140[1,3] SAY RetTitle("F1_OPGOV") Of oDlg PIXEL SIZE 63 ,9 // Tipo de Operação
	@ aPosGet[1,1] + aPos140[1,8], aPosGet[1,2] + aPos140[1,4] MSCOMBOBOX oTpoNFGOV VAR aInfAdic[23] ITEMS ComboGen("F1_OPGOV", .T.) WHEN (lFieldGov .AND. !l103Visual) SIZE 80,10 of oDlg PIXEL

endif

bRefresh := {|| NfeRFldAdic(aObjetos)} 
FwFreeArray(aPos140)
Return

/*/
{Protheus.doc} NfeRFldAdic
Refresh Foldes Informações adicionais
NT2020-006

@author rodrigo.mpontes
@since 10/03/21
@version 1.0
/*/

Static Function NfeRFldAdic(aObjetos) 

Local nX			:= 1
Local nF1IndPres	:= 0

For nX := 1 To Len(aObjetos)
	If nX == 16
		aIndPres := LoadX3Arr("F1_INDPRES")
		If !Empty(aInfAdic[16])
			nF1IndPres := aScan(aIndPres ,{|x| AllTrim(Substr(x,1,1)) == AllTrim(aInfAdic[16])})
			If nF1IndPres == 0
				nF1IndPres := aScan(aIndPres ,{|x| AllTrim(Substr(x,1)) == AllTrim(aInfAdic[16])})
			Endif 
		EndIf	
		nF1IndPres := Max(1,nF1IndPres)
	Endif
	If aObjetos[nX]<>Nil
		If nX == 16
			aObjetos[nX]:NAT := nF1IndPres 
		Endif
		aObjetos[nX]:Refresh()
	EndIf
Next nX

Return


/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeVincOri³Autor  ³ Marcelo Custodio      ³ Data ³15/12/2008 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Permite consultar as notas de saida de devolucao do produto  ³±±
±±³          ³para vincular no documento de entrada - Projeto Oleo e Gas - ³±±
±±³          ³Pilar 1                                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Informa o codigo do fornecedor                        ³±±
±±³          ³ExpC2: Informa codigo da loja                                ³±±
±±³          ³ExpC3: Informa o codigo do produto                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                         y    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeVincOri(cCodForn,cCodLoja,cCodProd)
Local oTempTable := NIL
Local cQuery     := ""
Local cAlias     := ""
Local nPosCod	 := aScan(aHeader,{|x| AllTrim(x[2])=='D1_COD'})
Local aSize      := MsAdvSize( .F. )
Local aObjects   := {}
Local aInfo      := {}
Local aArea      := GetArea()
Local aAreaSB1   := SB1->(GetArea())
Local aAreaSA2   := SA2->(GetArea())
Local aOrdem     := {AllTrim(RetTitle("F2_DOC"))+"+"+AllTrim(RetTitle("F2_SERIE")),AllTrim(RetTitle("F2_EMISSAO"))}
Local aPesq      := {{Space(Len(SD1->D1_DOC+SD1->D1_SERIE)),"@!"},{Ctod(""),"@!"}}
Local aSavHead   := aClone(aHeader)
Local lContinua  := .T.
Local aHeadTrb   := {}
Local aStruTrb   := {}
Local cAliasTRB  := ""
Local nPosNfVinc := aScan(aHeader,{|x| AllTrim(x[2])=='D1_NFVINC'})
Local nPosSeVinc := aScan(aHeader,{|x| AllTrim(x[2])=='D1_SERVINC'})
Local nPosItVinc := aScan(aHeader,{|x| AllTrim(x[2])=='D1_ITMVINC'})
Local oGetDb
Local nX
Local oPanel
Local oDlg
Local oCombo
Local cCombo
Local oGet
Local xPesq
Local nOpca

//Preenche os filtros com os valores definidos na nota
DEFAULT cCodForn := cA100For
DEFAULT cCodLoja := cLoja
DEFAULT cCodProd := aCols[n][nPosCod]

lContinua := (!Empty(cCodForn) .AND. !Empty(cCodLoja) .AND. !Empty(cCodProd) .And. !Empty(nPosNfVinc) .And. !Empty(nPosSeVinc) .And. !Empty(nPosItVinc))

If lContinua
	SB1->(dbSetOrder(1))
	SA2->(dbSetOrder(1))

	lContinua := (SB1->(dbSeek(xFilial("SB1")+cCodProd)) .And. SA2->(dbSeek(xFilial("SA2")+cCodForn+cCodLoja)))

	If lContinua
	
		//Monta estrutura do arquivo temporario
		dbSelectArea("SX3")
		dbSetOrder(1)
		MsSeek("SD2")
		While !Eof() .And. SX3->X3_ARQUIVO == "SD2"
			If ( X3USO(SX3->X3_USADO) .And. cNivel >= SX3->X3_NIVEL .And. SX3->X3_CONTEXT<>"V" .And. SX3->X3_TIPO<>"M" .And. !(SX3->X3_CAMPO $ "D2_CLIENTE,D2_LOJA") ) .OR. (AllTrim(SX3->X3_CAMPO) $ "D2_DOC,D2_SERIE,D2_EMISSAO")
				Aadd(aHeadTrb,{ TRIM(X3Titulo()),;
					SX3->X3_CAMPO,;
					SX3->X3_PICTURE,;
					SX3->X3_TAMANHO,;
					SX3->X3_DECIMAL,;
					SX3->X3_VALID,;
					SX3->X3_USADO,;
					SX3->X3_TIPO,;
					SX3->X3_ARQUIVO,;
					SX3->X3_CONTEXT,;
					IIf(AllTrim(SX3->X3_CAMPO)$"D2_DOC,D2_SERIE,D2_ITEM,D2_COD","00",SX3->X3_ORDEM) })
				aadd(aStruTRB,{SX3->X3_CAMPO,SX3->X3_TIPO,SX3->X3_TAMANHO,SX3->X3_DECIMAL,IIf(AllTrim(SX3->X3_CAMPO)$"D2_DOC,D2_SERIE,D2_ITEM,D2_COD","00",SX3->X3_ORDEM)})
			EndIf				
			dbSelectArea("SX3")
			dbSkip()
		EndDo
		
		aHeadTrb := aSort(aHeadTrb,,,{|x,y| x[11] < y[11]})
		aStruTrb := aSort(aStruTrb,,,{|x,y| x[05] < y[05]})
		
		//Gera arquivo temporario
		cAliasTRB := GetNextAlias()
		oTempTable := FWTemporaryTable():New( cAliasTRB )
		oTempTable:SetFields( aStruTRB )
		oTempTable:AddIndex("indice1", {"D2_DOC","D2_SERIE"} )
		oTempTable:AddIndex("indice2", {"D2_EMISSAO"} )
		oTempTable:Create()
		
		PRIVATE aHeader := aHeadTRB
		xPesq := aPesq[(cAliasTRB)->(IndexOrd())][1]
	
		//Filtra notas de devolucao do fornecedor e produto informados
		cQuery := "SELECT SD2.R_E_C_N_O_ AS RECNO "
		cQuery += "  FROM " + RetSQLName("SD2") + " SD2, " + RetSQLName("SF2") + " SF2, " + RetSQLName("SF4") + " SF4 "
		cQuery += " WHERE SD2.D2_FILIAL  = '" + xFilial("SD2") + "'"
		cQuery += "   AND SF2.F2_FILIAL  = '" + xFilial("SF2") + "'"
		cQuery += "   AND SF4.F4_FILIAL  = '" + xFilial("SF4") + "'"
		cQuery += "   AND SD2.D2_DOC     = SF2.F2_DOC    "
		cQuery += "   AND SD2.D2_TES     = SF4.F4_CODIGO "
		cQuery += "   AND SD2.D2_COD     = '" + SB1->B1_COD + "'"
		cQuery += "   AND SF2.F2_CLIENTE = '" + SA2->A2_COD + "'"
		cQuery += "   AND SF2.F2_LOJA    = '" + SA2->A2_LOJA + "'"
		cQuery += "   AND (SF4.F4_PODER3 = 'D' OR SF2.F2_TIPO = 'D')"
		cQuery += "   AND SD2.D_E_L_E_T_ = ' ' "
		cQuery += "   AND SF2.D_E_L_E_T_ = ' ' "
		cQuery += "   AND SF4.D_E_L_E_T_ = ' '"
		
		cAlias := GetNextAlias()
		cQuery := ChangeQuery(cQuery)

		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAlias,.T.,.T.)
		
		//Preenche arquivo temporario
		While !(cAlias)->(Eof())
			SD2->(MsGoto((cAlias)->RECNO))
			
			If !SD2->(Eof())
				RecLock(cAliasTRB,.T.)
				For nX := 1 To Len(aStruTRB)
					(cAliasTRB)->(FieldPut(nX,SD2->(FieldGet(FieldPos(aStruTRB[nX][1])))))
				Next nX
				MsUnlock()
			EndIf

			(cAlias)->(dbSkip())
		EndDo
		(cAlias)->(DbCloseArea())
		
		If !(cAliasTRB)->(Eof())
			//Calcula dimensoes da tela
			aSize[1] /= 1.5
			aSize[2] /= 1.5
			aSize[3] /= 1.5
			aSize[4] /= 1.3
			aSize[5] /= 1.5
			aSize[6] /= 1.3
			aSize[7] /= 1.5
			
			AAdd( aObjects, { 100, 020,.T.,.F.,.T.} )
			AAdd( aObjects, { 100, 060,.T.,.T.} )
			AAdd( aObjects, { 100, 020,.T.,.F.} )
			aInfo   := { aSize[ 1 ], aSize[ 2 ], aSize[ 3 ], aSize[ 4 ], 3, 3 }
			aPosObj := MsObjSize( aInfo, aObjects,.T.)
			
			DEFINE MSDIALOG oDlg TITLE STR0065 FROM aSize[7],000 TO aSize[6],aSize[5] OF oMainWnd PIXEL //"Vinculo - Documento de Saída"
			@ aPosObj[1,1],aPosObj[1,2] MSPANEL oPanel PROMPT "" SIZE aPosObj[1,3],aPosObj[1,4] OF oDlg CENTERED LOWERED
			cTexto1 := AllTrim(RetTitle("F2_CLIENTE"))+"/"+AllTrim(RetTitle("F2_LOJA"))+": "+SA2->A2_COD+"/"+SA2->A2_LOJA+"  -  "+RetTitle("A2_NOME")+": "+;
			If(lLGPD,RetTxtLGPD(SA2->A2_NOME,"A2_NOME"),SA2->A2_NOME)
			@ 002,005 SAY cTexto1 SIZE aPosObj[1,3],008 OF oPanel PIXEL
			cTexto2 := AllTrim(RetTitle("B1_COD"))+": "+SB1->B1_COD+"/"+SB1->B1_DESC
			@ 012,005 SAY cTexto2 SIZE aPosObj[1,3],008 OF oPanel PIXEL	
	
			oGetDb := MsGetDB():New(aPosObj[2,1],aPosObj[2,2],aPosObj[2,3],aPosObj[2,4],1,"Allwaystrue","allwaystrue","",.F., , ,.F., ,cAliasTRB)
			
			DEFINE SBUTTON FROM aPosObj[3,1]+000,aPosObj[3,4]-030 TYPE 1 ACTION (nOpcA := 1,oDlg:End()) ENABLE OF oDlg
			DEFINE SBUTTON FROM aPosObj[3,1]+012,aPosObj[3,4]-030 TYPE 2 ACTION (nOpcA := 0,oDlg:End()) ENABLE OF oDlg
			
			@ aPosObj[3,1]+00,aPosObj[3,2]+00 SAY STR0066 PIXEL //"Pesquisar por:"
			@ aPosObj[3,1]+12,aPosObj[3,2]+00 SAY STR0067 PIXEL //"Localizar"
			@ aPosObj[3,1]+00,aPosObj[3,2]+40 MSCOMBOBOX oCombo VAR cCombo ITEMS aOrdem SIZE 100,044 OF oDlg PIXEL ;
				VALID ((cAliasTRB)->(dbSetOrder(oCombo:nAt)),(cAliasTRB)->(dbGotop()),xPesq := aPesq[(cAliasTRB)->(IndexOrd())][1],.T.)
			@ aPosObj[3,1]+12,aPosObj[3,2]+40 MSGET oGet VAR xPesq Of oDlg PICTURE aPesq[(cAliasTRB)->(IndexOrd())][2] PIXEL ;
				VALID ((cAliasTRB)->(MsSeek(Iif(ValType(xPesq)=="C",AllTrim(xPesq),xPesq),.T.)),.T.).And.IIf(oGetDb:oBrowse:Refresh()==Nil,.T.,.T.)
			ACTIVATE MSDIALOG oDlg CENTERED
			
			If nOpca == 1
				//Carrega documento selecionado
				aCols[n,nPosNfVinc] := (cAliasTRB)->D2_DOC
				aCols[n,nPosSeVinc] := (cAliasTRB)->D2_SERIE
				aCols[n,nPosItVinc] := (cAliasTRB)->D2_ITEM
			EndIf
		Else
			Aviso(STR0018,STR0068,{"OK"}) //"Atenção"###"Não existe devolução para o fornecedor/produto informado"
		EndIf
		
		dbSelectArea(cAliasTRB)
		dbCloseArea()
	EndIf
Else
	Aviso(STR0018,STR0069,{"OK"}) //"Atenção"###"Informe o fornecedor e o produto"
EndIf

aHeader   := aClone(aSavHead)

RestArea(aAreaSA2)
RestArea(aAreaSB1)
RestArea(aArea)

Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³NfeVldVinc³Autor  ³ Marcelo Custodio      ³ Data ³15/12/2008 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³          ³Valida o documento de saida informado no vinculo             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpN1: Informa o campo a ser validado                        ³±±
±±³          ³       1 - Documento                                         ³±±
±±³          ³       2 - Serie                                             ³±±
±±³          ³       3 - Item                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³Nenhum                                                       ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Materiais                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function NfeVldVinc(nFld)
Local cValor     := &(ReadVar())
Local nPosNfVinc := aScan(aHeader,{|x| AllTrim(x[2])=='D1_NFVINC'})
Local nPosSeVinc := aScan(aHeader,{|x| AllTrim(x[2])=='D1_SERVINC'})
Local nPosProd   := aScan(aHeader,{|x| AllTrim(x[2])=='D1_COD'})
Local lRet       := .T.

SD2->(DbSetOrder(3))

Do Case
	Case nFld==1//Valida documento
		lRet := SD2->(dbSeek(xFilial("SD2")+cValor))
	Case nFld==2//Valida Serie
		lRet := SD2->(dbSeek(xFilial("SD2")+aCols[n,nPosNfVinc]+cValor))
	Case nFld==3//Valida Item
		lRet := SD2->(dbSeek(xFilial("SD2")+aCols[n,nPosNfVinc]+aCols[n,nPosSeVinc]+cA100For+cLoja+aCols[n][nPosProd]+cValor))
EndCase

If lRet//Valida TES de devolucao
	SF4->(dbSetOrder(1))
	lRet := (SF4->(dbSeek(xFilial("SF4")+SD2->D2_TES)) .And. (SF4->F4_PODER3 == "D" .OR. SD2->D2_TIPO == "D"))
EndIf

If !lRet
	Aviso(STR0018,STR0070,{"OK"}) //"Atenção"###"Documento de saída inválido"
EndIf

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³A103LCF   ³ Autor ³ Julio C Guerato       ³ Data ³22.01.2009³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Funcao que aplica ponto de entrada para manipular o bloqueio³±±
±±³          ³ou desbloqueio de campos. 								  ³±±
±±³          ³Nao existindo o campo no ponto de entrada, sera retornado   ³±±
±±³          ³.T. a fim de que o programa continue operando normalmente.  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Nome do Campo 				                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL:  Retorna .F. ou .T. 					              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MATA103X                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A103LCF(cCampo)

Local lRet103 	:= .T.
Local aArea    	:= GetArea()
Local aAreaSX3 	:= SX3->(GetArea())
Local lMT103LCF := ExistBlock("MT103LCF")

DbSelectArea('SX3')
DbSetOrder(2)

// Se não houver o ponto de entrada que determina o bloqueio ou a edição de um campo,
// a função retornará o que estiver no SX3.

If MsSeek(cCampo)
	If( SX3->X3_VISUAL=="V" .OR. (IIF(ALLTRIM(SX3->X3_WHEN) == '',.F.,ALLTRIM(SX3->X3_WHEN))))
		lRet103	:=	.F.
	EndIf
EndIf

If cCampo != Nil
	If lMT103LCF
		lRet103 := ExecBlock("MT103LCF",.F.,.F.,{cCampo})
		If!ValType(lRet103)=="L"
			lRet103 := .T.
		Endif
	EndIf
EndIf

RestArea(aAreaSX3)
RestArea(aArea)
Return(lRet103) 

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³A103VLDCPO³ Autor ³ Julio C Guerato       ³ Data ³11/12/2009³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Funcao para verificar se um determinado caracter existe em  ³±±
±±³          ³uma variável				 								  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1: Variável com conteudo que será validado              ³±±
±±³			 ³ExpC2: Caracter a ser procurado na String                   ³±±
±±³			 ³ExpN1: Tipo de verificação				                  ³±±
±±³			 ³  	 0 = Verifica se existe algum caracterer de ExpC2 que ³±±
±±³			 ³		   	 que não é permitido em ExpC1					  ³±±
±±³			 ³		 1 = Verifica se todos os caracteres de ExpC1 existem ³±±
±±³			 ³		   	 em ExpC2										  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL:  Retorna .F. ou .T. 					              ³±±
±±³		     ³.F. = Caracter Não Existe / .T. = Caracter Existe           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MATA103X                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A103VldCpo(cValor, cCarac, nTipo)
                                
Local lRet := .F.                                      
Local nX   := 0  
Local nCT  := 0
Default nTipo:=0

If Len(cValor)>0 .And. Len(cCarac)>0
	If nTipo==0
	    For nX:=1 To len(cCarac)
    	     if RAT(SUBSTR(cCarac,nX,1),cValor)>0 .And. !lRet
        	    lRet:= .T.
	         EndIf
    	Next nX     
 	Else
 	    For nX:=1 To len(Trim(cValor))
    	     if RAT(SUBSTR(cValor,nX,1),cCarac)=0
    	     	nCT++ 
	         EndIf
    	Next nX                                              
    	lRet:=iif(nCT>0,.F.,.T.)
  	EndIf
EndIF

Return (lRet)


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    ³A103VLDNFO³ Autor ³ Julio C Guerato       ³ Data ³30/12/2009³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³Funcao para validar todos os Documentos vinculados aos itens³±±
±±³          ³de uma nota fiscal		 								  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±  
±±³Parametros³ nItem = Número do Item no Acols                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±  
±±³Retorno   ³ExpL:  Retorna .F. ou .T. 					              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³MATA103X                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A103VldNFO(n)
                                
Local lRet  	 := .T.       
Local cItem 	 := ""
Local nPosItmOri := GetPosSD1("D1_ITEMORI")

If cTipo$"DCPI"      
    cItem:=IIf(Empty(aCols[n][nPosItmOri]),"x",aCols[n][nPosItmOri])  
    lRet:=A103ITDEV(cItem)
EndIf

Return(lRet)


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³RatPed2NF ºAutor  ³Microsiga           º Data ³  06/18/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Carrega automaticamente o rateio do item da Nota fiscal    º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function RatPed2NF(aHeadSDE,aColsSDE,cItem,nRecSC7,aRateioCC)
Local aArea			:= GetArea()
Local nPosItem		:= Ascan(aHeadSDE,{|x| AllTrim(x[2]) == "DE_ITEM"} )
Local nPosPerc		:= Ascan(aHeadSDE,{|x| AllTrim(x[2]) == "DE_PERC"} )
Local nPosCC		:= Ascan(aHeadSDE,{|x| AllTrim(x[2]) == "DE_CC"} )
Local nPosConta		:= Ascan(aHeadSDE,{|x| AllTrim(x[2]) == "DE_CONTA"} )
Local nPosItCta		:= Ascan(aHeadSDE,{|x| AllTrim(x[2]) == "DE_ITEMCTA"} )
Local nPosCLVL		:= Ascan(aHeadSDE,{|x| AllTrim(x[2]) == "DE_CLVL"} )
Local nPosACols		:= Ascan(aColsSDE,{|x| AllTrim(x[1]) == Alltrim(cItem) } )
Local nPosCpoCus    := 0
Local nCt			:= 0
Local nLinha		:= 0
Local nX			:= 0
Local nPos			:= 0
Local cCpoSCH		:= ""
Local aAux			:= {}
Local aEntidades	:= {}
Local aCustomCPO    := {}
Local nEnt			:= 0
Local nDeb			:= 0
Local nTamItem		:= TamSX3("DE_ITEM")[1]
Local lSC7Exclsv	:= FWModeAcces("SC7", 1) + FWModeAcces("SC7", 2) + FWModeAcces("SC7", 3) == "EEE"
Local lCTTExclsv    := FWModeAcces("CTT", 3) == "E"
Local lGetRat		:= .T.
Local lPCFilen		:= SuperGetMv("MV_PCFILEN",.F.,.F.)
Local ny            := 1

Default aRateioCC := {}

If !Empty(aRateioCC)
	If (nPos := Ascan(aRateioCC,{|x| x[1]== cItem})) > 0
		aAux := aRateioCC[nPos][2]
		For nX := 1 To Len(aAux)
			
			If nCt == 0
				If nPosACols <= 0
					aAdd(aColsSDE,{ cItem,{} } )
					nPosACols := Len(aColsSDE)
					nCt+=1
				EndIf
			EndIF
			
			aAdd(aColsSDE[nPosACols][2],Array( Len(aHeadSDE) + 1 ) )
			nLinha++

			For ny := 1 to Len(aAux[nx])

				nPosHead	:= aScan(aHeadSDE,{|x| AllTrim(x[2]) == Alltrim(aAux[1][ny][1])})
				nPos		:= Ascan(aAux[nX],{|x| AllTrim(x[1]) == Alltrim(aAux[1][ny][1])})

				If nPosHead > 0 .And. nPos > 0
					aColsSDE[nPosACols][2][nLinha][nPosHead] := aAux[nx][nPos][2]
				Endif
			Next

			aColsSDE[nPosACols][2][nLinha][nPosItem]  := RetAsc(nLinha,nTamItem,.T.)
			aColsSDE[nPosACols][2][nLinha][Len(aHeadSDE) + 1] := .F.

			aEntidades := CtbEntArr()
			For nEnt := 1 to Len(aEntidades)
				For nDeb := 1 to 2
					cCpo := "DE_EC"+aEntidades[nEnt]
						
					If nDeb == 1
						cCpo += "DB"
					Else
						cCpo += "CR"
					EndIf
						
					nPosHead	:= aScan(aHeadSDE,{|x| AllTrim(x[2]) == Alltrim(cCpo) } )
					nPos		:= Ascan(aAux[nX],{|x| AllTrim(x[1]) == Alltrim(cCpo) } )
						
					If nPosHead > 0 .And. nPos > 0
						aColsSDE[nPosACols][2][nLinha][nPosHead] := aAux[nX][nPos][2]
					EndIf
						
				Next nDeb
			Next nEnt
						
		Next nX	

	EndIf	
Else
	SC7->(MsGoTo(nRecSC7))
	If lCTTExclsv .And. lSC7Exclsv
		lGetRat := SC7->C7_FILIAL == cFilAnt

		If !lGetRat .And. lPCFilen
			lGetRat := SC7->C7_FILENT == cFilAnt
		Endif
	EndIf
	If lGetRat
		dbSelectArea("SCH")
		cFilSCH := xFilial("SCH", Iif(lSC7Exclsv, SC7->C7_FILIAL, cFilAnt))
		SCH->(dbSetOrder(1))//CH_FILIAL+CH_PEDIDO+CH_FORNECE+CH_LOJA+CH_ITEMPD+CH_ITEM
		If SCH->(dbSeek(cFilSCH + SC7->( C7_NUM + C7_FORNECE + C7_LOJA + C7_ITEM ) ))
			For nX := 1 to len(aHeadSDE)
				If FwGetSx3Cache(aHeadSDE[nX][2],"X3_PROPRI") == "U"
					aadd(AcustomCPO,{aHeadSDE[nX][2],FwGetSx3Cache(aHeadSDE[nX][2],"X3_TIPO"),Substr(aHeadSDE[nX][2],4,len(aHeadSDE[nX][2])-3) })
				Endif
			Next nX
					While SCH->(!Eof()) .And. SCH->(CH_FILIAL + CH_PEDIDO + CH_FORNECE+ CH_LOJA+ CH_ITEMPD) == cFilSCH + SC7->( C7_NUM + C7_FORNECE + C7_LOJA + C7_ITEM  )
				If nCt == 0
					If nPosACols <= 0
						aAdd(aColsSDE,{ cItem,{} } )
						nPosACols := Len(aColsSDE)
					Else
						aColsSDE[nPosACols][2] := {}
					EndIf
					nCt+=1
				EndIF
				nLinha++
				If len(aColsSDE[nPosACols][2]) < nLinha
				
					aAdd(aColsSDE[nPosACols][2],Array( Len(aHeadSDE) + 1 ) )

				EndIf

				aColsSDE[nPosACols][2][nLinha][nPosItem]  := RetAsc(Str(nLinha),nTamItem,.T.)
				aColsSDE[nPosACols][2][nLinha][nPosPerc]   	:= SCH->CH_PERC
				aColsSDE[nPosACols][2][nLinha][nPosCC]   	:= SCH->CH_CC
				aColsSDE[nPosACols][2][nLinha][nPosConta]   := SCH->CH_CONTA
				aColsSDE[nPosACols][2][nLinha][nPosItCta]  	:= SCH->CH_ITEMCTA
				aColsSDE[nPosACols][2][nLinha][nPosCLVL]   	:= SCH->CH_CLVL
				aColsSDE[nPosACols][2][nLinha][Len(aHeadSDE) + 1] := .F.
				
				aEntidades := CtbEntArr()
				For nEnt := 1 to Len(aEntidades)
					For nDeb := 1 to 2
						cCpo := "DE_EC"+aEntidades[nEnt]
						cSCH := "CH_EC"+aEntidades[nEnt]
							
						If nDeb == 1
							cCpo += "DB"
							cSCH += "DB"
						Else
							cCpo += "CR"
							cSCH += "CR"
						EndIf
							
						nPosHead := aScan(aHeadSDE,{|x| AllTrim(x[2]) == Alltrim(cCpo) } )
							
						If nPosHead > 0
							aColsSDE[nPosACols][2][nLinha][nPosHead] := SCH->(&(cSCH))
						EndIf
							
					Next nDeb
				Next nEnt
				// Carrega campos customizados
				For nX := 1 to len(aCustomCPO)

					nPosCpoCus := Ascan(aHeadSDE,{|x| AllTrim(x[2]) == alltrim(aCustomCPO[nX][1]) } )
					cCpoSCH := "CH_"+ aCustomCPO[nX][3]
					If FieldPos(cCpoSCH) > 0
						aColsSDE[nPosACols][2][nLinha][nPosCpoCus] := SCH->(&(cCpoSCH))
					Else
						If aCustomCPO[nX][2] = "C"
							aColsSDE[nPosACols][2][nLinha][nPosCpoCus]   	:= SPACE(LEN(aHeadSDE[nX][2]))

						ElseIf aCustomCPO[nX][2] = "N"
							aColsSDE[nPosACols][2][nLinha][nPosCpoCus]   	:= 0
						
						ElseIf aCustomCPO[nX][2] = "D"
							aColsSDE[nPosACols][2][nLinha][nPosCpoCus]   	:= CtoD("  /  /  ")

						ElseIf aCustomCPO[nX][2] = "L"
							aColsSDE[nPosACols][2][nLinha][nPosCpoCus]   	:= .F.
						Else
							aColsSDE[nPosACols][2][nLinha][nPosCpoCus]   	:= NIL
						EndIf
					Endif
				Next 

				SCH->(dbSkip())
			EndDo
		EndIf
	EndIf
Endif
FwFreeArray(aCustomCPO)
RestArea(aArea)
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³A103ValNatºAutor  ³TOTVS			     º Data ³  14/10/2010 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Validacoes na Natureza									  º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function A103ValNat(cNatureza)
Local aArea:= GetArea()
Local lRet := .T.
If !Empty(cNatureza)
	DbSelectArea("SED")
	DbSetOrder(1)
	DbSeek (xFilial("SED")+cNatureza)
	If !Eof() .And. ED_TIPO == "1"
        Help("  ",1,"A103VLDNAT")
     	lRet:= .F.
	EndIf         
	//Valida se a natureza pode ser utilizada pelo compras
	If lRet
	   lRet:=FinVldNat(.F.,cNatureza,2)
	EndIf

	if lRet .And. !RegistroOk("SED")
		lRet := .F.
	endif
EndIf    
RestArea(aArea)
Return (lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³A103ValFrete ºAutor  ³TOTVS		     º Data ³  23/02/2011 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Valida Campo Tipo de Frete / Aba: DANFE					  º±±  
±±º		     ³ O conteudo somente podera ser preenchido quando nao existirº±±  
±±º		     ³ nenhum pedido vinculado ao pedido de compras				  º±±  
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A103ValFrete()
Local aArea	   := GetArea()
Local nPosPc   := GetPosSD1("D1_PEDIDO")
Local nPosItPc := GetPosSD1("D1_ITEMPC")
Local nX       := 0
Local lPed     := .F.
Local lRet     := .T.
Local lvldFret := SuperGetMV("MV_VALFRET",.F.,.F.)

For nX:=1 to Len(aCols)
	If nPosPc>0
		lPed:=IIF(Empty(aCols[nX][nPosPc]),.F.,.T.) 
	EndIf
	If nPosItPc>0 .And. !lPed
		lPed:=IIF(Empty(aCols[nX][nPosPc]),.F.,.T.)
	EndIf
	If lPed 
	   Exit 
	EndIf
Next nX   
                            
IF Len(aNfeDanfe)>0
    If !lvldFret .And. lPed .And. Len(Trim(aNFEDanfe[14]))>0   //Tem PC vinculado a Nota e Tipo de Frete esta preenchido
    	lRet:=.F.
    EndIf
EndIf

If !lRet     
	Help('',1,'A103FRETE')
EndIf

RestArea(aArea)
Return (lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³A103ValEstNegºAutor  ³TOTVS		     º Data ³  25/02/2011 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Valida se irá permitir estoque negativo					  º±±  
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A103ValEstNeg(cProd,cAliasSd1)
Local aArea	     := GetArea()   
Local lMT103ENEG := ExistBlock("MT103ENEG")  
Local lRet	     := .F.

//Ponto de Entrada que permite o saldo negativo mesmo o parâmetro MV_ESTNEG estando como N
//Produto não poderá ter lote ou localizacao  
If lMT103ENEG
	If !(Rastro(cProd) .And. !Localiza(cProd))
		lRet:=ExecBlock("MT103ENEG",.F.,.F.,{cAliasSD1})
		If ValType(lRet)<>"L"
			lRet:=.F.
		EndIf
	EndIf
Else
	Aviso(STR0018,STR0019 + AllTrim((cAliasSD1)->D1_COD)+"/"+(cAliasSD1)->D1_LOCAL + STR0023 + AllTrim(Str(nSaldoB2))+") ",{STR0025}) //"Atencao" //"O Saldo do Prod/Loc "###" ficara negativo apos a Exclusao ("###"Aborta"
	lRet:=.F.
EndIf

RestArea(aArea)
Return (lRet)
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³A103CompDanfeºAutor  ³TOTVS		     º Data ³  13/06/2011 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Campos complementares aba DANFE	             			  º±±  
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A103CompDanfe()
Local aCompDanfe:={}

aCompDanfe:=execblock("MT103DCF",.F.,.F.,{INCLUI,ALTERA,L103VISUAL,aDanfeComp})
If Valtype(aCompDanfe)=="A"
	aDanfeComp:=aClone(aCompDanfe)
EndIf

Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ A103LockPC ºAutor  ³TOTVS              º Data ³  30/08/11  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Bloqueia Pedidos utilizados no Acols				    	  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³                                               		      º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/ 
Function A103LockPC(aCabec, aItens) 
Local nPed		:= GetPosSD1("D1_PEDIDO")
Local nItPed	:= GetPosSD1("D1_ITEMPC")
Local nCodProd	:= GetPosSD1("D1_COD")
Local nXp		:= 0
Local nBlq		:= 0
Local cUnico   := ""
Local lRet		:= .T.
Local aAreaAtu	:= GetArea()

aRegsLock:={}

If Len(aItens)>0 .and. nPed>0 .And. nItPed>0 
	
	If Len(aItens)>0 .and. nPed>0 .And. nItPed>0 
		If FindFunction("FWX2Unico")
			cUnico := FWX2Unico("SC7")
		Else
			cUnico := "C7_FILIAL+C7_NUM+C7_ITEM+C7_SEQUEN+C7_ITEMGRD" // X2_UNICO da SC7
		EndIf
	EndIf
	If Len(AllTrim(cUnico))>0
		DbSelectArea("SC7")
		DbSetOrder(4)
		For nXp:=1 to Len(aItens)
			If !Empty(aItens[nXp][nPed]) .And. !Empty(aItens[nXp][nItPed])
				If DbSeek(xFilial("SC7")+aItens[nXp][nCodProd]+aItens[nXp][nPed]+aItens[nXp][nItPed])
					If !MultLock("SC7",{&cUnico},1,.F.,.T.)
						nBlq++
						Exit
					Else
						aaDD(aRegsLock,{"SC7",Recno()})
						If DbSeek(xFilial("SC7")+aItens[nXp][nCodProd]+aItens[nXp][nPed]+aItens[nXp][nItPed])
							If	!(MA103CkAIC(SC7->C7_FORNECE,SC7->C7_LOJA,SC7->C7_PRODUTO))
								If ( !(C7_QUANT-C7_QUJE-IIF(l103Class,0,C7_QTDACLA))>0 .Or. C7_RESIDUO$'S' .Or. C7_ENCER$'E' ) .And. C7_ORIGEM <> 'EICPO400'
									Help(" ",1,"QTDLIBMAI")
									lRet := .F.
									nBlq++
									Exit
								EndIf
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf
	   Next nXp
	EndIf
EndIf

If nBlq>0
	A103UnlkPC()
	lRet := .F.
EndIf

RestArea(aAreaAtu)

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ A103LockPC ºAutor  ³TOTVS              º Data ³  30/08/11  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Desbloqueia Pedidos utilizados no Acols			    	  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³                                               		      º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A103UnlkPC
	SC7->(MsUnLockAll())
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ A103ChamaHelp ºAutor  ³TOTVS           º Data ³  03/10/11  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Funcao para exibir os Helps do campo F1_CHVNFE ao finalizarº±± 
±±º          | o documento de entrada                                     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³                                               		      º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/ 
Function A103ChamaHelp(l103Inc,l103Cla)

Local lDigChv 	:= GetNewPar("MV_DCHVNFE",.F.) 
Local lRetorno 	:= .T.
Local cChvEspe	:= SuperGetMV( "MV_CHVESPE" , .F. , "" )
Local cCompara	:= "|SPED|CTE|"
Local aCompara	:= {}
Local lRotAuto  := Type("l103Auto") == "L" .And. l103Auto

Default l103Inc := .F.
Default l103Cla := .F.

If lDigChv
	cChvEspe := StrTran(cChvEspe,",","|")
	cChvEspe := StrTran(cChvEspe,";","|")
	
	If !Empty( cChvEspe )
		cCompara += cChvEspe + "|"
	EndIf
Endif

//Adequeacao da Validacao
//Transforma a String em Array
aCompara := StrToKarr(cCompara,"|")
    
If lDigChv 
	If SF1->(FieldPos("F1_CHVNFE")) > 0 .And. (!lRotAuto .Or. (lRotAuto .And. (l103Inc .Or. l103Cla)))
		If (cFormul == "N" .and. aScan(aCompara,{|x| x == ALLTRIM(cEspecie)} ) > 0 )
			If Type("aNFEDanfe[13]") <> "U"
				M->F1_CHVNFE 	:= IIF(!EMPTY(M->F1_CHVNFE),M->F1_CHVNFE,aNFEDanfe[13]) 
			EndIf

			If GetSx3Cache("F1_CHVNFE",'X3_VISUAL') == "V"
			 	Help(" ",1,"CHVALTERAR")
	   			lRetorno := .F.
	   		ElseIf Empty(M->F1_CHVNFE)
				Help(" ",1,"DCHVNFE")
				lRetorno := .F.
			ElseIf len(Alltrim(M->F1_CHVNFE)) < 44
				Help(" ",1,"CHVMENOR")
				lRetorno := .F.
			EndIf
         EndIf   
	EndIf  	
EndIf  

Return lRetorno

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ A103ConsNfeSef ºAutor  ³TOTVS          º Data ³  03/10/11  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Consulta a chave da NFe digitada na Sefaz                  º±± 
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³                                               		      º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/ 
Function A103ConsNfeSef(cVarChvNfe,aCab) 

Local lConChv 	:= GetNewPar("MV_CHVNFE",.F.)
Local lDigChv 	:= GetNewPar("MV_DCHVNFE",.F.)
Local lBlqChv	:= GetNewPar("MV_BCHVNFE",.F.)
Local lRet	  	:= .F.   
Local cURL      := PadR(GetNewPar("MV_SPEDURL","http://"),250)
Local cIdEnt   	:= ""
Local cChaveNFe := ""
Local cCodRet	:= "Codigo de retorno: "
Local cMensRet  := "Mensagem de retorno: " 
Local cProt		:= "Protocolo: "
Local cChavCan	:= "A chave informada não poderá ser gravada, pois está cancelada junto à Sefaz."
Local cChvAuto	:= ""
Local nPos		:= ""
Local cChvEspe	:= SuperGetMV( "MV_CHVESPE" , .F. , "" )
Local cCompara	:= "|SPED|CTE|NFA|"
Local cError	:= ""

local lConsCte	:= SuperGetMV("MV_CONSCTE",.F.,.F.)
local lConsNfe	:= SuperGetMV("MV_CONSNFE",.F.,.F.)
Local nPosVld056	:= 0

DEFAULT aCab	:= IIf( Type("aAutoCab") == "A",aAutoCab,{})

nPosVld056		:= IIf (Len(acab)>0,aScan(acab,{|x| AllTrim(x[1]) == "VLDAMNFE"}),0)

Private oWS

Default cVarChvNfe	:= ""

if Type("lAbreTela") == "U"
	lAbreTela := .F.
endif 	


If lDigChv
	cChvEspe := StrTran(cChvEspe,",","|")
	cChvEspe := StrTran(cChvEspe,";","|")
	
	If !Empty( cChvEspe )
		cCompara += cChvEspe + "|"
	EndIf
Endif
If Type("aNFEDanfe[13]") ==  "C"
	M->F1_CHVNFE := aNFEDanfe[13]
EndIf
If	(lDigChv .and. cFormul == "N" .and. ( "|" + AllTrim(cEspecie) + "|" $ cCompara ) )  
	If Empty(cVarChvNfe)
		M->F1_CHVNFE 	:= &(ReadVar())
		cChaveNFe  		:= M->F1_CHVNFE
	Else
		cChaveNFe  		:= cVarChvNfe
	EndIF
	
	If Type("l103Auto") == "U"
		Private l103Auto := .F.
	EndIf
	
	If Type("l116Auto") == "U"
		Private l116Auto := .F.
	EndIf
		
	If l103Auto
		nPos := aScan(aAutoCab,{|x| AllTrim(x[1]) == "F1_CHVNFE"})
		If nPos > 0
			cChvAuto := aAutoCab[nPos,2]
		Endif
		
		If !Empty(cChvAuto) .And. cChvAuto <> cChaveNFe
			M->F1_CHVNFE	:= cChvAuto	
			cChaveNFe		:= M->F1_CHVNFE
		Endif
	Endif		
	
    If lConChv
    	If IsReady(cURL)
	
	    	//Obtem o codigo da entidade
			If FindFunction("getCfgEntidade") 
				cIdEnt := getCfgEntidade(@cError)
			Else 
				cError := "Função getCfgEntidade não localizada no RPO!"
			EndIf

			If !Empty(cError)
				Aviso("SPED",cError,{"OK"},3)
			EndIf  
			
			oWs:= WsNFeSBra():New()
			oWs:cUserToken   := "TOTVS"
			oWs:cID_ENT      := cIdEnt
			ows:cCHVNFE		 := cChaveNFe
			oWs:_URL         := AllTrim(cURL)+"/NFeSBRA.apw"
			
			If oWs:ConsultaChaveNFE()
				If Type ("oWs:oWSCONSULTACHAVENFERESULT:cPROTOCOLO") == "U" .OR. Empty (oWs:oWSCONSULTACHAVENFERESULT:cPROTOCOLO)
					If AllTrim(oWs:oWSCONSULTACHAVENFERESULT:cCODRETNFE) == "731" .or. AllTrim(oWs:oWSCONSULTACHAVENFERESULT:cCODRETNFE) == "526"
						If ((FwIsInCallStack("GFEA065") .Or. FwIsInCallStack("GFEA070") .Or. (FwIsInCallStack("GFEA067")) .And. lConsCte) .or. (FwIsInCallStack("MATA103") .And. lConsNfe) )  .And. (l103Auto .Or. l116Auto)
							lRet := .T.
						Else
							If !l103Auto
								If MsgNoYes(cCodRet+oWs:oWSCONSULTACHAVENFERESULT:cCODRETNFE+CRLF+;
											cMensRet+oWs:oWSCONSULTACHAVENFERESULT:cMSGRETNFE+CRLF+;
											"Verificar se o Ano-Mês da Chave de Acesso está com atraso"+CRLF+;
											"superior a 6 meses em relação ao Ano-Mês atual."+CRLF+CRLF+CRLF+;
											"Deseja inserir a chave mesmo assim?")
									lRet := .T.							
								Else
									M->F1_CHVNFE := "" 
									lRet := .F.
								EndIf
							
							Else
								If nPosVld056 > 0 .And. aCab[nPosVld056][2] == "S"
									Help("  ",1,"CONSULTNF",,cCodRet+oWs:oWSCONSULTACHAVENFERESULT:cCODRETNFE+CRLF+;
												cMensRet+oWs:oWSCONSULTACHAVENFERESULT:cMSGRETNFE+CRLF+;
												"Verificar se o Ano-Mês da Chave de Acesso está com atraso"+CRLF+;
												"superior a 6 meses em relação ao Ano-Mês atual.",1,0)
									lRet := .F.
								EndIf	
							Endif
						EndIf
					ElseIf AllTrim(oWs:oWSCONSULTACHAVENFERESULT:cCODRETNFE) == "101" .or. AllTrim(oWs:oWSCONSULTACHAVENFERESULT:cCODRETNFE) == "151"
						Help("  ",1,"CONSULTNF",,cCodRet+oWs:oWSCONSULTACHAVENFERESULT:cCODRETNFE+CRLF+;
				   		       cMensRet+oWs:oWSCONSULTACHAVENFERESULT:cMSGRETNFE+CRLF+CRLF+cChavCan,1,0) 
						lRet := .F.
					ElseIF AllTrim(oWs:oWSCONSULTACHAVENFERESULT:cCODRETNFE) == "100" //Autorizado porém sem as informações do Protocolo por Instabilidade na SEFAZ
						If !l103Auto
							MsgAlert(cCodRet+oWs:oWSCONSULTACHAVENFERESULT:cCODRETNFE+CRLF+;
							         cMensRet+oWs:oWSCONSULTACHAVENFERESULT:cMSGRETNFE+CRLF)
						Endif
						lRet := .T.
					ElseIf AllTrim(oWs:oWSCONSULTACHAVENFERESULT:cCODRETNFE) == "999" .And. Alltrim(cEspecie) == "NF3E"
						If !l103Auto
							If MsgNoYes(cCodRet+oWs:oWSCONSULTACHAVENFERESULT:cCODRETNFE+CRLF+;
								cMensRet+oWs:oWSCONSULTACHAVENFERESULT:cMSGRETNFE+CRLF+CRLF+CRLF+;
								"Deseja inserir a chave mesmo assim?")
								lRet := .T.							
							Else
								M->F1_CHVNFE := "" 
								lRet := .F.
							EndIf
						else 
							lRet := .T.
						endif
					Else
						If !l103Auto .And. !lAbreTela
							MsgAlert("A chave digitada não foi encontrada na Sefaz, favor verificar")
						Else
							Help("  ",1,"CONSULTNF",,"A chave digitada não foi encontrada na Sefaz, favor verificar",1,0)
						Endif
						M->F1_CHVNFE := "" 
						lRet := .F.
					endIf
				Else
				    If AllTrim(oWs:oWSCONSULTACHAVENFERESULT:cCODRETNFE) == "101" .or. AllTrim(oWs:oWSCONSULTACHAVENFERESULT:cCODRETNFE) == "151"
						Help("  ",1,"CONSULTNF",,cCodRet+oWs:oWSCONSULTACHAVENFERESULT:cCODRETNFE+CRLF+;
				   		       cMensRet+oWs:oWSCONSULTACHAVENFERESULT:cMSGRETNFE+CRLF+CRLF+cChavCan,1,0) 
						lRet := .F.		
					Else	
						lRet := .T.
						If !l103Auto
							MsgAlert(cCodRet+oWs:oWSCONSULTACHAVENFERESULT:cCODRETNFE+CRLF+;
							         cMensRet+oWs:oWSCONSULTACHAVENFERESULT:cMSGRETNFE+CRLF+;
							         cProt+oWs:oWSCONSULTACHAVENFERESULT:cPROTOCOLO)
						Endif
					EndIf
				EndIf
			Else
				Aviso("SPED",IIf(Empty(GetWscError(3)),GetWscError(1),GetWscError(3)),{"OK"},3)
				If len(Alltrim(M->F1_CHVNFE)) > 0 .and. len(Alltrim(M->F1_CHVNFE)) < 44
					If GetRemoteType() == -1 //Job
						lRet := .T. 
					Else 
						If !l103Auto
							If MsgNoYes("A chave informada é menor que o permitido e impossibilita a consulta na Sefaz."+CRLF+CRLF+;
										"Deseja APAGAR o conteúdo do campo para inserir uma nova chave?")
								M->F1_CHVNFE := "" 
								lRet := .F.  //Limpa o campo caso tenha uma chave menor 
							Else 
								lRet := .T.
							EndIf
						Else
							Help("  ",1,"CONSULTNF",,"A chave informada é menor que o permitido e impossibilita a consulta na Sefaz.",1,0)
							lRet := .F.
						Endif
					Endif
				ElseIf  (lBlqChv .And. !Empty(GetWscError(3))) .Or.;  //"Falha no retorno da SEFAZ"
				 		(!Empty(GetWscError(3)) .and. "INTERNAL SERVER ERROR" $ Upper(GetWscError(3))) //Internal Server Error
				  	M->F1_CHVNFE := "" 
					lRet := .F.
				Else
					lRet := .T.			
				EndIf	
			EndIf
		Else
			Help(" ",1,"TSSINATIVO")	
			lRet := .F.
		EndIf	
	Else
		lRet := .T.
	EndIf
Else
	lRet := .T.  
EndIf    

Return  lRet        
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ IsReady ºAutor  ³TOTVS                 º Data ³  03/10/11  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Verifica se a conexao com o TSS pode ser estabelecida      º±± 
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³                                               		      º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/ 
Static Function IsReady(cURLTss)

Local oWS
Local lRetorno := .F.    

PutMV("MV_SPEDURL",cURLTss)

SuperGetMv() //Limpa o cache de parametros - nao retirar        

DEFAULT cURLTss  := PadR(GetNewPar("MV_SPEDURL","http://"),250)

//Verifica se o servidor da Totvs esta no ar
oWs := WsSpedCfgNFe():New()
oWs:cUserToken := "TOTVS"
oWS:_URL := AllTrim(cURLTss)+"/SPEDCFGNFe.apw"

If oWs:CFGCONNECT()
	lRetorno := .T.
EndIf

Return lRetorno


/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ A103VldEsp ºAutor  ³Leandro Paulino    º Data ³  28/12/11  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Valida as especies permitidas quando a integração com o    º±±
±±º			 ³	TOTVSGEF estiver habilitada                           	  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³                                               		      º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/

Function A103VldEsp ()
Local lRet			:= .T.                                                                                                

If ("CTR" $ cEspecie .Or. "CTE" $ cEspecie .Or. "NFST" $ cEspecie ) .And. (!( FWIsInCallStack( "FWUMESSAGE" ) .OR. FWIsInCallStack( "FWFORMEAI" ) ))
	If MsgYesNo(STR0121 + Chr(13) + STR0122,STR0018) //"Com a integração ativa entre o ERP Protheus e o TOTVSGFE, os documentos de Transporte devem ser lançados pelo TOTVSGFE! "/"Confirma o lançamento? ")
	Else 
		lRet := .F.
	EndIF	
EndIf

Return lRet
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³A103ConsCTEºAutor  ³TOTVS S.A.		 º Data ³  29/12/2011 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Consiste o Tipo CTE		   						          º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³MATA103                                                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A103ConsCTE(cTpCTE)
Local lRet :=.T.

If Type("cEspecie")<>"U" .And. "CTE" == AllTrim(cEspecie)
	If Empty(trim(cTPCTE))
	    Aviso(STR0014 + " " + RetTitle("F1_TPCTE"),STR0118,{STR0038})
		lRet := .F.		
	EndIf
EndIf
Return lRet
            
/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o	 ³M103GrvSE5³ Autor ³ Aline S Damasceno     ³ Data ³ 26/07/12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³ Gravacao de registros do SE5 na exclusao C.Pagar			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ F050GrvSE5()		 										  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ MATA103										    		  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function MT103GrvSE5()
Local aAreaGrv	:= GetArea()
Local oModelMov 	:= NIL
Local oSubFK5
Local oSubFKA
Local oSubFK2
Local cCamposE5	:= ""
Local lRet 		:= .T.
Local lBkpAltera	:= ALTERA

//Limpa chaves de relacionamento (SE5)
Local cAliasSE5  	As Character 
Local cQuery 		As Character 
Local nOrder  		As Numeric
Local oQry    		As Object

	cAliasSE5 	:= GetNextAlias()
	cQuery 		:= ""
	nOrder 		:= 1  
	oQry 		:= Nil

	cQuery := "SELECT SE5.E5_FILIAL, SE5.E5_PREFIXO,SE5.E5_NUMERO,SE5.E5_PARCELA,SE5.E5_TIPO, SE5.E5_CLIFOR,SE5.E5_LOJA, SE5.R_E_C_N_O_ "
	cQuery += "FROM ? SE5 "
	cQuery += "WHERE SE5.D_E_L_E_T_= ? AND SE5.E5_FILIAL = ? " 
	cQuery += "AND SE5.E5_PREFIXO = ? AND SE5.E5_NUMERO = ? AND SE5.E5_PARCELA = ? AND SE5.E5_TIPO = ? AND SE5.E5_FORNECE = ? AND SE5.E5_LOJA = ? "
	cQuery += "ORDER BY E5_FILIAL, E5_PREFIXO, E5_NUMERO, E5_PARCELA, E5_TIPO, E5_CLIFOR, E5_LOJA "
	
	oQry := FWPreparedStatement():New()
	oQry:SetQuery(cQuery)
	
	oQry:SetNumeric(nOrder++,RetSqlName("SE5"))
	oQry:SetString(nOrder++,Space(1) )
	oQry:SetString(nOrder++,xFilial("SE5"))
	oQry:SetString(nOrder++,SE2->E2_PREFIXO )
	oQry:SetString(nOrder++,SE2->E2_NUM )
	oQry:SetString(nOrder++,SE2->E2_PARCELA )
	oQry:SetString(nOrder++,SE2->E2_TIPO )
	oQry:SetString(nOrder++,SE2->E2_FORNECE )
	oQry:SetString(nOrder++,SE2->E2_LOJA )

	cQuery    := oQry:GetFixQuery()
	cAliasSE5 := MpSysOpenQuery(cQuery,cAliasSE5)

	dbSelectArea(cAliasSE5)
	DbGoTop()
	
	While (cAliasSE5)->(!Eof())
		
		SE5->(DbGoTo((cAliasSE5)->R_E_C_N_O_)) 

		cCamposE5 := ""
		
		cCamposE5 += "{"
		cCamposE5 += "{'E5_KEY'		, SE5->(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_FORNECE+E5_LOJA)	}"
		cCamposE5 += ",{'E5_PREFIXO', ''																			}"
		cCamposE5 += ",{'E5_NUMERO'	, ''																			}"
		cCamposE5 += ",{'E5_PARCELA', ''																			}"
		cCamposE5 += ",{'E5_TIPO'	, ''																			}"
		//Manda o campo LA com o valor de 2 Caracteres, para manter a gravação original na E5
		cCamposE5 += ",{'E5_LA'		, 'S"  + SubStr( SE5->E5_LA, 2, 1 ) + "'										}" 
		cCamposE5 += "}"
		
		If SE5->E5_TABORI == "FK5"
			oModelMov := FWLoadModel("FINM030") //Recarrega o Model de movimentos para pegar o campo do relacionamento (SE5->E5_IDORIG)
			oModelMov:SetOperation( MODEL_OPERATION_UPDATE ) //Alteração
			oModelMov:Activate()
			oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //Habilita gravação de SE5
			oModelMov:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que serão gravados indepentes de FK5
			
			//Posiciona a FKA com base no IDORIG da SE5 posicionada
			oSubFKA := oModelMov:GetModel( "FKADETAIL" )
			oSubFKA:SeekLine( { {"FKA_IDORIG", SE5->E5_IDORIG } } )
					
			//Dados Contábeis
			oSubFK5 := oModelMov:GetModel("FK5DETAIL")	
			oSubFK5:SetValue( "FK5_LA", "S" ) //Salva apenas 1 caractere (S ou N) nas FKs
			
			If oModelMov:VldData()
				oModelMov:CommitData()
		   		oModelMov:DeActivate()
			Else
				lRet := .F.
				cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
				cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
				cLog += cValToChar(oModelMov:GetErrorMessage()[6])        	
				Help( ,,"M030VALID",,cLog, 1, 0 )
    		Endif
		ElseIf SE5->E5_TABORI == "FK2"
			oModelMov := FWLoadModel("FINM020") //Recarrega o Model de movimentos para pegar o campo do relacionamento (SE5->E5_IDORIG)
			oModelMov:SetOperation( MODEL_OPERATION_UPDATE ) //Alteração
			oModelMov:Activate()
			oModelMov:SetValue( "MASTER", "E5_GRV", .T. ) //Habilita gravação de SE5
			oModelMov:SetValue( "MASTER", "E5_CAMPOS", cCamposE5 ) //Informa os campos da SE5 que serão gravados indepentes de FK5
			
			//Posiciona a FKA com base no IDORIG da SE5 posicionada
			oSubFKA := oModelMov:GetModel( "FKADETAIL" )
			oSubFKA:SeekLine( { {"FKA_IDORIG", SE5->E5_IDORIG } } )
					
			//Dados Contábeis
			oSubFK2 := oModelMov:GetModel("FK2DETAIL")	
			oSubFK2:SetValue( "FK2_LA", "S" ) //Salva apenas 1 caractere (S ou N) nas FKs
			
			If oModelMov:VldData()
				oModelMov:CommitData()
		   		oModelMov:DeActivate()
			Else
				lRet := .F.
				cLog := cValToChar(oModelMov:GetErrorMessage()[4]) + ' - '
				cLog += cValToChar(oModelMov:GetErrorMessage()[5]) + ' - '
				cLog += cValToChar(oModelMov:GetErrorMessage()[6])        	
				Help( ,,"M020VALID",,cLog, 1, 0 )
	    	Endif
		EndIf
    	
	(cAliasSE5)->(dbskip())
	Enddo

ALTERA := lBkpAltera  

(cAliasSE5)->(dbclosearea())
RestArea(aAreaGrv)
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³FillCTBEntºAutor  ³ Andre Anjos		 º Data ³ 02/08/12    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDescricao ³ Inicaliza campos das entidades contabeis de acordo com a   º±±
±±º          ³ origem.                                                    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ MATA103                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function FillCTBEnt(cOrigem,nItem)

Local nX	  := 0

If _aCTBEnt == Nil
	_aCTBEnt := CTBEntArr()
Endif

For nX := 1 To Len(_aCTBEnt)
	If GetPosSD1("D1_EC"+_aCTBEnt[nX]+"CR") > 0 .And. (cOrigem)->(FieldPos(Substr(cOrigem,2)+"_EC"+_aCTBEnt[nX]+"CR")) > 0
		aCols[nItem,GetPosSD1("D1_EC"+_aCTBEnt[nX]+"CR")] := (cOrigem)->&(Substr(cOrigem,2)+"_EC"+_aCTBEnt[nX]+"CR")
	EndIf
	If GetPosSD1("D1_EC"+_aCTBEnt[nX]+"DB") > 0 .And. (cOrigem)->(FieldPos(Substr(cOrigem,2)+"_EC"+_aCTBEnt[nX]+"DB")) > 0
		aCols[nItem,GetPosSD1("D1_EC"+_aCTBEnt[nX]+"DB")] := (cOrigem)->&(Substr(cOrigem,2)+"_EC"+_aCTBEnt[nX]+"DB")
	EndIf
Next nX

Return

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o    |ISSFldDiv ³Autor  ³ Vitor Felipe          ³ Data ³06/06/2012 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Desc.     ³ Rotina tratamento do folder para informacoes do ISS e INSS. ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ oDlg: Objeto da Janela que sera disponibilizado os Get.     ³±±
±±³          ³ aPosGet: Array com as posicoes dos gets da NF-e.            ³±±
±±³          ³ aObjetos: Codeblock para atualizaco dos dados do Folder.    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                      ³±±
±±³          ³                                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Fiscal.                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function ISSFldDiv(oDlg,aPosGet,aObjetos,aInfISS,aFldCBAtu,nInfISS,oDescMun,cDescMun)      

Local aCombo1 := {STR0126,STR0127} //"1=Sim","2=Nao"
Local lEditMun:= .F.

PRIVATE M->F1_ESTPRES := ""

@ 04,03 TO 23 ,630 LABEL "" OF oDlg PIXEL
@ 05,aPosGet[1,1] SAY STR0128 Of oDlg PIXEL SIZE 50,50	// "Dados do Município:"

@ 010,aPosGet[1,2]    SAY STR0131 OF oDlg PIXEL SIZE 100,100 //"UF:"
@ 009,aPosGet[1,2]+15 MSGET aObjetos[01,03] VAR aInfISS[01,03] PICTURE X3Picture("CC2_EST") ; 
WHEN !l103Visual ;
VALID Vazio(aInfISS[01,03]) .or. (ExistCpo("SX5","12" + aInfISS[01,03]) .And. Eval( {|| M->F1_ESTPRES := aInfISS[01,03] , aInfAdic[18] := aInfISS[01,03] , lEditMun:= .T. } ) .And. ;
MaFisAlt("NF_UFPREISS",aInfISS[01,03],) .And. aObjetos[1,1]:SetFocus());
	F3 "12" OF oDlg PIXEL SIZE 10,08 HASBUTTON 

@ 010,aPosGet[1,10]+10 SAY STR0129 Of oDlg PIXEL SIZE 100,100 //"Codigo Mun:"
@ 009,aPosGet[1,10]+45 MSGET aObjetos[01,01] VAR aInfISS[01,01] PICTURE PesqPict('SA2','A2_COD_MUN');
WHEN !l103Visual .And. lEditMun  ;
VALID NaoVazio(aInfISS[01,01]) .and. A103DescMun( aInfISS[01,01] , @aObjetos[01,02] , @aInfISS[01,02] , aInfISS[01,03] ) .And. ;
MaFisAlt("NF_CODMUN",aInfISS[01,01],) .And. EncForIss(M->F1_ESTPRES,MaFisRet(,"NF_CODMUN"),aObjetos,@aInfISS) .And.; 
Eval( {|| aInfAdic[1] := aInfISS[01,01] , A103DescMun(aInfAdic[01], @oDescMun, @cDescMun, aInfAdic[18]) } );
F3 "CC2SF1" OF oDlg PIXEL SIZE 30,08 HASBUTTON

@ 010,aPosGet[1,10]+088 SAY STR0130 Of oDlg PIXEL SIZE 100,100 //"Desc. Mun:"
@ 009,aPosGet[1,10]+115 MSGET aObjetos[01,02] VAR aInfISS[01,02] PICTURE X3Picture("CC2_MUN"); 
WHEN .F. OF oDlg PIXEL SIZE 60,08 HASBUTTON  

@ 10,aPosGet[1,5] SAY STR0132 Of oDlg PIXEL SIZE 100,100	   		// "Ded Mat:"
@ 09,aPosGet[1,13] MSCOMBOBOX aObjetos[01,04] VAR aInfISS[01,04];
	ITEMS aCombo1 SIZE 25,08;
	WHEN .F.;
	OF oDlg PIXEL
@ 10,aPosGet[1,7] SAY STR0133 Of oDlg PIXEL SIZE 100,100		// "Ded Serv:"
@ 09,aPosGet[1,14] MSCOMBOBOX aObjetos[01,05] VAR aInfISS[01,05];
	ITEMS aCombo1 SIZE 25,08;
	WHEN .F.;
	OF oDlg PIXEL
@ 10,aPosGet[1,8] SAY STR0134 Of oDlg PIXEL SIZE 100,100	   		// "%Ded. Mat.:"
@ 09,aPosGet[1,15] MSGET aObjetos[01,06] VAR aInfISS[01,06] PICTURE X3Picture("CC2_PERMAT");
SIZE 35,08 HASBUTTON;
WHEN .F.;
OF oDlg PIXEL
@ 10,aPosGet[1,9] SAY STR0135 Of oDlg PIXEL SIZE 100,100		// "%Ded. Ser.:"
@ 09,aPosGet[1,16] MSGET aObjetos[01,07] VAR aInfISS[01,07] PICTURE X3Picture("CC2_PERSER");
	SIZE 35,08 HASBUTTON;
	WHEN .F.;
	OF oDlg PIXEL

@ 24,03 TO 43 ,630 LABEL "" OF oDlg PIXEL
@ 25,aPosGet[1,1] SAY STR0136 Of oDlg PIXEL SIZE 100,100		// "ISS Apurado:"
@ 30,aPosGet[1,2] SAY STR0137 Of oDlg PIXEL SIZE 100,100		// "Valor dos Sericos:"
@ 29,aPosGet[1,10] MSGET aObjetos[02,01] VAR aInfISS[02,01];
	PICTURE X3Picture("D1_TOTAL") ;
	OF oDlg PIXEL ;
	WHEN .F. HASBUTTON
@ 30,aPosGet[1,3] SAY STR0138 Of oDlg PIXEL SIZE 100,100		// "Sericos:"
@ 29,aPosGet[1,11] MSGET aObjetos[02,02] VAR aInfISS[02,02] ;
	PICTURE X3Picture("D1_ABATISS") ;
	OF oDlg PIXEL ;
	WHEN .F. HASBUTTON
@ 30,aPosGet[1,4] SAY STR0139 Of oDlg PIXEL SIZE 100,100		// "Materiais:"
@ 29,aPosGet[1,17] MSGET aObjetos[02,03] VAR aInfISS[02,03] ;
	PICTURE X3Picture("D1_ABATMAT") ;
	OF oDlg PIXEL ;
	WHEN .F. HASBUTTON
@ 30,aPosGet[1,5] SAY STR0140 Of oDlg PIXEL SIZE 100,100	// "B. Cálculo:"
@ 29,aPosGet[1,18] MSGET aObjetos[02,04] VAR aInfISS[02,04] ;
	PICTURE X3Picture("D1_BASEISS") ;
	OF oDlg PIXEL ;
	WHEN .F. HASBUTTON
@ 30,aPosGet[1,6] SAY STR0141 Of oDlg PIXEL SIZE 100,100		// "Val. ISS:"
@ 29,aPosGet[1,19] MSGET aObjetos[02,05] VAR aInfISS[02,05] ;
	PICTURE X3Picture("D1_VALISS") ;
	OF oDlg PIXEL ;
	WHEN .F. HASBUTTON

@ 44,03 TO 63 ,630 LABEL "" OF oDlg PIXEL
@ 45,aPosGet[1,1] SAY STR0142 Of oDlg PIXEL SIZE 100,100	// "INSS Apurado:"
@ 50,aPosGet[1,2] SAY STR0143 Of oDlg PIXEL SIZE 100,100	// "Valor Serviço:"
@ 49,aPosGet[1,10] MSGET aObjetos[03,01] VAR aInfISS[03,01] ;
	PICTURE X3Picture("D1_TOTAL") ;
	OF oDlg PIXEL ;
	WHEN .F. HASBUTTON 

@ 50,aPosGet[1,3] SAY STR0144 Of oDlg PIXEL SIZE 100,100		// "Recolhido:"
@ 49,aPosGet[1,11] MSGET aObjetos[03,02] VAR aInfISS[03,02] ;
	PICTURE X3Picture("D1_ABATINS") ;
	OF oDlg PIXEL ;
	WHEN .F. HASBUTTON    

@ 50,aPosGet[1,4] SAY STR0138 Of oDlg PIXEL SIZE 100,100		// "Servicos:"
@ 49,aPosGet[1,17] MSGET aObjetos[03,03] VAR aInfISS[03,03] ;
	PICTURE X3Picture("D1_AVLINSS") ;
	OF oDlg PIXEL ;
	WHEN .F. HASBUTTON
@ 50,aPosGet[1,5] SAY STR0146 Of oDlg PIXEL SIZE 100,100	// "B. Cálculo:"
@ 49,aPosGet[1,18] MSGET aObjetos[03,04] VAR aInfISS[03,04] ;
	PICTURE X3Picture("D1_BASEINS") ;
	OF oDlg PIXEL ;
	WHEN .F. HASBUTTON
@ 50,aPosGet[1,6] SAY STR0147 Of oDlg PIXEL SIZE 100,100		// "Val. INSS:"
@ 49,aPosGet[1,19] MSGET aObjetos[03,05] VAR aInfISS[03,05] ;
	PICTURE X3Picture("D1_VALINS") ;
	OF oDlg PIXEL ;
	WHEN .F. HASBUTTON

aFldCBAtu[nInfISS] := {|| ISSRFldTot(aObjetos,@aInfISS)}

Return(.T.)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  |ISSRFldTotºAutor  ³ Vitor Felipe       º Data ³ 19/06/2012  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Roda validacoes e atualiza para o ISS x Municipio.         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ aObjetos: Array contento os Objetos do Folder.             º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function ISSRFldTot(aObjetos,aInfISS)

Local nX		:= 0
Local nY		:= 0
Local nPosCod 	:= GetPosSD1("D1_COD")
Local lMeples 	:= .F.
Local cTmun     := SuperGetMv("MV_EISSXM") 

If Len(aCols) > 0 .And. !Empty(aCols[01,nPosCod])
	
	If cTmun = "1"
		lMeples := .T.
	Endif
    If Empty(aInfISS[1,1]) .Or. aInfISS[1,1] != MaFisRet(,"NF_CODMUN")
		aInfISS[1,1] := Iif(lMeples,SubSTR(MaFisRet(,"NF_M0CODMUN"),3, Len(MaFisRet(,"NF_M0CODMUN"))),MaFisRet(,"NF_CODMUN") ) 
		aInfISS[1,3] := Iif(lMeples,MaFisRet(,"NF_UFDEST"),MaFisRet(,"NF_UFPREISS") )
	Endif
	
	//BUSCA O MUNICIPIO NA TABELA CC2 (MUNICIPIOS) E CARREGA O RESTANTE DOS CAMPOS
	dbSelectArea("CC2")
	dbSetOrder(1)
	If CC2->(MsSeek(xFilial("CC2")+aInfISS[1,3]+aInfISS[1,1]))
	If cPaisLoc $ "ANG|AUS|BRA|CHI|COL|COS|DOM|EQU|HAI|MEX|PER|PTG|VEN"
		aInfISS[1,2] := AllTrim(CC2->CC2_MUN)
	EndIf
		If cPaisLoc == "BRA"
		aInfISS[1,4] := CC2->CC2_MDEDMA
		aInfISS[1,5] := CC2->CC2_MDEDSR
		aInfISS[1,6] := CC2->CC2_PERMAT
		aInfISS[1,7] := CC2->CC2_PERSER
		EndIf
	EndIf
	
	If INCLUI .Or. ALTERA .Or. l103Visual
		aInfISS[2,2] := 0 ; aInfISS[2,3] := 0 ; aInfISS[3,2] := 0 ; aInfISS[3,3] := 0
		//ATUALIZA OS ARRAYS DO FOLDER - ISS
		aInfISS[2,1] := MaFisRet(,"NF_TOTAL")		//Valor Total
		aInfISS[2,2] := MaFisRet(,"NF_ISSABSR")	//Abatimentos de Sericos
		aInfISS[2,3] := MaFisRet(,"NF_ISSABMT")	//Abatimentos de Materiais
		aInfISS[2,4] := MaFisRet(,"NF_BASEISS")	//Base do ISS
		aInfISS[2,5] := MaFisRet(,"NF_VALISS")		//Valor do ISS
		//ATUALIZA OS ARRAYS DO FOLDER - INSS
		aInfISS[3,1] := MaFisRet(,"NF_TOTAL")		//Valor Total
		aInfISS[3,2] := MaFisRet(,"NF_INSABSR")	//Abatimentos de Sericos
		aInfISS[3,3] := MaFisRet(,"NF_INSABMT")	//Abatimentos de Materiais
		aInfISS[3,4] := MaFisRet(,"NF_BASEINS")	//Base de Calculo do INSS
		aInfISS[3,5] := MaFisRet(,"NF_VALINS")		//Valor do INSS
	EndIf
	
	//Atualiza os Objetos.
	For nX := 1 to Len(aObjetos)
		For nY := 1 To Len(aObjetos[nX])
			aObjetos[nX,nY]:Refresh()
		Next nY
	Next nX
	
	If aObjetos[01,03] <> Nil
		aObjetos[01,03]:lReadOnly := !MaFisFound("IT",1)
		aObjetos[01,03]:Refresh()
	EndIf
	
EndIF

Return(.T.)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o	 ³ EncForIss ³Autor  ³ Adilson Roberto      ³ Data ³ 12/05/20 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³ Funcao para checar se existe cadastro com as informações   ³±±
±±³          ³ inseridas na rotina FISA052                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ EncForIss()	 										      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ MATA103X										    		  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
STATIC FUNCTION EncForIss(cEstIss,cCodmunIss,aObjetos,aInfISS)
Local nPosCodISS := GetPosSD1("D1_CODISS")
Local nPosCod	 := GetPosSD1('D1_COD')

If nPosCod > 0
	DbSelectArea("SB1")
	DbSetORder(1)
	If DbSeek(xFilial("SB1")+aCols[01][nPosCod])    
		If SB1->B1_MEPLES == "2"			
			CE1->(DbSeek(xFilial("CE1")+Iif(nPosCodISS >0, aCols[01][nPosCodISS], SB1->B1_CODISS)+ cEstIss + cCodmunIss))
			If !xFilial("CE1") == CE1->CE1_FILIAL .And. !(Iif(nPosCodISS >0, aCols[01][nPosCodISS], SB1->B1_CODISS) == CE1->CE1_CODISS) .And. !cEstIss == CE1->CE1_ESTISS .And. !cCodmunIss == CE1->CE1_CMUISS
				MsgAlert("Cadastro não localizado na rotina FISA052")
			Endif
			ISSRFldTot(aObjetos,@aInfISS)				
		EndIf
	EndIf
Else
	MsgAlert("Código do Produto não localizado, o campo D1_COD deve ser configurado como Usado")
EndIf

Return(.T.)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o	 ³ A103VLDITO ³Autor  ³ Carlos Capeli       ³ Data ³ 29/10/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³ Funcao para validar os itens da nota fiscal original	na	  ³±±
±±³          ³ classificacao de uma nota de devolucao                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ A103VLDITO()	 										      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ MATA103X										    		  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A103VLDITO()

Local nPosItOri	:= 0
Local nX		:= 0
Local cItem		:= ""
local lClass	:= Iif(Type('l103Class')=='L',l103Class,.F.)
Local nBkp		:= n

If lClass
	If (nPosItOri := GetPosSD1("D1_ITEMORI")) > 0
		For nX := 1 To Len(aCols)
			cItem := aCols[nX][nPosItOri]
			n := nX
			If !Empty(cItem)
				A103ItDev(cItem)
			EndIf
		Next nX
		n := nBkp
	EndIf
EndIf

Return

/*±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun?ao    ³a103RatPCnf| Autor ³Aline S Damasceno      ³ Data ³ 08/01/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri?ao ³ Funcao utilizada para a funcao AdmRatExt e refresh no       ³±±
±±³          ³ objeto.  							                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ oGetDad = Objeto MSSelect				                   ³±±
±±³ 	     ³ aHeadSde= Cabecalho SDE  				                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ MATA103                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function a103RatPCnf(aHeadSde,oGetDad)

If A103PRERAT(aHeadSde)
	AdmRatExt(aHeadSde,oGetDad:aCols,{ |x,y,z,w,t| NfeCarCC(x,y,@z,w,@t) })
	
	If ValType(oGetDad) == "O"
		oGetDad:oBrowse:Refresh()   
	EndIf
Endif   

Return .T.

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o	 ³A103CODRSEF³ Autor ³ TOTVS                 ³ Data ³ 01/02/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³ Busca código de retorno SEFAZ da Nota Original			   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ A103CODRSEF()	 										   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ MATA103										    		   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A103CODRSEF(aHeader,aCols)
Local aAreaSF3	:= SF3->(GetArea())
Local nPosNfOri := GetPosSD1("D1_NFORI" )
Local nPosSerOri:= GetPosSD1("D1_SERIORI" )
Local lRet		:= .T.
Local cForRural As Character 

// Verifica se a nota original foi transmitida à SEFAZ (F3_CODRSEF = 100)
If nPosNfOri > 0 .And. nPosSerOri > 0
	DbSelectArea("SF3")
	DbSetOrder(4)
	If MsSeek(xFilial("SF3")+cA100For+cLoja+aCols[1][nPosNfOri]+aCols[1][nPosSerOri])
		cForRural := GetAdvFVal("SA2","A2_INDRUR",xFilial("SA2") + cA100For + cLoja,1)
		If AllTrim(SF3->F3_CODRSEF) != "100" .And. ( !( Alltrim(SF3->F3_ESPECIE) $ "NFP|SPED" ) .Or. ( Alltrim(SF3->F3_ESPECIE) == "SPED" .And. !(cForRural $ "1|2|3") ) )
			Aviso(STR0018,STR0148,{STR0038})
			lRet := .F.
		EndIf
	EndIf
EndIf

RestArea(aAreaSF3)
Return lRet

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun??o	 ³A103VencSE2³ Autor ³ Carlos Capeli         ³ Data ³ 13/10/13 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri??o ³ Recalcula IR ao alterar vencimento do título na aba Duplic. ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ A103VencSE2()	 										   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ MATA103										    		   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function A103VencSE2()

Local cCampo	  := ReadVar()
Local cCpoE2	  := StrTran(cCampo,"M->","")
Local nPosIrrf	  := aScan(aHeader,{|x| AllTrim(x[2])=="E2_IRRF"})
Local nPosVenc	  := aScan(aHeader,{|x| AllTrim(x[2])=="E2_VENCTO"})
Local nPosE2	  := 0
Local lRet		  := .T.
Private aIrrfNew  := {}
Private dDVencAnt := stod("")

//Atualiza o campo no aCols
nPosE2 := aScan(aHeader,{|x| AllTrim(x[2]) == cCpoE2 .And. cCpoE2 != "F2D_VALOR"})
If nPosE2 > 0
	If cCpoE2 == "E2_VENCTO"
		dDVencAnt := acols[n][nPosE2]
	Endif
    

	aCols[n,nPosE2] := &cCampo
EndIf

If cCampo == "M->E2_VENCTO" .And. nPosIrrf > 0 .And. N == 1
	If Type("bIRRefresh")=="B"
		Eval(bIRRefresh)
	EndIf
	If Len(aIrrfNew) >= 1
		aCols	:= aIrrfNew
		dNewVenc:= aIrrfNew[1][nPosVenc]
	EndIf
Endif

If Type("bRefresh")=="B"
	Eval(bRefresh,6)
EndIf

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³MTA103TROPºAutor  ³Microsiga           º Data ³  08/24/13   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Funçao para automatizar digitacao de tipos de operacoes na º±±
±±º          ³ Classificacao da Nota de Entrada                           º±±
±±º          ³                                                            º±±
±±º          ³ Parametro: nItem - Linha do acols que esta posicionado     º±±
±±º          ³                                                            º±±
±±º          ³ Incluido na validacao do campo D1_OPER                     º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ P11                                                        º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function MTA103TROP(nItem)
Local lClassifica 	:= IIf(Type('l103Class')=="L" .And. l103Class,.T.,.F.)
Local nPosOpe		:= 0
Local nPosTes		:= 0
Local nPosCod		:= 0
Local nVezes		:= 0
Local lValOp		:= IIf( Type('mv_par22')=='N' .And. mv_par22 == 1, .T., .F. )
Local cTpOpAtu		:= M->D1_OPER
Local nItemOri		:= n
Local lFirst		:= .T.
Local lTrocAll  	:= .T.
Local lDivImp		:= SuperGetMV("MV_NFDVIMP",.F.,.F.) ; 
					.And. COLConVinc(SF1->F1_DOC,SF1->F1_SERIE,SF1->F1_FORNECE,SF1->F1_LOJA) > 0 ;
					.And. Type("oListDvIm") == "O" ;
					.And. Type("oDivCount") == "O"
Local nOpc		:= 0

Default nItem	:= 0

If (lClassifica .Or. Inclui)  .And. lValOp .And. nItem >= 1
	nPosOpe:= aScan(aHeader, { |x| AllTrim(Upper(x[2])) == 'D1_OPER'}) 
	If nItem < Len(aCols) .and. nPosOpe > 0 
 		if readvar() == "M->D1_OPER"
			cTpOpAtu := IIF( !empty(M->D1_OPER), M->D1_OPER, space(TAMSX3("D1_OPER")[1]))
		else
			cTpOpAtu := aCols[nItem][nPosOpe]
		endif
		nPosTes  := aScan(aHeader, { |x| AllTrim(Upper(x[2])) == 'D1_TES' })
		nPosCod  := aScan(aHeader, { |x| AllTrim(Upper(x[2])) == 'D1_COD' })
		
		For nVezes	:= nItem to Len(aCols)
			// Substituo o valor do item do aCols para atualizaçoes na função MaTesInt()
			n	:= nVezes
			// Se é um item válido
			If !aCols[nVezes][Len(aHeader)+1]
				// Realiza atualização
        		If lFirst .AND. EMPTY(cTpOpAtu)
					If nItemOri < Len(aCols)
						nOpc := Aviso(STR0153,STR0207,{STR0008,STR0007,STR0215}) // Tipo de operação não preenchido, deseja apagar o conteúdo dos campos TES e Tipo operação a todos os próximos itens ?
						If nOpc == 1
							lTrocAll := .T.
						Elseif nOpc == 2
							lTrocAll := .F.
						Else
							Exit
						Endif
					Endif
				EndIf
		    	if  lTrocAll .OR. lFirst 
		    			aCols[nVezes][nPosTes]	:= MaTesInt(1,cTpOpAtu,cA100For,cLoja,If((cTipo$"DB" .Or. A103RtCliRT(cTipo, cTpCompl, cFormul) ), "C", "F"),aCols[nVezes][nPosCod],"D1_TES")
		    			aCols[nVezes][nPosOpe]	:= cTpOpAtu
						MaFisAlt("IT_TPOPER",cTpOpAtu,n)
						lFirst	 := .F.

		    		//Atualiza a Grid de Divergência de Impostos
						If lDivImp
							ColLoadDiv(oListDvIm,oDivCount)
					    EndIf
				endif				
				
				/*Integracao com o modulo de Armazenagem - SIGAWMS*/
				If lClassifica .And. IntWMS() .And. SF4->F4_ESTOQUE == "S" .And. cTipo $ "N|D|B"					
					WmsAvalSD1("2","SD1",aCols,nVezes,aHeader)//Efetua o tratamento dos campos do SIGAWMS do aCols
				EndIf
			EndIf
		Next nVezes
	
	EndIf
EndIf

n	:= nItemOri
//Atualiza a Grid de Divergência de Impostos no item original
If lDivImp	.And. ( nPosOpe:= aScan(aHeader, { |x| AllTrim(Upper(x[2])) == 'D1_OPER'}) ) > 0 ;
			.And. ( nPosTes:= aScan(aHeader, { |x| AllTrim(Upper(x[2])) == 'D1_TES' }) ) > 0 ;
			.And. ( nPosCod:= aScan(aHeader, { |x| AllTrim(Upper(x[2])) == 'D1_COD' }) ) > 0 
	If !Empty(M->D1_OPER)
		aCols[n][nPosOpe]	:= M->D1_OPER
	EndIf
	aCols[n][nPosTes]	:= MaTesInt(1,aCols[n][nPosOpe],cA100For,cLoja,If((cTipo$"DB" .Or. A103RtCliRT(cTipo, cTpCompl, cFormul) ), "C", "F"),aCols[n][nPosCod],"D1_TES")
	ColLoadDiv(oListDvIm,oDivCount)
EndIf


If Upper (AllTrim (FunName ()))=="MATA103"  
    Eval (bRefresh,6) 
Endif


Return(.T.)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³MTA103OPERºAutor  ³Microsiga           º Data ³  08/24/13   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Funcao para automatizar digitacao de tipos de operacoes na º±±
±±º          ³ Digitação da Nota Fiscal de Entrada                        º±±
±±º          ³                                                            º±±
±±º          ³ Parametro: nItem - Linha do acols que esta posicionado     º±±
±±º          ³                                                            º±±
±±º          ³ Incluído na validação do campo D1_TOTAL                    º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MTA103OPER(nItem)

Local lRet	:= .T.
Local nPosOpe	:= 0
Local nPosTes	:= 0
Local nPosCod	:= 0
Local lValOp	:= .F. 

Default nItem	:= 0
If INCLUI 
	lValOp	:= GetNewPar("MV_A103OPE",.F.)
	If lValOp .and. nItem > 1
		If ( nPosOpe:= aScan(aHeader, { |x| AllTrim(Upper(x[2])) == 'D1_OPER'}) ) > 0
	    	aCols[nItem][nPosOpe]	:= aCols[nItem-1][nPosOpe]
		
			nPosTes:= aScan(aHeader, { |x| AllTrim(Upper(x[2])) == 'D1_TES'})
			nPosCod:= aScan(aHeader, { |x| AllTrim(Upper(x[2])) == 'D1_COD'})
		
			aCols[nItem][nPosTes]	:= MaTesInt(1,aCols[nItem][nPosOpe],cA100For,cLoja,If((cTipo$"DB" .Or. A103RtCliRT(cTipo, cTpCompl, cFormul)), "C", "F"),aCols[nItem][nPosCod],"D1_TES")

		EndIf
	EndIf
EndIf
	
Return(lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³RetModCTE ºAutor  ³Carlos Capeli		 º Data ³  20/02/2014 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Retorna a Modalidade do Transporte				          º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³MATA103                                                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function RetModCTE(cMod)
Local aCombo1  :={}
Local aComboMod:={}
Local cModCte  := ""
Local nMod      := 0

aCombo1:=x3CboxToArray("F1_MODAL")[1]
aSize(aComboMod,Len(aCombo1)+1)
For nMod:=1 to Len(aComboMod)
	aComboMod[nMod]:=IIf(nMod==1," ",aCombo1[nMod-1])
Next nMod
nMod:=Ascan(aComboMod, {|x| Substr(x,1,2) == cMod})
If nMod>0
	cModCte:=aComboMod[nMod]
EndIf

Return cModCte

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³A103VldMod ºAutor  ³Carlos Capeli		 º Data ³  20/02/2014 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Validacao Modalidade Transporte					          º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³MATA103X                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A103VldMod(cModCTE)

Local cOpcao := Substr(cModCTE,1,2)

If !Empty(MafisScan("NF_MODAL",.F.)) .And. (cOpcao $ "  |01|02|03|04|05|06")
	MaFisRef("NF_MODAL","MT100",cOpcao)
	MaFisToCols(aHeader,aCols,,"MT100")
	Eval(bGDRefresh)
	Eval(bRefresh)
EndIf

Return

/* 
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³A103ChkInfAdicºAutor  ³TOTVS		     º Data ³  03/10/2014  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Cria Array com Estrutura dos Campos da Aba de Informacoes    º±±  
±±º          ³Adicionais												   º±±  
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ nTipo: 1 - Inclusao										   ³±±
±±³					  2 - Visualizacao / Exclusao						   ³±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A103ChkInfAdic(nTipo)          

Local aAreaInfAdic 		:= GetArea()
Local lCteOriDest		:= SF1->(ColumnPos("F1_UFORITR")) > 0 .And. SF1->(ColumnPos("F1_MUORITR")) > 0 .And. SF1->(ColumnPos("F1_UFDESTR")) > 0 .And. SF1->(ColumnPos("F1_MUDESTR")) > 0
Local lBrasil			:= cPaisLoc == "BRA"
Local lCompraGov		:= A103CmpGovernamental()
Local lInclusaDE		:= .F.

DEFAULT nTipo := 1

// Para ativar a aba de Informacoes Adicionais e necessario possuir pelo menos um dos campos abaixo:
// F1_INCISS  - Criado pelo UPDFIS
// F1_VEICUL1 - Criado pelo NFEP11R1 -> NFE11R164
// F1_VEICUL2 - Criado pelo NFEP11R1 -> NFE11R164
// F1_VEICUL3 - Criado pelo NFEP11R1 -> NFE11R164

aInfAdic := {}
DbSelectArea("SF1")
lInclusaDE := (nTipo == 1)

If lBrasil .And. FieldPos("F1_INCISS") > 0	// Grava municipio de incidencia do ISS para apresentar este dado quando o município da prestacao do servico nao for o do cliente, fornecedor ou SIGAMAT
	AADD(aInfAdic, IIF(lInclusaDE, CriaVar("F1_INCISS"), SF1->F1_INCISS ))
	lFldInfAdic := .T.
EndIf
	// Grava dados do veiculo para transmissao do Manifesto Eletronico de Documentos Fiscais
If lBrasil .And. FieldPos("F1_VEICUL1") > 0	// Grava dados do veiculo para transmissao do Manifesto Eletronico de Documentos Fiscais
	AADD(aInfAdic, IIF(lInclusaDE, CriaVar("F1_VEICUL1"), SF1->F1_VEICUL1 ))
	lFldInfAdic := .T.
EndIf
	// Grava dados do veiculo para transmissao do Manifesto Eletronico de Documentos Fiscais
If lBrasil .And. FieldPos("F1_VEICUL2") > 0	// Grava dados do veiculo para transmissao do Manifesto Eletronico de Documentos Fiscais
	AADD(aInfAdic, IIF(lInclusaDE, CriaVar("F1_VEICUL2"), SF1->F1_VEICUL2 ))
	lFldInfAdic := .T.
EndIf
	// Grava dados do veiculo para transmissao do Manifesto Eletronico de Documentos Fiscais
If lBrasil .And. FieldPos("F1_VEICUL3") > 0	// Grava dados do veiculo para transmissao do Manifesto Eletronico de Documentos Fiscais
	AADD(aInfAdic, IIF(lInclusaDE, CriaVar("F1_VEICUL3"), SF1->F1_VEICUL3 ))
	lFldInfAdic := .T.
EndIf
	// Data de execução do serviço
If lBrasil .And. ColumnPos("F1_DTCPISS") > 0	// Data de execução do serviço
    AADD(aInfAdic, IIF(lInclusaDE, CriaVar("F1_DTCPISS"), SF1->F1_DTCPISS ))
	lFldInfAdic := .T.
EndIf
// Grava dados do do Simples Nacional
If lBrasil .And. ColumnPos("F1_SIMPNAC") > 0	// Grava dados do do Simples Nacional
	AADD(aInfAdic, IIF(lInclusaDE, CriaVar("F1_SIMPNAC"), SF1->F1_SIMPNAC ))
	lFldInfAdic := .T.
EndIf
If lBrasil .And. ColumnPos("F1_CLIDEST") > 0	
	AADD(aInfAdic, IIF(lInclusaDE, CriaVar("F1_CLIDEST"), SF1->F1_CLIDEST ))	
	lFldInfAdic := .T.
EndIf
If lBrasil .And. ColumnPos("F1_LOJDEST") > 0	
	AADD(aInfAdic, IIF(lInclusaDE, CriaVar("F1_LOJDEST"), SF1->F1_LOJDEST ))	
	lFldInfAdic := .T.
EndIf
If lBrasil .And. ColumnPos("F1_ESTDES") > 0	
	AADD(aInfAdic, IIF(lInclusaDE, CriaVar("F1_ESTDES"), SF1->F1_ESTDES ))	
	lFldInfAdic := .T.
EndIf
If lBrasil .And. lCteOriDest
	AADD(aInfAdic, IIF(lInclusaDE, CriaVar("F1_UFORITR"), SF1->F1_UFORITR ))
	AADD(aInfAdic, IIF(lInclusaDE, CriaVar("F1_MUORITR"), SF1->F1_MUORITR ))
	AADD(aInfAdic, IIF(lInclusaDE, CriaVar("F1_UFDESTR"), SF1->F1_UFDESTR ))
	AADD(aInfAdic, IIF(lInclusaDE, CriaVar("F1_MUDESTR"), SF1->F1_MUDESTR ))
	lFldInfAdic := .T.
Endif
If lBrasil .And. ColumnPos("F1_CLIPROP") > 0	
	AADD(aInfAdic, IIF(lInclusaDE, CriaVar("F1_CLIPROP"), SF1->F1_CLIPROP ))	
	lFldInfAdic := .T.
Else
	AADD(aInfAdic, " ")
EndIf
If lBrasil .And. ColumnPos("F1_LJCLIPR") > 0	
	AADD(aInfAdic, IIF(lInclusaDE, CriaVar("F1_LJCLIPR"), SF1->F1_LJCLIPR ))	
	lFldInfAdic := .T.
Else
	AADD(aInfAdic, " ")
EndIf 

If lBrasil .And. Type("lIntermed") == "L" .And. lIntermed
	AADD(aInfAdic, IIF(lInclusaDE, CriaVar("F1_INDPRES"), SF1->F1_INDPRES ))
	AADD(aInfAdic, IIF(lInclusaDE, CriaVar("F1_CODA1U"), SF1->F1_CODA1U ))
	lFldInfAdic := .T.
Else 
	AADD(aInfAdic, " ")
	AADD(aInfAdic, " ") 
	lFldInfAdic := .T.
Endif

If lBrasil .And. FieldPos("F1_ESTPRES") > 0	// Grava Estado de incidencia do ISS para apresentar este dado quando o município da prestacao do servico nao for o do cliente, fornecedor ou SIGAMAT
	AADD(aInfAdic, IIF(lInclusaDE, CriaVar("F1_ESTPRES"), SF1->F1_ESTPRES ))
	lFldInfAdic := .T.
EndIf

If lBrasil .And. FieldPos("F1_OBSFTIT") > 0
	AADD(aInfAdic, IIF(lInclusaDE, CriaVar("F1_OBSFTIT"), SF1->F1_OBSFTIT ))
	lFldInfAdic := .T.
EndIf

If lBrasil .And. FieldPos("F1_OBSFISC") > 0
	AADD(aInfAdic, IIF(lInclusaDE, CriaVar("F1_OBSFISC"), SF1->F1_OBSFISC ))
	lFldInfAdic := .T.
EndIf

//Campos Compra Governamental
If ( lBrasil .AND. lCompraGov )
	AADD(aInfAdic, IIF(lInclusaDE, CriaVar("F1_CPGOVE"), SF1->F1_CPGOVE ))	//Array posição 21
	AADD(aInfAdic, 0)														//Array posição 22, era F1_PCTRED que virou não usado.....
	AADD(aInfAdic, IIF(lInclusaDE, CriaVar("F1_OPGOV") , SF1->F1_OPGOV  ))	//Array posição 23
	lFldInfAdic := .T.
EndIf

RestArea(aAreaInfAdic)         

Return
                 
//-------------------------------------------------------------------
/*/{Protheus.doc} A103LimpIT() 
Limpa itens ao trocar o tipo da nota no pré documento de entrada
@author taniel.silva
@since 17/10/2014
@version P12
/*/
//-------------------------------------------------------------------
Function A103LimpIT(Tipo,cFornece,cLoja)
Local nY := 0

cFornece	:= CriaVar("F1_FORNECE",.F.)
cLoja	:= CriaVar("F1_LOJA",.F.)
aCols	:= {}

aadd(aCols,Array(Len(aHeader)+1))

	For ny := 1 to Len(aHeader)
	If Trim(aHeader[ny][2]) == "D1_ITEM"
		aCols[1][ny] 	:= StrZero(1,Len(SD1->D1_ITEM))
	Else    
		If Trim(aHeader[ny][2]) <> "D1_ALI_WT".And. Trim(aHeader[nY][2]) <> "D1_REC_WT"
			aCols[1][ny] := CriaVar(aHeader[ny][2])
	    EndIf
	EndIf
	aCols[1][Len(aHeader)+1] := .F.
Next nY	


If bGdRefresh<>Nil
	Eval(bGDRefresh)
EndIf

If bRefresh<>Nil
	Eval(bRefresh)
EndIf

Return .T.


Function A103VldInss() 

Local lRet     := .T.
Local cINSS	 := SX3->X3_WHEN

If !Empty(cINSS) .And. Valtype(cINSS) == "C"  
   If  RAT(  ("M->"),cinss ) == 0  
	   lRet:= &(cINSS)
   Endif     
Endif

Return(lRet)

//-------------------------------------------------------------------
/*/{Protheus.doc} VALIDSM4
Rotina que irá fazer a validação do campo F1_MENPAD na tabela SM4.
@author Allan Santos da Silva
@since 10/04/2015
@version 11.90
/*/
//-------------------------------------------------------------------

Static Function VALIDSM4(aNFEletr)

Local lRet := .F.

If SM4->(DbSeek(xFilial("SM4")+aNFEletr[8])) .Or. Empty(aNFEletr[8])
	If  !RegistroOk("SM4") 
		lRet := .F.
	Else
		lRet := .T.
	EndIf
Else
	Help(" ",1,"A084MSBLQ",,STR0211,1,0)//Código Invalido ou Não Cadastrado!!!
EndIf	

Return(lRet)

//-------------------------------------------------------------------
/*/{Protheus.doc} A103CIAP()
Realiza a geração de CIAP ou Exclusão
@author Leonardo Quintania
@since 27/10/2014
@version 1.0
/*/
//-------------------------------------------------------------------
Function A103CIAP(nOpc,cAliasSD1,nQtdReq,cRotina,nF1Origem,nFilCiap,nCodCiap,aRecSF1Ori)

	If FindFunction("FISCIAP")
		cCiap := FISCIAP(nOpc,cAliasSD1,nQtdReq,cRotina,nF1Origem,nFilCiap,nCodCiap,aRecSF1Ori)
	EndIf
	
Return cCiap


//-------------------------------------------------------------------
/*/{Protheus.doc}A103ChkBN
Verifica se deve baixar o empenho na inclusao da nota.
Caso a nota seja retorno do beneficiamento, nao devera baixar empenho neste momento.
Se jah houver SGO para a OP e produto, significa que o empenho jah foi baixado
no envio para beneficiamento via Faturamento.

@author isaias.silva
@since 04/05/2015
@version P11.80 replica 12
/*/
//-------------------------------------------------------------------

Function A103ChkBN(cOp, cProduto , cLocal , nRecSD4, cTRT, cLote, cNumlot, cOrdem, cOpOrig, cSeq)
Local aAreas := { GetArea(), SGO->(GetArea()) }
Local lRet   := .F.
Local lContinua := If(FindFunction("A410CtEmpBN"), A410CtEmpBN() == 2, .F.)
Local lIxSGO := .F.

If lContinua
If A103ChSGO() 
		// GO_FILIAL+GO_COD+GO_OP+GO_TRT+GO_LOTECTL+GO_NUMLOTE+GO_LOCAL+GO_ORDEM+GO_OPORIG+GO_SEQ                                                                          
		lIxSGO := ExistChav("SGO",cProduto + cOp + cTRT + cLote + cNumlot + cLocal + cOrdem + cOpOrig + cSeq)

		If lIxSGO
			SGO->(dbSetOrder(3)) // GO_FILIAL+GO_COD+GO_OP+GO_TRT+GO_LOTECTL+GO_NUMLOTE+GO_LOCAL+GO_ORDEM+GO_OPORIG+GO_SEQ  
			If SGO->(MsSeek(xFilial('SGO')+cProduto+cOp+cTRT+cLote+cNumlot+cLocal+cOrdem+cOpOrig+cSeq)) 
				If SGO->GO_RECNOD4 > 0 .AND. SGO->(GO_RECNOD4) == nRecSD4
					lRet := .T.
				ElseIf SGO->GO_RECNOD4 == 0
					lRet := .T.
				EndIf
			EndIf
		EndIf
	Else
		SGO->(dbSetOrder(1)) // FILIAL + OP + COD + LOCAL
		If SGO->(MsSeek(xFilial('SGO')+cOP+cProduto+cLocal)) .And. SGO->(GO_RECNOD4) == nRecSD4
			lRet := .T.
		EndIf
	Endif
EndIf

RestArea(aAreas[2])
RestArea(aAreas[1])
Return lRet
//-------------------------------------------------------------------
/*/{Protheus.doc}M103XAFEXC
Valida se a nota tem ativo a classificar.

@author alvaro.camillo
@since 14/12/2015
@version P12
/*/
//-------------------------------------------------------------------
Static Function M103XAFEXC(cDoc,cSerie,cFornec,cLoja,cProduto)
Local lRet			:= .T.
Local aArea		:= GetArea()
Local cQuery		:= ""
Local cNextAlias	:= GetNextAlias()

dbSelectArea('SN1')
dbSetOrder(1)

cQuery	+= " SELECT " 
cQuery	+= " 	N1_FILIAL, "
cQuery	+= " 	N1_CBASE, "
cQuery	+= " 	N1_ITEM  "
cQuery	+= " FROM  "
cQuery	+= " 	"+RetSQLName("SN1")+" SN1 "
cQuery	+= " WHERE "
cQuery	+= " 	N1_FILIAL = '"+xFilial("SN1")+"' AND "
cQuery	+= " 	N1_PRODUTO = '"+cProduto+"' AND "
cQuery	+= " 	N1_FORNEC = '"+cFornec+"' AND "
cQuery	+= " 	N1_LOJA = '"+cLoja+"' AND "
cQuery	+= " 	N1_NSERIE = '"+cSerie+"' AND "
cQuery	+= " 	N1_NFISCAL = '"+cDoc+"' AND "
cQuery	+= " 	SN1.D_E_L_E_T_ = ' ' "

cQuery := ChangeQuery(cQuery)  
dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cNextAlias,.T.,.T.)  


While (cNextAlias)->(!EOF())
	
	If SN1->(Dbseek( (cNextAlias)->(N1_FILIAL+N1_CBASE+N1_ITEM)))
		If AF012AVLDL("SN3",.T.)
			If !SoftLock('SN1')
				lRet := .F.
				Exit
			EndIf
		Else
			lRet := .F.
			Exit
		EndIf
	EndIf
	(cNextAlias)->(dbSkip())
EndDo

(cNextAlias)->(dbCloseArea())
RestArea(aArea)
Return lRet 

//-------------------------------------------------------------------
/*/{Protheus.doc}A103Desp
Recalcula despesas acessórias, com base no percentual da quantidade 
utilizada do pedido de compras ou Doumento de saída

@author jose.delmondes
@since 20/01/2016
@version P11.80
/*/
//-------------------------------------------------------------------
Function A103Desp(lClassOrd)
Local nPosPc	:= GetPosSD1("D1_PEDIDO") 	//Pedido - Número Pedido de Compra
Local nPosItPc	:= GetPosSD1("D1_ITEMPC") 	//Pedido - Item Pedido de Compra

Local nPosNfOri := GetPosSD1("D1_NFORI")  	//Devolução - NF Origem
Local nPosSerOri:= GetPosSD1("D1_SERIORI")	//Devolução - Serie Origem
Local nPosITOri := GetPosSD1("D1_ITEMORI")	//Devolução - Item Origem
Local nPosProd  := GetPosSD1("D1_COD")		//Devolução - Cod Produto Origem
Local cCliOri	:= ca100for											//Devolução - Cliente Origem
Local cLojaOri	:= cLoja											//Devolução - Loja Origem

Local aAreaAnt := getArea()
Local aAreaSC7 := SC7->(getArea())
Local aAreaSD2 := SD2->(getArea())

Local nPosQuant	:= GetPosSD1("D1_QUANT")
Local nDivisor	:= 0
Local nMultipl	:= 0
Local nQuant	:= 0
Local nVlrDesp	:= 0
Local nVlrSeg	:= 0
Local nVlrFrt	:= 0

Default lClassOrd := .F.

SC7->(dbSetOrder(1))
SD2->(dbSetOrder(3))

If lClassOrd
	nQuant := aCols[n][nPosQuant]
Else
	nQuant := if(Empty(M->D1_QUANT),SD1->D1_QUANT,M->D1_QUANT)
EndIf
If nPosPc > 0 .And. nPosItPc > 0.And.;
 SC7->(MsSeek(xFilial("SC7")+aCols[n][nPosPc]+aCols[n][nPosItPc])) 
	
	If nQuant + SC7->C7_QUJE < SC7->C7_QUANT 
		nDivisor := SC7->C7_QUANT
		nMultipl := nQuant	
	Else
		nDivisor := SC7->C7_QUANT
		nMultipl := SC7->C7_QUANT - SC7->C7_QUJE
	EndIf
			 
	//Recalcula despesa
	If !Empty(SC7->C7_DESPESA)
		nVlrDesp := xMoeda((SC7->C7_DESPESA/nDivisor)*nMultipl,SC7->C7_MOEDA,1,dDEmissao,Nil,SC7->C7_TXMOEDA)		
		MaFisAlt("IT_DESPESA",nVlrDesp,N)
	EndIf
	//Recalcula seguro
	If !Empty(SC7->C7_SEGURO)
		nVlrSeg := 	xMoeda((SC7->C7_SEGURO/nDivisor)*nMultipl,SC7->C7_MOEDA,1,dDEmissao,Nil,SC7->C7_TXMOEDA)	
		MaFisAlt("IT_SEGURO",nVlrSeg,N)
	EndIf
	//Recalcula frete
	If !Empty(SC7->C7_VALFRE)
		nVlrFrt := xMoeda((SC7->C7_VALFRE/nDivisor)*nMultipl,SC7->C7_MOEDA,1,dDEmissao,Nil,SC7->C7_TXMOEDA)		
		MaFisAlt("IT_FRETE",nVlrFrt,N)
	EndIf
ElseIf nPosNfOri > 0 .And. nPosSerOri > 0 .And. nPosITOri > 0 .And. nPosITOri > 0 .And.;
  SD2->(MsSeek(xFilial("SD2")+aCols[n][nPosNfOri]+aCols[n][nPosSerOri]+cCliOri+cLojaOri+aCols[n][nPosProd]+aCols[n][nPosITOri]))
	nMultipl := nQuant
	nDivisor := SD2->D2_QUANT
	//Recalcula despesa
	If !Empty(SD2->D2_DESPESA)		
		MaFisAlt("IT_DESPESA",(SD2->D2_DESPESA/nDivisor)*nMultipl,N)
	EndIf
	//Recalcula seguro
	If !Empty(SD2->D2_SEGURO)		
		MaFisAlt("IT_SEGURO",(SD2->D2_SEGURO/nDivisor)*nMultipl,N)
	EndIf
	//Recalcula frete
	If !Empty(SD2->D2_VALFRE)		
		MaFisAlt("IT_FRETE",(SD2->D2_VALFRE/nDivisor)*nMultipl,N)
	EndIf
EndIf

RestArea(aAreaSD2)
RestArea(aAreaSC7)
RestArea(aAreaAnt)

Return

/*/{Protheus.doc}A103CodR
Função para auxiliar a validação do Ponto de Entrada M103CODR 
@author Manuela Cavalcante
@since 18/02/2016
@version P11.80
@return Nil
/*/
Function A103CodR(aCodR)
Local lRet := .T.
Local lCodR := .F.
Local lM103CODR := ExistBlock("M103CODR")

	If lM103CODR // P.E. para validar se o array "aCodR" está preenchido ou não".
		lCodR := ExecBlock("M103CODR",.F.,.F.,{aCodR})
		If Valtype(lCodR)=="L"
			lRet := lCodR
		EndIf
	EndIf			

Return lRet

/*/{Protheus.doc} A103CTECOL
Função para validar a existência de CT-e (Totvs Colaboração) ao excluir uma NF 
@author Rodrigo Machado Pontes
@since 27/04/16
@version P12
@return Nil
/*/

Static Function A103CTECOL(cNFCol,cSerCol,cFilCol,cForCol,cLjCol,cTipo)

Local lRet 		:= .F.
Local lIndCteCol	:= .F.
Local cIndexSD1	:= ""
Local cQuery		:= ""
Local aArea		:= GetArea()

cFilCol	:= PadR(cFilCol,TamSx3("D1_FILIAL")[1])
cNFCol	:= PadR(cNFCol,TamSx3("D1_NFORI")[1])
cSerCol	:= PadR(cSerCol,TamSx3("D1_SERIORI")[1])
cForCol	:= PadR(cForCol,TamSx3("D1_FORNECE")[1])
cLjCol	:= PadR(cLjCol,TamSx3("D1_LOJA")[1])
cTipo	:= PadR(cTipo,TamSx3("D1_TIPO")[1])

DbSelectArea("SD1")

If lIndCteCol == Nil
	If !Empty(SD1->(IndexKey(19))) //D1_FILIAL+D1_NFORI+D1_SERIORI+D1_FORNECE+D1_LOJA 
		lIndCteCol := .T.
	Else
		lIndCteCol := .F.
	Endif
Endif

If lIndCteCol
	SD1->(DbSetOrder(19)) //D1_FILIAL+D1_NFORI+D1_SERIORI+D1_FORNECE+D1_LOJA
	If SD1->(DbSeek(cFilCol + cNFCol + cSerCol + cForCol + cLjCol)) .And. SD1->D1_TIPO == "C"
		lRet := .T.
	Endif
Else
	cIndexSD1 := CriaTrab(,.f.)  
	
	cQuery    := "D1_FILIAL == '"     +cFilCol+  "' .AND. "
	cQuery    += "D1_NFORI == '"      +cNFCol+     "' .AND. "
	cQuery    += "D1_SERIORI == '"    +cSerCol+   "' .AND. "  
	cQuery    += "D1_FORNECE == '"    +cForCol+ "' .AND. "  
	cQuery    += "D1_LOJA == '"       +cLjCol+    "' .AND. "
	cQuery    += "D1_TIPO == '"       +cTipo+    "' .AND. "	  
	cQuery    += "D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA+D1_TIPO <> '" + cNFCol+cSerCol+cForCol+cLjCol+cTipo + "'"

	IndRegua("SD1",cIndexSD1,"D1_FILIAL+D1_NFORI+D1_SERIORI+D1_FORNECE+D1_LOJA",, cQuery ,"")
	nIndexSD1 :=RetIndex("SD1")+1  
	
	SD1->(dbSetorder(nIndexSD1))  
	SD1->(dbGoTop())     

	If SD1->(!Eof()) .And. SD1->D1_TIPO == "C"
		lRet := .T.
	EndIf

	FErase(cIndexSD1 + OrdBagExt())
	DbClearFilter()
Endif

RestArea(aArea)

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} COLConVinc()
Função que verifica se o documento tem vinculo com o  totvs 
colaboração e retorna o RECNO da SDS referente ao documento ou zero 
caso não tenha vinculo.
Requer posicionamento da SF1

@author Flavio Lopes Rasta
@since 20/06/2016
@version 11 
/*/
//-------------------------------------------------------------------
Function COLConVinc(cNota,cSerie,cFornece,cLoja)
Local aAreaSDS	:= SDS->(GetArea())
Local nRecno 	:= 0
Local cChvNf	:= SF1->F1_CHVNFE

SDS->(DbSetOrder(1))
If SDS->(DbSeek(xFilial("SDS")+cNota+cSerie+cFornece+cLoja))
	If cChvNf == SDS->DS_CHAVENF
		nRecno := SDS->(Recno())
	EndIf
Endif

RestArea(aAreaSDS)
Return nRecno

//-------------------------------------------------------------------
/*/{Protheus.doc} COLConVinc()
Cria grid de divergência de impostos na classificação do documento
de entrada(MATA103)

@author Flavio Lopes Rasta
@since 22/06/2016
@version 11 
/*/
//-------------------------------------------------------------------
Function COLListDiv(oWnd,aPosWnd,oGet)
Local aHeadImp	:={}
Local nX			:= 0

Aadd(aHeadImp, {" ","LEGENDA", "@BMP", 2, 0,,, 'C',,'V'})
Aadd(aHeadImp, {AllTrim("Imposto"),"IMPOSTO","@!",25,0,,,'C',,'R'})
Aadd(aHeadImp, {AllTrim("Valor TES"),"VALORT"	,"@E 999,999,999.99",14,2,,,'N',,'R'})
Aadd(aHeadImp, {AllTrim("Valor XML"),"VALORX"	,"@E 999,999,999.99",14,2,,,'N',,'R'})
Aadd(aHeadImp, {AllTrim("Aliq. TES"),"ALIQT"	,"@E 999,999,999.99",14,2,,,'N',,'R'})
Aadd(aHeadImp, {AllTrim("Aliq. XML"),"ALIQX"	,"@E 999,999,999.99",14,2,,,'N',,'R'})	

TSay():New(5,10,{|| "Impostos:"},oWnd,,,,,,.T.,,,50,10)
oListDvIm := MsNewGetDados():New(5,45,60,385,4, "AllwaysTrue", "AllwaysTrue", /*cIniCpos*/, ,, 999, "AllwaysTrue", "", "AllwaysTrue", oWnd,@aHeadImp)

TSay():New(5,415,{|| "Itens com Divergência:"},oWnd,,,,,,.T.,,,70,9)
@ 5 ,476 MSGET oDivCount VAR nDivCount COLOR CLR_RED OF oWnd PIXEL SIZE 20,9 When .F.
TSay():New(7,500,{|| "/"},oWnd,,,,,,.T.,,,9,9)
@ 5 ,506 MSGET oDivTot VAR Len(aCols) COLOR CLR_RED OF oWnd PIXEL SIZE 20,9 When .F.
@ 20 ,476 BUTTON "Próximo Item com Divergência" SIZE 80 ,11 ACTION {||oGet:GoTo(A103ProDiv()),A103PosFld()}  OF oWnd PIXEL

For nX := 1 To Len(aCols)
	n := nX
ColLoadDiv(oListDvIm,oDivCount)
Next nX

n := 1

Return oListDvIm

//-------------------------------------------------------------------
/*/{Protheus.doc} ColLoadDiv()
Carrega dados no grid de divergência de impostos na classificação
do documento de entrada (MATA103)
@author Flavio Lopes Rasta
@since 22/06/2016
@version 11 
/*/
//-------------------------------------------------------------------
Function ColLoadDiv(oListDvIm,oDivCount)
Local oOK			:= LoadBitmap(GetResources(),'BR_VERDE')
Local oNO			:= LoadBitmap(GetResources(),'BR_VERMELHO')
Local aImpostos		:= {}
Local nX			:= 1
Local aColsImp		:= {}
Local nPosLegend 	:= GetPosSD1("D1_LEGENDA")

Local nPosFornec	:= GetPosSD1("D1_FORNECE")
Local nPosLoja		:= GetPosSD1("D1_LOJA")
Local nPosDoc		:= GetPosSD1("D1_DOC")
Local nPosSerie		:= GetPosSD1("D1_SERIE")
Local nPosItem		:= GetPosSD1("D1_ITEM")

Local nValorTes := 0
Local nAliqTes	:= 0
Local lMVDiviZer:= SuperGetMv("MV_DIVIZER",.F.,.F.)
Local nDiverg	:= 0
Local lCOLDVIMP := ExistBlock("COLDVIMP")

SDT->(DbSetOrder(8))
If SDT->(DbSeek(xFilial("SDT") + aCols[n,nPosFornec] + aCols[n,nPosLoja] + aCols[n,nPosDoc] + aCols[n,nPosSerie] + aCols[n,nPosItem] ))

	aAdd(aImpostos,{"IPI"		,MaFisRet(n,"IT_VALIPI")	,"DT_XMLIPI"	,MaFisRet(n,"IT_ALIQIPI" )	,"DT_XALQIPI"})
	aAdd(aImpostos,{"ICMS"		,MaFisRet(n,"IT_VALICM")	,"DT_XMLICM"	,MaFisRet(n,"IT_ALIQICM" )	,"DT_XALQICM"})
	aAdd(aImpostos,{"ISS"		,MaFisRet(n,"IT_VALISS")	,"DT_XMLISS"	,MaFisRet(n,"IT_ALIQISS" )	,"DT_XALQISS"})
	aAdd(aImpostos,{"PIS"		,MaFisRet(n,"IT_VALPS2")	,"DT_XMLPIS" 	,MaFisRet(n,"IT_ALIQPS2")	,"DT_XALQPIS"})
	aAdd(aImpostos,{"COFINS"	,MaFisRet(n,"IT_VALCF2")	,"DT_XMLCOF"	,MaFisRet(n,"IT_ALIQCF2")	,"DT_XALQCOF"})
	aAdd(aImpostos,{"ICMS ST"	,MaFisRet(n,"IT_VALSOL")	,"DT_XMLICST"	,MaFisRet(n,"IT_ALIQSOL")	,"DT_XALICST"})
		
	For nX:=1 To Len(aImpostos)
		
		aAdd(aColsImp,{})
		
		nValorTes 	:= aImpostos[nX][2]
		nAliqTes	:= If(lMVDiviZer .And. nValorTes == 0 ,0,aImpostos[nX][4])
	
		If nValorTes <> SDT->&(aImpostos[nX][3]) .Or. nAliqTes <> SDT->&(aImpostos[nX][5])
			aAdd(aTail(aColsImp),oNO)
		Else
			aAdd(aTail(aColsImp),oOK)
		Endif
		aAdd(aTail(aColsImp),aImpostos[nX][1])
		aAdd(aTail(aColsImp),nValorTes)
		aAdd(aTail(aColsImp),SDT->&(aImpostos[nX][3]))
		aAdd(aTail(aColsImp),nAliqTes)
		aAdd(aTail(aColsImp),SDT->&(aImpostos[nX][5]))
		aAdd(aTail(aColsImp),.F.)
	Next nX

	If lCOLDVIMP
		aColsImp := ExecBlock("COLDVIMP",.F.,.F.,{"MATA103",aColsImp})
	Endif
	
	If (nPos:=aScan(aColsImp,{|x| x[1]:cName == "BR_VERMELHO"})) > 0
		aCols[n][nPosLegend] := aColsImp[nPos][1]:cName 
	Else
		aCols[n][nPosLegend] := aColsImp[1][1]:cName
	Endif

Endif

oListDvIm:SetArray(aColsImp)

oListDvIm:Refresh()

For nX:=1 To Len(aCols)
	If aCols[nX,nPosLegend] == "BR_VERMELHO"
		nDiverg++
	Endif
Next nX

nDivCount := nDiverg

oDivCount:Refresh()

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} A103PosFld()
Atualiza dados no grid de divergência de impostos na classificação
do documento de entrada (MATA103)
@author Flavio Lopes Rasta
@since 22/06/2016
@version 11 
/*/
//-------------------------------------------------------------------

Function A103PosFld()
Local nItem := n
Local lClassifica 	:= IIf(Type('l103Class')=="L" .And. l103Class,.T.,.F.)
Local cMvNFEAval 	:= GetNewPar( "MV_NFEAFSD", "000" )
Local cFilOri       := xFilial("SD2")
Local nPosNfOri 	:= GetPosSD1("D1_NFORI")
Local nPosSerOri	:= GetPosSD1("D1_SERIORI")
Local nItOrig		:= GetPosSD1("D1_ITEMORI")  
Local nPQuant   	:= GetPosSD1("D1_QUANT")
Local nPProd        := GetPosSD1("D1_COD")
Local nPClasFis		:= GetPosSD1("D1_CLASFIS")
Local aArea			:= GetArea()
Local aAreaSD2		:= SD2->(GetArea())
Local aAreaSF2		:= SF2->(GetArea())
Local cReadVar		:= ReadVar()
Local cCpo          := StrTran(cReadVar,"M->","")

If SuperGetMV("MV_NFDVIMP",.F.,.F.) .And. COLConVinc(SF1->F1_DOC,SF1->F1_SERIE,SF1->F1_FORNECE,SF1->F1_LOJA) > 0 .And. !INCLUI
	ColLoadDiv(oListDvIm,oDivCount)
Endif

if cCpo $ "D1_QUANT|D1_VUNIT|D1_TOTAL"
	
	If (lClassifica .Or. Inclui) .And. cTipo == "D" .And. (nPosNfOri > 0 .And. !Empty(aCols[nItem][nPosNfOri])) .And. (nPosSerOri >0 .And. !Empty(aCols[nItem][nPosSerOri])) .And. ; 
		(nItOrig >0 .And. !Empty(aCols[nItem][nItOrig])) .And. (nPProd>0 .And. !Empty(aCols[nItem][nPProd]))
		
		If ExistTrigger(cCpo)     
   			RunTrigger(2,nItem,nil,,cCpo)
			MaColsToFis(aHeader,aCols,nItem,"MT100")
		Endif
		
		DbSelectArea("SF2")
		DbSetOrder(1)
		MsSeek(xFilial("SF2",cFilOri) + aCols[nItem][nPosNfOri] + aCols[nItem][nPosSerOri] )

		DbSelectArea("SD2")
		DbSetOrder(3)
		MsSeek(xFilial('SD2',cFilOri)+aCols[nItem][nPosNfOri]+aCols[nItem][nPosSerOri]+SF2->F2_CLIENTE+SF2->F2_LOJA+aCols[nItem][nPProd]+aCols[nItem][nItOrig])	

		If SD2->D2_VALFRE <> 0     
			If len(cMvNFEAval)>=1
				If Substr(cMvNFEAval,1,1)=="1"     
					nValor := A410Arred(IIF(SD2->D2_QUANT-aCols[nItem][nPQuant] == 0 , SD2->D2_VALFRE, (SD2->D2_VALFRE/SD2->D2_QUANT)*aCols[nItem][nPQuant]),"D1_VALFRE")
					MaFisAlt("IT_FRETE",nValor,nItem)
				EndIf
			EndIf                  
		EndIf

		If SD2->D2_SEGURO <> 0
			If len(cMvNFEAval)>=2
				If Substr(cMvNFEAval,2,1)=="1"
					nValor := A410Arred(IIF(SD2->D2_QUANT-aCols[nItem][nPQuant] == 0 , SD2->D2_SEGURO, (SD2->D2_SEGURO/SD2->D2_QUANT)*aCols[nItem][nPQuant]),"D1_SEGURO")
					MaFisAlt("IT_SEGURO",nValor,nItem)
				EndIf
			EndIf
		EndIf

		If SD2->D2_DESPESA <> 0
			If len(cMvNFEAval)=3
				If Substr(cMvNFEAval,3,1)=="1"
					nValor := A410Arred(IIF(SD2->D2_QUANT-aCols[nItem][nPQuant] == 0 , SD2->D2_DESPESA, (SD2->D2_DESPESA/SD2->D2_QUANT)*aCols[nItem][nPQuant]),"D1_DESPESA")
					MaFisAlt("IT_DESPESA",nValor,nItem)
				EndIf
			EndIf
		EndIf  
		
		MaFisToCols(aHeader,aCols,nItem,"MT100")
		
		If Upper (AllTrim (FunName ()))=="MATA103"  
			Eval (bRefresh,1)
			Eval (bRefresh,3) 
		Endif
		
	Endif
Endif

//--------------------------------------------------------------------------
// Atualiza a variável de memória, evitando inconsistência em tela causada
// pelo MaFisRef no X3_VALID, que alterava o ACOLS sem atualizar a variável
//--------------------------------------------------------------------------
If cCpo == "D1_CLASFIS" .And. &(cReadVar) <> aCols[nItem,nPClasFis]
	&(cReadVar) := aCols[nItem,nPClasFis]
EndIf

If Upper (AllTrim (FunName ()))=="MATA103"  
    Eval (bRefresh,6) 
Endif

RestArea(aArea)
RestArea(aAreaSD2)
RestArea(aAreaSF2)

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} A103DivImp()
Carrega dados no grid de divergência de impostos na classificação
do documento de entrada (MATA103)
@author Flavio Lopes Rasta
@since 22/06/2016
@version 11 
/*/
//-------------------------------------------------------------------
Function A103DivImp(aLineDiv)
Local aImpostos	:= {}
Local aColsImp	:= {}
Local nX		:= 1
Local cRet		:= "BR_VERDE"
Local oOK		:= LoadBitmap(GetResources(),'BR_VERDE')
Local oNO		:= LoadBitmap(GetResources(),'BR_VERMELHO')

Local nPosFornec	:= GetPosSD1("D1_FORNECE")
Local nPosLoja		:= GetPosSD1("D1_LOJA")
Local nPosDoc		:= GetPosSD1("D1_DOC")
Local nPosSerie		:= GetPosSD1("D1_SERIE")
Local nPosItem		:= GetPosSD1("D1_ITEM")

Local nValorTes := 0
Local nAliqTes	:= 0
Local lMVDiviZer:= SuperGetMv("MV_DIVIZER",.F.,.F.)
Local lCOLDVIMP := ExistBlock("COLDVIMP")

SDT->(DbSetOrder(8))
If SDT->(DbSeek(xFilial("SDT") + aCols[n,nPosFornec] + aCols[n,nPosLoja] + aCols[n,nPosDoc] + aCols[n,nPosSerie] + aCols[n,nPosItem] ))

	aAdd(aImpostos,{"IPI"		,MaFisRet(n,"IT_VALIPI")	,"DT_XMLIPI"	,MaFisRet(n,"IT_ALIQIPI" )	,"DT_XALQIPI"})
	aAdd(aImpostos,{"ICMS"		,MaFisRet(n,"IT_VALICM")	,"DT_XMLICM"	,MaFisRet(n,"IT_ALIQICM" )	,"DT_XALQICM"})
	aAdd(aImpostos,{"ISS"		,MaFisRet(n,"IT_VALISS")	,"DT_XMLISS"	,MaFisRet(n,"IT_ALIQISS" )	,"DT_XALQISS"})
	aAdd(aImpostos,{"PIS"		,MaFisRet(n,"IT_VALPS2")	,"DT_XMLPIS" 	,MaFisRet(n,"IT_ALIQPS2")	,"DT_XALQPIS"})
	aAdd(aImpostos,{"COFINS"	,MaFisRet(n,"IT_VALCF2")	,"DT_XMLCOF"	,MaFisRet(n,"IT_ALIQCF2")	,"DT_XALQCOF"})
	aAdd(aImpostos,{"ICMS ST"	,MaFisRet(n,"IT_VALSOL")	,"DT_XMLICST"	,MaFisRet(n,"IT_ALIQSOL")	,"DT_XALICST"})
	
	If lCOLDVIMP
		For nX:=1 To Len(aImpostos)
			
			nValorTes	:= aImpostos[nX][2]
			nAliqTes	:= If(lMVDiviZer .And. (nValorTes == 0),0,aImpostos[nX][4])
			
			aAdd(aColsImp,{})
			aAdd(aTail(aColsImp),If(nValorTes == SDT->&(aImpostos[nX][3]) .And. nAliqTes == SDT->&(aImpostos[nX][5]),oOK,oNO))
			aAdd(aTail(aColsImp),aImpostos[nX][1])
			aAdd(aTail(aColsImp),nValorTes)
			aAdd(aTail(aColsImp),SDT->&(aImpostos[nX][3]))
			aAdd(aTail(aColsImp),nAliqTes)
			aAdd(aTail(aColsImp),SDT->&(aImpostos[nX][5]))
			aAdd(aTail(aColsImp),.F.)
		Next nX
		
		aColsImp := ExecBlock("COLDVIMP",.F.,.F.,{"MATA103",aColsImp})
		
		If aScan(aColsImp,{|x| x[1]:cName == "BR_VERMELHO"}) > 0
			cRet := "BR_VERMELHO"
		Endif
	Else
		For nX:=1 To Len(aImpostos)
			
			nValorTes	:= aImpostos[nX][2]
			nAliqTes	:= If(lMVDiviZer .And. (nValorTes == 0),0,aImpostos[nX][4])
			
			If nValorTes <> SDT->&(aImpostos[nX][3]) .Or. nAliqTes <> SDT->&(aImpostos[nX][5])
				cRet:= "BR_VERMELHO"
				Exit
			Endif
		Next nX
	Endif	
Endif

Return cRet

//-------------------------------------------------------------------
/*/{Protheus.doc} A103ProDiv()
Atualiza legenda do item do docuemtnto de entrada (MATA103)
@author Flavio Lopes Rasta
@since 22/06/2016
@version 11 
/*/
//-------------------------------------------------------------------
Function A103ProDiv()
Local nX	:= 1
Local nRet	:= 1
For nX:=1 To Len(aCols)
	If aCols[nX,GetPosSD1("D1_LEGENDA")] == "BR_VERMELHO"
		nRet:=nX
		Exit
	Endif
Next
Return nRet

//-------------------------------------------------------------------
/*/{Protheus.doc} A103ProDiv()
@since 22/06/2016
@version 11 
/*/
//-------------------------------------------------------------------
Function A103TpComp(aObjetos,c103Tipo,c103TpComp)
Local lRet := .F.

If !(c103Tipo $ "Complemento|Credito|Debito")
	aObjetos[11]:lActive := .F.
	c103TpComp := ""
Else
	aObjetos[11]:lActive := .T.
EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} RetDevMerc()
Retorna descricao da marcacao de opcao de devolucao de mercadoria nao entregue
@author TOTVS
@since 08/02/2017
@version 11 
/*/
//-------------------------------------------------------------------
Function RetDevMerc(cDevMerc)

Local cRet := " "

If cDevMerc == "N"   
	cRet := "Nao"
ElseIf cDevMerc == "S"
	cRet := "Sim"
Else
	cRet := " "
EndIf

Return cRet

//-------------------------------------------------------------------
/*/{Protheus.doc} A103GRVSF8()
Grava SF8 (Conhecimento Frete x Nota Original)
@author Rodrigo M Pontes
@since 10/04/2017
@version 11 
/*/
//-------------------------------------------------------------------

Function A103GRVSF8()

Local aArea		:= GetArea()
Local aF8NfOri	:= {}
Local nI		:= 0
Local nPosNFOri	:= GetPosSD1("D1_NFORI")
Local nPosSeOri	:= GetPosSD1("D1_SERIORI")
Local nPosPrd	:= GetPosSD1("D1_COD")
Local lF8NfOri	:= .F.
Local lColab	:= .F.
Local cForOrig	:= ""
Local cLojOrig	:= ""
Local cNFOri    := ""

If nPosNFOri > 0 .And. nPosSeOri > 0 .And. nPosPrd > 0
	lColab := !COLFINSDS(1,cNFiscal+cSerie+cA100For+cLoja,1) //.F. = Encontrou na SDS

	For nI := 1 To Len(aCols)
		If !aCols[nI,Len(aHeader)+1]
			If (!Empty(aCols[nI,nPosNFOri]) .Or. (Empty(aCols[nI,nPosNFOri]) .And. cTipo == "N" .And. AllTrim(cEspecie) $ "CTE|CTEOS"))
				//Verifica se CTE existe na SF8 e possui vinculo com a nota original
				If !lColab
					lF8NfOri	:= A103OriSF8(cNFiscal,cSerie,cA100For,cLoja,aCols[nI,nPosNFOri],aCols[nI,nPosSeOri])
				ElseIf cNFOri <> aCols[nI,nPosNFOri]
					aF8NfOri	:= A103OriSDS(cNFiscal,cSerie,cA100For,cLoja,aCols[nI,nPosNFOri],aCols[nI,nPosSeOri])
					lF8NfOri	:= aF8NfOri[1]
					cForOrig	:= aF8NfOri[2]
					cLojOrig	:= aF8NfOri[3]
					cNFOri      := aCols[nI,nPosNFOri]					
				Endif
				
				If !lF8NfOri
					If RecLock("SF8",.T.)
						SF8->F8_FILIAL	:= xFilial("SF8")
						SF8->F8_DTDIGIT	:= Iif(Empty(SF1->F1_DTDIGIT),Date(),SF1->F1_DTDIGIT)
						SF8->F8_NFDIFRE	:= cNFiscal
						SF8->F8_SEDIFRE	:= cSerie
						SF8->F8_TRANSP	:= cA100For
						SF8->F8_LOJTRAN	:= cLoja
						SF8->F8_NFORIG	:= aCols[nI,nPosNFOri]
						SF8->F8_SERORIG	:= aCols[nI,nPosSeOri]
						SF8->F8_FORNECE	:= Iif(!lColab,cA100For,cForOrig)
						SF8->F8_LOJA	:= Iif(!lColab,cLoja,cLojOrig)
						SF8->F8_TIPO	:= "F"
						SF8->(MsUnlock())
						lF8NfOri := .T.
					Endif
				Endif
			Endif
		Endif
	Next nI
Endif

RestArea(aArea)

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} A103OriSDS()
Busca pelo Fornecedor + Loja da nf original via Colaboração
@author Rodrigo M Pontes
@since 10/04/2020
@version 11 
/*/
//-------------------------------------------------------------------

Function A103OriSDS(cNFiscal,cSerie,cA100For,cLoja,cNFOri,cSeOri)

Local cQry		:= ""
Local cFornOrig	:= ""
Local cLojaOrig	:= ""
Local cAliasQry := GetNextAlias()
Local lExistSF8	:= .F.
Local aRet		:= {}

cQry := " SELECT DISTINCT F1_FORNECE, F1_LOJA"
cQry += " FROM " + RetSqlName("SF1") + " SF1, " + RetSqlName("SDT") + " SDT "
cQry += " WHERE  SF1.F1_DOC = SDT.DT_NFORI"
cQry += " AND    SF1.F1_SERIE = SDT.DT_SERIORI"
cQry += " AND    SF1.F1_CHVNFE = SDT.DT_CHVNFO"
cQry += " AND    SDT.DT_DOC = '" + cNFiscal + "'"
cQry += " AND    SDT.DT_SERIE = '" + cSerie + "'"
cQry += " AND 	 SDT.DT_FORNEC = '" + cA100For + "'"
cQry += " AND 	 SDT.DT_LOJA = '" + cLoja + "'"
cQry += " AND	 SDT.DT_NFORI = '" + cNFOri + "'"
cQry += " AND 	 SDT.DT_SERIORI = '" + cSeOri + "'"
cQry += " AND SF1.D_E_L_E_T_ = ' '
cQry += " AND SDT.D_E_L_E_T_ = ' ' 

cQry := ChangeQuery(cQry)
dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQry),cAliasQry)

DbSelectArea(cAliasQry)
If (cAliasQry)->(!EOF())
	cFornOrig	:= (cAliasQry)->F1_FORNECE
	cLojaOrig	:= (cAliasQry)->F1_LOJA
Endif

(cAliasQry)->(DbCloseArea())

If !Empty(cFornOrig) .And. !Empty(cLojaOrig)
	lExistSF8 := A103OriSF8(cNFiscal,cSerie,cA100For,cLoja,cNFOri,cSeOri,cFornOrig,cLojaOrig)
Endif

aRet := {lExistSF8,cFornOrig,cLojaOrig}

Return aRet

//-------------------------------------------------------------------
/*/{Protheus.doc} A103OriSF8()
Verifica se amarração cte x nf original ja existe na SF8
@author Rodrigo M Pontes
@since 10/04/2017
@version 11 
/*/
//-------------------------------------------------------------------

Function A103OriSF8(cNFiscal,cSerie,cA100For,cLoja,cNFOri,cSeOri,cFornOrig,cLojaOrig)

Local lRet		 := .F.
Local cQry		 := ""
Local cAlF8NFCTE := GetNextAlias()

Default cFornOrig	:= ""
Default cLojaOrig	:= ""

cQry := " SELECT F8_NFDIFRE"
cQry += " FROM " + RetSqlName("SF8")
cQry += " WHERE D_E_L_E_T_ = ''"
cQry += " AND F8_NFDIFRE = '" + cNFiscal + "'"
cQry += " AND F8_SEDIFRE = '" + cSerie + "'"
cQry += " AND F8_TRANSP = '" + cA100For + "'"
cQry += " AND F8_LOJTRAN = '" + cLoja + "'"
cQry += " AND F8_NFORIG = '" + cNFOri + "'"
cQry += " AND F8_SERORIG = '" + cSeOri + "'"

If !Empty(cFornOrig) .And. !Empty(cLojaOrig)
	cQry += " AND F8_FORNECE = '" + cFornOrig + "'"
	cQry += " AND F8_LOJA = '" + cLojaOrig + "'"
Else
	cQry += " AND F8_FORNECE = '" + cA100For + "'"
	cQry += " AND F8_LOJA = '" + cLoja + "'"
Endif

cQry := ChangeQuery(cQry)
dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQry),cAlF8NFCTE)

DbSelectArea(cAlF8NFCTE)
If (cAlF8NFCTE)->(!EOF())
	lRet := .T.
Endif

(cAlF8NFCTE)->(DbCloseArea())

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} AProdFanta()
Retorna se o produto é fantasma
@author Yuri Porto
@since 03/02/2017
@version 11 
/*/
//-------------------------------------------------------------------
Function AProdFanta(nProd)

Local lRet := .T.
// Remover apos Dez/2018
Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} GetDelTitImp()
Função responsavel por buscar o proximo prefixo dos titulos de COF, PIS ou ISS de importação, 
caso não tenha encontrado pelos parametros "MV_PREFCOF", "MV_PREFPIS" e "MV_PREFISS" respectivamente.

@author Bruno Akyo Kubagawa
@since 01/11/2017
@version 12.1.17
/*/
//-------------------------------------------------------------------
static function GetDelTitImp(cPrefPIS, cPrefCOF, cPrefISS, cPreFase, nCont, nTotal)
	local lRet := .F.
	local cPrefixo := SE2->E2_PREFIXO
	local cPrefAux := ""
	local lContinua := .F.
	
	if nCont < nTotal

		if alltrim(SE2->E2_TIPO) == "PIS" .and. cPrefixo > cPrefPIS 
			lContinua := .T.
			cPrefAux := cPrefPIS

		elseif alltrim(SE2->E2_TIPO) == "COF" .and. cPrefixo > cPrefCOF
			lContinua := .T.
			cPrefAux := cPrefCOF
		
		elseif alltrim(SE2->E2_TIPO) == "ISS" .and. cPrefixo > cPrefISS
			lContinua := .T.
			cPrefAux := cPrefISS
		elseif alltrim(SE2->E2_TIPO) == "TX" .and. cPrefixo > cPreFase
			lContinua := .T.
			cPrefAux := cPreFase
		endif	

		While lContinua
			cPrefAux := soma1(cPrefAux)
			If cPrefAux == cPrefixo .and. (SE2->E2_FILIAL+SE2->E2_PREFIXO+SE2->E2_NUM == (xFilial("SE2") + cPrefAux + SF1->F1_DUPL) )
				lRet := .T.
				nCont += 1
				lContinua := .F.
				exit
			ElseIf (SE2->E2_FILIAL+SE2->E2_NUM != (xFilial("SE2") + SF1->F1_DUPL) )
				lContinua := .F.
				exit
			Endif
		EndDo
		
	endif
	
return lRet

/*/{Protheus.doc}A103TpRep
Função para habilitação do campo D1_TPREPAS utilizado no REINF
@return lRet = .T. habilita; .F. não habilita 

@author Carlos Capeli
@since  30/08/2016
		 
/*/
Function A103TpRep()

Local aArea := GetArea()
local aAreaSA2 := SA2->(GetArea())
Local lRet := .F.

SA2->(dbSetOrder(1))
If SA2->(MsSeek(xFilial("SA2")+cA100For+cLoja))
	If SA2->A2_DESPORT == "1"
		lRet := .T.
	EndIf
EndIf

RestArea(aAreaSA2)
RestArea(aArea)

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} A103MUFCTE()
Função de validação do codigo de municipio

@author Rodrigo Machado Pontes
@since 17/01/18
@version 11
/*/
//-------------------------------------------------------------------

Function A103MUFCTE(cCpoVld)

Local lRet		:= .T.
Local cEst		:= ""
Local cCodMun	:= ""
Local aArea	:= GetArea()

If cCpoVld == "ORIG"
	cEst 		:= PadR(aInfAdic[10],TamSx3("CC2_EST")[1])
	cCodMun 	:= PadR(aInfAdic[11],TamSx3("CC2_CODMUN")[1])
Elseif cCpoVld == "DEST"
	cEst 		:= PadR(aInfAdic[12],TamSx3("CC2_EST")[1])
	cCodMun 	:= PadR(aInfAdic[13],TamSx3("CC2_CODMUN")[1])
Endif

If !Empty(cCodMun)
	DbSelectArea("CC2")
	CC2->(DbSetOrder(3))
	If CC2->(DbSeek(xFilial("CC2") + cCodMun))
		If cCpoVld == "ORIG" .And. Empty(aInfAdic[10])
			aInfAdic[10] := CC2->CC2_EST
		Elseif cCpoVld == "DEST" .And. Empty(aInfAdic[12])
			aInfAdic[12] := CC2->CC2_EST
		Endif
	Else
		lRet := .F.
	Endif
Else
	If cCpoVld == "ORIG"
		aInfAdic[10] := Space(2)
		A103UFREF()
	Elseif cCpoVld == "DEST"
		aInfAdic[12] := Space(2)
		A103UFDEST()
	Endif	
Endif

RestArea(aArea)

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} A103MUFCTE()
Filtro da consulta padrão CC2CTE

@author Rodrigo Machado Pontes
@since 17/01/18
@version 11
/*/
//-------------------------------------------------------------------

Function M103FILCTE()

Local cFiltro 	:= ".T."
Local cReadVar	:= ReadVar()

//Municipio Origem
If cReadVar == "AINFADIC[11]"
	cFilUF := "O"
	M->F1_UFORITR := AINFADIC[10]
	
	cFiltro := "M->F1_UFORITR == CC2->CC2_EST"
	
//Municipio Destino
Elseif cReadVar == "AINFADIC[13]"
	cFilUF := "D"
	M->F1_UFDESTR := AINFADIC[12] 
	
	cFiltro := "M->F1_UFDESTR == CC2->CC2_EST"
Endif

If cFiltro == ".T."
	If cFilUf == "O"
		M->F1_UFORITR := AINFADIC[10]
		cFiltro := "M->F1_UFORITR == CC2->CC2_EST"
	Elseif cFilUf == "D"
		M->F1_UFDESTR := AINFADIC[12]
		cFiltro := "M->F1_UFDESTR == CC2->CC2_EST"
	Endif
Endif

Return &cFiltro

//-------------------------------------------------------------------
/*/{Protheus.doc} A103UFREF()
Atualiza UF de origem

@author Rodrigo Machado Pontes
@since 17/01/18
@version 11
/*/
//-------------------------------------------------------------------

Static Function A103UFREF()

If !Empty(aInfAdic[10])
	cUfOrig := aInfAdic[10]
	MaFisRef("NF_UFORIGEM","MT100",aInfAdic[10])
Else
	If ( cTipo $ "DB" .Or. A103RtCliRT(cTipo, cTpCompl, cFormul) )//Cliente
		cUfOrig := Posicione("SA1",1,xFilial("SA1")+cA100For+cLoja,"A1_EST")
	Else
		cUfOrig := Posicione("SA2",1,xFilial("SA2")+cA100For+cLoja,"A2_EST")
	Endif
	MaFisRef("NF_UFORIGEM","MT100",cUfOrig)
Endif

Return .T.

//-------------------------------------------------------------------
/*/{Protheus.doc} A103UFDEST()
Atualiza UF de origem

@author r.cavalcante
@since 29/04/2022
@version 12
/*/
//-------------------------------------------------------------------

Static Function A103UFDEST()
Local cEstado		:= "" 

If !Empty(aInfAdic[12])
	MaFisRef("NF_UFDEST","MT100", aInfAdic[12])
Else
	cEstado	:= GetNewPar("MV_ESTADO", "")  
	MaFisRef("NF_UFDEST","MT100", cEstado)
Endif

Return .T.


//-------------------------------------------------------------------
/*/{Protheus.doc} A103UFREF()
Validação para que os valores de retenção/dedução/faturamento direto
não sejam maiores que os valores do PC/NF.

@author Rodrigo Machado Pontes
@since 17/01/18
@version 11
/*/
//-------------------------------------------------------------------

Function A103RDFVLD()

Local aArea		:= GetArea()
Local nRet		:= 0
Local nDed		:= 0
Local nFat		:= 0
Local nTot		:= 0
Local nToRDF	:= 0
Local nRetPC	:= 0
Local nDedPC	:= 0
Local nFatPC	:= 0
Local nTotPC	:= 0
Local nToRDFPC	:= 0
Local nI		:= 0
Local nRound	:= TamSx3("D1_TOTAL")[2]
Local nPD1PC	:= GetPosSD1("D1_PEDIDO")
Local nPD1ITPC	:= GetPosSD1("D1_ITEMPC")
Local nPD1XRET	:= GetPosSD1("D1_RETENCA")
Local nPD1XDED	:= GetPosSD1("D1_DEDUCAO")
Local nPD1XFAT	:= GetPosSD1("D1_FATDIRE")
Local nPD1TOT	:= GetPosSD1("D1_TOTAL")
Local cMsgRet	:= ""
Local cMsgDed	:= ""
Local cMsgFat	:= ""
Local cMsg		:= ""
Local lRet		:= .T.

DbSelectArea("SC7")
SC7->(DbSetOrder(1))

If nPD1PC > 0 .And. nPD1ITPC > 0
	For nI := 1 To Len(aCols)
		If !aCols[nI,Len(aHeader)+1]
			If !Empty(aCols[nI,nPD1PC]) //Tem pedido
				If SC7->(DbSeek(xFilial("SC7") + aCols[nI,nPD1PC] + aCols[nI,nPD1ITPC]))
					//Valores do PC
					nTotPC		:= Round((SC7->C7_QUANT - SC7->C7_QUJE) * SC7->C7_PRECO,nRound)
					nRetPC 		:= SC7->C7_RETENCA - SC7->C7_QUJERET
					nDedPC 		:= SC7->C7_DEDUCAO - SC7->C7_QUJEDED
					nFatPC 		:= SC7->C7_FATDIRE - SC7->C7_QUJEFAT
					nToRDFPC	:= nRetPC+nDedPC+nFatPC
					
					//Valores na NF
					nTot	:= aCols[nI,nPD1TOT]
					nRet	:= aCols[nI,nPD1XRET]
					nDed	:= aCols[nI,nPD1XDED]
					nFat	:= aCols[nI,nPD1XFAT]
					nToRDF	:= nRet+nDed+nFat 
					
					//Saldo do PC apos NF
					nSaldoPC	:= nTotPC-nTot 
					
					//Saldo Ret/Ded/Fat do PC apos NF
					nSaldoRDF := nToRDFPC-nToRDF
					
					//Valida se valores de retenção/dedução/faturamento direto são maiores do que o PC
					If nRet > nRetPc //Valor retenção maior que saldo disponivel
						cMsgRet	:= STR0179 + AllTrim(Transform(nRet,X3Picture("D1_RETENCA"))) + STR0180 + AllTrim(Transform(nRetPC,X3Picture("D1_RETENCA"))) //"Valor de retenção: "##" é maior que o saldo disponivel no PC: "
					Endif
					
					If nDed > nDedPC //Valor dedução maior que saldo disponivel
						cMsgDed	:= STR0181 + AllTrim(Transform(nDed,X3Picture("D1_DEDUCAO"))) + STR0180 + AllTrim(Transform(nDedPC,X3Picture("D1_DEDUCAO"))) //"Valor de dedução: "##" é maior que o saldo disponivel no PC: "
					Endif
						
					If nFat > nFatPC //Valor faturamento direto maior que saldo disponivel
						cMsgFat	:= STR0182 + AllTrim(Transform(nFat,X3Picture("D1_FATDIRE"))) + STR0180 + AllTrim(Transform(nFatPC,X3Picture("D1_FATDIRE"))) //"Valor de faturamento direto: "##" é maior que o saldo disponivel no PC: "
					Endif
					
					If !Empty(cMsgRet) .Or. !Empty(cMsgDed) .Or. !Empty(cMsgFat)
						cMsg := STR0183 + StrZero(nI,TamSx3("D1_ITEM")[1]) + STR0184 //"O Item NF: "##" esta com divergencias nos valores de Retenção/Dedução/Faturamento Direto"
							
						If !Empty(cMsgRet)
							cMsg += CRLF + CRLF + cMsgRet
						Endif
							
						If !Empty(cMsgDed)
							cMsg += CRLF + CRLF + cMsgDed
						Endif
						
						If !Empty(cMsgFat)
							cMsg += CRLF + CRLF + cMsgFat
						Endif
					Endif
					
					If !Empty(cMsg)
						Exit
					Endif					

					If nSaldoPC <= 0 //PC totalmente atendido
						If nRet <> nRetPC
							cMsgRet	:= STR0185 + AllTrim(Transform(nRetPC,X3Picture("D1_RETENCA"))) //"Valor de retenção deve ser igual ao saldo disponivel no PC: "
						Endif
						
						If nDed <> nDedPC
							cMsgDed	:= STR0186 + AllTrim(Transform(nDedPC,X3Picture("D1_DEDUCAO"))) //"Valor de dedução deve ser igual ao saldo disponivel no PC: "
						Endif
						
						If nFat <> nFatPC
							cMsgFat	:= STR0187 + AllTrim(Transform(nFatPC,X3Picture("D1_FATDIRE"))) //"Valor de faturamento direto deve ser igual ao saldo disponivel no PC: "
						Endif
						
						If !Empty(cMsgRet) .Or. !Empty(cMsgDed) .Or. !Empty(cMsgFat)
							cMsg := STR0183 + StrZero(nI,TamSx3("D1_ITEM")[1]) + STR0184 + CRLF + ; //"O Item NF: "##" esta com divergencias nos valores de Retenção/Dedução/Faturamento Direto"
									 STR0188 //"É necessario que os valores sejam iguais aos saldos disponiveis, pois o PC esta sendo totalmente atendido."
							
							If !Empty(cMsgRet)
								cMsg += CRLF + CRLF + cMsgRet
							Endif
							
							If !Empty(cMsgDed)
								cMsg += CRLF + CRLF + cMsgDed
							Endif
							
							If !Empty(cMsgFat)
								cMsg += CRLF + CRLF + cMsgFat 
							Endif
							
							Exit
						Endif
					//PC parcialmente atendido
					Else
						If nSaldoRDF > nSaldoPC //saldo de retenção/dedução/faturamento maior que o saldo do PC
							cMsg := STR0183 + StrZero(nI,TamSx3("D1_ITEM")[1]) + STR0189 + AllTrim(Transform(nSaldoRDF - nSaldoPC,X3Picture("D1_FATDIRE"))) //Item NF: # esta com os valores de retenção/dedução/faturamento direto muito baixo. A soma dos valores deve ser pelo menos, mais: "
							Exit
						Elseif nSaldoPC > 0 .and. nSaldoRDF == 0 .And. nToRDFPC > 0 //PC parcialmente atendido, valores de retenção/dedução/faturamento totalmente atendido
							cMsg := STR0183 + StrZero(nI,TamSx3("D1_ITEM")[1]) + STR0190 //Item NF: # esta com os valores de retenção/dedução/faturamento direto estão sendo totalmente atendidos, porem o PC não. Corrija os valores."
							Exit
						Endif
					Endif
				Endif
			Endif
		Endif
	Next nI
Endif

If !Empty(cMsg)
	Help(" ",1,"INTRM",,cMsg,1,1)
	lRet := .F.
Endif

RestArea(aArea)

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} A103ATURM()
Atualização do saldo atendido dos valores de retenção/dedução 
e faturamento direto no pedido de compra.

@author Rodrigo Machado Pontes
@since 17/01/18
@version 11
/*/
//-------------------------------------------------------------------

Function A103ATURM(cOperador,cCampo,nValor,cPedido,cItemPC)

Local aArea	:= GetArea()

DbSelectArea("SC7")
SC7->(DbSetOrder(1))
If SC7->(DbSeek(xFilial("SC7") + cPedido + cItemPc))
	If RecLock("SC7",.F.)
		If cOperador == "+"
			If cCampo == "RET" //Retenção
				SC7->C7_QUJERET += nValor
			Elseif cCampo == "DED" //Dedução
				SC7->C7_QUJEDED += nValor
			Elseif cCampo == "FAT" //Faturamento Direto
				SC7->C7_QUJEFAT += nValor
			Endif			
		Elseif cOperador == "-"
			If cCampo == "RET" //Retenção
				SC7->C7_QUJERET -= nValor
			Elseif cCampo == "DED" //Dedução
				SC7->C7_QUJEDED -= nValor
			Elseif cCampo == "FAT" //Faturamento Direto
				SC7->C7_QUJEFAT -= nValor
			Endif
		Endif
		SC7->(MsUnlock())
	Endif 
Endif

RestArea(aArea)

Return

//-------------------------------------------------------------------
/*/{Protheus.doc} A103GATRM()
Gatilho para atualizar valores de retenção/dedução/faturamento direto
quando o pedido esta sendo atendido parcialmente.

@author Rodrigo Machado Pontes
@since 17/01/18
@version 11
/*/
//-------------------------------------------------------------------

Function A103GATRM(cCpo)

Local aArea	:= GetArea()
Local nRet		:= 0
Local nTotPC	:= 0
Local nTotNF	:= 0
Local cPC		:= aCols[n,GetPosSD1("D1_PEDIDO")]
Local cITPC	:= aCols[n,GetPosSD1("D1_ITEMPC")]

If !Empty(cPC)
	nTotPC := Posicione("SC7",1,xFilial("SC7") + cPC + cITPC,"C7_TOTAL")
	
	nTotNF := aCols[n,GetPosSD1("D1_QUANT")]*aCols[n,GetPosSD1("D1_VUNIT")]
	
	If cCpo == "RET"
		nVlr := Posicione("SC7",1,xFilial("SC7") + cPC + cITPC,"C7_RETENCA") - Posicione("SC7",1,xFilial("SC7") + cPC + cITPC,"C7_QUJERET")
	Elseif cCpo == "DED"
		nVlr := Posicione("SC7",1,xFilial("SC7") + cPC + cITPC,"C7_DEDUCAO") - Posicione("SC7",1,xFilial("SC7") + cPC + cITPC,"C7_QUJEDED")
	Elseif cCpo == "FAT"
		nVlr := Posicione("SC7",1,xFilial("SC7") + cPC + cITPC,"C7_FATDIRE") - Posicione("SC7",1,xFilial("SC7") + cPC + cITPC,"C7_QUJEFAT")
	Endif
	
	nRet := (nTotNF/nTotPC)*nVlr
Endif

RestArea(aArea)

Return nRet

/*/{Protheus.doc} A103EvDes()
Envio do evento de desacordo CTE

@author Rodrigo Machado Pontes
@since 17/01/18
@version 11
/*/

Function A103EvDes()

Local cString  		:= ""
Local nOpcA    		:= 0
Local oDlgObs
Local oGetObs
Local cMsgHelp		:= ""
Local cMsgNoYes		:= ""
Local lRet			:= .T.

cMsgNoYes := STR0195 + CRLF + ; //"Você deseja enviar o desacordo do CTE: "
			STR0196 + AllTrim(SF1->F1_DOC) + CRLF + ; //"Documento: "
			STR0197 + AllTrim(SF1->F1_SERIE) + CRLF + ; //"Serie: "
			STR0198 + AllTrim(SF1->F1_FORNECE) + CRLF + ; //"Fornecedor: "
			STR0199 + AllTrim(SF1->F1_LOJA) + CRLF + ; //"Loja: "
			STR0200 + AllTrim(SF1->F1_CHVNFE) + CRLF + ; //"Chave: "
			" ?" + CRLF + CRLF + STR0201 //"Ao confirmar o envio, não será possível desfazer a ação."

If Empty(SF1->F1_IDDES) .Or. SF1->F1_IDDES $ '0/1/5' .Or. ( SF1->F1_IDDES == '6' .and. SF1->F1_STATUS == 'A' )
	cString := SF1->F1_OBSDES 
	DEFINE MSDIALOG oDlgObs TITLE STR0202 FROM 15,20 TO 24,60 //"Observação - Evendo Desacordo"
	DEFINE SBUTTON FROM 52, 101.8 TYPE 1  ENABLE OF oDlgObs ACTION (nOpca := 1,oDlgObs:End())
	DEFINE SBUTTON FROM 52, 128.9 TYPE 2  ENABLE OF oDlgObs ACTION (nOpca := 2,oDlgObs:End())

	@ 0.5,0.7  GET oGetObs VAR cString OF oDlgObs MEMO size 150,40
	
	ACTIVATE MSDIALOG oDlgObs	
	
	If nOpca == 1
		
		If !Empty(cString) .And. Len(AllTrim(cString)) >= 15 .And. Len(AllTrim(cString)) <= 255
			If MsgNoYes(cMsgNoYes)
				If RecLock('SF1',.F.)
					SF1->F1_OBSDES	:= AllTrim(cString)
					SF1->F1_IDDES	:= "1" //1=Aguardando retorno SEFAZ
					SF1->F1_STATUS	:= "D" //D=Aguardando retorno SEFAZ evento desacordo
					SF1->(MsUnLock())
				Endif
				
				cIDEvento := A103EnvDes()
				If !Empty(cIDEvento) .And. ExistFunc("TMSPedMDes")
					TMSPedMDes("SF1")
				EndIf
			Endif 
		Else
			cMsgHelp := STR0203 //"Verificar o tamanho do campo Observacao. Deve ser  maior que 15 e menor que 255 posições."
			Help( " ", 1, "A103OBSDES",,cMsgHelp,1,0)
			lRet := .F.
		EndIf		
	EndIf
EndIf 

Return lRet

/*/{Protheus.doc} A103EvCanDes() 
Envio do evento de cancelamento de desacordo

@author Leandro Fini
@since 10/2024
@version 12
/*/

Static Function A103EvCanDes()

Local cXml			:= ""
Local cURL			:= PadR(GetNewPar("MV_SPEDURL","http://"),250)
Local cIdEnt		:= ""
Local cRet			:= ""
Local lUsaColab	:= .F.
Local oWs
Local aRet 			:= {}
Local aRetorno		:= {}

Private cIDEvento	:= ""

If MsgNoYes(STR0242,STR0245)//'Efetuar envio do evento "610111 - Cancelamento de desacordo"?' # "Confirmar envio de evento"

	aRet := TMSpedWDes("SF1",1)//-- Resgatar protocolo do desacordo.

	if len(aRet) = 1 .and. len(aRet[1]) > 2 .and. !empty(aRet[1][2])

		If RecLock('SF1',.F.)
			SF1->F1_OBSDES	:= ""
			SF1->F1_IDDES	:= "1" //1=Aguardando retorno SEFAZ
			SF1->(MsUnLock())
		Endif

		cXml :='<envEvento>'
		cXml +=	'    <eventos>'
		cXml +=	'        <detEvento>'
		cXml +=	'            <tpEvento>610111</tpEvento>'
		cXml +=	'            <ChNfe>' + SF1->F1_CHVNFE + '</ChNfe>'
		cXml +=	'            <evCancPrestDesacordo>'
		cXml +=	'                <descEvento>Cancelamento Prestacao do Servico em Desacordo</descEvento>'
		cXml +=	'                <nProtEvPrestDes>'+ aRet[1][2] +'</nProtEvPrestDes>'
		cXml +=	'            </evCancPrestDesacordo>'
		cXml +=	'        </detEvento>'
		cXml +=	'    </eventos>'
		cXml +=	'</envEvento>'
			
		If CTIsReady(,,,lUsaColab)
			// Obtem o codigo da entidade
			cIdEnt := RetIdEnti(lUsaColab)	
			
			oWs:= WsNFeSBra():New()
			oWs:cUserToken	:= "TOTVS" 
			oWs:cID_ENT		:= cIdEnt
			oWs:cXML_LOTE	:= cXml
			oWS:_URL		:= AllTrim(cURL)+"/NFeSBRA.apw"
			
			If oWs:RemessaEvento()	
				aRetorno := {oWS:oWsRemessaEventoResult:cString}
				If !Empty(aRetorno[1][1])
					cIDEvento := aRetorno[1][1]
				EndIf
			EndIf

			If !Empty(cIDEvento) .And. ExistFunc("TMSPedMDes")
				TMSPedMDes("SF1",2)
			EndIf
		EndIf
	else 
		//Não foi possível obter o protocolo de desacordo, verifique a conexão com o TSS.
		Help( " ", 1, "A103EvCanDes",,STR0244,1,0)
	endif
endif


Return cRet

/*/{Protheus.doc} A103EnvDes() 
Envio do evento de desacordo CTE

@author Rodrigo Machado Pontes
@since 17/01/18
@version 11
/*/

Static Function A103EnvDes()

Local cXml			:= ""
Local cURL			:= PadR(GetNewPar("MV_SPEDURL","http://"),250)
Local cIdEnt		:= ""
Local cRet			:= ""
Local lUsaColab		:= .F.
Local aRetorno		:= {}
Local oWs

cXml :='<envEvento>'
cXml +=	'<eventos>'
cXml +=		'<detEvento>'
cXml +=			'<tpEvento>610110</tpEvento>'
cXml +=			'<chNFe>' + SF1->F1_CHVNFE + '</chNFe>'
cXml +=			'<indDesacordoOper>1</indDesacordoOper>'
cXml +=			'<xObs>' + AllTrim(SF1->F1_OBSDES) + '</xObs>
cXml +=		'</detEvento>'
cXml +=	'</eventos>'
cXml +='</envEvento>'
	
If CTIsReady(,,,lUsaColab)
	// Obtem o codigo da entidade
	cIdEnt := RetIdEnti(lUsaColab)	
	
	oWs:= WsNFeSBra():New()
	oWs:cUserToken	:= "TOTVS" 
	oWs:cID_ENT		:= cIdEnt
	oWs:cXML_LOTE		:= cXml
	oWS:_URL			:= AllTrim(cURL)+"/NFeSBRA.apw"
	
	If oWs:RemessaEvento()	
		aRetorno := {oWS:oWsRemessaEventoResult:cString}
		If !Empty(aRetorno[1][1])
			cRet := aRetorno[1][1]
		EndIf
	EndIf
EndIf

Return cRet

/*/{Protheus.doc} A103Aposen
Interface para informacao dos valores de aposentadoria especial - Projeto REINF
@author carlos.capeli
@since 28/03/2018
@version 12.1.17
@type function
/*/
Function A103Aposen(aHeadDHP,aColsDHP,lIncApos,lClaApos,aColRotAut)

Local aArea     := GetArea()
Local aColApEsp := {}
Local oDlg      := Nil
Local oGetDHP   := Nil
Local nPosItNf  := GetPosSD1("D1_ITEM" )
Local nPosItTot := GetPosSD1("D1_TOTAL" )
Local nItem     := 0
Local nOpcA     := 0
Local nX        := 0
Local nY        := 0
Local nItemDHP  := 0

Default aHeadDHP   := {}
Default aColsDHP   := {}
Default aColRotAut := {}
Default lIncApos   := .T.
Default lClaApos   := .T.

// Montagem do aHeader DHP
If Empty(aHeadDHP)
	dbSelectArea("SX3")
	dbSetOrder(1)
	MsSeek("DHP")
	While !Eof() .And. (SX3->X3_ARQUIVO == "DHP")
		If X3USO(SX3->X3_USADO) .And. cNivel >= SX3->X3_NIVEL
			aAdd(aHeadDHP,{ Trim(x3Titulo()),;
				SX3->X3_CAMPO,;
				SX3->X3_PICTURE,;
				SX3->X3_TAMANHO,;
				SX3->X3_DECIMAL,;
				SX3->X3_VALID,;
				SX3->X3_USADO,;
				SX3->X3_TIPO,;
				SX3->X3_F3,;
				SX3->X3_CONTEXT,;
				SX3->X3_PROPRI } )
		EndIf
		dbSelectArea("SX3")
		dbSkip()
	EndDo
EndIf

// Montagem do aCols DHP
If !lIncApos .And. Empty(aColsDHP)	// Entra nesta condicao somente quando for Visualizacao, Classificacao ou Exclusao
	DbSelectArea("DHP")
	DbSetOrder(1)
	If MsSeek(xFilial("DHP")+cNFiscal+cSerie+cA100For+cLoja)
		While DHP->(!Eof()) .And. xFilial("DHP") == DHP->DHP_FILIAL .And. ;
				DHP->DHP_DOC == cNFiscal .And. ;
				DHP->DHP_SERIE == cSerie .And. ;
				DHP->DHP_FORNEC == cA100For .And. ;
				DHP->DHP_LOJA == cLoja

			aAdd(aColsDHP,{DHP->DHP_ITEMNF,{Array(Len(aHeadDHP)+1)}})
			nItemDHP++
			For nX := 1 To Len(aHeadDHP)
				If aHeadDHP[nX][10] <> "V"
					aColsDHP[nItemDHP][2][Len(aColsDHP[nItemDHP][2])][nX] := DHP->(FieldGet(FieldPos(aHeadDHP[nX][2])))
				Else
					aColsDHP[nItemDHP][2][Len(aColsDHP[nItemDHP][2])][nX] := DHP->(CriaVar(aHeadDHP[nX][2]))
				EndIf
			Next nX
			aColsDHP[nItemDHP][2][Len(aColsDHP[nItemDHP][2])][Len(aHeadDHP)+1] := .F.

			DHP->(DbSkip())
		End
	EndIf
ElseIf l103Auto .And. Len(aColRotAut) > 0	// Entra nesta condicao somente quando for rotina automatica
	For nX := 1 To Len(aColRotAut)
		aAdd(aColsDHP,{aColRotAut[nX][1],{Array(Len(aHeadDHP)+1)}})
		For nY := 1 To Len(aHeadDHP)
			If ( nPosCpo := aScan(aColRotAut[nX][2][1],{|x| x[1] == aHeadDHP[nY][2]}) ) > 0
				aColsDHP[Len(aColsDHP)][2][1][nY] := aColRotAut[nX][2][1][nPosCpo][2]
			EndIf
		Next nY
		aColsDHP[Len(aColsDHP)][2][1][Len(aHeadDHP)+1] := .F.
	Next nX
EndIf

If !l103Auto

	If (nItem := aScan(aColsDHP,{|x| x[1] == aCols[N][nPosItNf]})) > 0
		aColApEsp := aClone(aColsDHP[nItem][2])
	Else
		aAdd(aColApEsp,Array(Len(aHeadDHP)+1))
		For nX := 1 To Len(aHeadDHP)
			aColApEsp[1,nX] := CriaVar(aHeadDHP[nX,2])
		Next nX
		aColApEsp[1,Len(aHeadDHP)+1] := .F.
	EndIf

	DEFINE MSDIALOG oDlg FROM 100,100 TO 280,550 TITLE "Aposentadoria Especial" Of oMainWnd PIXEL //"Aposentadoria Especial"

	oGetDHP := MsNewGetDados():New(20,3,65,225,IIF((lIncApos.Or.lClaApos),GD_INSERT+GD_UPDATE+GD_DELETE,0),,,,,,1,,,,oDlg,aHeadDHP,aColApEsp)

	@ 6 ,4 SAY AllTrim(RetTitle("F1_DOC"))+":" OF oDlg PIXEL SIZE 20,09
	@ 6 ,26 SAY cNFiscal +"-"+ Substr(cSerie,1,3) OF oDlg PIXEL SIZE 50,09
	@ 6 ,80 SAY AllTrim(RetTitle("D1_ITEM"))+":" OF oDlg PIXEL SIZE 20,09
	@ 6 ,102 SAY aCols[N][nPosItNf] OF oDlg PIXEL SIZE 20,09

	Define SButton From 73,195 Type 1 Of oDlg Enable Action ( nOpcA := 1, oDlg:End() )
	Define SButton From 73,160 Type 2 Of oDlg Enable Action oDlg:End()

	ACTIVATE MSDIALOG oDlg CENTERED

	If nOpcA == 1 .And. (lIncApos .Or. lClaApos)
		If A103ApoTok(aHeadDHP,oGetDHP:aCols,aCols[N][nPosItTot])
			If nItem > 0
				aColsDHP[nItem][2] := aClone(oGetDHP:aCols)
			Else
				aAdd(aColsDHP,{aCols[N][nPosItNf],aClone(oGetDHP:aCols)})
			EndIf
			A103AtuApos(aHeadDHP,aColsDHP)
		EndIf
	EndIf

EndIf

RestArea(aArea)

Return

/*/{Protheus.doc} A103ApoTok
Funcao de validacao TudoOk de aposentadoria especial - Projeto REINF
@author carlos.capeli
@since 28/03/2018
@version 12.1.17
@type function
/*/
Function A103ApoTok(aHeadDHP,aColsDHP,nValTot)

Local nPos15   := aScan(aHeadDHP,{|x| AllTrim(x[2]) == "DHP_FAIXA1"} )
Local nPos20   := aScan(aHeadDHP,{|x| AllTrim(x[2]) == "DHP_FAIXA2"} )
Local nPos25   := aScan(aHeadDHP,{|x| AllTrim(x[2]) == "DHP_FAIXA3"} )
Local nValor15 := 0
Local nValor20 := 0
Local nValor25 := 0
Local lRet     := .T.

If nPos15 > 0
	nValor15 := aColsDHP[1][nPos15]
EndIf
If nPos20 > 0
	nValor20 := aColsDHP[1][nPos20]
EndIf
If nPos25 > 0
	nValor25 := aColsDHP[1][nPos25]
EndIf
If ( nValor15 + nValor20 + nValor25 ) > nValTot
	Help("",1,"A103APOESP",,"A somatória dos valores de aposentadoria especial não pode ser superior ao total do item da nota.",1,0)
	lRet := .F.
EndIf

Return lRet

/*/{Protheus.doc} A103AtuApos
Funcao de atualizacao das referencias fiscais de aposentadoria especial - Projeto REINF
@author carlos.capeli
@since 28/03/2018
@version 12.1.17
@type function
/*/
Function A103AtuApos(aHeadDHP,aColsDHP)

Local nPosItNf  := GetPosSD1("D1_ITEM" )
Local nPos15    := aScan(aHeadDHP,{|x| AllTrim(x[2]) == "DHP_FAIXA1"} )
Local nPos20    := aScan(aHeadDHP,{|x| AllTrim(x[2]) == "DHP_FAIXA2"} )
Local nPos25    := aScan(aHeadDHP,{|x| AllTrim(x[2]) == "DHP_FAIXA3"} )
Local nValor15  := 0
Local nValor20  := 0
Local nValor25  := 0
Local nX        := 0
Local nItemNf   := 0
Local lRefImp15 := !Empty(MafisScan("IT_SECP15",.F.))
Local lRefImp20 := !Empty(MafisScan("IT_SECP20",.F.))
Local lRefImp25 := !Empty(MafisScan("IT_SECP25",.F.))
Local lDeletado := .F.

For nX := 1 To Len(aColsDHP)
	If ( nItemNf := aScan(aCols,{|x| x[nPosItNf] == aColsDHP[nX][1]}) ) > 0
		lDeletado := aColsDHP[nX][2][1][Len(aColsDHP[nX][2][1])]
		aColsDHP[nX][2][1][Len(aColsDHP[nX][2][1])] := .F.
		If lRefImp15 .And. nPos15 > 0
			nValor15 := Iif(lDeletado,0,aColsDHP[nX][2][1][nPos15])
			MaFisAlt("IT_SECP15",nValor15,nItemNf)
		EndIf
		If lRefImp20 .And. nPos20 > 0
			nValor20 := Iif(lDeletado,0,aColsDHP[nX][2][1][nPos20])
			MaFisAlt("IT_SECP20",nValor20,nItemNf)
		EndIf
		If lRefImp25 .And. nPos25 > 0
			nValor25 := Iif(lDeletado,0,aColsDHP[nX][2][1][nPos25])
			MaFisAlt("IT_SECP25",nValor25,nItemNf)
		EndIf
		aColsDHP[nX][2][1][Len(aColsDHP[nX][2][1])] := lDeletado
	EndIf
Next nX

Return

/*/{Protheus.doc} A103disObr
Função para desabilitar a obrigatoriedade dos campos do ativo SN3 : N3_HISTOR E N3_CCONTAB

@author Gustavo Mantovani Cândido
@since 19/04/2018
@version 12.1.17
@type function
/*/
Function A103disObr()

Local lMata240	:= If(FindFunction("CallsOfEst"),CallsOfEst(),FwIsInCallStack("MATA241") .Or. FwIsInCallStack("MATA240"))
Local lMata103	:= FwIsInCallStack("MATA103")
Local lMata116	:= FwIsInCallStack("MATA116")
Local lMata101N	:= FWIsInCallStack("MATA101N")
Local lMata102N	:= FWIsInCallStack("MATA102N") .or. (FindFunction("CallsMI").and. CallsMI() ) .or. (FWIsInCallStack("A143GERANF") .and. cPaisLoc=="ARG"  )
Local lMata119	:= FwIsInCallStack("MATA119")
Local lRet := .f.

If lMata103 .OR. lMata116 .Or. lMata240 .Or. lMata101N .Or. lMata119 .Or. lMata102N
	lRet := .T.
EndIf

Return (lRet)

/*/{Protheus.doc} A103DESARC()
Validação do evento desacordo

@param	nOpc 1-Parametros,2-Evento Desacordo,3-Monitor

@author Rodrigo Machado Pontes
@since 17/01/18
@version 11
/*/

Function A103DESARC(nOpc)

Local lRet			:= .T.
Local lF1Desa		:= SF1->(FieldPos("F1_IDDES")) > 0 .And. SF1->(FieldPos("F1_OBSDES")) > 0
Local cMsgHelp		:= ""
Local cInscr   		:= ""
Local cContrib 		:= ""
Local cEspDes		:= "|CTE|CTEOS|"
Local dDataFec		:= MVUlmes()
Local lContrib 		:= .F.
Local nOpcDes 		:= 1 //1 = Evento de desacordo - 2 = Evento de cancelamento de desacordo

If !lF1Desa
	cMsgHelp := STR0194 //"Campos: F1_IDDES e F1_OBSDES não encontrados no dicionario."
	Help( " ", 1, "A103CPODES",,cMsgHelp,1,0) 
	lRet := .F.
Else
	If nOpc == 2 .Or. nOpc == 3 .Or. nOpc == 4
		If !("|"+Alltrim(SF1->F1_ESPECIE)+"|" $ cEspDes)
			cMsgHelp := STR0192 //"Evento de desacordo apenas para conhecimentos de frete."
			Help( " ", 1, "A103DESACORDO",,cMsgHelp,1,0) 
			lRet := .F.
		Endif
	Endif

	If lRet .and. nOpc == 4 .and. Alltrim(SF1->F1_STATUS) <> 'E'
		cMsgHelp := STR0243 //"Evento de cancelamento de desacordo só pode ser enviado para CTE que esteja em desacordo. (F1_STATUS = E)"
		Help( " ", 1, "A103CANCDES",,cMsgHelp,1,0)
		lRet := .F.
	EndIf
	
	If lRet .And. nOpc == 2
		//Valida se possui chave do documento
		If lRet .And. Empty(SF1->F1_CHVNFE)
			cMsgHelp := STR0216 //"Documento não possui chave informada."
			Help( " ", 1, "A103DESCHV",,cMsgHelp,1,0)
			lRet := .F.
		Endif

		//Validação se esta dentra do fechamento de estoque
		If lRet .And. dDataFec >= dDataBase .Or. dDataFec >= SF1->F1_DTDIGIT
			Help( " ", 1, "FECHTO" )
			lRet := .F.
		Endif
		
		//Verifica Fiscal
		If lRet .And. !FisChkExc(SF1->F1_SERIE,SF1->F1_DOC,SF1->F1_FORNECE,SF1->F1_LOJA,,"E")
			lRet := .F.
		Endif
		
		// Verifica se existe bloqueio contabil
		If lRet
			lRet := CtbValiDt(Nil ,SF1->F1_DTDIGIT,.T. ,Nil ,Nil ,{"COM001"}) // Retorno .F. -> Help CTBBLOQ - Calendario Contabil Bloqueado. Verifique o processo.
		EndIf
		
		If lRet
			//-- Verifica se fornecedor e contribuinte do ICMS
			cInscr   := Posicione("SA2", 1, xFilial("SA2") + SF1->F1_FORNECE + SF1->F1_LOJA,"A2_INSCR")
			cContrib := Posicione("SA2", 1, xFilial("SA2") + SF1->F1_FORNECE + SF1->F1_LOJA,"A2_CONTRIB")
			
			If	Alltrim(cContrib) == "2" .Or. Empty(cInscr) .Or. Alltrim(Upper(cInscr)) $ "ISENT" .Or. Alltrim(Upper(cInscr)) $ "RG"
				lContrib := .F.
			Else
				lContrib := .T.
			EndIf
			
			If !lContrib
				cMsgHelp := STR0193 //"Fornecedor não é contribuinte. Evento de Desacordo não permitido."
				Help( " ", 1, "A103FORNDES",,cMsgHelp,1,0) 
				lRet := .F.
			EndIf
		Endif
	Endif

	If lRet .And. nOpc == 3
		If Empty(SF1->F1_IDDES)
			cMsgHelp := STR0204 //"É preciso realizar o envio do evento primeiro."
			Help( " ", 1, "A103EVNDES",,cMsgHelp,1,0) 
			lRet := .F.
		Endif
	Endif
	
	If lRet
		If nOpc == 1 //Parametros
			SpedEpecPar()
		Elseif nOpc == 2 //Evento Desacordo
			A103EvDes()
		Elseif nOpc == 3 .And. ExistFunc("TMSPedMDes") //Monitor
			if SF1->F1_STATUS $ "A|H"
				nOpcDes := 2
			endif
			TMSPedMDes("SF1",nOpcDes)
		Elseif nOpc == 4 //Evento Cancelamento Desacordo
			A103EvCanDes()
		Endif
	Endif
Endif

Return lRet

/*/{Protheus.doc} A103NfElet
Funcao para executar ponto de entrada para carregar informacoes nas abas Nota Fiscal Eletronica, Danfe e Inf. Adicionais
@author carlos.capeli
@since 25/06/2018
@version 12.1.17
@type function
/*/
Function A103NfElet(cCampoVld,cUf,aNFEletr,aNfeDanfe,aInfAdic)

Local lM103NfEl := Existblock("M103NFEL")
Local aRetPE    := {}

Default cCampoVld := ""
Default cUf       := ""
Default aNFEletr  := {}
Default aNfeDanfe    := {}
Default aInfAdic  := {}

If lM103NfEl
	aRetPE := ExecBlock("M103NFEL",.F.,.F.,{cCampoVld,cUf,aNFEletr,aNfeDanfe,aInfAdic})
	If ValType(aRetPE) == "A"
		If Len(aRetPE) > 0 .And. ValType(aRetPE[1]) == "A"
			aNFEletr := aClone(aRetPE[1])
		EndIf
		If Len(aRetPE) > 1 .And. ValType(aRetPE[2]) == "A"
			aNfeDanfe := aClone(aRetPE[2])
		EndIf
		If Len(aRetPE) > 2 .And. ValType(aRetPE[3]) == "A"
			aInfAdic := aClone(aRetPE[3])
		EndIf
	EndIf
EndIf

Return .T.
/*/{Protheus.doc} A103XDesfaz()
Validacao da rotina de Desfazimento para processo de Compra com Entrega Futura
@param	Nenhum
@author Carlos Capeli
@since 28/08/18
@version 12
/*/
Function A103XDesfaz()

Local lDHQInDic := AliasInDic("DHQ") .And. SF4->(ColumnPos("F4_EFUTUR") > 0)
Local lMt103Com := FindFunction("A103Desfaz")
Local lRet      := .T.

If lDHQInDic .And. lMt103Com
	A103Desfaz()
ElseIf !lDHQInDic
	Help( " ", 1, "A103DHQ",,STR0205,1,0)
	lRet := .F.
ElseIf !lMt103Com
	Help( " ", 1, "A103COMFUT",,STR0206,1,0) 
	lRet := .F.
EndIf

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} A103VldObr()
Validação dos campos caso sejam configurados como obrigatórios. gerando Help para aviso de campos vazios

@param    aNFEletr - Array - Nota Fiscal Eletrônica
@return   lRet - Lógica - Caso exista algum campo obrigatório em branco retornarão Falso

@author Gustavo Mantovani Cândido
@since 04/10/18
@version 11
/*/
//-------------------------------------------------------------------
Function A103VldObr(aNFEletr,lMT140)
Local lRet				:= .T.
Local lCteOriDest		:= SF1->(FieldPos("F1_UFORITR")) > 0 .And. SF1->(FieldPos("F1_MUORITR")) > 0 .And. SF1->(FieldPos("F1_UFDESTR")) > 0 .And. SF1->(FieldPos("F1_MUDESTR")) > 0
Local lObrigat			:= "|"+Alltrim(cEspecie)+"|" $ "|CTE|CTEOS|"
Local cCpoVazio			:= ""
Local aCpoNota 			:= {}
Local aCpoDanfe 		:= {}
Local aCpoInfAdi 		:= {}

Default lMT140 := .F. 

If !lMT140
	aCpoNota	:= {		{"F1_NFELETR",1},;
							{"F1_CODNFE",2},;				
							{"F1_EMINFE",3},;
							{"F1_HORNFE",4},;
							{"F1_CREDNFE",5},;
							{"F1_NUMRPS",6},;
							{"F1_MENNOTA",7},;
							{"F1_MENPAD",8}}

	aCpoDanfe 	:= {		{"F1_TRANSP",1},;
							{"F1_PLIQUI",2},;
							{"F1_PBRUTO",3},;
							{"F1_ESPECI1",4},;
							{"F1_VOLUME1",5},;
							{"F1_ESPECI2",6},;
							{"F1_VOLUME2",7},;
							{"F1_ESPECI3",8},;
							{"F1_VOLUME3",9},;
							{"F1_ESPECI4",10},;
							{"F1_VOLUME4",11},;
							{"F1_PLACA",12},;
							{"F1_CHVNFE",13},;
							{"F1_TPFRETE",14},;
							{"F1_VALPEDG",15},;
							{"F1_FORRET",16},;
							{"F1_LOJARET",17},;
							{"F1_TPCTE",18},;
							{"F1_FORENT",19},;
							{"F1_LOJAENT",20},;
							{"F1_NUMAIDF",21},;
							{"F1_ANOAIDF",22},;
							{"F1_MODAL",23},;
							{"F1_DEVMERC",24}}

	aCpoInfAdi	:= {		{"F1_INCISS",1},;
							{"F1_VEICUL1",2},;
							{"F1_VEICUL2",3},;
							{"F1_VEICUL3",4},;
							{"F1_DTCPISS",5},;
							{"F1_SIMPNAC",6},;
							{"F1_CLIDEST",7},;
							{"F1_LOJDEST",8},;
							{"F1_ESTDES",9}}
Endif							

If lCteOriDest .And. lObrigat
	Aadd(ACpoInfAdi, {"F1_UFORITR",10})
	Aadd(ACpoInfAdi, {"F1_MUORITR",11})
	Aadd(ACpoInfAdi, {"F1_UFDESTR",12})
	Aadd(ACpoInfAdi, {"F1_MUDESTR",13})
ENdIf

If cPaisLoc == "BRA" .And. Type("lIntermed") == "L" .And. lIntermed
	Aadd(ACpoInfAdi, {"F1_INDPRES",16})
	Aadd(ACpoInfAdi, {"F1_CODA1U" ,17})
Endif

//Validando campos obrigatÃ³rios da Nota Fiscal EletrÃ´nica
If !lMT140 .And. ValType(aNFEletr) == "A" .And. !empty(aNFEletr)
       cCpoVazio += A103CpoFor(aCpoNota, aNFEletr)
EndIf

//validando os campos obrigatÃ³rios da aba Danfe
If !lMT140 .And. type("aNFEDanfe") == "A" .And. !empty(aNFEDanfe)
       cCpoVazio += A103CpoFor(aCpoDanfe, aNFEDanfe) 
EndIf

//validando os campos obrigatÃ³rios InformaÃ§Ãµes Adicionais
If type("aInfAdic") == "A" .And. !empty(aInfAdic)
    cCpoVazio += A103CpoFor(aCpoInfAdi, aInfAdic) 
EndIf        

If !empty(cCpoVazio)
	cCpoVazio := substr(cCpoVazio,1, (len(cCpoVazio) - 2))
	Help(1," ","OBRIGAT",,cCpoVazio,2,1)
	lRet := .F.
EndIf

Return lRet
 
//-------------------------------------------------------------------
/*/{Protheus.doc} A103CpoFor()
Laço de validação para campos da função A103VldObr

@param    aCpoHeader - Array - Nome dos Campos da aba
@param    aCpoCont - Array - Conteúdo dos Campos da aba
@return   cCpoVazio - String - Retorna nome dos campos obrigatÃ³rios que estÃ£o vazios

@author Gustavo Mantovani Cândido
@since 04/10/18
@version 11
/*/
//-------------------------------------------------------------------
Static Function A103CpoFor(aCpoHeader,aCpoCont)
Local cCpoVazio := ""
Local cTipoCPO  := ""
Local ni 		:= 0
 
For ni := 1 to len(aCpoHeader)
       If SF1->(FieldPos(aCpoHeader[ni,1])) > 0
              if x3obrigat(aCpoHeader[ni,1])
                     cTipoCPO := tamSX3(aCpoHeader[ni,1])[3]                     
                     if ((cTipoCPO  == "C" .or. cTipoCPO  == "D") .And. empty(aCPOCont[aCpoHeader[ni,2]])) .Or. ;
                           (cTipoCPO == "N" .And. aCpoCont[aCpoHeader[ni,2]] <= 0)
                                  cCpoVazio += aCpoHeader[nI,1] + ", "
                     EndIf
              EndIf
       EndIf        
next ni
Return cCpoVazio

/*-------------------------------------------------------------------
{Protheus.doc} a103AtuTaxa()
@author Leandro Nishihata
@since 13/03/19
@version 12
-------------------------------------------------------------------*/
Static Function a103AtuTaxa(nMoedAux)
Local lRet := .T.

If nMoedAux <> nMoedaCor
	Eval(bRefresh)
Endif
	nMoedAux := NMOEDACOR
return lRet

/*/{Protheus.doc} LoadX3Arr
	Retorna um array contendo as opcoes de um campo combobox
	fornecido em <cField>, alem disso adiciona uma opcao vazia
	no comeco do vetor.
@author philipe.pompeu
@since 21/06/2019
@return aResult, opcoes do X3 de <cField>
@param cField, caracter, campo que deve ter seu X3 retornado
@param bAlter, block, bloco de cod. p/ alterar o retorno
/*/
Static Function LoadX3Arr(cField, bAlter)
	Local aResult := {}
	Local nI := 0
	Default bAlter := Nil
	
	aResult := X3CboxToArray(cField)[1]
	
	If(bAlter != Nil)
		For nI:= 1 to Len(aResult)
			aResult[nI] := Eval(bAlter, aResult[nI])
		Next nI
	EndIf
		
	aAdd(aResult,Nil)
	AIns(aResult,1)
	aResult[1] := " "
Return aResult

/*/{Protheus.doc} A103RATAFN
Monta array de rateio de projeto ao alterar pre nota ou
classificar um documento de entrada

@author rodrigo.mpontes
@since 21/06/2019
/*/

Function A103RATAFN(cNF,cSer,cFor,cLoj,aRatAFN,aHdrAFN)

Local aArea		:= GetArea()
Local aItens	:= {}
Local nI		:= 0
Local nPosRat	:= 0
Local cQry		:= ""
Local cAliasD1	:= GetNextAlias()
Local cItemAnt	:= "0001"

DbSelectArea("AFN")
AFN->(DbSetOrder(2))

aHdrAFN := GetaHeader("AFN")

cQry	:= " SELECT D1_DOC, D1_SERIE, D1_FORNECE, SD1.D1_LOJA, D1_ITEM, "
cQry	+= "AFN_PROJET, AFN_REVISA, AFN_TAREFA, AFN.R_E_C_N_O_ "
cQry	+= " FROM " + RetSqlName("SD1") + " SD1" 
cQry	+= " INNER JOIN " + RetSqlName("AFN") + " AFN"
cQry	+= " ON AFN.AFN_FILIAL = SD1.D1_FILIAL"
cQry	+= " AND AFN.AFN_DOC = SD1.D1_DOC"
cQry	+= " AND AFN.AFN_SERIE = SD1.D1_SERIE"
cQry	+= " AND AFN.AFN_FORNEC = SD1.D1_FORNECE"
cQry	+= " AND AFN.AFN_LOJA = SD1.D1_LOJA"
cQry	+= " AND AFN.AFN_ITEM = SD1.D1_ITEM"
cQry	+= " WHERE AFN.AFN_FILIAL = '" +xFilial("AFN")+ "' "
cQry	+= " AND AFN.AFN_DOC = '" +cNF+ "' "
cQry	+= " AND AFN.AFN_SERIE = '" +cSer+ "' "
cQry	+= " AND AFN.AFN_FORNEC = '" +cFor+ "' "
cQry	+= " AND AFN.AFN_LOJA = '" +cLoj+ "' "
cQry	+= " AND AFN.D_E_L_E_T_ = ' '  "
cQry	+= " AND SD1.D_E_L_E_T_ = ' ' "
cQry	:= ChangeQuery(cQry)

dbUseArea( .T., "TOPCONN", TcGenQry( , , cQry ), cAliasD1, .T., .T. )

While (cAliasD1)->(!Eof())
	AFN->(DbGoTo((cAliasD1)->R_E_C_N_O_))
	If (cAliasD1)->AFN_REVISA == PmsAF8Ver((cAliasD1)->AFN_PROJET)
		If cItemAnt <> (cAliasD1)->D1_ITEM
			aSize(aItens,0)
		EndIf
		aADD(aItens,Array(Len(aHdrAFN)+1))
		For nI := 1 to Len(aHdrAFN)
			If ( aHdrAFN[nI,10] != "V")
				aItens[Len(aItens),nI] := AFN->(FieldGet(AFN->(ColumnPos(aHdrAFN[nI,2]))))
			ElseIf AllTrim(aHdrAFN[nI,2]) $ "AFN_ALI_WT | AFN_REC_WT"
				If AllTrim(aHdrAFN[nI,2]) == "AFN_ALI_WT"
					aItens[Len(aItens),nI] := "AFN"
				ElseIf AllTrim(aHdrAFN[nI,2]) == "AFN_REC_WT"
					aItens[Len(aItens),nI] := AFN->(Recno())
				EndIf
			Else
				aItens[Len(aItens),nI] := CriaVar(aHdrAFN[nI,2])
			EndIf
		Next nI
		aItens[Len(aItens),Len(aHdrAFN)+1] := .F.
	EndIf
	
	nPosRat    := aScan(aRatAFN,{|x| x[1] == (cAliasD1)->D1_ITEM})
	If nPosRat > 0
		aRatAFN[nPosRat,2]    := aClone(aItens)
	Else
		aADD(aRatAFN,{(cAliasD1)->D1_ITEM,aClone(aItens)})
	EndIf
	cItemAnt := (cAliasD1)->D1_ITEM	
	(cAliasD1)->(DbSkip())
EndDo				

aSize(aItens,0)
(cAliasD1)->(DbCloseArea())
RestArea(aArea)

Return

/*/{Protheus.doc} A103VlStr
Funcao que valida a existencia de caracteres especiais em uma string.
@type  Function
@author leonardo.magalhaes
@since 30/07/2019
@version 1.00
@return lRet, Boolean, Retorna true (.T.) Quando não existir caracter especial e false (.F.) quando existir
@example (examples)
@see (links_or_references)
/*/
Function A103VlStr(cString, nOpcx)
	
	Local lRet       	:= .T.
	Local nCont			:= 0
	Local cConteudo		:= "" 
	Local cCaracter		:= "'|" + '"'

	Default cString		:= ""
	Default nOpcx		:= 1

	cConteudo := Alltrim(Iif(nOpcx == 1, &(ReadVar()), cString))

	If !(ValType(cConteudo) == "C")
		lRet := .F.
	Else
		For nCont := 1 to Len(cConteudo)
			If SubStr(cConteudo, nCont, 1) $ cCaracter
				lRet := .F.
				Exit
			EndIf
		Next nCont
	EndIf 

	If !lRet 
		Help(,, "A103VLSTR",, STR0212, 1, 0) //Para este campo, não é permitido a utilização de caracteres especiais!
	EndIf

Return lRet

/*/{Protheus.doc} A103PRERAT
Validação do pre rateio para que o campo ITEM fique
na primeira posição, pois a função é generica da 
controladoria.

@author rodrigo.mpontes
@since 21/06/2019
/*/

Static Function A103PRERAT(aHead)

Local lRet	:= .T.
Local nPos	:= 0

nPos := aScan(aHead,{|x| AllTrim(x[2]) == "DE_ITEM"})
If nPos > 0 .And. nPos <> 1
	Help(" ",1,"A103PRERAT",,STR0213,1,1) //"O campo ITEM deve ficar na primeira posição."
	lRet := .F.
Endif

Return lRet

/*/{Protheus.doc} A103CLASFIS
Importar o clasfis caso documento é originado via
totvs colaboração / importador xml

@author rodrigo.mpontes
@since 21/06/2019
/*/

Function A103CLASFIS(cDoc,cSer,cForn,cLoja,cItem,cD1ClasFis) 

Local aArea		:= GetArea()
Local aRet		:= {}
Local lColab	:= .F.
Local cClasFis	:= ""
Local nClasFis	:= SuperGetMV("MV_COLCLAS",.F.,0)

If nClasFis < 2 
	DbSelectArea("SDT")
	SDT->(DbSetOrder(8)) //DT_FILIAL, DT_FORNEC, DT_LOJA, DT_DOC, DT_SERIE, DT_ITEM

	If SDT->(FieldPos("DT_CLASFIS")) > 0 .And. SDT->(DbSeek(xFilial("SDT") + cForn + cLoja + cDoc + cSer)) .And. !Empty(SDT->DT_CLASFIS)
		lColab := .T.
		If SDT->(DbSeek(xFilial("SDT") + cForn + cLoja + cDoc + cSer + cItem))
			cClasFis := Iif(nClasFis==0,SDT->DT_CLASFIS,SubStr(SDT->DT_CLASFIS,1,1) + SubStr(cD1ClasFis,2,Len(cD1ClasFis)))
		Endif 
	Endif
Endif

aRet := {lColab,cClasFis}

RestArea(aArea)

Return aRet


/*/{Protheus.doc} A103TrfIPI
Valida se e necessario alterar a Base do IPI conforme
implementacao do parametro MV_PBIPITR. 

@author Materiais
@since 11/09/2019
/*/
Function A103TrfIPI(cTES, n)

Local nPosItem  := GetPosSD1("D1_ITEM")
Local nPosTES   := GetPosSD1("D1_TES")
Local nPosCod   := GetPosSD1("D1_COD")
Local nPosQtd   := GetPosSD1("D1_QUANT")
Local nPbIPITr  := SuperGetMv("MV_PBIPITR",.F.,0)
Local cFilOri   := ""
Local cNumPV    := ""
Local cItmPV    := ""
Local aAreaSF4  := {}
Local aAreaSC6  := {}
Local aItmSD2   := {}
Default cTES    := aCols[n,nPosTES]

If FindFunction("A103xTrfIPI")
	Return A103xTrfIPI(cTES, n)
EndIf

If !Empty(MaFisScan("IT_PRCCF",.F.)) .And. nPbIPITr > 0
	aAreaSF4 := SF4->(GetArea())
	aAreaSC6 := SC6->(GetArea())
	SF4->(dbSetOrder(1))
	If SF4->(MsSeek(xFilial("SF4")+cTES)) .And. SF4->F4_TRANFIL == "1"
 		If A103TrFil(cTES,cTipo,ca100For,cLoja,cNFiscal,cSerie,aCols[n,nPosCod],aCols[n,nPosQtd],@aItmSD2,GdFieldGet('D1_LOTECTL',n),GdFieldGet('D1_NUMLOTE',n),.F.,aCols[n,nPosItem])
 			If Len(aItmSD2) > 0
	 			cFilOri := aItmSD2[aScan(aItmSD2,{|x| AllTrim(x[1])=="D2_FILIAL"})][2]
	 			cNumPV  := aItmSD2[aScan(aItmSD2,{|x| AllTrim(x[1])=="D2_PEDIDO"})][2]
	 			cItmPV  := aItmSD2[aScan(aItmSD2,{|x| AllTrim(x[1])=="D2_ITEMPV"})][2]
	 			dbSelectArea("SC6") 
	 			SC6->(dbSetOrder(1))
	 			If SC6->(FieldPos("C6_IPITRF")) > 0 .And. SC6->(MsSeek(cFilOri+cNumPV+cItmPV)) 
					MaFisAlt("IT_PRCCF",SC6->C6_IPITRF,n)
				EndIf
			EndIf
		EndIf
	EndIf
	RestArea(aAreaSF4)
	RestArea(aAreaSC6)
EndIf

Return .T.

/*/{Protheus.doc} A103ExstNF
Valida se a nota fiscal e/ou titulo NF e/ou NCC já existe
@author Kevin Alexander
@since 30/10/2019
/*/
Static Function A103ExstNF()

Local aArea      	:= GetArea()
Local aAreaSF1   	:= SF1->(GetArea())
Local aSerAltern	:= {}

Local lRetorno 		:= .T.
Local lUsaNewKey 	:= TamSX3("F1_SERIE")[1] == 14 // Verifica se o novo formato de gravacao do Id nos campos _SERIE esta em uso
Local lNaoExiste 	:= .T.

Local cSerAltern	:= ""
Local cTamSerie 	:= SerieNfId("SF1",6,"F1_SERIE") 
Local cMsg		  	:= ""
Local cQuery   		:= ""
Local cSerieId   	:= IIf( lUsaNewKey , SerieNfId("SD1",4,"D1_SERIE",dDEmissao,cEspecie,cSerie) , cSerie )
Local cEASYFIN		:= SuperGetMv("MV_EASYFIN")
Local c2DUPREF		:= SuperGetMv("MV_2DUPREF")
Local lVTESDUP		:= SuperGetMv("MV_VTESDUP", .F., .F.)

Local nI 			:= 0
	
If INCLUI
	FreeUsedCode()
	If A103TEMNF( cNFiscal, cSerieId, cA100For, cLoja, cFormul )
		If ExistBlock("M103ALTS") .And. !lUsaNewKey
			aSerAltern := ExecBlock("M103ALTS",.F.,.F.,{cNFiscal,cSerie,cA100For,cLoja})
			If Valtype(aSerAltern) == 'A' .And. Len(aSerAltern) > 0 
				For nI:=1 To Len(aSerAltern) 
					If Len(Alltrim(cSerie)) = cTamSerie // Serie atual com o mesmo tamanho do campo
						If aSerAltern[nI,2] = 1 // Prefixo (a frente da serie) Ex. '.1'
							cSerAltern := Substr(aSerAltern[nI,1],1,1)+Substr(cSerie,2,cTamSerie-1)
						Else // Sufixo (apos a serie) Ex. '1.'
							cSerAltern := Substr(cSerie,1,cTamSerie-1)+Substr(aSerAltern[nI,1],1,1)
						Endif
					Else // Serie atual com tamanho menor que o tamanho do campo
						If aSerAltern[nI,2] = 1 // Prefixo (a frente da serie) Ex. '.1'
							cSerAltern := Substr(aSerAltern[nI,1],1,1)+Alltrim(cSerie)
						Else // Sufixo (apos a serie) Ex. '1.'
							cSerAltern := Alltrim(cSerie)+Substr(aSerAltern[nI,1],1,1)
						Endif					
					Endif
					If A103TEMNF( cNFiscal, Padr(cSerAltern,cTamSerie), cA100For, cLoja, cFormul )
						If !l103Auto
							cMsg := 'Os documentos de entrada: '+_CRLF+cNFiscal+' '+cSerie+_CRLF+cNFiscal+' '+cSerAltern+_CRLF+'Já existem cadastrados'
							MsgAlert(cMsg)
						Endif
						If Len(aSerAltern) > nI // Ainda possui alternativas
							Loop
						Endif
						lRetorno := .F.
						Exit
					Else // Quando não existir ainda, sugerir a alteração da série
						cMsg := 'Deseja alterar a série para continuar ?'+_CRLF+"Novo valor: "+cSerAltern
						If l103Auto .Or. MsgYesNo(cMsg)
							cSerie := cSerAltern
							Exit
						Else
							lRetorno := .F.
							Exit
						Endif
					Endif
				Next nI
			Else
				lRetorno := .F.
			Endif
		Else
			lRetorno := .F.
		Endif
		
		If !lRetorno
			Help(" ",1,"EXISTNF")
			lNaoExiste := .F.
		EndIf	
	Else
		If !FreeForUse("NFE",xFilial("SF1")+cNFiscal+cSerieId+cA100For+cLoja)
			lRetorno := .F.
		EndIf
	EndIf
	
	If cTipo == "D" 
		If lRetorno .And. cEASYFIN == "N" .And. "SF1->F1_SERIE" $ c2DUPREF .And. !lUsaNewKey
			cQuery := "SELECT COUNT(E1_FILIAL) TITULOS "
			cQuery += "  FROM "+RetSqlName("SE1")+" SE1 "
			cQuery += " WHERE SE1.E1_FILIAL  ='"+xFilial("SE1")+"'"
			cQuery += "   AND SE1.E1_PREFIXO ='"+cSerie+"'"
			cQuery += "   AND SE1.E1_NUM	 ='"+cNFiscal+"'"
			cQuery += "   AND SE1.E1_TIPO    ='"+MV_CRNEG+"'"
			cQuery += "   AND SE1.E1_CLIENTE ='"+cA100For+"'"
			cQuery += "   AND SE1.E1_LOJA	 ='"+cLoja+"'"
			cQuery += "   AND SE1.D_E_L_E_T_ =' ' "
	
			cQuery := ChangeQuery(cQuery)
			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"NFEFORNECE")
	
			If NFEFORNECE->TITULOS > 0 
				Help(" ",1,"FANUMNCC",,"NCC a ser gerada ja existe.",4,1)
				lRetorno := .F.
			EndIf
			NFEFORNECE->(dbCloseArea())
			dbSelectArea("SE1") 
		EndIf                      
	Else	
		If lNaoExiste .And. lRetorno .And. cEASYFIN == "N" .And. "SF1->F1_SERIE" $ c2DUPREF .And. !lUsaNewKey .And. !lVTESDUP
			lRetorno := A103F50NUM(cSerie,cNFiscal,cA100For,cLoja)
		EndIf
	EndIf
EndIf

RestArea(aAreaSF1)
RestArea(aArea)

Return lRetorno

/*/{Protheus.doc} A103BXADT
Verifica se possui alguma baixa no titulo que ja foi utilizado uma PA

@param cPref	Prefixo
@param cNum		Numero
@param cParc	Parcela
@param cTip		Tipo
@param cForn	Fornecedor/Cliente
@param cLoj		Loja
@param cFilOrig	Filial Origem

@author rodrigo.mpontes
@since 30/10/2019
/*/

Static Function A103BXADT(cPref,cNum,cParc,cTip,cForn,cLoj,cFilOrig)

Local aArea			:= GetArea()
Local aBaixa		:= {}
Local nTotAdto		:= 0
Local nTotImpost	:= 0
Local lBaixaAbat 	:= .F.
Local lBxCec 		:= .F.
Local lNotBax 		:= .F.
Local lAglImp 		:= .F.
Local lRet			:= .F.

Private ABAIXASE5	:= {}
Private aRecBorra	:= {}

aBaixa := Sel080Baixa("BA /VL /",cPref,cNum,cParc,cTip,@nTotAdto,@lBaixaAbat,cForn,cLoj,@lBxCec,.F.,@lNotBax,@nTotImpost,@lAglImp,.T.,,,,,cFilOrig,.T.)

If Len(aBaixa) > 0 //Tem baixas alem da compensação do PA
	lRet := .T.
Endif

RestArea(aArea)
Return lRet

/*/{Protheus.doc} A103SELPC
Verifica na seleção do PC/AE na classificação se ja possui o vinculo, 
caso ja tenha, o vinculo deve ser via Pedido (Item).

@param aTitCampos	Cabeçalho
@param aF4For		Array com os PC/AE
@param nSel			Posição selecionada
@param lIntPms		Integração com o PMS

@author rodrigo.mpontes
@since 25/09/2020
/*/

Function A103SELPC(aTitCampos,aF4For,nSel,lIntPms)

Local aArea		:= GetArea()
Local aPCAE		:= {}
Local nPos		:= aScan(aTitCampos,{|x| AllTrim(Upper(x)) == "PEDIDO"})
Local nFind		:= 0 
Local lAlerta	:= .F.
Local cFilSD1	:= xFilial("SD1")

If Type('l103Class') <> "L" 
	l103Class := .F.  
Endif

If l103Class
	If nPos > 0//Encontrou o campo PEDIDO
		DbSelectArea("SD1") //Busca PC/AE ja vinculados ao abrir a tela de classificação
		SD1->(DbSetOrder(1))
		If SD1->(DbSeek(cFilSD1 + cNFiscal + cSerie + cA100For + cLoja ))
			While SD1->(!EOF()) .And. SD1->D1_FILIAL == cFilSD1 .And. ;
					SD1->D1_DOC == cNFiscal .And. SD1->D1_SERIE == cSerie .And. ;
					SD1->D1_FORNECE == cA100For .And. SD1->D1_LOJA == cLoja 

				If !Empty(SD1->D1_PEDIDO) 
					aAdd(aPCAE,{SD1->D1_PEDIDO,SD1->D1_ITEM})
				Endif
				SD1->(DbSkip())
			Enddo
		Endif

		If Len(aPCAE) > 0 //Verifica se o PC/AE selecionado, ja estava vinculado
			nFind := aScan(aPCAE,{|x| AllTrim(x[1]) == AllTrim(aF4For[nSel,3])})
			If nFind > 0
				lAlerta := .T.
			Endif
		Endif

		If lAlerta //Apresenta alerta, para que o mesmo PC/AE seja vinculado via Pedido (Item) 
			Aviso(STR0018,STR0217 + aPCAE[nFind,2] + STR0218) //"Esse PC/AE ja está vinculado no item: " ## " do documento, utilize o vinculo via Pedido(Item) "                                                                                                                                                                                                                                                                                                                                                                                                                                                                
		Else
			aF4For[nSel,1] := !aF4For[nSel,1]

			If lIntPms .And. FindFunction("PmsInt")
				PmsInt(aF4For[nSel,3])
			Endif
		Endif
	Endif
Else
	aF4For[nSel,1] := !aF4For[nSel,1]

	If lIntPms .And. FindFunction("PmsInt")
		PmsInt(aF4For[nSel,3])
	Endif
Endif

RestArea(aArea)

Return

/*/{Protheus.doc} A103RECC7
Função para realizar a busca do recno pedido de compra
pelo indice 25 ou através de query.  

@param cFilent		Filial de entrega
@param cPedido		Numero do pedido
@param cCodFor		Código do Fornecedor
@param cLjFor		Loja do Fornecedor
@param cNumIt		Numero do item

@author fabiano.dantas
@since 17/12/2020
@version P12
@return Nil
/*/

Function A103RECC7(cFilent,cPedido,cCodFor,cLjFor,cProd,cNumIt,aParamSX1)

Local nRecSC7   := 0
Local aArea		:= GetArea()
Local cAliasAux := GetNextAlias()
Local cIndexC7  := SC7->(IndexKey(6))
Local lMt140	:= FwIsInCallStack("MATA140")
Local lMt103	:= FwIsInCallStack("MATA103")
Local lProcCOL	:= FwIsInCallStack("ProcDocs")
Local lForPCNF	:= SuperGetMV("MV_FORPCNF",.F., .F.)
Local lFindNew	:= .T.
Local lFornCOL	:= .F.
Local aParLoc 	:= {}
Local oPerg 	:= Nil

Default aParamSX1 := {}

cFilent	:= PadR(cFilent,TamSx3("C7_FILENT")[1])
cPedido	:= PadR(cPedido,TamSx3("C7_NUM")[1])
cCodFor	:= PadR(cCodFor,TamSx3("C7_FORNECE")[1])
cLjFor	:= PadR(cLjFor,TamSx3("C7_LOJA")[1])
cProd	:= PadR(cProd,TamSx3("C7_PRODUTO")[1])
cNumIt	:= PadR(cNumIt,TamSx3("C7_ITEM")[1])

DbSelectArea("SC7")

If lProcCOL .Or. AllTrim(SF1->F1_ORIGEM) == "COMXCOL" 
	
	oPerg := FWSX1Util():New()
	oPerg:AddGroup("MTA140I")
	oPerg:SearchGroup()
	aParLoc := oPerg:GetGroup("MTA140I")

	FreeObj(oPerg)

	If aParLoc[2,12]:NX1_PRESEL == 2 
		lFornCOL := .T.
	Endif
Endif

If lMt140
	oPerg := FWSX1Util():New()
	oPerg:AddGroup("MTA140")
	oPerg:SearchGroup()
	aParLoc := oPerg:GetGroup("MTA140")

	FreeObj(oPerg)

	If aParLoc[2,2]:NX1_PRESEL == 2 .Or. lForPCNF .Or. lProcCOL .Or. lFornCOL //Fornecedor
		lFindNew := .F.
		SC7->(DbSetOrder(19))
	Endif
Endif

If lMt103

	//------------------------------------------------------
	// Tratamento para armazenar os dados do pergunte(SX1), 
	// evitando chamadas repetitivas da funcao Pergunte()
	//------------------------------------------------------
	A103LoadX1(@aParamSX1,"MTA103")

	If aParamSX1[2,07]:NX1_PRESEL == 2 .Or. lForPCNF .Or. lProcCOL .Or. lFornCOL  //Fornecedor 
		lFindNew := .F.
		SC7->(DbSetOrder(19))
	Endif
Endif

If lFindNew
	If "C7_ITEM" $ cIndexC7 //C7_FILENT+C7_PRODUTO+C7_FORNECE+C7_LOJA+C7_NUM+C7_ITEM+C7_ITEMGRD
		SC7->(DbSetOrder(6))
		If SC7->(DbSeek((cFilent+cProd+cCodFor+cLjFor+cPedido+cNumIt)))
			nRecSC7 := SC7->(RecNo())
		Endif
		If nRecSC7 == 0
			SC7->(DbSetOrder(19))
			If SC7->(DbSeek(cFilent+cProd+cPedido+cNumIt))
				nRecSC7 := SC7->(Recno())				
			Endif
		Endif
	Else

		BeginSQL Alias cAliasAux
			SELECT 	SC7.R_E_C_N_O_ AS SC7RECNO
			FROM 	%Table:SC7% SC7
			WHERE 	C7_FILENT 	 	 = %Exp:cFilent%
					AND C7_NUM  	 = %Exp:cPedido%
					AND C7_FORNECE 	 = %Exp:cCodFor%
					AND C7_LOJA 	 = %Exp:cLjFor%
					AND C7_PRODUTO   = %Exp:cProd%
					AND C7_ITEM 	 = %Exp:cNumIt%
					AND SC7.%NotDel%
		EndSQL
		If !(cAliasAux)->(Eof())
			nRecSC7 := (cAliasAux)->SC7RECNO
		ENDIF
		If nRecSC7 == 0
			SC7->(DbSetOrder(19))
			If SC7->(DbSeek(cFilent+cProd+cPedido+cNumIt))
				nRecSC7 := SC7->(Recno())				
			Endif			
		EndIf
		(cAliasAux)->(DbCloseArea())
	Endif
Else
	If lMt140 .Or. lMT103
		If SC7->(DbSeek(cFilent+cProd+cPedido+cNumIt))
			nRecSC7 := SC7->(Recno())
		Endif
	Endif
Endif 

RestArea(aArea)
FwFreeArray(aParLoc)

Return nRecSC7 

/*/
{Protheus.doc} A103CPOINTER
Valida existencia dos campos para processo de intermediador
NT2020-006

@author rodrigo.mpontes
@since 10/03/21
@version 1.0
/*/

Function A103CPOINTER()

Local lRet := .F.

If 	SF1->(FieldPos("F1_INDPRES")) > 0 .And. SF1->(FieldPos("F1_CODA1U")) > 0
	lRet := .T.
Endif

Return lRet

/*/
{Protheus.doc} A103VldPres
Valida indicador de presença
NT2020-006

@author rodrigo.mpontes
@since 10/03/21
@version 1.0
/*/

Function A103VldPres()

Local lRet			:= .T.

Return lRet

/*/
{Protheus.doc} A103ChgPres
Valida mudança em tempo de execução do indicador de presença
NT2020-006

@author rodrigo.mpontes
@since 10/03/21
@version 1.0
/*/

Function A103ChgPres() 

Local lRet			:= .T.
Local nI			:= 0
Local nPNFOri		:= GetPosSD1("D1_NFORI")
Local nPNFSerOri	:= GetPosSD1("D1_SERIORI")
Local nPNFItOri		:= GetPosSD1("D1_ITEMORI")
Local nPProd		:= GetPosSD1("D1_COD")
Local cIndPres		:= ""
Local cPedC5		:= ""
Local nLinAtv		:= 0
Local lDtNT2006		:= A103DNT2006()

If lDtNT2006
	For nI := 1 To Len(aCols)
		If !aCols[nI,Len(aCols[nI])]
			If (cTipo == "N" .And. !Empty(aCols[nI,nPNFOri]))
				nLinAtv++
			Endif
		Endif
	Next nI
Endif

If cFormul == "S" .And. lDtNT2006
	If cTipo == "N" 
		If (nPNFOri > 0 .And. nPNFSerOri > 0 .And. nPNFItOri > 0)
			For nI := 1 To Len(aCols)
				If !aCols[nI,Len(aCols[nI])]
					If !Empty(aCols[nI,nPNFOri])
						cPedC5 := GetAdvFVal("SD2","D2_PEDIDO",xFilial("SD2") + aCols[nI,nPNFOri] + aCols[nI,nPNFSerOri] + ca100For + cLoja + aCols[nI,nPProd] + aCols[nI,nPNFItOri],3)
						If !Empty(cPedC5)
							cIndPres := GetAdvFVal("SC5","C5_INDPRES",xFilial("SC5") + ca100For + cLoja + cPedC5,3)
							If nLinAtv == 0 
								aInfAdic[16] := cIndPres
								nLinAtv++
							Elseif nLinAtv >= 1
								If SubStr(aInfAdic[16],1,1) <> cIndPres
									Help(" ",1,"A103INDPRES",,STR0221 + RetTitle("F1_INDPRES"),1,0) //"Não é possivel alterar "
									aInfAdic[16] := cIndPres
									lRet := .F.
								Endif
							Endif
						Endif
					Endif
				Endif
				If !lRet
					Exit
				Endif
			Next nI
		Endif
	Endif
	
Endif 

Eval(bRefresh,10)

Return lRet

/*/
{Protheus.doc} A103VldA1U
Valida codigo do intermediador
NT2020-006

@author rodrigo.mpontes
@since 10/03/21
@version 1.0
/*/

Function A103VldA1U()

Local lRet			:= .T.
Local nI			:= 0
Local nPNFOri		:= GetPosSD1("D1_NFORI")
Local nPNFSerOri	:= GetPosSD1("D1_SERIORI")
Local nPNFItOri		:= GetPosSD1("D1_ITEMORI")
Local nPProd		:= GetPosSD1("D1_COD")
Local cCodA1U		:= ""
Local cPedC5		:= ""
Local lDtNT2006		:= A103DNT2006()

If cFormul == "S" .And. lDtNT2006
	If lRet .And. !Empty(aInfAdic[17]) 
		lRet := ExistCpo("A1U",aInfAdic[17],1)
	Endif

	If lRet .And. cTipo == "N"
		If (nPNFOri > 0 .And. nPNFSerOri > 0 .And. nPNFItOri > 0)
			For nI := 1 To Len(aCols)
				If !aCols[nI,Len(aCols[nI])]
					If !Empty(aCols[nI,nPNFOri])
						cPedC5 := GetAdvFVal("SD2","D2_PEDIDO",xFilial("SD2") + aCols[nI,nPNFOri] + aCols[nI,nPNFSerOri] + ca100For + cLoja + aCols[nI,nPProd] + aCols[nI,nPNFItOri],3)
						If !Empty(cPedC5)
							cCodA1U := GetAdvFVal("SC5","C5_CODA1U",xFilial("SC5") + ca100For + cLoja + cPedC5,3)
							If aInfAdic[17] <> cCodA1U
								Help(" ",1,"A103CODA1U",,STR0221 + RetTitle("F1_CODA1U"),1,0) //"Não é possivel alterar "
								aInfAdic[17] := cCodA1U
								lRet := .F.
							Endif
						Endif
					Endif
				Endif
			Next nI
		Endif
	Endif 
Endif

Eval(bRefresh,10) 

Return lRet 

/*/
{Protheus.doc} A103INTERMED
Validação nos campos D1_NFORI/D1_SERIORI/D1_ITEMORI para indicador de presenca
e codigo do intermediador
NT2020-006

@author rodrigo.mpontes
@since 10/03/21
@version 1.0
/*/

Function A103INTERMED() 

Local lRet 			:= .T.

Return lRet

/*/
{Protheus.doc} A103INTWHEN
Validação nos campos D1_NFORI/D1_SERIORI/D1_ITEMORI para indicador de presenca
e codigo do intermediador
NT2020-006

@author rodrigo.mpontes
@since 10/03/21
@version 1.0
/*/

Function A103INTWHEN() 

Local lRet 			:= .T.

Return lRet

/*/
{Protheus.doc} A103DNT2006
Validação de data para validação de indicador de presença e intermediador.
NT2020-006

@author rodrigo.mpontes
@since 10/03/21
@version 1.0
/*/

Function A103DNT2006()

Local lRet 			:= .F.
Local dDTNT2006		:= CtoD("05/04/2021")

If dDataBase >= dDTNT2006
	lRet := .T.
Endif

Return lRet

/*/
{Protheus.doc} A103EICTRANS
Verifica se documento é originado do EIC ou Transferencia entre filias

@author rodrigo.mpontes
@since 10/03/21
@version 1.0
/*/

Function A103EICTRANS(aCabAuto) 

Local lRet		:= .F.
Local lEic		:= .F.
Local lTransFil	:= FwIsInCallStack("MATA310") .Or. FwIsInCallStack("MATA311")
Local lDtNT2006	:= A103DNT2006()
Local nPHAWB	:= 0

Default aCabAuto	:= {}

If Len(aCabAuto) > 0
	nPHAWB := aScan(aCabAuto,{|x|Trim(x[1])== "F1_HAWB" })
	If nPHAWB > 0
		If !Empty(aCabAuto[nPHAWB,2])
			lEic := .T.
		Endif
	Endif
Endif

If lDtNT2006 .And. (lEic .Or. lTransFil)
	lRet := .T.
Endif

Return lRet

/*/{Protheus.doc} GetPosSD1
Efetuar o retorno da posição do aHeader do SD1

@Param cCampo		nome do campo

@author Nilton Rodrigues
@since 22/03/2022
@return Nil, indefinido
/*/
Function GetPosSD1(cCampo as character)
	Local nX           as numeric 
	Local nTotaHeader  as numeric 
	Local nPos         as numeric 
	Static _HeaderSD1
	//- verifica se é um SD1 
	If Substr(aHeader[1,2],1,3) == 'D1_'
		nTotaHeader:= Len(aHeader)
		//- Valida o cache se ele existe e se é válido
		If !_HeaderSD1 == nil .and. nTotaHeader <> Len(_HeaderSD1:Getnames())
			_HeaderSD1:fromJson("{}")
			FREEOBJ( _HeaderSD1 )
			_HeaderSD1 := nil 
		EndIF 

		//- Verifica a existencia do cache
		If _HeaderSD1 == nil 
			_HeaderSD1 := JsonObject():New()
			//- efetua a carga do cache pela posição do aHeader
			For nX := 1 to nTotaHeader
				_HeaderSD1[AllTrim(aHeader[nX,2])] := nX
			Next nX 
		EndIf 

		//- checa a existência do campo, sendo nulo ou 0 força mesmo assim 
		//- a pesquisa do registro pelo aScan
		If (nPos := _HeaderSD1[AllTrim(cCampo)]) == nil .or. nPos == 0
			nPos := aScan(aHeader,{|x| AllTrim(x[2]) == cCampo} )
			//- retiro o nulo 
			_HeaderSD1:DelName(AllTrim(cCampo))
		EndIf 
	Else 
		nPos := aScan(aHeader,{|x| AllTrim(x[2]) == cCampo} )
	EndIf 
Return nPos

/*/{Protheus.doc} A103F50NUM
Valida de numeração documento ja existe em duplicatas (SE2)


@author anderson.gomes
@since 22/03/2022
@return Nil, indefinido
/*/

Function A103F50NUM(cSer,cNF,cFor,cLoj)  

Local cQry		:= ""
Local cQryStat	:= ""
Local cAliTmp	:= GetNextAlias()
Local oChkDup	:= FWPreparedStatement():New()
Local lRet		:= .T.

cQry := "SELECT COUNT(E2_FILIAL) TITULOS "
cQry += "  FROM "+RetSqlName("SE2")+" SE2 "
cQry += " WHERE SE2.E2_FILIAL  = ?"
cQry += "   AND SE2.E2_PREFIXO = ?"   
cQry += "   AND SE2.E2_NUM	 = ?"
cQry += "   AND SE2.E2_TIPO	 = ?"
cQry += "   AND SE2.E2_FORNECE = ?"
cQry += "   AND SE2.E2_LOJA	 = ?"
cQry += "   AND SE2.D_E_L_E_T_ = ' ' "
cQry := ChangeQuery(cQry)

oChkDup:SetQuery(cQry) 

oChkDup:SetString(1,xFilial("SE2"))
oChkDup:SetString(2,cSer)
oChkDup:SetString(3,cNF)
oChkDup:SetString(4,MVNOTAFIS)
oChkDup:SetString(5,cFor)
oChkDup:SetString(6,cLoj)

cQryStat := oChkDup:GetFixQuery()
MpSysOpenQuery(cQryStat,cAliTmp) 

If (cAliTmp)->(!EOF()) .And. (cAliTmp)->TITULOS > 0
	Help(" ",1,"FA050NUM")
	lRet := .F.
Endif

(cAliTmp)->(DbCloseArea())

Return lRet

/*/{Protheus.doc} A103CSDXML
	Função que realiza a consolidação da NF para XML. (Projeto lei SEFAZ - AM)

	Parâmetro: MV_CSDXML = .T.
	@nOpc = 1 = Inclusão da consolidação
	@nOpc = 2 = Exclusão da consolidação
	@nOpc = 3 = Abertura de tela no mata103 para digitação de dados.
	@nOpc = 4 = Visualização via outras ações mata103.
@author Leandro Fini
@since 10/08/2022
/*/
Function A103CSDXML(nOpc, cDoc, cSerie, cFornec, cLoja, aColsSD1, aHeaderSD1, oModelCSD)

Local oModelCab
Local oMdlItXML
Local oMdlImp 
Local oMdlItNF
Local oMdlLote
Local nX 			:= 1
Local nY 			:= 1
Local nZ 			:= 1
Local nPosProd  	:= 0
Local nPosItNFE		:= 0
Local nPosItXML		:= 0
Local nPosDesFor	:= 0
Local nPosQtXML		:= 0
Local nPosUM		:= 0
Local nPosVlrUn 	:= 0
Local nPosVlrTot 	:= 0
Local nPosPC 		:= 0
Local nPosItPc 		:= 0
Local nPosLote 		:= 0
Local nPosLotVld	:= 0
Local nPosQtd		:= 0
Local aAux 			:= {}
Local aItensDKA		:= {} //Itens da consolidação NFE x XML
Local aItensDKC 	:= {} //Pedidos e lotes vinculados
Local nPos 			:= 0
Local lRet 			:= .F.
Local nView 		:= 0
Local lInclbkp 		:= INCLUI
Local oMdl	    	:= nil
Local oItDKB		:= Nil
Local aItXML 		:= {}
Local cLog 			:= ""
Local cUmXml		:= ""
Local nQtdXML		:= 0
Local lDocSDT		:= .F.
Local lDkaCSD		:= .F.
Local aButtons    := {  {.F.,Nil},;             //- Copiar
                                         {.F.,Nil},;			//- Recortar
                                         {.F.,Nil},;			//- Colar
                                         {.F.,Nil},;			//- Calculadora
                                         {.F.,Nil},;			//- Spool
                                         {.F.,Nil},;			//- Imprimir
                                         {.T.,STR0254},;     	//- "Confirmar"
                                         {.T.,STR0255},;   		//- "Cancelar"
                                         {.F.,Nil},;			//- WalkThrough
                                         {.F.,Nil},;			//- Ambiente
                                         {.F.,Nil},;			//- Mashup
                                         {.F.,Nil},;			//- Help
                                         {.F.,Nil},;			//- Formulário HTML
                                         {.F.,Nil}}				//- ECM

Default cDoc 	:= ""
Default cSerie 	:= ""
Default cFornec := ""
Default cLoja 	:= ""
Default aColsSD1 	:= {}
Default aHeaderSD1  := {}
Default oModelCSD 	:= nil

//nOpc == 1 --> Inclusão
//nOpc == 2 --> Exclusão
//nOpc == 3 --> Complemento de dados no MATA103
//nOpc == 4 --> Visualização

if nOpc == 1 //Inclusão
	if(oModelCSD <> nil)
		if oModelCSD:IsActive()
			oModelCSD:DeActivate()
		endif
		oModelCSD:Destroy() 
		oModelCSD := nil
	endif
	oModelCSD := FWLoadModel( "MATA103C" )
	oModelCSD:SetOperation( MODEL_OPERATION_INSERT ) 
	oModelCSD:Activate()

	if oModelCSD <> NIL

		nPosProd  	:= GetPosSD1("D1_COD")
		nPosItNFE	:= GetPosSD1("D1_ITEM")
		nPosItXML	:= GetPosSD1("D1_ITXML")
		nPosDesFor 	:= GetPosSD1("D1_DESCFOR")
		nPosQtXML 	:= GetPosSD1("D1_QTDXML")
		nPosUM		:= GetPosSD1("D1_UM")
		nPosVlrUn 	:= GetPosSD1("D1_VUNIT")
		nPosVlrTot 	:= GetPosSD1("D1_TOTAL")
		nPosQtd 	:= GetPosSD1("D1_QUANT")

		if !FwIsInCallStack("MATA910")
			nPosPC 		:= GetPosSD1("D1_PEDIDO")
			nPosItPc 	:= GetPosSD1("D1_ITEMPC")
			nPosLote 	:= GetPosSD1("D1_LOTECTL")
			nPosLotVld 	:= GetPosSD1("D1_DTVALID")
		endif

		oModelCab := oModelCSD:GetModel("DKAMASTER")//Cabeçalho
		oMdlItXML := oModelCSD:GetModel("DKADETAIL")//Itens de consolidação XML
		oMdlImp   := oModelCSD:GetModel("DKBDETAIL")//Impostos dos itens
		oMdlItNF   := oModelCSD:GetModel("DKCDETAIL")//Itens dos pedidos
		oMdlLote  := oModelCSD:GetModel("DKCLOTE")//Itens dos lotes

		oModelCab:SetValue("DKA_DOC", if(cFormul <> "S", cDoc, "Formprop"))
		oModelCab:SetValue("DKA_SERIE", if(cFormul <> "S", cSerie, "0"))
		oModelCab:SetValue("DKA_FORNEC", cFornec)
		oModelCab:SetValue("DKA_LOJA", cLoja)
		
		for nX := 1 to Len(aCols)
			
			if !aCols[nX][Len(aCols[nX])]//Verifica se está deletado

				//Realiza a consolidação de acordo com o item do XML.
				nPos := aScan(aItensDKA, {|x|AllTrim(x[1])== Alltrim(StrZero(Val(aCols[nX][nPosItXML]), TamSX3("D1_ITXML")[1])) })
				if nPos == 0

					aAux := {}
					aAux := {;
							StrZero(Val(aCols[nX][nPosItXML]), TamSX3("D1_ITXML")[1]),; 	//[1] - Item XML
							aCols[nX][nPosProd],; 		//[2] - Produto
							aCols[nX][nPosItNFE] + "|",;//[3] - Item NFE
							aCols[nX][nPosUM],; 		//[4] - Unidade de medida
							aCols[nX][nPosQtd],; 		//[5] - Quantidade SD1
							aCols[nX][nPosVlrTot];		//[6] - Valor Total
						}

					aAdd(aItensDKA,aClone(aAux))
				else
					aItensDKA[nPos][3] += aCols[nX][nPosItNFE] + "|"
					aItensDKA[nPos][5] += aCols[nX][nPosQtd]
					aItensDKA[nPos][6] += aCols[nX][nPosVlrTot]
				endif

				//Atualiza aNfIem com o Item do XML
				MafisAlt("IT_ITEMXML",Alltrim(StrZero(Val(aCols[nX][nPosItXML]), TamSX3("D1_ITXML")[1])),nX)


				aAux := {}
				aAux := {;
							StrZero(Val(aCols[nX][nPosItXML]), TamSX3("D1_ITXML")[1]),; 	//[1] - Item XML
							aCols[nX][nPosItNFE],;	//[2] - Item NFE
							Alltrim(GetAdvFVal("SB1","B1_DESC",fwxFilial("SB1") + aCols[nX][nPosProd] ,1)),;	//[3] - Desc Produto.
							aCols[nX][nPosQtd],;	//[4] - Quantidade
							aCols[nX][nPosVlrUn],;	//[5] - Valor Unitário
							aCols[nX][nPosVlrTot],;	//[6] - Valor Total
							if(nPosPC <> 0,aCols[nX][nPosPC],""),;			//[7] - Pedido de compra
							if(nPosItPc <> 0, aCols[nX][nPosItPc], ""),;	//[8] - Item do pedido
							if(nPosLote <> 0, aCols[nX][nPosLote],""),;		//[9] - Lote
							if(nPosLotVld <> 0, aCols[nX][nPosLotVld], CtoD(""));//[10] - Validade do lote
						}
				
				aAdd(aItensDKC,aClone(aAux))
	
			endif

		next nX

		//Gravação da consolidação dos itens XML.
		for nY := 1 to Len(aItensDKA)
			
			if nY > 1
				oMdlItXML:AddLine()
			endif

			oMdlItXML:SetValue("DKA_FILIAL" , fwxFilial("DKA"))
			oMdlItXML:SetValue("DKA_DOC"	, if(cFormul <> "S", cDoc, "Formprop"))
			oMdlItXML:SetValue("DKA_SERIE"	, if(cFormul <> "S", cSerie, "0"))
			oMdlItXML:SetValue("DKA_FORNEC"	, cFornec)
			oMdlItXML:SetValue("DKA_LOJA"	, cLoja)
			oMdlItXML:SetValue("DKA_ITXML"	, aItensDKA[nY][1])
			oMdlItXML:SetValue("DKA_PRODUT"	, aItensDKA[nY][2])
			oMdlItXML:SetValue("DKA_DESCFO"	, DescPrFor(cDoc, cSerie, cFornec, cLoja, Alltrim(aItensDKA[nY][2])))

			//Verifica se documento é originado do Totvs Colaboração / Importador XML
			lDocSDT := !COLFINSDS(1,oMdlItXML:GetValue("DKA_DOC") + oMdlItXML:GetValue("DKA_SERIE") + oMdlItXML:GetValue("DKA_FORNEC") + oMdlItXML:GetValue("DKA_LOJA"))

			If lDocSDT //Busca informação nos itens do documento do Totvs Colaboração / Importador XML
				cUmXml  := GetAdvFVal("SDT","DT_UMXML" ,fwxFilial("SDT") + oMdlItXML:GetValue("DKA_FORNEC") + oMdlItXML:GetValue("DKA_LOJA") + oMdlItXML:GetValue("DKA_DOC") + oMdlItXML:GetValue("DKA_SERIE") + oMdlItXML:GetValue("DKA_PRODUT"),3)
				nQtdXML := A103CSDQTD(oMdlItXML:GetValue("DKA_FORNEC"),oMdlItXML:GetValue("DKA_LOJA"),oMdlItXML:GetValue("DKA_DOC"),oMdlItXML:GetValue("DKA_SERIE"),oMdlItXML:GetValue("DKA_PRODUT"),aItensDKA[nY][1])
			Endif

			If Empty(cUmXml) //Busca informação na amarração produto x fornecedor
				cUmXml := GetAdvFVal("SA5","A5_UNID",fwxFilial("SA5") + cFornec + cLoja + Alltrim(aItensDKA[nY][2])  ,1)//Unidade de medida do fornecedor - Produto x Fornecedor
			Endif

			oMdlItXML:SetValue("DKA_UMXML"	, cUmXml)
			oMdlItXML:SetValue("DKA_ITEMNF"	, aItensDKA[nY][3])
			oMdlItXML:SetValue("DKA_UM"		, Alltrim(aItensDKA[nY][4]))
			oMdlItXML:SetValue("DKA_QUANT"	, aItensDKA[nY][5])
			oMdlItXML:SetValue("DKA_VLRTOT"	, aItensDKA[nY][6])

			If !Empty(cUmXml) 
				If Alltrim(aItensDKA[nY][4]) == AllTrim(cUmXml) //Se UM do Produto igual do (Colab/Importador ou Amarração Prod x Fornecedor)
					oMdlItXML:SetValue("DKA_QTDXML"	, aItensDKA[nY][5])
					oMdlItXML:SetValue("DKA_FATOR"	, 1)
				Elseif nQtdXML > 0 //Se DOC é do Colab/Importador
					oMdlItXML:SetValue("DKA_QTDXML", nQtdXML) 
				Endif
			Endif

			if type("aAutoCSD") == "A" .and. Len(aAutoCSD) > 0
				nPos := aScan(aAutoCSD, {|x|AllTrim(x[1,2])== aItensDKA[nY][1] })
				if nPos > 0
					for nZ := 1 to len(aAutoCSD[nPos])
						if DKA->(fieldPos( aAutoCSD[nPos][nZ][1] )) > 0
							oMdlItXML:SetValue(aAutoCSD[nPos][nZ][1]	,aAutoCSD[nPos][nZ][2])
						endif
					next nZ
				endif
			endif

		next nY

		// FUNÇÃO RETORNARÁ .JSON COM TRIBUTOS AGRUPADOS POR ITEM DE XML
		oItDKB := MaFisAgrIt()  
		//Estrutura do objeto: 01- Base, 02- Aliquota,03- Valor Tributo, 04- Referencia do Tributo, 05- Descrição do Tributo, 06- Item do XML

		if oItDKB <> nil
			aItXML := oItDKB:GetNames()
			for nY := 1 to Len(aItXML)
				//Posiciono na linha da DKA correspondente.
				if oMdlItXML:SeekLine( {{"DKA_ITXML", aItXML[nY] }} )
					for nZ := 1 to Len(oItDKB[aItXML[nY]])
						if nZ > 1 .and. !empty(oMdlImp:GetValue("DKB_IDTRIB"))
							oMdlImp:AddLine()
						endif
						if !empty(oItDKB[aItXML[nY]][nZ][4])
							oMdlImp:SetValue("DKB_IDTRIB", oItDKB[aItXML[nY]][nZ][4])
							oMdlImp:SetValue("DKB_DESCTR", oItDKB[aItXML[nY]][nZ][5])
							oMdlImp:SetValue("DKB_BASTRI", oItDKB[aItXML[nY]][nZ][1])
							oMdlImp:SetValue("DKB_ALQTRI", oItDKB[aItXML[nY]][nZ][2])
							oMdlImp:SetValue("DKB_VLRTRI", oItDKB[aItXML[nY]][nZ][3])
						endif
					next nZ
				endif
			next nY
		endif

		//Gravação dos pedidos e lotes
		for nY := 1 to Len(aItensDKC)

			//Posiciono na linha da DKA correspondente.
			if oMdlItXML:SeekLine( {{"DKA_ITXML", aItensDKC[nY][1] }} )

				if nY > 1 .and. !empty(oMdlItNF:GetValue("DKC_ITEMNF"))
					oMdlItNF:AddLine() 
				endif

				oMdlItNF:SetValue("DKC_ITEMNF"	, aItensDKC[nY][2])
				oMdlItNF:SetValue("DKC_DESCPR"	, aItensDKC[nY][3])
				oMdlItNF:SetValue("DKC_QUANT"	, aItensDKC[nY][4])
				oMdlItNF:SetValue("DKC_VUNIT"	, aItensDKC[nY][5])
				oMdlItNF:SetValue("DKC_VLRTOT"	, aItensDKC[nY][6])		
				oMdlItNF:SetValue("DKC_PEDIDO"	, aItensDKC[nY][7])
				oMdlItNF:SetValue("DKC_ITPED"	, aItensDKC[nY][8])
				oMdlItNF:SetValue("DKC_LOTE"	, aItensDKC[nY][9]) 
				oMdlItNF:SetValue("DKC_DTVLD"	, aItensDKC[nY][10]) 
			
			endif

		next nY

		if oModelCSD:VldData()
			lRet := .T.
			oMdlItXML:SetLine(1)
			oMdlImp:SetLine(1)
			oMdlItNF:SetLine(1)
			if isBlind() .and. type("aAutoCSD") == "A" .and. Len(aAutoCSD) > 0
				oMdlCSDGRV := oModelCSD
			endif
		else
			lRet := .F.
			cLog := cValToChar(oModelCSD:GetErrorMessage()[4]) + ' - '
			cLog += cValToChar(oModelCSD:GetErrorMessage()[5]) + ' - '
			cLog += cValToChar(oModelCSD:GetErrorMessage()[6])        	
			Help( ,,"103CSDXML",,cLog, 1, 0 )
		endif

		//Restauro a variável inclui pois o MVC altera o conteúdo.
		INCLUI := if(ValType(lInclbkp)=="L",lInclbkp,!l103Class)

	endif

elseif nOpc == 2//Exclusão

	DbSelectArea("DKA")
	DKA->(DbSetOrder(1))//DKA_FILIAL+DKA_DOC+DKA_SERIE+DKA_FORNEC+DKA_LOJA

	if DKA->(MsSeek(fwxFilial("DKA") + cDoc + cSerie + cFornec + cLoja))
		oMdl := FWLoadModel( "MATA103C" )
		oMdl:SetOperation( MODEL_OPERATION_DELETE ) 
		oMdl:Activate()

		if oMdl <> NIL
			if oMdl:VldData()
				oMdl:CommitData()
				lRet := .T.
			endif

			oMdl:DeActivate()
			oMdl:Destroy()
		endif

	endif
elseif nOpc == 3//Edição de dados após inclusão MATA103
	
	if oModelCSD:IsActive()
	
		oModelCab := oModelCSD:GetModel("DKAMASTER")//Cabeçalho
		oMdlItXML := oModelCSD:GetModel("DKADETAIL")//Itens de consolidação XML
		oMdlImp	  := oModelCSD:GetModel("DKBDETAIL")//Impostos
		oMdlItNF   := oModelCSD:GetModel("DKCDETAIL")//Itens da NF

		if type("lGrvCSD") == "L"
			lGrvCSD := .F.
		endif

		oMdlItXML:SetNoInsertLine(.T.)
		oMdlItXML:SetNoDeleteLine(.T.)

		oMdlItNF:SetNoInsertLine(.T.)
		oMdlItNF:SetNoDeleteLine(.T.)

		oMdlImp:SetNoInsertLine(.T.)
		oMdlImp:SetNoDeleteLine(.T.)

		oModelCab:GetStruct():SetProperty("*",MODEL_FIELD_WHEN,{||.F.})
		oMdlItXML:GetStruct():SetProperty("*",MODEL_FIELD_WHEN,{||.F.})
		oMdlItNF:GetStruct():SetProperty("*",MODEL_FIELD_WHEN,{||.F.})
		oMdlImp:GetStruct():SetProperty("*",MODEL_FIELD_WHEN,{||.F.})

		oModelCab:GetStruct():SetProperty("*",MVC_VIEW_CANCHANGE, .F.)
		oMdlItXML:GetStruct():SetProperty("*",MVC_VIEW_CANCHANGE, .F.)
		oMdlItNF:GetStruct():SetProperty("*",MVC_VIEW_CANCHANGE, .F.)
		oMdlImp:GetStruct():SetProperty("*",MVC_VIEW_CANCHANGE, .F.)

		//Habilito somente os campos de Descrição do fornecedor, Unidade de medida e quantidade do XML.
		oMdlItXML:GetStruct():SetProperty("DKA_DESCFO",MVC_VIEW_CANCHANGE, .T.)
		oMdlItXML:GetStruct():SetProperty("DKA_UMXML",MVC_VIEW_CANCHANGE, .T.)
		oMdlItXML:GetStruct():SetProperty("DKA_QTDXML",MVC_VIEW_CANCHANGE, .T.)
		oMdlItXML:GetStruct():SetProperty("DKA_FATOR",MVC_VIEW_CANCHANGE, .T.)
		oMdlItXML:GetStruct():SetProperty("DKA_DESCFO",MODEL_FIELD_WHEN,{||.T.})
		oMdlItXML:GetStruct():SetProperty("DKA_UMXML",MODEL_FIELD_WHEN,{||.T.})
		oMdlItXML:GetStruct():SetProperty("DKA_QTDXML",MODEL_FIELD_WHEN,{||.T.})
		oMdlItXML:GetStruct():SetProperty("DKA_FATOR",MODEL_FIELD_WHEN,{||.F.})

		oMdlItXML:GetStruct():SetProperty( "*", MODEL_FIELD_OBRIGAT, .T. )
		if ( oMdlItXML:HasField("DKA_CSDXML") )
			oMdlItXML:GetStruct():SetProperty( "DKA_CSDXML", MODEL_FIELD_OBRIGAT, .F. )
		endif
	endif

	//"Consolidação NF x XML"
	nView := FWExecView(STR0234,"VIEWDEF.MATA103C",MODEL_OPERATION_VIEW,/*oDlg*/,/*bCloseOnOk*/,{|| setOK() }/*bOk*/,0,aButtons,/*bCancel*/,/*cOperationId*/,/*cToolBar*/,oModelCSD)
	if nView == 0
		if !isBlind()
			lRet := MsgYesNo(STR0233)//"Confirmar gravação dos dados da NF e consolidados?"
		endif
	else 
		lRet := .F. //usuário clicou em cancelar.
	endif

	//Restauro a variável inclui pois o MVC altera o conteúdo.
	INCLUI := if(ValType(lInclbkp)=="L",lInclbkp,!l103Class)

elseif nOpc == 4//Visualização

	DbSelectArea("DKA")
	DKA->(DbSetOrder(1))//DKA_FILIAL+DKA_DOC+DKA_SERIE+DKA_FORNEC+DKA_LOJA
	lDkaCSD := DKA->(FieldPos("DKA_CSDXML")) > 0
	if DKA->(MsSeek(fwxFilial("DKA") + SF1->(F1_DOC+F1_SERIE+F1_FORNECE+F1_LOJA))) .and. ( ( lDkaCSD .and. (empty(DKA->DKA_CSDXML) .or. DKA->DKA_CSDXML == "1") ) .or. !lDkaCSD ) 
		FWExecView(STR0232,"VIEWDEF.MATA103C",MODEL_OPERATION_VIEW,/*oDlg*/,/*bCloseOnOk*/,/*bOk*/,0,aButtons,/*bCancel*/,/*cOperationId*/,/*cToolBar*/,)//"Visualização - Consolidação NF x XML"
	else 
		Help(" ",1,'A103CSDXML',,STR0231,1,0)//"Não há consolidação vinculada a este documento."
	endif

endif

Return lRet

/*/{Protheus.doc} setOK
	Função acionada ao clicar em confirmar na edição de dados
	da consolidação do XML
	@lGrvCSD = controla a gravação dos dados.
@author Leandro Fini
@since 10/08/2022
/*/
Static Function setOK()

Local oModel 	:= FwModelActive()
Local oModelDKA := oModel:GetModel("DKADETAIL")
Local lRet 		:= .T.
Local cDescFo 	:= ""

	if oModelDKA <> nil 
		lRet := A103CPosDKA(oModelDKA)
		if !lRet
			Help(" ",1,'A103CSDXML',,STR0230,1,0)//"Os campos Qtd XML (DKA_QTDXML) e/ou Fator de conversão (DKA_FATOR) estão em branco."
		endif
	endif

	//Controle de gravação para realizar a cópia do modelo.
	if type("lGrvCSD") == "L"
		lGrvCSD := .T.
	endif

	//Quando não há edição no formulario (model), 'tudook' não esta sendo chamado pelo MVC
	//Alteração forçada para que 'tudook' passe a ser executado.
	cDescFo := oModelDKA:GetValue("DKA_DESCFO")
	oModelDKA:SetValue("DKA_DESCFO","")
	oModelDKA:SetValue("DKA_DESCFO",cDescFo)
Return lRet

/*/{Protheus.doc} A103ItXml
	Função que retorna o item do XML
	utilizado ao visualizar ou classificar
	documento de entrada.

	@cItem = Item da NF
	@cProd = Código do produto
	@lTColab = NF proveniente do TOTVS Colaboração.
@author Leandro Fini
@since 10/08/2022
/*/
Function A103ItXml(cItem,cProd,lTColab)

Local cRet 	   := ""
Local cAliasDKC := GetNextAlias()
Local cQuery    := ""

Default cItem  	:= ""
Default cProd  	:= ""
Default lTColab := .F.

if !lTColab

	cQuery := "SELECT DKC_ITXML FROM " + RetSqlName("DKC")
	cQuery += " WHERE DKC_FILIAL  = '" + fwxFilial("DKC") + "'"
	cQuery += " AND DKC_DOC = '" + SF1->F1_DOC + "'"
	cQuery += " AND DKC_SERIE = '" + SF1->F1_SERIE + "'"
	cQuery += " AND DKC_FORNEC = '" + SF1->F1_FORNECE + "'"
	cQuery += " AND DKC_LOJA = '" + SF1->F1_LOJA + "'"
	cQuery += " AND DKC_ITEMNF = '" + cItem + "'"
	cQuery += " AND D_E_L_E_T_ = ' '"

	cQuery := ChangeQuery(cQuery)

	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasDKC,.T.,.T.)

	If (cAliasDKC)->(!Eof())
		cRet := (cAliasDKC)->DKC_ITXML
	Endif
		
	(cAliasDKC)->(DbCloseArea())

else
	DbSelectArea("SDT")
	SDT->(DbSetOrder(3))//DT_FILIAL+DT_DOC+DT_SERIE+DT_FORNEC+DT_LOJA+DT_COD
	if SDT->(MsSeek(fwxFilial("SDT") + SF1->(F1_FORNECE+F1_LOJA+F1_DOC+F1_SERIE+cProd)))
		cRet := SDT->DT_ITXML
	endif
endif

Return cRet

/*/{Protheus.doc} DescPrFor
	Função para retornar a descrição do produto no fornecedor.
	Seja do produto x fornecedor, seja do Totvs colaboração.
@author Leandro Fini
@since 10/08/2022
/*/
Static Function DescPrFor(cDoc, cSerie, cFornec, cLoja, cProd)

Local cRet := ""

Default cFornec := ""
Default cLoja 	:= ""
Default cDoc 	:= ""
Default cSerie 	:= ""
Default cProd 	:= ""

cRet := GetAdvFVal("SDT","DT_DESCFOR",fwxFilial("SDT") + cFornec + cLoja + cDoc + cSerie + cProd  ,3)

if empty(cRet)
	cRet := GetAdvFVal("SA5","A5_DESCPRF",fwxFilial("SA5") + cFornec + cLoja + cProd  ,1)
endif

Return cRet

/*/{Protheus.doc} A103TEMNF
Valida se existe NF com a numeração informada

@author anderson.gomes
@since 17/11/2022
@return Nil, indefinido
/*/

Function A103TEMNF( cNF, cSer, cFor, cLoj, cForm )
	Local cQry		:= ""
	Local cQryStat	:= ""
	Local cAliTmp	:= GetNextAlias()
	Local oChkNf	:= FWPreparedStatement():New()
	Local lRet		:= .F.
	Local lFormul   := SuperGetMV("MV_FORMDOC",.F.,.F.)

	cQry := "SELECT COUNT(F1_DOC) DOCS "
	cQry += "  FROM " + RetSqlName("SF1") + " SF1 "
	cQry += " WHERE SF1.F1_FILIAL  = ?"
	cQry += "   AND SF1.F1_DOC = ?"   
	cQry += "   AND SF1.F1_SERIE = ?"
	cQry += "   AND SF1.F1_FORNECE = ?"
	cQry += "   AND SF1.F1_LOJA = ?"
		cQry += "   AND SF1.D_E_L_E_T_ = ?"
		
		if lFormul 
			cQry += "   AND SF1.F1_FORMUL IN (?)"
		endif 

	cQry := ChangeQuery(cQry)

	oChkNf:SetQuery(cQry) 

	oChkNf:SetString( 1, FWxFilial("SF1") )
	oChkNf:SetString( 2,   cNF )
	oChkNf:SetString( 3,  cSer )
	oChkNf:SetString( 4,  cFor )
	oChkNf:SetString( 5,  cLoj )
	oChkNf:SetString( 6,   ' ' )
	
	if lFormul
		oChkNf:SetIn( 7, Iif(cForm == "N" .Or. Empty(cForm),{cForm,' '},{cForm}))
	endif
	
	cQryStat := oChkNf:GetFixQuery()
	MpSysOpenQuery( cQryStat, cAliTmp ) 

	If (cAliTmp)->(!EoF()) .And. (cAliTmp)->DOCS > 0
		lRet := .T.
	Endif

	(cAliTmp)->(DbCloseArea())

Return lRet

/*/{Protheus.doc} A103ChSGO
Valida a existencia de campos na SGO
@author nilton.mioshi
@return lRet
/*/

Static Function A103ChSGO ()
Local aCpoSGO   := {}
Local lRet		:= .T.

If FindFunction('A103EChSGO')
	lRet:= A103EChSGO()
Else
	aCpoSGO   := FWSX3Util():GetAllFields('SGO',.f.)
	If Ascan (aCpoSGO,{|x|AllTrim(x) == "GO_LOTECTL"}) = 0 .or. ;
	   Ascan (aCpoSGO,{|x|AllTrim(x) == "GO_NUMLOTE"}) = 0 .or. ;
	   Ascan (aCpoSGO,{|x|AllTrim(x) == "GO_ORDEM"}) = 0 .or. ;
	   Ascan (aCpoSGO,{|x|AllTrim(x) == "GO_OPORIG"}) = 0 .or. ;
	   Ascan (aCpoSGO,{|x|AllTrim(x) == "GO_SEQ"}) = 0 	
	   lRet := .F.
	Endif
EndIf

Return lRet


 /*/{Protheus.doc} A103VSpec
	(Valida especie caso MV_ESPOBG esteja .T.)
	@type  Function
	@author Thiago Rodrigues
	@since 03/06/2024
	@version version
	@see (links_or_references)
	/*/
static Function A103VSpec()
Local lEspObg := SuperGetMV("MV_ESPOBG",.F.,.F.)
local lRet    := .T.

if lEspObg .and. Empty(cEspecie)
	Help("nil", nil , "A100FALTA", nil, STR0240, 1, 0, nil, nil, nil, nil, nil, {STR0241} ) //"O preenchimento da espécie é obrigatório devido à utilização do parâmetro: MV_ESPOBG. Informe a espécie para continuar."
	lRet := .F.
endif

Return lRet

/*/{Protheus.doc} A103CONNFS
Função para consultar a chave NFs.	
@author Guilherme Futro
@since 03/04/2024
@return lRet 
/*/

Function A103CONNFS(cVarChvNfs As Character) As Logical 

Local lRet	   As Logical 
Local lConsNFs As Logical

Local cUrl      As Character
Local cEspValid As Character
Local cIdEnt    As Character
Local cChvNFS   As Character
Local cMsgRet   As Character 

Private oWS As Object

Default cVarChvNfs	:= ""

lConsNFs  	:= SuperGetMV( "MV_CHVNFS" ,.F.,.F.) //Consulta Chave NFs 
lRet		:= .T. 
cEspValid 	:= "|NFS|NFSE|NFSC|NFST|" 
cUrl      	:= PadR(GetNewPar("MV_SPEDURL","http://"),250)
cIdEnt    	:= ""
cChvNFS   	:= ""
cMsgRet 	:= ""
oWS	  		:= Nil 


If	(lConsNFs .And. cFormul == "N" .And. ( "|" + AllTrim(cEspecie) + "|" $ cEspValid ) ) 
	
	If !Empty(cVarChvNfs)
		cChvNFS := cVarChvNfs
	EndIF

	if Len(Alltrim(cChvNFS)) == 50
		
		If IsReady(cUrl)

			//Obtem o codigo da entidade
			If FindFunction("getCfgEntidade") 
				cIdEnt := getCfgEntidade()
			EndIf

			oWS := WsNFSE001():New()
			oWS:cUSERTOKEN		:= "TOTVS"
			oWS:cID_ENT			:= cIdEnt
			oWS:_URL			:= AllTrim(cUrl)+"/NFSE001.apw"
			oWs:CHVNFSE			 := cChvNFS

			If ExecWSRet(oWS,"CONSCHVNFSE001")
				
				cMsgRet := Upper(AllTrim(oWS:OWSCONSCHVNFSE001RESULT:MSGRETNFE))
				
				if "REJEI" $ Upper(cMsgRet)
					Help(" ",1,"A103CONSNFS",,cMsgRet,4,4)	
					lRet := .F.
				endif
			else 
				cMsgRet := GetWscError(3)
				Help(" ",1,"A103CONSNFS",,cMsgRet,1,1)
				lRet:= .F.
			endif 	 
		else 
			Help(" ",1,"A103CONSNFS",,"TSS INATIVO",1,1)
			lRet := .F.
		endif
	endif 		
endif 


Return  lRet

 /*/{Protheus.doc} ATriGenCol
	(Atualiza os tributos genéricos
	utilizado pelo totvs colaboração)
	@type  Function
	@author Thiago Rodrigues
	@since 03/06/2024
	@see (links_or_references)
	/*/
Static Function ATriGenCol(nItem)
Local nPosBicm     := GetPosSD1("D1_BASEICM")
Local nPosPicm     := GetPosSD1("D1_PICM")
Local nPosVicm     := GetPosSD1("D1_VALICM")
Local nPosBipi     := GetPosSD1("D1_BASEIPI")
Local nPosIpi      := GetPosSD1("D1_IPI")
Local nPosVipi     := GetPosSD1("D1_VALIPI")

Default nItem := 1

aCols[nItem,nPosBicm] := MaFisRet(nItem,"IT_BASEICM")
aCols[nItem,nPosPicm] := MaFisRet(nItem,"IT_ALIQICM")
aCols[nItem,nPosVicm] := MaFisRet(nItem,"IT_VALICM")
aCols[nItem,nPosBipi] := MaFisRet(nItem,"IT_BASEIPI")
aCols[nItem,nPosIpi]  := MaFisRet(nItem,"IT_ALIQIPI")
aCols[nItem,nPosVipi] := MaFisRet(nItem,"IT_VALIPI")

return 

/*/{Protheus.doc} A103SNFSTra
	Avaliação de deve gerar numeração automatica quando
	documento for NFS (Atender NFSe Nacional)
	
	@type  Function
	@author rodrigo.mpontes 
	@since 03/06/2024
	@see (links_or_references)
/*/

Static Function A103SNFSTra(aObjetos,bWhenBkpDoc,lClassif) 

Local nTamF1Doc		:= TamSX3("F1_DOC")[1]
Local lNFsNumAut	:= SuperGetMv("MV_NFSNAUT",.F.,.F.) 

If !lClassif .And. lNFsNumAut .And. FwIsInCallStack("MATA103")
	If cFormul == "N" .And. !(Alltrim(cEspecie) $ "NFS|NFSE|NFSC|NFST")
		If SubStr(cNFiscal,1,1) == "T"	
			cNFiscal 	:= Space(TamSX3("F1_DOC")[1])
		Endif
		aObjetos[3]:bWhen := bWhenBkpDoc
	Elseif cFormul == "N" .And. Alltrim(cEspecie) $ "NFS|NFSE|NFSC|NFST"
		If MsgYesNo(STR0259 + AllTrim(Str(nTamF1Doc)) + STR0262 + " ?" + CRLF + CRLF + ; //"A numeração dessa Nota Fiscal de Serviço será maior que "
					STR0260 + CRLF + CRLF +; //"Se sim, preencher o campo 'Numero NF Eletr' na aba 'Nota Fiscal Eletrônica' com a numeração da Nota Fiscal de Serviço."
					STR0261) //"A Numeração do documento (cabeçalho) sera feita de forma automatica ao 'Salvar' o Documento de Entrada"
			cNFiscal 	:= "TOTVSAUTO"
			aObjetos[3]:bWhen := {|| .F.} 
		Else
			If SubStr(cNFiscal,1,1) == "T"
				cNFiscal 	:= Space(TamSX3("F1_DOC")[1])
			Endif  
			aObjetos[3]:bWhen := bWhenBkpDoc 
		Endif
	Endif 
Endif

Return .T.

/*/{Protheus.doc} A103CTESUB
Função para inclusão de uma CT-e Substituto
@author rodrigo.mpontes
@since 03/04/2024
@return lRet 
/*/

Function A103CTESUB()

Local lRet			:= .T.
Local oQry			:= Nil
Local cQuery		:= ""
Local aForm			:= {"Não","Sim"}
Local cForm			:= ""
Local cNDoc			:= Space(TamSX3("F1_DOC")[1])
Local cNSer			:= Space(TamSX3("F1_SERIE")[1])
Local dDTEmissao	:= dDatabase
Local aHeaderAux	:= {}
Local aColsAux		:= {} 
Local nOrder		:= 1
Local nOpc			:= 0
Local nI			:= 0
Local nY			:= 0
Local aCabec		:= {}
Local aItem			:= {}
Local aItens		:= {}
Local aNoFields		:= {"D1_DOC","D1_SERIE","D1_EMISSAO","D1_DTDIGIT","D1_MSUIDT","D1_ALI_WT","D1_REC_WT"} 

Private lMsErroAuto := .F.
Private lMsHelpAuto := .F. 
Private dDEmissao	:= Date()
Private cFormul		:= ""
Private cEspecie	:= SF1->F1_ESPECIE
Private cSerie		:= ""
Private cA100For	:= SF1->F1_FORNECE
Private cLoja		:= SF1->F1_LOJA 

If AllTrim(SF1->F1_STATUS) <> "E" 
	Help(" ",1,"A103CTESUB",,STR0246,1,1,,,,,, {STR0247}) //"CT-e não esta em desacordo" # "Para realizar a substituição, realize primeiro o evento de desacordo."
	lRet := .F.
Endif

//Verifica se ja foi gerado alguma CTe Substituto, para não gerar em duplicidade.
If lRet
	//Apaga SF8 CTe Substituido (Queda conexão)
	A103SubDelSF8() 

	lRet := !A103IsCTeSub("I",SF1->F1_DOC,SF1->F1_SERIE,SF1->F1_FORNECE,SF1->F1_LOJA)
	If !lRet
		Help(" ",1,"A103CTESUBDUP",,STR0248,1,1,,,,,, {STR0249}) //"CT-e já possui um CT-e Substituto" # "Excluir CT-e substituto para poder gerar novo"
	Endif
Endif

If lRet
	
	DEFINE MSDIALOG oDlgCTeSub FROM 100,100 TO 280,550 TITLE STR0250 Of oMainWnd PIXEL //"CTe Substituto"

		oForm  := TSay():New(07,05,{|| STR0251},oDlgCTeSub,,,,,,.T.) //"Form. Proprio: "
		oCForm := TComboBox():New(05,55,{|u|if(PCount()>0,cForm:=u,cForm)},aForm,50,10,oDlgCTeSub,,{|| A103ChgCteSub(cForm,oGNDoc,oGNSer)},,,,.T.,,,,,,,,,'cForm')

		oNDoc  := TSay():New(20,05,{|| STR0252},oDlgCTeSub,,,,,,.T.) //"Documento: "
		oGNDoc := TGet():New(20,55, {|u| If(PCount() == 0, cNDoc, cNDoc:= u )},oDlgCTeSub,50,10,"@!",,,,,.F.,,.T.,,.F.,,.F.,.F.,,.F.,.F. ,,"cNDoc")

		oNSer  := TSay():New(35,05,{|| STR0253},oDlgCTeSub,,,,,,.T.) //"Serie: "
		oGNSer := TGet():New(35,55, {|u| If(PCount() == 0, cNSer, cNSer:= u )},oDlgCTeSub,30,10,"@!",,,,,.F.,,.T.,,.F.,,.F.,.F.,,.F.,.F. ,,"cNSer")

		oDtEmis:= TSay():New(07,110,{|| STR0278},oDlgCTeSub,,,,,,.T.) //"Data Emissão: "
		oGDtEm := TGet():New(05,160, {|u| If(PCount() == 0, dDTEmissao, dDTEmissao:= u )},oDlgCTeSub,50,10,"@D",,,,,.F.,,.T.,,.F.,,.F.,.F.,,.F.,.F. ,,"dDTEmissao")

		oTConf := TButton():New(65,05, STR0254,oDlgCTeSub,{|| Iif(!A103IsCTeSub("D",cNDoc,cNSer,SF1->F1_FORNECE,SF1->F1_LOJA),(nOpc:=1,lMsHelpAuto := .T.,oDlgCTeSub:End()),nOpc:=0)}, 40,10,,,.F.,.T.,.F.,,.F.,,,.F. )  //"Confirmar"
		oTCanc := TButton():New(65,50, STR0255,oDlgCTeSub,{||(nOpc:=0,oDlgCTeSub:End())}, 40,10,,,.F.,.T.,.F.,,.F.,,,.F. ) //"Cancelar"

	ACTIVATE MSDIALOG oDlgCTeSub CENTERED 

	If nOpc == 1
		//Busca pelos itens do CTe a ser substituido
		cQuery    := "SELECT SD1.*,SD1.R_E_C_N_O_ SD1RECNO, B1_GRUPO,B1_CODITE,B1_TE,B1_COD "
		cQuery    += "  FROM "+RetSqlName("SD1")+" SD1, "
		cQuery    += RetSqlName("SB1")+" SB1 "
		cQuery    += " WHERE SD1.D1_FILIAL	= ?"
		cQuery    += "   AND SD1.D1_DOC		= ?"
		cQuery    += "   AND SD1.D1_SERIE	= ?"
		cQuery    += "   AND SD1.D1_FORNECE	= ?"
		cQuery    += "   AND SD1.D1_LOJA	= ?"
		cQuery    += "   AND SD1.D1_TIPO	= ?"
		
		If SF1->F1_FORMUL == "S"
			cQuery    += "   AND SD1.D1_FORMUL	= ?"
		Else
			cQuery    += "   AND SD1.D1_FORMUL	in (?)"
		Endif
		
		cQuery    += "   AND SD1.D_E_L_E_T_	= ?"
		cQuery    += "   AND SB1.B1_FILIAL  = ?"
		cQuery    += "   AND SB1.B1_COD 	= SD1.D1_COD "
		cQuery    += "   AND SB1.D_E_L_E_T_ =' ' "

		cQuery    += "ORDER BY "+SqlOrder( "D1_FILIAL+D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA+D1_ITEM+D1_COD" )

		oQry := FWPreparedStatement():New()
		nOrder := 1
		oQry:SetQuery(cQuery)
		
		oQry:SetString(nOrder++,xFilial("SD1"))
		oQry:SetString(nOrder++,SF1->F1_DOC)
		oQry:SetString(nOrder++,SF1->F1_SERIE)
		oQry:SetString(nOrder++,SF1->F1_FORNECE)
		oQry:SetString(nOrder++,SF1->F1_LOJA)
		oQry:SetString(nOrder++,SF1->F1_TIPO)
		if SF1->F1_FORMUL == "S"
			oQry:SetString(nOrder++,SF1->F1_FORMUL)
		Else
			oQry:SetIn(nOrder++,{SF1->F1_FORMUL," "})
		Endif
		oQry:SetString(nOrder++,Space(1))
		oQry:SetString(nOrder++,xFilial("SB1"))

		cQuery := oQry:GetFixQuery()

		FillGetDados(4,"SD1",1,/*cSeek*/,/*{|| &cWhile }*/,{||.T.},aNoFields,/*aYesFields*/,/*lOnlyYes*/,cQuery,,.F.,aHeaderAux,aColsAux,/*bAfterCols*/,/*bbeforeCols*/,/*bAfterHeader*/,/*cAliasQry*/)

		If Len(aColsAux) > 0
			If _oPosCpoHdr == Nil
				_oPosCpoHdr := JsonObject():New()
				For nI := 1 to Len(aHeaderAux)
					_oPosCpoHdr[aHeaderAux[nI,2]] := GdFieldPos(aHeaderAux[nI,2],aHeaderAux)
				Next nI 
			Endif

			For nI := 1 To Len(aColsAux)
				aItem := {}
				For nY := 1 To Len(aHeaderAux)
					nPos := _oPosCpoHdr[aHeaderAux[nY,2]]
					If nPos > 0 .And. !Empty(aColsAux[nI,nPos])
						aadd(aItem,{aHeaderAux[nY,2] ,aColsAux[nI,nPos] ,NIL})
					Endif 
				Next nY
				aAdd(aItens,aItem)

				nPos := _oPosCpoHdr["D1_REC_WT"]
				If nPos > 0 .And. !Empty(aColsAux[nI,nPos])
					aAdd(aAutoImp, {'IT_RECORI', aColsAux[nI,nPos], nI})  
				Endif
			Next nI
		Endif

		If cForm == "Sim"
			aCols := aClone(aColsAux) 
			cFormul := "S"
			NfeNextDoc(@cNDoc,@cNSer,.T.,"") 
		Endif

		aadd(aCabec,{"F1_TIPO"   		,SF1->F1_TIPO		,NIL})

		If SF1->F1_TIPO == "C"
			aadd(aCabec,{"F1_TPCOMPL"		,SF1->F1_TPCOMPL	,NIL})
		Endif

		aadd(aCabec,{"F1_FORMUL"  		,Iif(cForm=="Não","N","S")	,NIL})
		aadd(aCabec,{"F1_DOC"			,cNDoc				,NIL})
		aadd(aCabec,{"F1_SERIE"  		,cNSer				,NIL})
		aadd(aCabec,{"F1_FORNECE"		,SF1->F1_FORNECE	,NIL})
		aadd(aCabec,{"F1_LOJA"   		,SF1->F1_LOJA  		,NIL})
		aadd(aCabec,{"F1_EMISSAO"		,Iif(!Empty(dDTEmissao),dDTEmissao,dDataBase),NIL})
		aadd(aCabec,{"F1_DTDIGIT"		,dDataBase			,NIL})
		aadd(aCabec,{"F1_ESPECIE"		,SF1->F1_ESPECIE	,NIL})
		aadd(aCabec,{"F1_COND"			,SF1->F1_COND		,NIL})
		aadd(aCabec,{"F1_EST"			,SF1->F1_EST		,NIL})
		
		If Len(aCabec) > 0 .And. Len(aItens) > 0
			MSExecAuto({|x,y,z,a,b,c| MATA103(x,y,z,a,b,,,,,,,,,,,,,c)},aCabec,aItens,3,.T.,aAutoImp,.T.) 
		Endif
	Endif
	
	_oPosCpoHdr := Nil

Endif

Return lRet

/*/{Protheus.doc} A103ChgCteSub
Função para atualização de numeração do CT-e Substituto

@param	cForm	Se formulario proprio é Sim ou Não
@param	oGNDoc	Objeto do numero do documento
@param	oGNSer	Objeto da serie do documento

@author rodrigo.mpontes
@since 03/04/2024
@return lRet 
/*/

Function A103ChgCteSub(cForm,oGNDoc,oGNSer)

Local lWhen := .T.

If cForm == "Sim"
	lWhen := .F.
	oGNDoc:cCaption := Space(TamSX3("F1_DOC")[1])
	oGNSer:cCaption := Space(TamSX3("F1_SERIE")[1])
Else
	lWhen := .T.
Endif

oGNDoc:bWhen := {|| lWhen }
oGNDoc:Refresh()
oGNSer:bWhen := {|| lWhen }
oGNSer:Refresh()

Return

/*/{Protheus.doc} A103SubGrvSF8
Função para atualização da SF8 realizando vinculo do novo CT-e Substituto com as NFs origem
e criando nova amarração do CT-e Substituto com o CT-e Origem

@param	cDocSub		CT-e Origem (numero documento)
@param	cSerSub		CT-e Origem (serie documento)
@param	cFornSub	CT-e Origem (fornecedor documento)
@param	cLojSub		CT-e Origem (loja documento)
@param	cNewDocSub	CT-e Substituto (numero documento)
@param	cNewSerSub	CT-e Substituto (serie documento)

@author rodrigo.mpontes
@since 03/04/2024
@return lRet 
/*/

Function A103SubGrvSF8(cDocSub,cSerSub,cFornSub,cLojSub,cNewDocSub,cNewSerSub)

Local cQry		:= ""
Local cQryStat	:= ""
Local cAliTmp	:= GetNextAlias()
Local oGrvF8	:= FWPreparedStatement():New()
Local lRet		:= .T.
Local lGrvF8	:= .F.

cQry := " SELECT F8_NFORIG, F8_SERORIG, F8_FORNECE, F8_LOJA "
cQry += " FROM " + RetSqlName("SF8") + " SF8 "
cQry += " WHERE SF8.F8_FILIAL  = ?"
cQry += " AND SF8.F8_NFDIFRE = ?"   
cQry += " AND SF8.F8_SEDIFRE = ?"
cQry += " AND SF8.F8_TRANSP	 = ?"
cQry += " AND SF8.F8_LOJTRAN = ?"
cQry += " AND SF8.D_E_L_E_T_ = ?"

oGrvF8:SetQuery(cQry) 

oGrvF8:SetString(1,xFilial("SF8"))
oGrvF8:SetString(2,cDocSub)
oGrvF8:SetString(3,cSerSub)
oGrvF8:SetString(4,cFornSub)
oGrvF8:SetString(5,cLojSub)
oGrvF8:SetString(6,Space(1))

cQryStat := oGrvF8:GetFixQuery()
MpSysOpenQuery(cQryStat,cAliTmp) 

While (cAliTmp)->(!EOF())
	If RecLock("SF8",.T.)
		SF8->F8_FILIAL	:= xFilial("SF8")
		SF8->F8_DTDIGIT	:= Date()
		SF8->F8_NFDIFRE	:= cNewDocSub
		SF8->F8_SEDIFRE	:= cNewSerSub
		SF8->F8_TRANSP	:= cFornSub
		SF8->F8_LOJTRAN	:= cLojSub
		SF8->F8_NFORIG	:= (cAliTmp)->F8_NFORIG
		SF8->F8_SERORIG	:= (cAliTmp)->F8_SERORIG
		SF8->F8_FORNECE	:= (cAliTmp)->F8_FORNECE
		SF8->F8_LOJA	:= (cAliTmp)->F8_LOJA
		SF8->F8_TIPO	:= "F"
		SF8->(MsUnlock())
		lGrvF8 := .T.
	Endif
	(cAliTmp)->(DbSkip())	
Enddo
(cAliTmp)->(DbCloseArea())

If lGrvF8
	If RecLock("SF8",.T.)
		SF8->F8_FILIAL	:= xFilial("SF8")
		SF8->F8_DTDIGIT	:= Date()
		SF8->F8_NFDIFRE	:= cNewDocSub
		SF8->F8_SEDIFRE	:= cNewSerSub
		SF8->F8_TRANSP	:= cFornSub
		SF8->F8_LOJTRAN	:= cLojSub
		SF8->F8_NFORIG	:= cDocSub
		SF8->F8_SERORIG	:= cSerSub
		SF8->F8_FORNECE	:= cFornSub
		SF8->F8_LOJA	:= cLojSub
		SF8->F8_TIPO	:= "S"
		SF8->(MsUnlock())
	Endif
Endif

FreeObj(oGrvF8)

Return lRet

/*/{Protheus.doc} A103SubDelSF8
Função para deleção da SF8 do novo CT-e Substituto com as NFs origem
e da amarração do CT-e Substituto com o CT-e Origem

@author rodrigo.mpontes
@since 03/04/2024
@return lRet 
/*/

Function A103SubDelSF8()

Local cQry		:= ""
Local cQryStat	:= ""
Local cAliTmp	:= GetNextAlias()
Local oDelF8	:= FWPreparedStatement():New()
Local oUpdF8	:= FWPreparedStatement():New()
Local cUpd		:= ""
Local nOrder	:= 1
Local aArea		:= SF1->(GetArea())

cQry := " SELECT F8_NFDIFRE, F8_SEDIFRE, F8_TRANSP, F8_LOJTRAN "
cQry += " FROM " + RetSqlName("SF8") + " SF8 "
cQry += " WHERE SF8.F8_FILIAL  = ?"
cQry += " AND SF8.F8_TIPO = ?"
cQry += " AND SF8.D_E_L_E_T_ = ?" 

oDelF8:SetQuery(cQry) 

oDelF8:SetString(nOrder++,xFilial("SF8"))
oDelF8:SetString(nOrder++,"S")
oDelF8:SetString(nOrder++,Space(1))

cQryStat := oDelF8:GetFixQuery()
MpSysOpenQuery(cQryStat,cAliTmp) 

DbSelectArea("SF1")
SF1->(DbSetOrder(1))

While (cAliTmp)->(!EOF())
	If SF1->(!DbSeek(xFilial("SF1") + (cAliTmp)->F8_NFDIFRE + (cAliTmp)->F8_SEDIFRE + (cAliTmp)->F8_TRANSP + (cAliTmp)->F8_LOJTRAN))
		cUpd := " DELETE FROM " + RetSqlName("SF8")
		cUpd += " WHERE F8_FILIAL  = ?"
		cUpd += " AND F8_NFDIFRE = ?"   
		cUpd += " AND F8_SEDIFRE = ?"
		cUpd += " AND F8_TRANSP	 = ?"
		cUpd += " AND F8_LOJTRAN = ?"
		cUpd += " AND D_E_L_E_T_ = ?"

		oUpdF8:SetQuery(cUpd)  
		nOrder := 1

		oUpdF8:SetString(nOrder++,xFilial("SF8"))
		oUpdF8:SetString(nOrder++,(cAliTmp)->F8_NFDIFRE)
		oUpdF8:SetString(nOrder++,(cAliTmp)->F8_SEDIFRE)
		oUpdF8:SetString(nOrder++,(cAliTmp)->F8_TRANSP) 
		oUpdF8:SetString(nOrder++,(cAliTmp)->F8_LOJTRAN)
		oUpdF8:SetString(nOrder++,Space(1))

		cQryStat := oUpdF8:GetFixQuery() 
		
		TcSqlExec(cQryStat)
	Endif
	(cAliTmp)->(DbSkip()) 
Enddo

(cAliTmp)->(DbCloseArea()) 

RestArea(aArea)
FwFreeArray(aArea)
FreeObj(oDelF8)
FreeObj(oUpdF8)

Return

/*/{Protheus.doc} A103IsCTeSub
Função para identificar se CT-e sendo incluido ou excluido é uma CT-e Substituto

@param	cOpc		Valida no momento da "I" - Inclusão / "E" - Exclusão / "D" - Duplicidade
@param	cDoc		CT-e Substituto (numero documento)
@param	cSer		CT-e Substituto (serie documento)
@param	cFor		CT-e Substituto (fornecedor documento)
@param	cLoj		CT-e Substituto (loja documento)

@author rodrigo.mpontes
@since 03/04/2024
@return lRet 
/*/

Function A103IsCTeSub(cOpc,cDoc,cSer,cFor,cLoj)

Local lRet			:= .F.
Local cQry			:= ""
Local cQryStat		:= ""
Local cRetCpoQry	:= ""
Local cCpoFilt1		:= ""  
Local cCpoFilt2		:= ""
Local cCpoFilt3		:= ""
Local cCpoFilt4		:= ""
Local cTipoF8		:= "S"
Local cAliTmp		:= GetNextAlias()
Local oDelCTeSub	:= FWPreparedStatement():New()

//Avalia se pode inserir novo CTe Substituto
//Verificação de duplicidade
If cOpc == "I"
	cRetCpoQry	:= "F8_NFDIFRE"
	cCpoFilt1	:= "F8_NFORIG"
	cCpoFilt2	:= "F8_SERORIG"
	cCpoFilt3	:= "F8_FORNECE"
	cCpoFilt4	:= "F8_LOJA"
//Verifica se esta excluindo um CTe Substituto
Elseif cOpc == "E" .Or. cOpc == "D"
	cRetCpoQry	:= "F8_NFORIG"
	cCpoFilt1	:= "F8_NFDIFRE"
	cCpoFilt2	:= "F8_SEDIFRE"
	cCpoFilt3	:= "F8_TRANSP"
	cCpoFilt4	:= "F8_LOJTRAN"
Endif

If cOpc == "D"
	cTipoF8 := "F"
Endif

cQry := " SELECT ?"
cQry += " FROM " + RetSqlName("SF8")
cQry += " WHERE F8_FILIAL  = ?"
cQry += " AND ? = ?"   
cQry += " AND ? = ?"
cQry += " AND ?	= ?"
cQry += " AND ? = ?"
cQry += " AND F8_TIPO    = ?"
cQry += " AND D_E_L_E_T_ = ?"

oDelCTeSub:SetQuery(cQry) 

oDelCTeSub:SetNumeric(1,cRetCpoQry)
oDelCTeSub:SetString(2,xFilial("SF8"))
oDelCTeSub:SetNumeric(3,cCpoFilt1)
oDelCTeSub:SetString(4,cDoc)
oDelCTeSub:SetNumeric(5,cCpoFilt2)
oDelCTeSub:SetString(6,cSer)
oDelCTeSub:SetNumeric(7,cCpoFilt3)
oDelCTeSub:SetString(8,cFor)
oDelCTeSub:SetNumeric(9,cCpoFilt4)
oDelCTeSub:SetString(10,cLoj)
oDelCTeSub:SetString(11,cTipoF8)
oDelCTeSub:SetString(12,Space(1))

cQryStat := oDelCTeSub:GetFixQuery()
MpSysOpenQuery(cQryStat,cAliTmp) 

If (cAliTmp)->(!EOF())
	lRet := .T.
Endif

If lRet .And. cOpc == "D"  
	Help(" ",1,"A103CTESUBDUP",,STR0256,1,1,,,,,, {STR0257}) //"Não podera utilizar mesma numeração do CT-e Original no CT-e Substituto" # "Ajuste a numeração do CT-e substituto"
Endif

(cAliTmp)->(DbCloseArea())
FreeObj(oDelCTeSub)

Return lRet

/*/{Protheus.doc} A103AglCTSub
Função para identificar se houve aglutinação na inclusão do CT-e Origem/Substituto

@author rodrigo.mpontes
@since 03/04/2024
@return lRet 
/*/

Function A103AglCTSub()

Local lRet		:= .F. 
Local lContinua	:= .T.
Local cQry		:= ""
Local cQryStat	:= ""
Local cAliTmp	:= ""
Local oAglCTeSub:= Nil
Local oD1Item	:= Nil
Local nTotItOri	:= 0
Local nTotItSub	:= Len(aCols)

lContinua	:= A103IsCTeSub("E",cNFiscal,cSerie,cA100For,cLoja)

If lContinua .Or. (!Inclui .And. !Altera .And. FwIsInCallStack("MATA116"))
	cAliTmp		:= GetNextAlias()
	oAglCTeSub	:= FWPreparedStatement():New()

	cQry := " SELECT F8_NFORIG,F8_SERORIG,F8_FORNECE,F8_LOJA"
	cQry += " FROM " + RetSqlName("SF8")
	cQry += " WHERE F8_FILIAL  = ?"
	cQry += " AND F8_NFDIFRE = ?"   
	cQry += " AND F8_SEDIFRE = ?"
	cQry += " AND F8_TRANSP  = ?"
	cQry += " AND F8_LOJTRAN = ?"
	cQry += " AND F8_TIPO    = ?"
	cQry += " AND D_E_L_E_T_ = ?"

	oAglCTeSub:SetQuery(cQry) 

	oAglCTeSub:SetString(1,xFilial("SF8"))
	oAglCTeSub:SetString(2,cNFiscal)
	oAglCTeSub:SetString(3,cSerie)
	oAglCTeSub:SetString(4,cA100For)
	oAglCTeSub:SetString(5,cLoja)
	oAglCTeSub:SetString(6,"F")
	oAglCTeSub:SetString(7,Space(1))

	cQryStat := oAglCTeSub:GetFixQuery()
	MpSysOpenQuery(cQryStat,cAliTmp) 

	While (cAliTmp)->(!EOF())

		cAliTmp2	:= GetNextAlias()
		If oD1Item == Nil
			oD1Item	:= FWPreparedStatement():New()
			cQry := " SELECT COUNT(D1_ITEM) TOTITENS"
			cQry += " FROM " + RetSqlName("SD1")
			cQry += " WHERE D1_FILIAL  	= ?"
			cQry += " AND D1_DOC 		= ?"   
			cQry += " AND D1_SERIE 		= ?"
			cQry += " AND D1_FORNECE 	= ?"
			cQry += " AND D1_LOJA 		= ?"
			cQry += " AND D_E_L_E_T_ 	= ?"
			oD1Item:SetQuery(cQry)
		Endif

		oD1Item:SetString(1,xFilial("SD1"))
		oD1Item:SetString(2,(cAliTmp)->F8_NFORIG)
		oD1Item:SetString(3,(cAliTmp)->F8_SERORIG)
		oD1Item:SetString(4,(cAliTmp)->F8_FORNECE)
		oD1Item:SetString(5,(cAliTmp)->F8_LOJA)
		oD1Item:SetString(6,Space(1))

		cQryStat := oD1Item:GetFixQuery()
		MpSysOpenQuery(cQryStat,cAliTmp2) 

		If (cAliTmp2)->(!EOF())
			nTotItOri += (cAliTmp2)->TOTITENS
		Endif
		(cAliTmp2)->(DbCloseArea())
		(cAliTmp)->(DbSkip())
	Enddo

	//Se houver diferença é que no CTe foi aglutinado produtos
	If nTotItOri <> nTotItSub
		lRet := .T.
	Endif

	(cAliTmp)->(DbCloseArea()) 
	FreeObj(oAglCTeSub)
	FreeObj(oD1Item)
Endif

Return lRet

/*/{Protheus.doc} A103CalIss
	Função centralizadora para calcular o ISS
	via Legado ou Configurador de tributos.

	@author rodrigo.oliveira
	@since 13/05/2025
	@param	lISSNat, character, Identifica se o ISS foi configurado via Nat.
				Financeira ou TES.
			lIssCfgTrb, logical, Identifica se o ISS é pelo Conf. Tributos.
	@return nRet, numeric, Valor do ISS
/*/
Static Function A103CalIss(lISSNat as Logical, lIssCfgTrb as Logical) as Numeric
	Local nRet as Numeric

	Default lISSNat		:= .F.
	Default lIssCfgTrb	:= .F.

	nRet	:= 0
	If ( MaFisRet(,"NF_RECISS")=="2" .And. lISSNat ) .Or. lIssCfgTrb
		nRet := MaFisRet(,"NF_VALISS")
	EndIf
Return nRet

//-------------------------------------------------------------------
/*/{Protheus.doc} BloqCpNFE()
Realiza o bloqueio do campo F1_CHVNFE (Chave NFE), quando utilizado especie de Notas Fiscais de Serviço

@param 	cEspecie - Character - Especie Informada no documento de entrada
@return  lRet - Logico - Retorna se bloqueia o campo 

@author Guilherme Futro
@since 25/07/2025
/*/
//-------------------------------------------------------------------

Static Function BloqCpNFE(cEspecie)
	Local lRet 			As Logical 

	Default cEspecie  	:= ""

	lRet 				:= .T.

	If !Empty(cEspecie)
		Do Case
			Case cEspecie == "NFS" 
				lRet := .F.
			Case cEspecie == "NFSE" 
				lRet := .F.
			Case cEspecie == "NFSC" 
				lRet := .F.
			Case cEspecie == "NFST" 
				lRet := .F.
		EndCase
	EndIf 

Return lRet

/*/{Protheus.doc} A103LoadX1
	Carrega o SX1 no aParamSX1 para reduzir a necessidade de chamadas da funcao Pergunte()
	Reduzindo o tempo de processamento quando houver muitos itens
	@type  Static Function
	@author Marcos Pires
	@since 25/07/2025
	@param aParamSX1, Array, Armazena os valores do pergunte desejado
	@param cSX1, Caracter, Codigo do pergunte para carga do objeto
/*/
Static Function A103LoadX1(aParamSX1,cSX1)
Local oPerg			:= nil

Default aParamSX1	:= {}
Default cSX1		:= ""

If Len(aParamSX1) == 0 .Or. aParamSX1[1] <> cSX1
	oPerg := FWSX1Util():New()
	oPerg:AddGroup(cSX1)
	oPerg:SearchGroup()
	aParamSX1 := oPerg:GetGroup(cSX1)
EndIf

Return Nil


/*/{Protheus.doc} ComboGen
	Retorna opções que existem no X3_CBOX do campo solicitado na SF1, para montar o array esperado no MSCOMBO da dialog
	@author renan.martins
	@since 10/2025
	@param cCampo, character, nome do campo a ser pesquisado
	@param lIncluiVazio, lógico, se deve incluir no array uma posição vazia, para inicializar vazio
	@return aOptions, Array, array com os dados do X3_CBOX 
	@version 1.0
/*/
Static Function ComboGen(cCampo, lIncluiVazio)
	Local aOptions 			:= {}
	Default cCampo			:= "F1_OPGOV"
	Default lIncluiVazio	:= .F.
	
	if ( SF1->(FieldPos(cCampo)) )
		aOptions := StrToArray(AllTrim(GetSX3Cache(cCampo, 'X3_CBOX')), ';')
	EndIf

	if ( lIncluiVazio )
		aAdd(aOptions, "")
	endif

Return aOptions

/*/{Protheus.doc} VldCmpGovDlg
	Função que atualiza o campo lógico do "Compra Governamental?" e atualiza no array aInfAdic a informação correta - "0" ou "1" - pois no banco, foi criado como character e CBOX,
	já que campo lógico gera problemas em execauto. É a posição 21 do array private "aInfAdic".
	@author renan.martins
	@since 10/2025
	@param oCmbCPGOV, object, objeto do campo "Compra Governamental?". (passagem de parâmetro)
	@param lAtual, lógico, o valor do campo ao ser clicado, para atualizar o array. (passagem de parâmetro)
	@param aDados, array, array com os dados adicionais da aba, para atualizar a posição 21. (passagem de parâmetro)
	@return nil, Nil, nil.
	@version 1.0
/*/
static function VldCmpGovDlg(oCmbCPGOV, lAtual, aDados)
	Default oCmbCPGOV 	:= Nil
	Default lAtual		:= .F.
	Default aDados		:= {}

	if lAtual
		aDados[21] := "1"
	else
		aDados[21] := "0"
		aDados[22] := 0
		aDados[23] := ""
	endif
	oCmbCPGOV:Refresh()
return nil


/*/{Protheus.doc} retTpNCND()

Retorna tipos de Notas de débito e crédito
Centralização para futuras alterações facilitar manutenção

@param 	cTipo - Character - "ND" / "NC"

@author Leandro Fini
@since 10/2025
/*/
Static Function retTpNCND(cTipo)

Local aCombo3 	 := {}
Local aAuxCombo3 := {}
Default cTipo := ""

	if cTipo == "NC"

		aCombo3 := { "",;
					STR0263,; 	//"1-Multa e juros"
					STR0264,; 	//"2-Apropriação de crédito presumido de IBS sobre saldo devedor ZFM"
					STR0265,; 	//"3-Retorno por recusa na entrega ou por não localização"
					STR0266,;  	//"4-Redução de valores"
					STR0277}	//"5-Transferência de crédito na sucessão"
		aAuxCombo3 := {"","1","2","3","4","5"}

	elseif cTipo == "ND"

		aCombo3 := {	"",;
					STR0267,; //"1-Trânsferência de Créditos para Cooperativas"
                    STR0268,; //"2-Anulação de Crédito por Saídas Imunes/Isentas"
                    STR0269,; //"3-Débitos de notas fiscais não processadas na apuração"s
                    STR0270,; //"4-Multa e juros"
                    STR0271,; //"5-Transferência de crédito na sucessão"
					STR0272,; //"6-Pagamento antecipado"
					STR0273}  //"8-Desenquadramento do SN"
		aAuxCombo3 := {"","1","2","3","4","5","6","8"}

	endif

Return { aCombo3, aAuxCombo3 }
