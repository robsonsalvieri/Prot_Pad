#include "tlpp-core.th"
#include "backoffice.stock.trackcosts.estr900a.ch"

namespace totvs.protheus.backoffice.stock.trackcosts.ESTR900A.service

using namespace totvs.protheus.backoffice.stock.trackcosts.ESTR900A.repository


class ESTR900AService
   
    
    public data cTableName01 as character
    public data cTableName02 as character
    public data cError as character

    public method new()
    public method setESTR900A()
    public method calculatePercentage()
    public method calculateESTR900A()
    public method getProducts()
    public method version()

    private method getQueryTotalProducts()
    Public method IsBodyValidFromAverageCost()
    private method getListProductsColumns()
    private method getListQueryProducts()
    private method getListWhereProducts()

    
endclass

/*/{Protheus.doc} ESTR900Service:New()
    Metodo responsavel por instanciar e iniciar as variaveis da class acUser
    @type  Metodo
    @author Pedro Missaglia
    @since  Outubro 02, 2020
    @version 12.1.27
/*/
method new() class ESTR900AService

::cTableName01 := ""
::cTableName02 := ""
::cError := ""

return Self

/*/{Protheus.doc} Mtstart
    Funcao chamada para subir as threads da MANUALJOB
    @type  Function
    @author Squad Entradas
    @since 20/06/2022
    @version 1.0
    @param cParam, character, empresa e filial
/*/

Method calculateESTR900A(dDataIni, dDataFim, cId, cIdConfig, oStructTable, cUserName, aBranches, nMoeda, cPayload) class ESTR900AService

Local nQuantTot     as numeric
Local nX            as numeric
Local oRepository   as Object
Local cCusFil       as character
Local cFilBack      as character

cFilBack    := cFilAnt
cCusFil     := Alltrim(SuperGetMv("MV_CUSFIL", .F., "A"))
oRepository := totvs.protheus.backoffice.stock.trackcosts.ESTR900A.repository.ESTR900ARepository():New()

For nX := 1 to Len(aBranches)

    cFilAnt := aBranches[nX, 2]

    nQuantTot := ::getQueryTotalProducts(oStructTable["table"]["product"]["realName"])

    oRepository:startAsyncESTR900A(dDataIni, dDataFim, cId, cIdConfig, cUserName, nQuantTot, nMoeda, cPayload)
    
    If cCusFil == 'E'
        Exit
    EndIf

Next nX

    cFilAnt := cFilBack

return 

/*/{Protheus.doc} Mtstart
    Funcao chamada para subir as threads da MANUALJOB
    @type  Function
    @author Squad Entradas
    @since 20/06/2022
    @version 1.0
    @param cParam, character, empresa e filial
/*/
Method setESTR900A(cEmp, cFil, cThread, nRangeIni, nRangeFim, dDataIni, dDataFim, cId, cIdConfig, nMoeda)  class ESTR900AService

    //Local aTabelas := {"SB2","SF4","SD1","SF1","SD3","SF1"}
    Local cTable        := ""
    Local lCusRep       := .F.
    Local aSalIni       := {}
    Local aSalFim       := {}
    Local aSalIniAux    := {}
    Local aSalFimAux    := {}
    Local oD4A          := totvs.protheus.backoffice.stock.trackcosts.model.D4A.D4A():New()
    Local lCusEmp       :=  AllTrim(SuperGetMv('MV_CUSFIL' ,.F.,"A")) == "E"
    Local lCusFil       :=  AllTrim(SuperGetMV('MV_CUSFIL' ,.F.,"A")) == "F"
    Local nX            :=  0
    Local oProduct      := JsonObject():New()
    Local cTrbSB2	    := CriaTrab(,.F.)
    
    Local nIndice       := 0
    Local nCusMedIni    := 0   
    Local nCusMedFin    := 0   

    Local cFilBack      := ""

    Local bBloco   := { |nV,nX| Trim(nV)+IIf(Valtype(nX)='C',"",Str(nX,1)) }

    cFilAnt     := cFil
    cFilBack    := cFilAnt

    lCusRep := SuperGetMv("MV_CUSREP", .F., .F.) .And. MA330AvRep()

    ::cTableName01 := "A" + Upper(cIdConfig) + "_01"
    ::cTableName02 := "A" + Upper(cIdConfig) + "_02"
    cTable := ::cTableName02

    DbUseArea(.T.,"TOPCONN",cTable,cTable,.T.)

    If lCusEmp

        dbSetIndex(cTable + '_07')
        (cTable)->(DbSetOrder(1))
        (cTable)->(DbSeek(Padr(cValToChar(nRangeIni), 9 )))

        DbSelectArea("SB1")
        SB1->(dbSetOrder(1))

        While (cTable)->(!Eof()) .AND. (cTable)->ORDEM <= nRangeFim
                    
            aSalIni     := { 0,0,0,0,0,0,0 }
            aSalFim     := { 0,0,0,0,0,0,0 }

            // CONSULTA A PRIMEIRA DESCRICAO PARA PREENCHER A TABELA = MATR900
            SB1->(dbSeek( xFilial("SB1") + (cTable)->PRODUTO))

            oProduct["code"]        := (cTable)->PRODUTO
            oProduct["description"] := SB1->B1_DESC

            dbSelectArea("SB2")
            SB2->(dbSetOrder(1))
            INDREGUA("SB2",cTrbSB2,"B2_COD+B2_LOCAL",,,,.F.)
            nIndice := RetIndex("SB2")
            SB2->(dbSetOrder(nIndice + 1))
            
            // CONSULTA O SALDO INICIAL DE TODOS OS ARMAZENS
            SB2->(dbSeek((cTable)->PRODUTO))

            While SB2->(!Eof()) .And. SB2->B2_COD == (cTable)->PRODUTO
                
                If !Empty(xFilial("SB2"))
                    cFilAnt := SB2->B2_FILIAL
                EndIf
                
                aSalIniAux  := CalcEst((cTable)->PRODUTO    ,SB2->B2_LOCAL      ,dDataIni       ,,, lCusRep)
                aSalFimAux  := CalcEst((cTable)->PRODUTO    ,SB2->B2_LOCAL      ,dDataFim + 1   ,,, lCusRep)
                
                For nX :=1 to Len(aSalIni)
                    aSalIni[nX] += aSalIniAux[nX]
                Next nX

                For nX :=1 to Len(aSalFim)
                    aSalFim[nX] += aSalFimAux[nX]
                Next nX

                SB2->(dbSkip())
            End

            SB2->(dbSetOrder(1))
            SB2->(MsSeek(cFilAnt + (cTable)->PRODUTO))
            
            If aSalIni[1] > 0
                nCusMedIni := aSalIni[nMoeda+1]/aSalIni[1]
            ElseIf aSalIni[1] == 0 .and. aSalIni[nMoeda+1] == 0
                nCusMedIni := 0
            Else
                nCusMedIni := &(Eval(bBloco,"SB2->B2_CM",nMoeda))
            EndIf

            If aSalFim[1] > 0
                nCusMedFin := aSalFim[nMoeda+1]/aSalFim[1]
            ElseIf aSalFim[1] == 0 .and. aSalFim[nMoeda+1] == 0
                nCusMedFin := 0
            Else
                nCusMedFin := &(Eval(bBloco,"SB2->B2_CM",nMoeda))
            EndIf

            cFilAnt := cFilBack

            RecLock(cTable, .F.)

            (cTable)->SALDOINI  := aSalIni[nMoeda+1] //Custo inicial do período
            (cTable)->SALDOFIN  := aSalFim[nMoeda+1] //Custo final do período
            (cTable)->QUANTINI  := aSalIni[01] //Quantidade inicial do período
            (cTable)->QUANTFIN  := aSalFim[01] //Quantidade final do período
            (cTable)->DESCRI    := oProduct["description"]

            (cTable)->CMINI     := nCusMedIni //Custo médio inicial do período
            (cTable)->CMIFIN    := nCusMedFin //Custo médio final do período

            (cTable)->VARIACAO  := ::calculatePercentage(nCusMedIni, nCusMedFin)
            (cTable)->VARIAQUANT:= ::calculatePercentage((cTable)->QUANTINI, (cTable)->QUANTFIN)

            (cTable)->ID_900A        := cId
            (cTable)->(MSUnlock())
            (cTable)->(dbSkip())
        Enddo

        SB1->(DBCLOSEAREA())
        SB2->(DBCLOSEAREA())

    Elseif lCusFil

        dbSetIndex(cTable + '_05') //acrescenta a ordem de indice para a área aberta
        (cTable)->(DbSetOrder(1))
        (cTable)->(DbSeek(cFilAnt + Padr(cValToChar(nRangeIni), 9)))

        dbSelectArea("SB2")
        SB2->(dbSetOrder(1))

        While (cTable)->(!Eof()) .AND.  (cTable)->FILIAL == cFilAnt .AND.(cTable)->ORDEM <= nRangeFim
            
            aSalIni     := { 0,0,0,0,0,0,0 }
            aSalFim     := { 0,0,0,0,0,0,0 }

            SB2->(dbSeek(xFilial("SB2") + (cTable)->PRODUTO))

            While SB2->(!Eof()) .And. SB2->B2_FILIAL + SB2->B2_COD == cFilAnt + (cTable)->PRODUTO

                aSalIniAux  := CalcEst((cTable)->PRODUTO    ,SB2->B2_LOCAL      ,dDataIni       ,,, lCusRep)
                aSalFimAux  := CalcEst((cTable)->PRODUTO    ,SB2->B2_LOCAL      ,dDataFim + 1   ,,, lCusRep)
                
                For nX :=1 to Len(aSalIni)
                    aSalIni[nX] += aSalIniAux[nX]
                Next nX

                For nX :=1 to Len(aSalFim)
                    aSalFim[nX] += aSalFimAux[nX]
                Next nX
                SB2->(dbSkip())
            End
            
            SB2->(dbSetOrder(1))
            SB2->(MsSeek(cFilAnt + (cTable)->PRODUTO))
            
            If aSalIni[1] > 0
                nCusMedIni := aSalIni[nMoeda+1]/aSalIni[1]
            ElseIf aSalIni[1] == 0 .and. aSalIni[nMoeda+1] == 0
                nCusMedIni := 0
            Else
                nCusMedIni := &(Eval(bBloco,"SB2->B2_CM",nMoeda))
            EndIf

            If aSalFim[1] > 0
                nCusMedFin := aSalFim[nMoeda+1]/aSalFim[1]
            ElseIf aSalFim[1] == 0 .and. aSalFim[nMoeda+1] == 0
                nCusMedFin := 0
            Else
                nCusMedFin := &(Eval(bBloco,"SB2->B2_CM",nMoeda))
            EndIf

            RecLock(cTable, .F.)

            (cTable)->SALDOINI  := aSalIni[nMoeda+1] //Custo inicial do período
            (cTable)->SALDOFIN  := aSalFim[nMoeda+1] //Custo final do período
            (cTable)->QUANTINI  := aSalIni[01] //Quantidade inicial do período
            (cTable)->QUANTFIN  := aSalFim[01] //Quantidade final do período

            (cTable)->CMINI     := nCusMedIni
            (cTable)->CMIFIN    := nCusMedFin

            //Custo médio inicial do período
            (cTable)->VARIACAO  := ::calculatePercentage(nCusMedIni, nCusMedFin)
            //Custo médio final do período
            (cTable)->VARIAQUANT:= ::calculatePercentage((cTable)->QUANTINI, (cTable)->QUANTFIN)

            (cTable)->ID_900A        := cId
            (cTable)->(MSUnlock())
            (cTable)->(dbSkip())
        Enddo

        SB2->(DBCLOSEAREA())

    Else 
        dbSetIndex(cTable + '_01') //acrescenta a ordem de indice para a área aberta
        (cTable)->(DbSetOrder(1))
        (cTable)->(DbSeek(cFilAnt + Padr(cValToChar(nRangeIni), 9)))

        DBSELECTAREA( "SB2" )

        // NECESSARIO TESTAR PROCESSO COM CUSTO POR EMPRESA
        While (cTable)->(!Eof()) .AND. (cTable)->FILIAL == cFilAnt .AND. (cTable)->ORDEM <= nRangeFim
            
            RecLock(cTable, .F.)

            //SE ARMAZEM ESTIVER VAZIO, É UM REGISTRO DE ARQUIVO SB1, OU SEJA, SEM MOVIMENTAÇÃO
            If !Empty((cTable)->ARMAZEM)
                aSalIni := CalcEst((cTable)->PRODUTO,(cTable)->ARMAZEM,dDataIni,,, lCusRep )
                aSalFim := CalcEst((cTable)->PRODUTO,(cTable)->ARMAZEM,dDataFim+1,,, lCusRep )


                SB2->(dbSetOrder(1))
                SB2->(MsSeek(cFilAnt + (cTable)->PRODUTO))

                If aSalIni[1] > 0
                    nCusMedIni := aSalIni[nMoeda+1]/aSalIni[1]
                ElseIf aSalIni[1] == 0 .and. aSalIni[nMoeda+1] == 0
                    nCusMedIni := 0
                Else
                    nCusMedIni := &(Eval(bBloco,"SB2->B2_CM",nMoeda))
                EndIf

                If aSalFim[1] > 0
                    nCusMedFin := aSalFim[nMoeda+1]/aSalFim[1]
                ElseIf aSalFim[1] == 0 .and. aSalFim[nMoeda+1] == 0
                    nCusMedFin := 0
                Else
                    nCusMedFin := &(Eval(bBloco,"SB2->B2_CM",nMoeda))
                EndIf

                //Custo inicial do período
                (cTable)->SALDOINI  := aSalIni[nMoeda+1]
                //Custo final do período
                (cTable)->SALDOFIN  := aSalFim[nMoeda+1]
                //Quantidade inicial do período
                (cTable)->QUANTINI  := aSalIni[01]
                //Quantidade final do período
                (cTable)->QUANTFIN  := aSalFim[01]

                //Custo médio inicial do período
                (cTable)->CMINI     := nCusMedIni
                //Custo médio final do período
                (cTable)->CMIFIN    := nCusMedFin

                (cTable)->VARIACAO  := ::calculatePercentage(nCusMedIni, nCusMedFin)
                (cTable)->VARIAQUANT:= ::calculatePercentage((cTable)->QUANTINI, (cTable)->QUANTFIN)

            Endif

            (cTable)->ID_900A        := cId
            (cTable)->(MSUnlock())
            (cTable)->(dbSkip())
        Enddo
        SB2->(DBCLOSEAREA())
    Endif

    oD4A:PATCH('D4A_STATUS', 'FINISHED')
Return

/*/{Protheus.doc} Mtstart
    Funcao chamada para subir as threads da MANUALJOB
    @type  Function
    @author Squad Entradas
    @since 20/06/2022
    @version 1.0
    @param cParam, character, empresa e filial
/*/

Method calculatePercentage(nCustoIni, nCustoFim) class ESTR900AService

Local nVar := 0


If nCustoIni == nCustoFim
    nVar := 0
Elseif nCustoIni == 0 .OR. nCustoFim == 0
    nVar := 1
Else
    nVar := ABS(((nCustoFim/nCustoIni)-1))
Endif

return nVar*100

/*/{Protheus.doc} ACKardexController:New()
Â Â Â Â Metodo responsavel por instanciar e iniciar as variaveis da class acUser
Â Â Â Â @typeÂ Â Metodo
Â Â Â Â @authorÂ Pedro Missaglia
Â Â Â Â @sinceÂ Â OutubroÂ 02, 2020
Â Â Â Â @versionÂ 12.1.27
/*/
method getQueryTotalProducts(cTable) class ESTR900AService

Local lCusEmp       as logical      
Local cQuery        as character 
Local oRepository   as Object

lCusEmp     :=  AllTrim(SuperGetMv('MV_CUSFIL' ,.F.,"A")) == "E"
oRepository := totvs.protheus.backoffice.stock.trackcosts.ESTR900A.repository.ESTR900ARepository():New()

cQuery := "SELECT count(PRODUTO) AS TOTAL "
cQuery += "FROM  " + cTable 

cQuery += " WHERE "

If !lCusEmp
    cQuery += " FILIAL = '"+ cFilAnt +"' AND "
Endif

cQuery += "D_E_L_E_T_ = ' '" 

return oRepository:getTotalProducts(cTable, cQuery)

/*/{Protheus.doc} IsBodyValidFromAverageCost()
    Metodo responsavel por validar a estrutura do json
    @type  Metodo
    @author Pedro Missaglia
    @since  Outubro 02, 2020
    @version 12.1.2310
/*/
method IsBodyValidFromAverageCost(jBody) class ESTR900AService

Local lBodyValid as Logical

lBodyValid := .F.

    If !(jBody == NIL)
        If jBody:HasProperty("parameters")
            If jBody:HasProperty("branches")
                If !Empty(jBody["branches"])
                    lBodyValid := .T. 
                Endif
            Else
                ::cError := STR0001
                lBodyValid := .F. 
            Endif
        Else
            ::cError := STR0002
            lBodyValid := .F. 
        Endif
    Else 
        ::cError := STR0003
        lBodyValid := .F.
    Endif 

return lBodyValid

/*/{Protheus.doc} version
    Metodo responsavel por indicar a versao da classe
    @type Method
    @author Adriano Vieira
    @since  15/02/2024
    @version 12.1.23.10
/*/
Method version() class ESTR900AService
    Local nVersion := 200
Return nVersion
