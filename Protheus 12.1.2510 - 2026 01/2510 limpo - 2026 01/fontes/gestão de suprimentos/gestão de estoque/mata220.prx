#INCLUDE "MATA220.CH"
#INCLUDE "PROTHEUS.CH"
#DEFINE USADO CHR(0)+CHR(0)+CHR(1)

/*


Ŀ
Descrio  PLANO DE MELHORIA CONTINUA                                 
Ĵ
ITEM PMC   Responsavel               Data                            
Ĵ
      01  Flavio Luiz Vicco          11/01/2006                      
      02  Flavio Luiz Vicco          30/12/2005                      
      03                                                             
      04                                                             
      05                                                             
      06                                                             
      07  Flavio Luiz Vicco          11/01/2006                      
      08                                                             
      09                                                             
      10  Flavio Luiz Vicco          30/12/2005                      
ٱ




Ŀ
Funo     MATA220   Autor  Eveli Morasco          Data  25/02/92 
Ĵ
Descrio  Cadastramento de saldos iniciais                           
Ĵ
 Uso       Generico                                                   
Ĵ
 ATUALIZACOES SOFRIDAS DESDE A CONSTRUCAO INICIAL.                     
Ĵ
 PROGRAMADOR   DATA    BOPS   MOTIVO DA ALTERACAO                   
Ĵ
Rodrigo Sarto.01/06/98XXXXXXAcerto na exclusao do saldo inicial.    
Rodrigo Sarto.21/09/9817684AAcerto na conversao para segunda UM     
Rodrigo Sarto.27/01/99META  Validacao do tipo da OP (Firme/Prevista)
Cesar Valadao 27/04/99XXXXXXInclusao do P.Ent MT220GRV, Apos GRV    
Rodrigo Sarto.12/07/99xxxxxxRevisao Locks                           
Rodrigo Sarto.25/07/99xxxxxxAcerto Localizacao Fisica               
Fernando Joly 06/04/9923138AAcerto na Mov. de Localizacao.          
ٱ

15
*/
Function MATA220(xRotAuto,xOpcAuto)

Local cFiltro	   := ""
Private l220Auto   := (xRotAuto <> NIL)
Private aRotAuto   := xRotAuto
Private nOpcAuto   := xOpcAuto
//Ŀ
// Define Array contendo as Rotinas a executar do programa      
// ----------- Elementos contidos por dimensao ------------     
// 1. Nome a aparecer no cabecalho                              
// 2. Nome da Rotina associada                                  
// 3. Usado pela rotina                                         
// 4. Tipo de Transao a ser efetuada                          
//    1 -Pesquisa e Posiciona em um Banco de Dados              
//    2 -Simplesmente Mostra os Campos                          
//    3 -Inclui registros no Bancos de Dados                    
//    4 -Altera o registro corrente                             
//    5 -Estorna registro selecionado gerando uma contra-partida
//
PRIVATE aRotina := MenuDef()

//Ŀ
// Define o cabecalho da tela de atualizacoes                   
//
PRIVATE cCadastro:=OemToAnsi(STR0006)   //"Saldos Iniciais"

//Ŀ
// Utilizados no controle de lotes iniciais / grade             
//
PRIVATE aLotesIni := {}
PRIVATE oListaProd
PRIVATE cProdAtu
PRIVATE cLocAtu

//Ŀ
// Endereca a funcao de BROWSE                                  
//
If l220Auto
	MsRotAuto(If(nOpcAuto!=Nil,nOpcAuto,3),aRotAuto,"SB9")
Else
	If (ExistBlock("M220FILB"))
		cFiltro := AllTrim(ExecBlock("M220FILB",.F.,.F.))
		If Valtype(cFiltro) <> "C"
			cFiltro := ""
		EndIf
	EndIf
	mBrowse( 6, 1,22,75,"SB9",,,,,,,,,,,,,, IF(!Empty(cFiltro), cFiltro, NIL))
EndIf

dbSelectArea("SB9")
Return NIL

/*

Ŀ
Funo    A220Inclui Autor  Eveli Morasco          Data  25/02/92 
Ĵ
Descrio  Programa para digitacao dos saldos iniciais dos almoxari-  
           fados                                                      
Ĵ
Sintaxe    A220Inclui(ExpC1,ExpN1,ExpN2)                              
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Numero da opcao selecionada                        
Ĵ
 Uso       MATA220                                                    
ٱ


*/
FUNCTION A220Inclui(cAlias,nReg,nOpc)
LOCAL nOpca     := 0
Local nLin      := 0
Local nCol      := 0
Local cRefer    := ""
Local cLocal 	:= ""
Local cMoeda	:= ""
Local aRecnos   := {}
Local aButtons  := {}
Local oSize
Private oGetDad
Private oGetMan
PRIVATE lGrade  := MaGrade()
PRIVATE aHeader := {}
PRIVATE aHeadBk := {}

//Ŀ
// Adiciona botao para captar os lotes iniciais.        
//
aAdd(aButtons, {"PRODUTO",{||A220GetLot()},STR0028+" - <F7> ",STR0029} )
SetKey( VK_F7 , { || A220GetLot() } )

//Ŀ
// Cria Ambiente/Objeto para tratamento de grade        
//
PRIVATE oGrade	  := MsMatGrade():New("oGrade",,"B9_QINI",,"aVldGr220()",, ;
										{{"B9_QINI"		,.T. ,{	{"B9_QISEGUM"	,{|| ConvUm(AllTrim(oGrade:GetNameProd(,nLinha,nColuna)),oGrade:aColsFieldByName("B9_QINI",1,nLinha,nColuna),oGrade:aColsFieldByName("B9_QISEGUM",1,n,nColuna),2) } }},.T. },;
										{"B9_QISEGUM"	,NIL ,{	{"B9_QINI"		,{|| ConvUm(AllTrim(oGrade:GetNameProd(,nLinha,nColuna)),oGrade:aColsFieldByName("B9_QINI",1,nLinha,nColuna),oGrade:aColsFieldByName("B9_QISEGUM",1,n,nColuna),1) } }},.F. },;
										{"B9_VINI1"	,NIL ,NIL},;
										{"B9_VINI2"	,NIL ,NIL},;
										{"B9_VINI3"	,NIL ,NIL},;
										{"B9_VINI4"	,NIL ,NIL},;
										{"B9_VINI5"	,NIL ,NIL},;
										{"B9_CUSTD"	,NIL ,NIL},;
										{"B9_CM1"	    ,NIL ,NIL},;
										{"B9_CM2"	    ,NIL ,NIL},;
										{"B9_CM3"	    ,NIL ,NIL},;
										{"B9_CM4"	    ,NIL ,NIL},;
										{"B9_CM5"	    ,NIL ,NIL};
										})
If ( Type("l220Auto") == "U" )
	Private l220Auto := .F.
EndIf

dbSelectArea("SB9")

If ( l220Auto )
	nOpca := AxIncluiAuto(cAlias,"A220TudoOk(1)",Nil,nOpc)
Else
	nOpca := AxInclui(cAlias,nReg,nOpc,,,,"A220TudoOk(1)",,,aButtons)
Endif

If nOpca == 1
	Begin Transaction

		dbSelectArea("SB9")
		cRefer := B9_COD
		cLocal := B9_LOCAL
		cMoeda := B9_MCUSTD
		aAdd(aRecnos,Recno())

		If MatGrdPrrf(@cRefer)
			For nLin :=1 to Len(oGrade:aColsGrade[1])
				For nCol :=2 to Len(oGrade:aHeadGrade[1])
					If oGrade:aColsFieldByName("B9_QINI",1,nLin,nCol) > 0
						RecLock("SB9",.T.)
						Replace B9_FILIAL With xFilial("SB9")
						Replace B9_COD With oGrade:GetNameProd(cRefer,nLin,nCol)
						Replace B9_LOCAL With cLocal
						Replace B9_MCUSTD with cMoeda
						Replace B9_QINI With oGrade:aColsFieldByName("B9_QINI",1,nLin,nCol)
						Replace B9_QISEGUM With oGrade:aColsFieldByName("B9_QISEGUM",1,nLin,nCol)
						Replace B9_VINI1 With oGrade:aColsFieldByName("B9_VINI1",1,nLin,nCol)
						Replace B9_VINI2 With oGrade:aColsFieldByName("B9_VINI2",1,nLin,nCol)
						Replace B9_VINI3 With oGrade:aColsFieldByName("B9_VINI3",1,nLin,nCol)
						Replace B9_VINI4 With oGrade:aColsFieldByName("B9_VINI4",1,nLin,nCol)
						Replace B9_VINI5 With oGrade:aColsFieldByName("B9_VINI5",1,nLin,nCol)
						Replace B9_CUSTD With oGrade:aColsFieldByName("B9_CUSTD",1,nLin,nCol)
						Replace B9_CM1 With oGrade:aColsFieldByName("B9_CM1",1,nLin,nCol)
						Replace B9_CM2 With oGrade:aColsFieldByName("B9_CM2",1,nLin,nCol)
						Replace B9_CM3 With oGrade:aColsFieldByName("B9_CM3",1,nLin,nCol)
						Replace B9_CM4 With oGrade:aColsFieldByName("B9_CM4",1,nLin,nCol)
						Replace B9_CM5 With oGrade:aColsFieldByName("B9_CM5",1,nLin,nCol)
						MsUnLock()
						aAdd(aRecnos,Recno())
					EndIf
				Next nCol
			Next nLin
			dbGoTo(aRecnos[1])
			RecLock("SB9",.F.)
			dbDelete()
			MsUnLock()
			aDel(aRecnos,1)
			aSize(aRecnos,Len(aRecnos)-1)
		EndIf

		//Ŀ
		// Atualizar saldos do SB2.                                     
		//
		For nLin := 1 To Len(aRecnos)
			dbGoTo(aRecnos[nLin])
			A220ATUSB2(,,,,,nOpc, nOpcA)
		Next nLin

	End Transaction

	dbSelectArea( cAlias )
EndIf

SetKey(VK_F7,Nil)

//Ŀ
//Protecao para nao deixar sujeira na variavel apos a execucao da rotina 
//
If ( Type("aLotesIni") == "A" )
	aLotesIni := {}
EndIf
Return

/*

Ŀ
Funo    A220Altera Autor  Jose Lucas             Data  28/03/94 
Ĵ
Descrio  Programa para digitacao dos saldos iniciais dos almoxari-  
           fados                                                      
Ĵ
Sintaxe    A220Altera(ExpC1,ExpN1,ExpN2)                              
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Numero da opcao selecionada                        
Ĵ
 Uso       MATA220                                                    
ٱ


*/
FUNCTION A220Altera(cAlias,nReg,nOpc)
LOCAL nOpca
LOCAL nRecOrig := SB9->(Recno())
LOCAL cSeek    := SB9->B9_FILIAL+SB9->B9_COD+SB9->B9_LOCAL
LOCAL lRet     := .T.
LOCAL aButtons := {}

//Ŀ
// Adiciona botao para captar os lotes iniciais.        
//
aAdd(aButtons, {"PRODUTO",{||A220GetLot()},STR0028+" - <F7> ",STR0029} )
SetKey( VK_F7 , { || A220GetLot() } )

If ( Type("l220Auto") == "U" )
	Private l220Auto := .F.
EndIf

dbSelectArea("SD3")
dbSetOrder(3)
If SD3->(DbSeek(xFilial("SD3")+SB9->B9_COD+SB9->B9_LOCAL))
	Aviso(STR0010,STR0036,{"OK"})
	lRet := .F.
EndIf

dbSelectArea("SB9")
If !Empty(SB9->B9_DATA)
	Help(" ",1,"A220FEC")
Else
	//-- Nao alterar se ja houver outra movimentacao
	dbSetOrder(1)
	dbSkip()
	If SB9->B9_FILIAL+SB9->B9_COD+SB9->B9_LOCAL == cSeek
		Aviso(STR0010,STR0011,{"OK"})
		lRet := .F.
	EndIf
	dbGoto(nRecOrig)

	If lRet
		If ( l220Auto )
			nOpca := AxIncluiAuto(cAlias,"A220TudoOk(2)",Nil,nOpc,nReg)
		Else
			nOpca := AxAltera(cAlias,nReg,nOpc,,,,,"A220TudoOk(2)",,,aButtons)
		Endif
		If nOpca == 1
			Begin Transaction
				//Ŀ
				// Atualizar saldos do SB2.                                     
				//
				A220ATUSB2(,,,,,nOpc, nOpcA)
			End Transaction
			dbSelectArea( cAlias )
		EndIf
	EndIf
EndIf

SetKey(VK_F7,Nil)

//Ŀ
//Protecao para nao deixar sujeira na variavel apos a execucao da rotina 
//
If ( Type("aLotesIni") == "A" )
	aLotesIni := {}
EndIf

Return

/*

Ŀ
Funo    A220Deleta Autor  Eveli Morasco          Data  25/02/92 
Ĵ
Descrio  Programa de exclusao de Produtos                           
Ĵ
Sintaxe    A220Deleta(ExpC1,ExpN1,ExpN2)                              
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Numero da opcao selecionada                        
Ĵ
 Uso       MATA220                                                    
ٱ


*/
Function A220Deleta(cAlias,nReg,nOpc)
Local aAreaAnt   := GetArea()
Local aAreaSD1   := SD1->(GetArea())
Local aAreaSD2   := SD2->(GetArea())
Local aAreaSD3   := SD3->(GetArea())
Local aLocaliz   := {}
Local aDelSDA    := {}
Local aDelSD5    := {}
Local aParam 	 := {{|| .T.}, {|| A220TudoOk(3)}, {|| .T.}, {|| .T.}}
Local cSeek      := ''
Local cCod       := ''
Local cLocal     := ''
Local cProduto   := ''
Local lRet       := .T.
Local lRastro    := .F.
Local lLocaliz   := .F.
Local nOpcA      := 0
Local nRecno     := 0
Local nX         := 0
Local aPPIDelete := {}
Local nSaldo     := 0

dbSelectArea('SB9')
cFil     := B9_FILIAL
cProduto := B9_COD
cLocal   := B9_LOCAL
nRecno   := Recno()
lRastro  := Rastro(SB9->B9_COD)
lLocaliz := Localiza(SB9->B9_COD)

//-- Nao exclui Movimentacoes geradas pela Virada de Saldos
If !Empty(SB9->B9_DATA)
	Help(' ',1,'A220FEC')
	Return .F.
EndIf

Begin Transaction

	//Ŀ
	//Abre tela de exduso  
	//
	nOpcA:= AxDeleta(cAlias,nReg,nOpc,,,,aParam,aRotAuto)

	IF nOpcA == 2

		//-- Nao exclui se ja houver outra movimentacao
		dbSkip()
		If SB9->B9_FILIAL + SB9->B9_COD  + SB9->B9_LOCAL == cFil + cProduto + cLocal
			Help(' ', 1, 'A220MOV')
			lRet := .F.
		EndIf
		dbGoto(nRecno)

		//-- Nao Exclui se NAO tiver movimentacao no SB2
		If lRet
			dbSelectArea('SB2')
			dbSetOrder(1)
			If !dbSeek(xFilial('SB2')+SB9->B9_COD+SB9->B9_LOCAL, .F.)
				lRet := .F.
			EndIf
		EndIf

		//-- Nao Exclui se tiver movimentacao no SD1
		If lRet
			dbSelectArea('SD1')
			aAreaSD1 := GetArea()
			dbSetOrder(5)
			If dbSeek(xFilial('SD1')+SB2->B2_COD+SB2->B2_LOCAL, .F.)
				lRet := .F.
				Help(' ', 1, 'A220MOV')
			EndIf
		EndIf

		//-- Nao Exclui se tiver movimentacao no SD2
		If lRet
			dbSelectArea('SD2')
			aAreaSD2 := GetArea()
			dbSetOrder(1)
			If dbSeek(xFilial('SD2')+SB2->B2_COD+SB2->B2_LOCAL, .F.)
				lRet := .F.
				Help(' ', 1, 'A220MOV')
			EndIf
		EndIf

		//-- Nao Exclui se tiver movimentacao no SD3
		If lRet
			dbSelectArea('SD3')
			aAreaSD3 := GetArea()
			dbSetOrder(3)
			If dbSeek(xFilial('SD3')+SB2->B2_COD+SB2->B2_LOCAL, .F.)
				lRet := .F.
				Help(' ', 1, 'A220MOV')
			EndIf
		EndIf

		// Verifica se existe movimentacoes que impecam a exclusao
		If lRet .And. lRastro
			aDelSD5 := {}
			If ExistMov(SB9->B9_COD, SB9->B9_LOCAL, aDelSD5)
				Help(' ', 1, 'A220MOV')
				lRet := .F.
			EndIf
		EndIf

		//-- Impede Excluses quando produdo ja tiver sido distribuido
		//-- ou quando gerou manutencao de lotes
		aDelSDA  := {}
		aLocaliz := ExistSDA(SB9->B9_COD, SB9->B9_LOCAL)
		If lRet .And. lLocaliz .And. aLocaliz[1]
			If aLocaliz[2] == "SD5" .And. Empty(aDelSD5) // Significa que NAO teve origem no saldo inicial, entao NAO pode apagar.
				lRet := .F.
				Help(' ', 1, 'A220MOV')
			ElseIf SDA->DA_QTDORI == SDA->DA_SALDO
				// Armazena o registro a ser excluido da SDA
				aAdd(aDelSDA, SDA->DA_PRODUTO)
				aAdd(aDelSDA, SDA->DA_LOCAL)
				aAdd(aDelSDA, SDA->DA_NUMSEQ)
			Else // Saldo ja foi distribuido. Impossivel excluir o saldo inicial
				lRet := .F.
				Help(' ', 1, 'SDAJADISTR')
			EndIf
		EndIf

		If lRet

			//Ŀ
			// Excluir saldo a enderecar.                 
			//
			If lLocaliz .And. Len(aDelSDA) > 0
				DeletSDA(aDelSDA[1], aDelSDA[2], aDelSDA[3])
			EndIf

			//Ŀ
			// Excluir o(s) lote(s) do saldo inicial.     
			//
			If lRastro .And. Len(aDelSD5) > 0
				// Exclusao da movimentacao na SD5 //
				For nX := 1 to Len(aDelSD5)
					MSExecAuto({|x,y| Mata390(x,y)}, aDelSD5[nX], 5)
				Next nX
			EndIf

			//Ŀ
			// Excluir Saldos no SB2 se nao existir qtd   
			// empenhada, reservada ou prevista p/ entrar 
			//
			dbSelectArea('SB2')
			dbSetOrder(1)
			If dbSeek(xFilial('SB2')+cProduto+cLocal, .F.)
				If !(B2_QEMP > 0 .Or. B2_SALPEDI > 0 .Or. B2_RESERVA > 0)

					// Integrao PPI
					aPPIDelete := {SB2->(Recno())}
					nSaldo     := SB2->B2_QATU

					RecLock('SB2', .F., .T.)
					dbDelete()
					MsUnlock()
					//Ŀ
					// Ponto de Entrada Executado Apos a Atualizacao de Todos os Arqs. 
					//
					If ExistBlock('MT220GRV')
						ExecBlock('MT220GRV', .F., .F.,{nOpc, nOpcA})
					EndIf

					// Integrao PPI
					A220PPI(cProduto, cLocal, nSaldo, 'delete', aPPIDelete)
				Else
					//Ŀ
					// Atualizar saldos do SB2.                                     
					//
					A220ATUSB2(,,.F.,.F.,.T.,nOpc,nOpcA)
				EndIf
			EndIf

		EndIf

		//Ŀ
		//Defaz a transao caso encontre alguma inconsistencia.
		//
		If !lRet
			DisarmTransaction()
		EndIf
	EndIf
End Transaction

RestArea(aAreaSD1)
RestArea(aAreaSD2)
RestArea(aAreaSD3)
RestArea(aAreaAnt)

dbSelectArea('SB9')

Return lRet

/*

Ŀ
Funo    A220Desc   Autor  Marcos Bregantim       Data  01/06/93 
Ĵ
Descrio  Mostra a descricao do produto (SB1)                        
Ĵ
 Uso       MATA220                                                    
ٱ


*/
Function A220Desc()
Local lRetorna := .T.,cAlias:=Alias()

dbSelectArea( "SB1" )
dbSeek( cFilial+M->B9_COD )

dbSelectArea( cAlias )
Return lRetorna

/*

Ŀ
Funo    A220Visual Autor  Marcos Bregantim       Data  01/06/93 
Ĵ
Descrio  Visualizacao dos Saldos em estoque                         
Ĵ
Sintaxe    A220Visual(ExpC1,ExpN1,ExpN2)                              
Ĵ
Parametros ExpC1 = Alias do arquivo                                   
           ExpN1 = Numero do registro                                 
           ExpN2 = Numero da opcao selecionada                        
Ĵ
 Uso       MATA220                                                    
ٱ


*/
FUNCTION A220Visual(cAlias,nReg,nOpc)

dbSelectArea("SB1")
dbSeek( cFilial+SB9->B9_COD )

dbSelectArea(cAlias)
nOpca := AxVisual(cAlias,nReg,nOpc,,4,SB1->B1_DESC)
Return

/*

Ŀ
Funo    A220IniCpo Autor  Eveli Morasco          Data  25/02/92 
Ĵ
Descrio  Verifica existencia do produto digitado e inicializa campo 
           da segunda unidade de medida.                              
Ĵ
 Uso       MATA220                                                    
ٱ

*/
Function A220IniCpo()
Local aAreaAnt := {}
Local lRet     := .T.

If !MatGrdPrrf(M->B9_COD)
	//Ŀ
	// Verifica se o produto existe 
	//
	If !Empty(M->B9_COD) .And. !ExistCpo("SB1", M->B9_COD)
		lRet := .F.
	EndIf

	//Ŀ
	// Verifica se jah existe algum saldo inicial cadastrado para este Produto/Local 
	//
	If lRet .And. (!Empty(M->B9_COD) .And. !Empty(M->B9_LOCAL))
		If !ExistChav("SB9",M->B9_COD+M->B9_LOCAL)
			lRet := .F.
		EndIf
	EndIf

	//Ŀ
	// Impede a inclusao de Saldos Iniciais para produtos que jah tenham saldo 
	//
	If lRet .And. (INCLUI .and. !Empty(M->B9_COD) .And. !Empty(M->B9_LOCAL))
		aAreaAnt := GetArea()
		dbSelectArea('SB2')
		dbSetOrder(1)
		If MsSeek(xFilial('SB2')+M->B9_COD+M->B9_LOCAL, .F.)
			If QtdComp(SaldoSB2())>QtdComp(0) .Or. (Localiza(M->B9_COD) .And. QtdComp(SB2->B2_QACLASS)>QtdComp(0))
				Aviso(STR0010,STR0014,{'Ok'})
				lRet := .F.
			EndIf
		EndIf
		RestArea(aAreaAnt)
	EndIf
EndIf
Return lRet

/*

Ŀ
Funo    A220SegUm  Autor  Eveli Morasco          Data  25/02/92 
Ĵ
Descrio  Calcula e inicializa segunda unidade de medida             
Ĵ
 Uso       MATA220                                                    
ٱ


*/
Function A220SegUm()
LOCAL nEndereco,nEnd1,nEnd2,nX
LOCAL aLocaliz:={}

If M->B9_QINI < 0
	Help(" ",1,"A220NEG")
	dbSelectArea("SB9")
	Return .F.
EndIf

//-- Impede Alteraoes quando produdo ja tiver sido distribuido
//-- ou quando gerou manutencao de lotes
aLocaliz:=ExistSDA(M->B9_COD,M->B9_LOCAL)
If Localiza(M->B9_COD) .And. aLocaliz[1]
	If aLocaliz[2] == "SD5"
		dbSelectArea('SB9')
		Return .F.
	ElseIf SDA->DA_QTDORI # SDA->DA_SALDO
		Help(' ', 1, 'SDAJADISTR')
		dbSelectArea('SB9')
		Return .F.
	EndIf
EndIf

dbSelectArea("SB1")
dbSelectArea("SB9")
dbSeek( cFilial+M->B9_COD+M->B9_LOCAL )
dbSelectArea("SB9")
//Ŀ
// Gravar qtde da seg. unidade de medida SB2. 
//
If SB1->B1_CONV != 0
	M->B9_QISEGUM := ConvUm(M->B9_COD,M->B9_QINI,M->B9_QISEGUM,2)
	nEndereco := Ascan(aGets,{ |x| Subs(x,9,10) == "B9_QISEGUM" } )
	If nEndereco > 0
		nEnd1 := Val(Subs(aGets[nEndereco],1,2))
		nEnd2 := Val(Subs(aGets[nEndereco],3,1))*2
		aTela[nEnd1][nEnd2] := Trans(M->B9_QISEGUM,trim(X3Picture('B9_QISEGUM')))
		For nX := 1 To 5
			A220Cm(Str(nX,1),M->B9_COD,M->B9_LOCAL)
		Next nX
		If M->B9_QINI == 0
			For nX := 1 To 5
				A220Vatu(Str(nX,1),M->B9_COD,M->B9_LOCAL)
			Next nX
		EndIf
	EndIf
EndIf
Return .T.

/*

Ŀ
Funo    A220PriUm  Autor  Eveli Morasco          Data  25/02/92 
Ĵ
Descrio  Calcula e inicializa a primeira unidade de medida          
Ĵ
 Uso       MATA220                                                    
ٱ


*/
Function A220PriUm()
LOCAL nEndereco,nEnd1,nEnd2,nX

If Empty(M->B9_QISEGUM)
	Return .T.
EndIf

dbSelectArea("SB1")
dbSeek( cFilial+M->B9_COD )
dbSelectArea("SB9")
//Ŀ
// Gravar qtde Atual com base Seg.Um  SB2.    
//
If SB1->B1_CONV != 0
	M->B9_QINI := ConvUm(M->B9_COD,M->B9_QINI,M->B9_QISEGUM,1)
	nEndereco := Ascan(aGets,{ |x| Subs(x,9,7) == "B9_QINI" } )
	If nEndereco > 0
		nEnd1 := Val(Subs(aGets[nEndereco],1,2))
		nEnd2 := Val(Subs(aGets[nEndereco],3,1))*2
		aTela[nEnd1][nEnd2] := Trans(M->B9_QINI,trim(X3Picture('B9_QINI')))
		For nX := 1 To 5
			A220Cm(Str(nX,1),M->B9_COD,M->B9_LOCAL)
		Next nX
		If M->B9_QINI == 0
			For nX := 1 To 5
				A220Vatu(Str(nX,1),M->B9_COD,M->B9_LOCAL)
			Next nX
		EndIf
	EndIf
EndIf
Return .T.

/*

Ŀ
Funo     A220Cm    Autor  Eveli Morasco          Data  25/02/92 
Ĵ
Descrio  Calcula o custo medio de acordo com valores informados     
Ĵ
Sintaxe    A220Cm(ExpC1)                                              
Ĵ
Parametros ExpC1 = Qual moeda ele devera calcular                     
Ĵ
 Uso       MATA220                                                    
ٱ


*/
Function A220Cm(cQual,cCodigo,cLocal)
LOCAL nV,bBloco,nEndereco,nEnd1,nEnd2
bBloco := { |nV| Trim(nV)+cQual }

cQual := Subs(cQual,1,1)
If !cQual$"12345"
	cQual := "1"
EndIf

dbSelectArea("SB2")
IF dbSeek (cFilial + cCodigo + cLocal )
	RecLock("SB2",.F.)
	If &(Eval(bBloco,"SB2->B2_VATU")) < 0
		Help(" ",1,"A220NEG")
		MsUnlock()
		Return .F.
	EndIf
	If SB2->B2_QATU == 0
		&(Eval(bBloco,"SB2->B2_CMFIM")) := &(Eval(bBloco,"SB2->B2_CM"))
	Else
		&(Eval(bBloco,"SB2->B2_CM")) := &(Eval(bBloco,"SB2->B2_VATU")) / SB2->B2_QATU
		&(Eval(bBloco,"SB2->B2_CMFIM")) := &(Eval(bBloco,"SB2->B2_CM"))
	EndIf
	MsUnLock()
Endif
dbSelectArea("SB9")
Return .T.

/*

Ŀ
Funo    A220Vatu   Autor  Eveli Morasco          Data  25/02/92 
Ĵ
Descrio  Calcula o valor total do estoque de acordo com custo medio 
Ĵ
 Uso       MATA220                                                    
ٱ


*/
Function A220Vatu(cQual,cCodigo,cLocal)
LOCAL nV,bBloco,nEndereco,nEnd1,nEnd2
bBloco := { |nV| Trim(nV)+cQual }

cQual := Subs(cQual,1,1)
If !cQual$"12345"
	cQual := "1"
EndIf

dbSelectArea("SB2")
dbSeek (cFilial + cCodigo + cLocal )
IF !Eof()
	RecLock("SB2",.F.)
	If &(Eval(bBloco,"SB2->B2_CM")) < 0
		Help(" ",1,"A220NEG")
		MsUnlock()
		Return .F.
	EndIf
	&(Eval(bBloco,"SB2->B2_VATU")) := &(Eval(bBloco,"SB2->B2_CM")) * SB2->B2_QATU
	dbSelectArea("SB9")
	MsUnlock()
Endif
Return .T.

/*

Ŀ
Funo    A220AtuSB2 Autor  Marcos Bregantim       Data  20/03/95 
Ĵ
Descrio  Atualizacao do SB2                                         
Ĵ
Sintaxe    A220AtuSB2()                                               
Ĵ
 Uso       MATA220                                                    
ٱ


*/
Function A220ATUSB2(cCod,cLocal,lShowHelp,lCriaSDA,lExclui,nOpc,nOpcA)
Local aSaldo
Local aLocaliz	:= {}
Local nX		:= 0
Local cTipo		:= ""
Local cDescricao:= ""

Default lExclui := .F.
Default nOpc 	:= 0
Default nOpcA := 0

lCusFIFO  := SuperGetMV("MV_CUSFIFO",.F.,.F.)
lCusLIFO  := SuperGetMv('MV_CUSLIFO',.F.,.F.)

If ( Type("l220Auto") == "U" )
	Private l220Auto := .F.
EndIf

cCod     :=IF(cCod              ==Nil,SB9->B9_COD,cCod)
cLocal   :=IF(cLocal            ==Nil,SB9->B9_LOCAL,cLocal)
lShowHelp:=If(valtype(lShowHelp)=="L",lShowHelp,.T.)
lCriaSDA :=If(valtype(lCriaSDA) =="L",lCriaSDA,.T.)

aSaldo := CalcEst(cCod,cLocal,Ctod("31/12/49","ddmmyy"))

dbSelectArea("NNR")
dbSetOrder(1)
If(DbSeek(FWxFilial("NNR")+cLocal))
	cDescricao := NNR_DESCRI; cTipo	:= NNR_TIPO
Endif

dbSelectArea("SB2")
dbSeek( xFilial("SB2")+cCod+cLocal)
If Found()
	RecLock("SB2",.F.)
Else
	RecLock("SB2",.T.)
	Replace B2_FILIAL With cFilial, B2_COD With cCod, B2_LOCAL  With cLocal
	Replace B2_LOCALIZ With cDescricao, B2_TIPO With cTipo
EndIf

Replace B2_QATU  With aSaldo[1] , B2_QTSEGUM With aSaldo[7],;
		B2_VATU1 With aSaldo[2] , B2_VATU2   With aSaldo[3],;
		B2_VATU3 With aSaldo[4] , B2_VATU4   With aSaldo[5],;
		B2_VATU5 With aSaldo[6] , B2_CM1	 With aSaldo[8] ,;
		B2_CM2	 With aSaldo[9] , B2_CM3	 With aSaldo[10] ,;
		B2_CM4   With aSaldo[11], B2_CM5	 With aSaldo[12]

//Flag para enviar mensagem de atualizacao de estoque 
If SB2->(ColumnPos("B2_DMOV")) > 0
	Replace	B2_DMOV With dDataBase
EndIf

If SB2->(ColumnPos("B2_HMOV")) > 0
	Replace	B2_HMOV With Time() 
EndIf

MsUnlock()

//Ŀ
//Atualiza o custo unificado ON-LINE                     
//
B2AtuUnif(SB2->B2_COD)

If (lCusFIFO .Or. lCusLIFO) .And. lShowHelp
	If ! l220Auto
		Help(" ",1,"A220CUSTO")
	EndIf
EndIf

If Localiza(SB9->B9_COD) .And. !Rastro(SB9->B9_COD)
	//-- Impede Alteraoes quando produdo ja tiver sido distribuido
	//-- ou quando gerou manutencao de lotes
	aLocaliz   := ExistSDA(cCod,cLocal)
	If aLocaliz[1]
		If SDA->DA_QTDORI # SDA->DA_SALDO .And. lShowHelp
			If ! l220Auto
				Help(' ', 1, 'SDAJADISTR')
			EndIf
		Else
			If lCriaSDA
				DeletSDA(SDA->DA_PRODUTO, SDA->DA_LOCAL, SDA->DA_NUMSEQ)
				CriaSDA("SB9")
			EndIf
		EndIf
	Else
		If lCriaSDA .And. SB9->B9_QINI > 0
			CriaSDA("SB9")
		EndIf
	EndIf
EndIf

For nX := 1 To 5
	A220Cm(Str(nX,1),cCod,cLocal)
Next nX

If SB9->B9_QINI == 0
	For nX := 1 To 5
		A220Vatu(Str(nX,1),cCod,cLocal)
	Next nX
EndIf

//Ŀ
// Atualizar movimentacao de lote (SD5) para o produto          
// Somente sera executada se nao for exclusao do saldo inicial  
//
If !lExclui .And. !l220Auto
	A220AtuSD5(SB9->B9_COD, SB9->B9_LOCAL)
EndIf

//Ŀ
// Ponto de Entrada Executado Apos a Atualizacao de Todos os Arqs. 
//
If ExistBlock("MT220GRV")
	ExecBlock("MT220GRV", .F., .F., {nOpc, nOpcA})
EndIf

// Integrao com TOTVS MES
A220PPI(cCod, cLocal, aSaldo[1])

Return(.T.)

/*

Ŀ
Funo     ExistSDA  Autor  Fernando Joly Siquini  Data  05/08/99 
Ĵ
Descrio  Verifica se existe registro com Saldo Inicial no SDA       
Ĵ
Sintaxe    ExistSDA(ExpC1, ExcC2)                                     
Ĵ
Parametros ExpC1 = Codigo do Produto                                  
           ExpC2 = Local do Produto                                   
Ĵ
Uso        Generico                                                   
ٱ

*/
Function ExistSDA(cProduto, cLocal)

Local aRet       := {.F.,""}
Local cSeek      := ''
Local nOrdSDA    := SDA->(IndexOrd())
Local nRecSDA    := SDA->(Recno())

SDA->(dbSetOrder(1))
If SDA->(dbSeek(cSeek := xFilial('SDA') + cProduto + cLocal, .F.))
	Do While !SDA->(Eof()) .And. cSeek == SDA->DA_FILIAL+SDA->DA_PRODUTO+SDA->DA_LOCAL
		If SDA->DA_ORIGEM == "SB9" .Or. SDA->DA_ORIGEM == "SD5"
			aRet := {.T.,SDA->DA_ORIGEM}
			nRecSDA := SDA->(Recno())
			Exit
		EndIf
		SDA->(dbSkip())
	EndDo
EndIf
SDA->(dbSetOrder(nOrdSDA))
SDA->(dbGoto(nRecSDA))
Return aRet

/*

Ŀ
Funo     DeletSDA  Autor  Fernando Joly Siquini  Data  05/08/99 
Ĵ
Descrio  Deleta Registros no SDA, SDB e SBF                         
Ĵ
Sintaxe    DeletSDA(ExpC1, ExcC2, ExpC3)                              
Ĵ
Parametros ExpC1 = Codigo do Produto                                  
           ExpC2 = Local do Produto                                   
           ExpC3 = Sequencia da Movimentacao                          
Ĵ
Uso        Generico                                                   
ٱ


*/
Function DeletSDA(cProduto, cLocal, cNumSeq)
Local cSeekSDA   := ''
Local cSeekSDB   := ''
Local aAreaAnt   := GetArea()
Local lRet       := .T.

dbSelectArea('SDA')
dbSetOrder(1)
If dbSeek(cSeekSDA := xFilial('SDA') + cProduto + cLocal, .F.)
	Begin Transaction
		Do While !SDA->(Eof()) .And. cSeekSDA == DA_FILIAL + DA_PRODUTO + DA_LOCAL
			If DA_ORIGEM == "SB9" .Or. SDA->DA_ORIGEM == "SD5"
				dbSelectArea('SDB')
				dbSetorder(1)
				If dbSeek(cSeekSDB := xFilial('SDB') + SDA->DA_PRODUTO + SDA->DA_LOCAL + SDA->DA_NUMSEQ, .F.)
					While !SDB->(Eof()) .And. cSeekSDB == DB_FILIAL + DB_PRODUTO + DB_LOCAL + DB_NUMSEQ
						If DB_ESTORNO == 'S'
							RecLock('SDB')
							dbDelete()
							MsUnlock()
						EndIf
						SDB->(dbSkip())
					EndDo
				EndIf
				dbSelectArea("SB2")
				If MsSeek( xFilial("SB2")+cProduto+cLocal ) .And. SDA->DA_SALDO > 0
					RecLock("SB2",.F.)
					Replace B2_QACLASS With B2_QACLASS - SDA->DA_SALDO
					MsUnlock()
				EndIf
				RecLock('SDA')
				dbDelete()
				MsUnlock()
			EndIf
			SDA->(dbSkip())
		EndDo
	End Transaction
EndIf
RestArea(aAreaAnt)
Return lRet

/*


ͻ
Programa  A220TudoOkAutor  Flavio Luiz Vicco    Data   11/01/06   
͹
Desc.      Programa que faz consistencias apos a digitacao da tela    
                                                                      
͹
Uso        MATA220                                                    
ͼ

*/
Function A220TudoOk(nTipo)
Local nX
Local nV
Local cQual
Local aAreaAnt  := GetArea()
Local aAreaSB8  := SB8->(GetArea())
Local bBloco	:= { |nV| Trim(nV)+cQual }
Local lRet		:= .T.
Local lRastro   := If(nTipo<>3,Rastro(M->B9_COD),.F.)
Local cPictSB9  := PesqPict('SB9', 'B9_QINI')
Local cLocProc  := GetMvNNR('MV_LOCPROC','99')

DEFAULT nTipo	:= 1

If nTipo != 3 .And. SuperGetMv("MV_WMSNEW",.F.,.F.) .And. QtdComp(M->B9_QINI) != QtdComp(0) .And. IntWms(M->B9_COD)
	Help(,1,"SIGAWMS",,STR0035,1,0) // "Produto informado possui controle WMS, no  possvel utilizar esta operao."
	lRet := .F.
EndIf

//Ŀ
// Verifica a permissao do armazem. 
//
If lRet
	If Inclui .OR. Altera
		lRet := MaAvalPerm(3,{M->B9_LOCAL,M->B9_COD})
	Else
		lRet := MaAvalPerm(3,{B9_LOCAL,B9_COD})
	EndIf
EndIf

If lRet .And. ExistBlock("MT220TOK")
	lRetPE := ExecBlock("MT220TOK", .F., .F.,{nTipo})
	If ValType(lRetPE) == "L"
		lRet := lRetPE
	EndIf
EndIf

//Ponto de Entrada Executado Apos a Atualizacao de Todos os Arqs.
If  lRet .And. ExistTemplate("MT220TOK")
	lRetPE := ExecTemplate("MT220TOK", .F., .F.,{nTipo,M->B9_COD})
	If ValType(lRetPE) == "L"
		lRet := lRetPE
	EndIf
EndIf

// se for inclusao ou alteracao
If nTipo<>3

	// Valida se o produto  fantasma
	lRet := lRet .And. !Empty(M->B9_COD) .and. A220VFanta(M->B9_COD)

	If lRet .And. !Empty(M->B9_DATA) 
		Help(" ",1,"A220DTSALDO")
		lRet := .F.
	EndIf

	If lRet .And. M->B9_QINI == 0
		For nX := 1 To 5
			cQual := Str(nX,1)
			If &(Eval(bBloco,"M->B9_VINI")) > 0
				lRet := .F.
				Help(" ",1,"A220QINI")
				Exit
			EndIf
		Next
	EndIf

	If lRet .And. lRastro
		dbSelectArea("SB8")
		dbSetOrder(1)
		If dbSeek(xFilial("SB8")+M->B9_COD+M->B9_LOCAL)
			If SB8->B8_SALDO > 0
				Help(" ",1,"JAGRAVADO")
				lRet := .F.
			EndIf
		EndIf
	EndIf

	If lRet .And. MatGrdPrrf(M->B9_COD)
		If Empty(oGrade:nQtdGrade) .And. !Empty(M->B9_QINI)
			Aviso(STR0010,STR0012 +RetTitle("B9_QINI") +STR0013,{"Ok"})
			lRet := .F.
		EndIf
	EndIf

	//Ŀ
	//Nova consistencia para os produtos que usam rastro.
	//O usuario devera informar obrigatoriamente o(s)    
	//lote(s) para evitar desbalanceamento de saldo.     
	//
	If lRet .And. !l220Auto
		If !A220VLtIni()
			lRet := .F.
		EndIf
	EndIf

	//Ŀ
	//O Armazem de processo (MV_LOCPROC) deve ser        
	//inicializado por uma requisicao contra o armazem   
	//padrao.                                            
	//
	If lRet .And. AllTrim(cLocProc) == Alltrim(M->B9_LOCAL)
		Help(" ",1,"A220LOCPRO")
		lRet := .F.
	EndIf

EndIf

RestArea(aAreaSB8)
RestArea(aAreaAnt)

Return lRet

/*/


Ŀ
Programa  MenuDef    Autor  Fabio Alves Silva      Data 03/10/2006
Ĵ
Descrio  Utilizacao de menu Funcional                               
                                                                      
                                                                      
Ĵ
Retorno   Array com opcoes da rotina.                                 
Ĵ
ParametrosParametros do array a Rotina:                               
          1. Nome a aparecer no cabecalho                             
          2. Nome da Rotina associada                                 
          3. Reservado                                                
          4. Tipo de Transao a ser efetuada:                        
          	  1 - Pesquisa e Posiciona em um Banco de Dados    	      
              2 - Simplesmente Mostra os Campos                       
              3 - Inclui registros no Bancos de Dados                 
              4 - Altera o registro corrente                          
              5 - Remove o registro corrente do Banco de Dados        
          5. Nivel de acesso                                          
          6. Habilita Menu Funcional                                  
Ĵ
   DATA    Programador   Manutencao efetuada                         
Ĵ
                                                                     
ٱ


/*/
Static Function MenuDef()
Local aRotAdic := {}

Private aRotina	:= { 	{STR0001,"AxPesqui"  , 0 , 1, 0,.F.},; 	//"Pesquisar"
						{STR0002,"A220Visual", 0 , 2, 0,nil},;  //"Visualizar"
						{STR0003,"A220Inclui", 0 , 3, 0,nil},;  //"Incluir"
						{STR0004,"A220Altera", 0 , 4, 0,nil},; 	//"Alterar"
						{STR0005,"A220Deleta", 0 , 5, 3,nil} }	//"Excluir"

If ExistBlock ("MTA220MNU")
	ExecBlock ("MTA220MNU",.F.,.F.)
Endif

//Ŀ
// P.E. utilizado p adicionar items ou Filtro no Menu da mBrowse
//
If ExistBlock("MT220FIL")
	aRotAdic := ExecBlock("MT220FIL",.f.,.f.)
	If ValType(aRotAdic) == "A"
		AEval(aRotAdic,{|x| AAdd(aRotina,x)})
	EndIf
EndIf
Return (aRotina)

/*


ͻ
Programa  aVldGr220 Autor  Rodrigo de T. Silva  Data   21/08/09   
͹
Descricao  Funcao de validacao dos campos da grade.                   
͹
Uso        MATA220                                                    
ͼ


*/
Function aVldGr220()
Local lRet  	:= .T.
Local nColGrd	:= aScan(aHeader,{|x| AllTrim(x[2]) == AllTrim(Substr(Readvar(),4))})
Local cProdGrd	:= ""
Local lReferencia := .F.

//ATENCAO: verifica se o produto eh referencia, eh analisada no proprio objeto.
cProdGrd := PadR(oGrade:GetNameProd(NIL,n,nColGrd),Len(SB9->B9_COD))
If Inclui
	If oGrade:cCpo $ "B9_QINI*B9_QISEGUM" .And. &(ReadVar()) < 0
		Help(" ",1,"A220Neg")
		lRet := .F.
	ElseIf !(oGrade:cCpo $ "B9_QINI")
		lRet := Positivo(&(ReadVar()))
		If lRet .And. oGrade:aColsFieldByName("B9_QINI",1,n,nColGrd) == 0  .And. !Empty(&(ReadVar()))
			lRet := .F.
			Help(" ",1,"A220QINI")
		Endif
	Endif
EndIF

If Empty(M->B9_LOCAL)
	Help(1," ","OBRIGAT",,RetTitle("B9_QINI") + Space(50-Len(RetTitle("B9_QINI"))),3,0)
	lRet := .F.
EndIf

//Ŀ
// Verifica se jah existe algum saldo inicial cadastrado para este Produto/Local 
//
If lRet .And. oGrade:cCpo $ "B9_QINI*B9_QISEGUM" .And. &(ReadVar()) > 0 .And. !ExistChav("SB9",cProdGrd+M->B9_LOCAL)
	lRet := .F.
EndIf

Return(lRet)

/*/


Ŀ
Funcao    aProdGr220 Autor Rodrigo de T. Silva     Data 17/08/2009
Ĵ
Descrio Efetua a Validao do Codigo do Produto e Inicializa as     
          variaveis do acols da Grade.                                
Ĵ
ParametrosExpC1: Codigo do Produto                                    
Ĵ
Retorno   ExpL1: Logico (Se o Produto  valido ou nao)                
Ĵ
Uso       Mata220                                                     
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/

Function aProdGr220(cProduto)
Local lRetorno		:= .T.
Local lReferencia	:= .F.
Local cCampo        := ReadVar()
Default cProduto	:= &(ReadVar())

//Ŀ
//Verifica se a grade esta ativa e se o produto digitado eh uma referencia
//
If MatGrdPrrf(@cProduto)
	lReferencia := .T.
	//Ŀ
	// Monta o AcolsGrade e o AheadGrade para este item     
	//
	oGrade:MontaGrade(1,cProduto,.T.,,lReferencia)
EndIf

If !lReferencia
	dbSelectArea("SB1")
	dbSetOrder(1)
	If (!dbSeek(xFilial("SB1")+cProduto,.F.) )
		lRetorno := .F.
	EndIf
EndIf
Return(lRetorno)

/*/


Ŀ
Funcao    |AQtdGr220  Autor  Rodrigo de T. Silva    Data 17/08/2009
Ĵ
Descrio Se a Grade estiver ativa, efetua a entrada de dados,na colu-
          na de Quantidade.                                           
Ĵ
ParametrosExpL1 - Se Mostra ou Nao a GetDados                         
Ĵ
Retorno   Sempre .T.                                                  
Ĵ
Uso       Mata220                                                     
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
			      			                                             
                         											  
ٱ


/*/
Function AQtdGr220(lMostra)
Local cProdRef
Local lRet      := .T.
Local lContinua	:= .T.
Local cCpoName	:= StrTran(Readvar(),"M->","")
Local lGrade    := MaGrade()
DEFAULT lMostra := .T.

cProdRef	:= M->B9_COD
lContinua	:= MatGrdPrRf(@cProdRef)

If lGrade .And. lContinua .And. Inclui
	oGrade:cProdRef := cProdRef
	oGrade:lShowGrd := lMostra
	oGrade:nPosLinO := 1
	//Ŀ
	// Verifica se a grade esta ativa                       
	//
	If lRet
		If oGrade:Show(cCpoName) //Chama grade para alteracao de informacoes
			DO CASE
				CASE "B9_QINI" $ cCpoName
					M->B9_QINI    			:= oGrade:nQtdInformada  //Quant. 1a UM
					oGrade:nQtdInformada	:= 0
					oGrade:nQtdInformada	:= oGrade:SomaGrade("B9_QINI",oGrade:nPosLinO,oGrade:nQtdInformada)
				CASE "B9_QISEGUM" $ cCpoName
					M->B9_QISEGUM 			:= oGrade:nQtdInformada  //Quant. 2a UM
					oGrade:nQtdInformada	:= 0
					oGrade:nQtdInformada	:= oGrade:SomaGrade("B9_QISEGUM",oGrade:nPosLinO,oGrade:nQtdInformada)
				CASE "B9_CUSTD" $ cCpoName
					M->B9_CUSTD 			:= oGrade:nQtdInformada  //Quant. 2a UM
					oGrade:nQtdInformada	:= 0
					oGrade:nQtdInformada	:= oGrade:SomaGrade("B9_CUSTD",oGrade:nPosLinO,oGrade:nQtdInformada)
				CASE "B9_VINI1" $ cCpoName
					M->B9_VINI1 			:= oGrade:nQtdInformada // Sld.Ini.Mes
					oGrade:nQtdInformada	:= 0
					oGrade:nQtdInformada	:= oGrade:SomaGrade("B9_VINI1",oGrade:nPosLinO,oGrade:nQtdInformada)
				CASE "B9_VINI2" $ cCpoName
					M->B9_VINI2 			:= oGrade:nQtdInformada // Sld.Ini.2a Mes
					oGrade:nQtdInformada	:= 0
					oGrade:nQtdInformada	:= oGrade:SomaGrade("B9_VINI2",oGrade:nPosLinO,oGrade:nQtdInformada)
				CASE "B9_VINI3" $ cCpoName
					M->B9_VINI3 			:= oGrade:nQtdInformada // Sld.Ini.3a Mes
					oGrade:nQtdInformada	:= 0
					oGrade:nQtdInformada	:= oGrade:SomaGrade("B9_VINI3",oGrade:nPosLinO,oGrade:nQtdInformada)
				CASE "B9_VINI4" $ cCpoName
					M->B9_VINI4 			:= oGrade:nQtdInformada // Sld.Ini.4a Mes
					oGrade:nQtdInformada	:= 0
					oGrade:nQtdInformada	:= oGrade:SomaGrade("B9_VINI4",oGrade:nPosLinO,oGrade:nQtdInformada)
				CASE "B9_VINI5" $ cCpoName
					M->B9_VINI5 			:= oGrade:nQtdInformada // Sld.Ini.5a Mes
					oGrade:nQtdInformada	:= 0
					oGrade:nQtdInformada	:= oGrade:SomaGrade("B9_VINI5",oGrade:nPosLinO,oGrade:nQtdInformada)
				CASE "B9_CM1" $ cCpoName
					M->B9_CM1 				:= oGrade:nQtdInformada // C Unit. 1a M
					oGrade:nQtdInformada	:= 0
					oGrade:nQtdInformada	:= oGrade:SomaGrade("B9_CM1",oGrade:nPosLinO,oGrade:nQtdInformada)
				CASE "B9_CM2" $ cCpoName
					M->B9_CM2 				:= oGrade:nQtdInformada // C Unit. 2a M
					oGrade:nQtdInformada	:= 0
					oGrade:nQtdInformada	:= oGrade:SomaGrade("B9_CM2",oGrade:nPosLinO,oGrade:nQtdInformada)
				CASE "B9_CM3" $ cCpoName
					M->B9_CM3 				:= oGrade:nQtdInformada // C Unit. 3a M
					oGrade:nQtdInformada	:= 0
					oGrade:nQtdInformada	:= oGrade:SomaGrade("B9_CM3",oGrade:nPosLinO,oGrade:nQtdInformada)
				CASE "B9_CM4" $ cCpoName
					M->B9_CM4 				:= oGrade:nQtdInformada // C Unit. 4a M
					oGrade:nQtdInformada	:= 0
					oGrade:nQtdInformada	:= oGrade:SomaGrade("B9_CM4",oGrade:nPosLinO,oGrade:nQtdInformada)
				CASE "B9_CM5" $ cCpoName
					M->B9_CM5 				:= oGrade:nQtdInformada // C Unit. 5a M
					oGrade:nQtdInformada	:= 0
					oGrade:nQtdInformada	:= oGrade:SomaGrade("B9_CM5",oGrade:nPosLinO,oGrade:nQtdInformada)
			ENDCASE
		EndIf
	EndIf
EndIf
Return lRet

/*/


Ŀ
Funcao    |A220GetLot Autor  Emerson Rony Oliveira  Data 05/11/2009
Ĵ
Descrio Captar os lotes que irao compor o saldo inicial, evitando   
          desbalanceamento de saldos.                                 
Ĵ
Parametros                                                            
Ĵ
Retorno   .F. ou .T.                                                  
Ĵ
Uso       Mata220                                                     
ٱ


/*/
Function A220GetLot()
Local aArea      := GetArea()
Local aRotBack   := aClone(aRotina)
Local aLotBack   := {}
Local aListaProd := {}
Local cTitulo    := ""
Local cRefer     := M->B9_COD
Local cProduto   := M->B9_COD
Local cLocal     := M->B9_LOCAL
Local cPictSB9   := PesqPict('SB9', 'B9_QINI')
Local lRastro    := Rastro(M->B9_COD)
Local lTemRastro := .F.
Local lContinua  := .T.
Local nQuant     := M->B9_QINI
Local nQiSegUM   := M->B9_QISEGUM
Local nOpca		 := 0
Local nX         := 0
Local nLin       := 0
Local nCol       := 0
Local aCompAlt	 :={}
//Ŀ
//Se o parametro MV_A390QTD nao existir no dicionario de dados       
//ou seu conteudo for verdadeiro (T), entao somente um lote podera   
//ser informado, se seu conteudo for falso (F) entao "N" lotes podem 
//ser informados para o saldo inicial.                               
//Valores: 3-Varias linhas no aCols                                  
//         6-Somente uma linha no aCols                              
//
Local lA390QTD  := SuperGetMv("MV_A390QTD",.F.,.T.)

If SuperGetMv("MV_WMSNEW",.F.,.F.) .And. IntWms(cRefer) 
	Help(,1,"SIGAWMS",,STR0035,1,0) // "Produto informado possui controle WMS, no  possvel utilizar esta operao."
	RestArea(aArea)
	Return Nil
EndIf

PRIVATE aAlter   := {}
PRIVATE aHeader  := {}
PRIVATE nUsado   := 0
PRIVATE nPosAtu  := 0
PRIVATE nPosAnt  := 9999
PRIVATE nColAnt  := 9999
PRIVATE oGet
PRIVATE aCols    := {}

//Ŀ
//Desabilita a tecla para nao executar a funcao mais de uma vez           
//
SetKey(VK_F7, Nil)

//Ŀ
//Desabilita a coluna D5_QUANT quando MV_A390QTD = T ou nao existir       
//
If lA390QTD
	// Uma linha apenas no aCols: nao edita a quantidade
	aAlter   := {"D5_LOTECTL","D5_NUMLOTE","D5_DTVALID","D5_POTENCI"}
Else
	// Multiplas linhas no aCols: edita a quantidade
	aAlter   := {"D5_QUANT","D5_QTSEGUM","D5_LOTECTL","D5_NUMLOTE","D5_DTVALID","D5_POTENCI"}
EndIf

//Ŀ
//Verifica se a grade esta ativa e se o produto digitado eh uma referencia
//
If !MatGrdPrrf(@cRefer)

	If lContinua .And. !lRastro
		Help(" ",1,"NAORASTRO")
		lContinua := .F.
	EndIf

	If lContinua .And. QtdComp(nQuant) == QtdComp(0)
		Help(" ",1,"A220LTZERO")
		lContinua := .F.
	EndIf

	If lContinua .And. lRastro
		SB8->(dbSelectArea("SB8"))
		SB8->(dbSetOrder(1))
		If SB8->(dbSeek(xFilial("SB8")+cProduto+cLocal))
			If SB8->B8_SALDO > 0
				Help(' ', 1, 'A220EXISLT')
				lContinua := .F.
			EndIf
		EndIf
	EndIf

	If lContinua .And. QtdComp(nQuant) > QtdComp(0)
		For nX := 1 to Len(aRotina)
			aRotina[nx,4] := IIf(lA390QTD, 6, 3)
		Next nX

		//Ŀ
		// Monta o cabecalho da GetDados                                
		//
		aTam:=TamSX3("D5_DATA")
		Aadd(aHeader,{STR0022	,"D5_DATA",PesqPict("SD5","D5_DATA",atam[1]),aTam[1],aTam[2],"",USADO, "D" ,""," " })  				//"Data"
		aTam:=TamSX3("D5_QUANT")
		Aadd(aHeader,{STR0023 	,"D5_QUANT",X3Picture("D5_QUANT"),aTam[1],aTam[2],"Positivo() .AND. A220CONV()",USADO, "N" ,""," " })  		//"Quantidade"
		aTam:=TamSX3("D5_QTSEGUM")
		Aadd(aHeader,{STR0030 	,"D5_QTSEGUM",X3Picture("D5_QTSEGUM"),aTam[1],aTam[2],"Positivo() .AND. A220CONV2()",USADO, "N" ,""," " }) //"Quant Segunda UM"
		aTam:=TamSX3("D5_LOTECTL")
		Aadd(aHeader,{STR0024	,"D5_LOTECTL",PesqPict("SD5","D5_LOTECTL",atam[1]),aTam[1],aTam[2],"A220VldLot(1)",USADO, "C" ,""," " })   	//"Lote"
		aTam:=TamSX3("D5_NUMLOTE")
		Aadd(aHeader,{STR0025	,"D5_NUMLOTE",PesqPict("SD5","D5_NUMLOTE",atam[1]),aTam[1],aTam[2],"A220VldLot(1)",USADO, "C" ,""," " })  	//"Sub-Lote"
		aTam:=TamSX3("D5_DTVALID")
		Aadd(aHeader,{STR0026	,"D5_DTVALID",PesqPict("SD5","D5_DTVALID",atam[1]),aTam[1],aTam[2],"M->D5_DTVALID >= dDataBase",USADO, "D" ,""," " })  //"Data de Validade"
		aTam:=TamSX3("D5_POTENCI")
		Aadd(aHeader,{STR0027	,"D5_POTENCI",PesqPict("SD5","D5_POTENCI",atam[1]),aTam[1],aTam[2],"A220Potenc(1)",USADO, "N" ,""," " })  	//"Potencia"

		// Monta o aCols com os dados do produto em questao
		aCols := {}
		If Empty(aLotesIni)
			AADD(aCols,{dDataBase,nQuant,nQiSegUM,CriaVar("D5_LOTECTL"),Criavar("D5_NUMLOTE"),dDataBase,Criavar("D5_POTENCI"),.F.})
		Else
			// Carregar o aCols com os dados do aLotesIni
			For nX := 1 to Len(aLotesIni)
				If !(aLotesIni[nX, Len(aLotesIni[nX])])
					aAdd(aCols, {	aLotesIni[nX,3],; 	// Data base
									aLotesIni[nX,4],; 	// Quantidade
									aLotesIni[nX,5],; 	// Quantidade seg. UM
									aLotesIni[nX,6],; 	// Numero do lote (LOTECTL)
									aLotesIni[nX,7],; 	// Sub-lote (NUMLOTE)
									aLotesIni[nX,8],; 	// Dt. Validade
									aLotesIni[nX,9],;  // Potencia
									.F.}) 		   		// Controle interno
				EndIf
			Next nX
		EndIf

		//Ŀ
		//| Exibe a GetDados |
		//
		aLotBack := aClone(aLotesIni)
		cTitulo  := STR0015
		nOpca    := 0

		If ExistBlock("MT220LOT")
			aCompAlt := ExecBlock("MT220LOT",.f.,.f.)
		EndIf

		If Len(aCompAlt) != 0
			aEval(aCompAlt,{|x| aAdd(aAlter,x)})
		EndIf

		//Ŀ
		// Monta Dialog                                                 
		//
		DEFINE MSDIALOG oDlg FROM 000,000 TO 250,635 TITLE STR0015 Of oMainWnd PIXEL // "Criao de lotes - Incluso de saldo inicial"

		oSize 				:= FwDefSize():New(.T.,,,oDlg)
		oSize:AddObject("GETDADOS", 100, 100, .T., .T.) 		// Totalmente dimensionavel
		oSize:lProp 		:= .T. 								// Proporcional
		oSize:aMargins 	:= { 3, 3, 3, 3 } 					// Espaco ao lado dos objetos 0, entre eles 3
		oSize:Process() 	   										// Dispara os calculos

		oGetDad := MSGetDados():New(oSize:GetDimension("GETDADOS","LININI"),oSize:GetDimension("GETDADOS","COLINI"),;
									oSize:GetDimension("GETDADOS","LINEND"),oSize:GetDimension("GETDADOS","COLEND");
									,1,"A220LnOK","A220LtTdOK","",.T.,,999)
		ACTIVATE MSDIALOG oDlg CENTERED ON INIT EnchoiceBar(oDlg,{||nOpca:=1,If(oGetDad:TudoOk(),oDlg:End(),nOpca := 0)},{||oDlg:End()})

		If (nOpca == 0) // Cancelar
			aLotesIni := aClone(aLotBack) // Restaura o vetor aLotesIni
		ElseIf (nOpca == 1) // OK
			// Gravar no aLotesIni o aCols atualmente editado
			aLotesIni := {}
			For nX := 1 to Len(aCols)
				If !(aCols[nX, Len(aCols[nX])])
					If QtdComp(aCols[nX,2]) != QtdComp(0) .And. !Empty(aCols[nX,4])
						aAdd(aLotesIni, {	cProduto,; 	// Cdigo do Produto
											cLocal,; 		// Local
											aCols[nX,1],; 	// Data base
											aCols[nX,2],; 	// Quantidade
											aCols[nX,3],; 	// Quantidade seg. UM
											aCols[nX,4],; 	// Numero do lote (LOTECTL)
											aCols[nX,5],; 	// Sub-lote (NUMLOTE)
											aCols[nX,6],; 	// Dt. Validade
											aCols[nX,7],; // Potencia
											.F.}) 			// Controle interno
					EndIf
				EndIf
			Next nX
		EndIf
	EndIf

	aRotina := aClone(aRotBack)
	RestArea(aArea)

Else // O produto digitado eh uma referencia

	//Monta o vetor com os produtos informados na grade
	aListaProd := {}
	For nLin := 1 to Len(oGrade:aColsGrade[1])
		For nCol := 2 to Len(oGrade:aHeadGrade[1])
			cProduto := oGrade:GetNameProd(cRefer,nLin,nCol)
			If Rastro(cProduto)
				lTemRastro := .T.
				If oGrade:aColsFieldByName("B9_QINI",1,nLin,nCol) > 0
					lContinua := .T.
					SB8->(dbSelectArea("SB8"))
					SB8->(dbSetOrder(1))
					If SB8->(dbSeek(xFilial("SB8")+cProduto+cLocal))
						If SB8->B8_SALDO > 0
							Help(' ', 1, 'A220EXISLT')
							lContinua := .F.
						EndIf
					EndIf

					If lContinua
						aAdd(aListaProd, {	cProduto,;															// Produto
											cLocal,;																// Armazem
											Transform(oGrade:aColsFieldByName("B9_QINI",1,nLin,nCol),cPictSB9),;	// Saldo inicial
											Transform(oGrade:aColsFieldByName("B9_QISEGUM",1,nLin,nCol),cPictSB9),; // Quantidade seg. UM
											.F.})																	// controle interno
					EndIf
				EndIf
			EndIf
		Next nCol
	Next nLin

	If lContinua .And. Len(aListaProd) > 0

		For nX := 1 to Len(aRotina)
			aRotina[nx,4] := IIf(lA390QTD, 6, 3)
		Next nX

		//Ŀ
		// Monta o cabecalho da GetDados                                
		//
		aTam:=TamSX3("D5_DATA")
		Aadd(aHeader,{STR0022	,"D5_DATA",PesqPict("SD5","D5_DATA",atam[1]),aTam[1],aTam[2],"",USADO, "D" ,""," " })  				//"Data"
		aTam:=TamSX3("D5_QUANT")
		Aadd(aHeader,{STR0023 	,"D5_QUANT",X3Picture("D5_QUANT"),aTam[1],aTam[2],"Positivo()",USADO, "N" ,""," " })  		//"Quantidade"
		aTam:=TamSX3("D5_QTSEGUM")
		Aadd(aHeader,{STR0030 	,"D5_QTSEGUM",X3Picture("D5_QTSEGUM"),aTam[1],aTam[2],"Positivo()",USADO, "N" ,""," " })  	//"Quant Segunda UM"
		aTam:=TamSX3("D5_LOTECTL")
		Aadd(aHeader,{STR0024	,"D5_LOTECTL",PesqPict("SD5","D5_LOTECTL",atam[1]),aTam[1],aTam[2],"A220VldLot(2)",USADO, "C" ,""," " })   	//"Lote"
		aTam:=TamSX3("D5_NUMLOTE")
		Aadd(aHeader,{STR0025	,"D5_NUMLOTE",PesqPict("SD5","D5_NUMLOTE",atam[1]),aTam[1],aTam[2],"A220VldLot(2)",USADO, "C" ,""," " })  	//"Sub-Lote"
		aTam:=TamSX3("D5_DTVALID")
		Aadd(aHeader,{STR0026	,"D5_DTVALID",PesqPict("SD5","D5_DTVALID",atam[1]),aTam[1],aTam[2],"M->D5_DTVALID >= dDataBase",USADO, "D" ,""," " })  //"Data de Validade"
		aTam:=TamSX3("D5_POTENCI")
		Aadd(aHeader,{STR0027	,"D5_POTENCI",PesqPict("SD5","D5_POTENCI",atam[1]),aTam[1],aTam[2],"A220Potenc(2)",USADO, "N" ,""," " })  	//"Potencia"
		// Monta o aCols com os dados do produto em questao
		cProdAtu := aListaProd[1,1] // produto previamente selecionado
		cLocAtu  := aListaProd[1,2] // local previamente selecionado
		aCols := {}
		If Empty(aLotesIni)
			aAdd(aCols,{dDataBase, A220FmtVal(aListaProd[1,3]),A220FmtVal(aListaProd[1,4]), CriaVar("D5_LOTECTL"), Criavar("D5_NUMLOTE"), dDataBase, Criavar("D5_POTENCI"),.F. })
		Else
			// Retirar do aLotesIni os itens que nao possuirem referencia na lista de produtos
			For nX := 1 to Len(aLotesIni)
				If nX > Len(aLotesIni)
					Exit
				EndIF
				If AScan( aListaProd, {|x| x[1] + x[2] == aLotesIni[nX,1] + aLotesIni[nX,2]} ) == 0 // Produto + Local
					aDel(aLotesIni, nX)
					aSize(aLotesIni, Len(aLotesIni)-1)
					nX--
					Loop
				Else // Carregar o aCols com os lotes do primeiro produto da lista
					If aLotesIni[nX,1] + aLotesIni[nX,2] == aListaProd[1,1] + aListaProd[1,2] // Produto + Local
						aAdd(aCols, {aLotesIni[nX,3], aLotesIni[nX,4], aLotesIni[nX,5], aLotesIni[nX,6], aLotesIni[nX,7], aLotesIni[nX,8], aLotesIni[nX,9], .F. })
					EndIf
				EndIf
			Next nX
		EndIf

		//Ŀ
		//| Exibe a GetDados |
		//
		aLotBack := aClone(aLotesIni)
		cTitulo  := STR0015 // "Criao de lotes - Incluso de saldo inicial"
		nOpca    := 0
		DEFINE MSDIALOG oDlg TITLE cTitulo From 9,0 To 30,103 OF oMainWnd
		@ 015,003 Say STR0016 FONT oDlg:oFont OF oDlg PIXEL	 // "Produtos:"
		@ 015,160 Say STR0017 FONT oDlg:oFont OF oDlg PIXEL	 // "Lotes:"
		@ 025,003 LISTBOX oListaProd FIELDS TITLE "" SIZE 155,131 Of oDlg PIXEL

		// Configuracao do ListBox
		oListaProd:aHeaders := {STR0018,STR0019,STR0020,STR0031}
		oListaProd:SetArray(aListaProd)
		oListaProd:bLine    := {|| oListaProd:aArray[oListaProd:nAt] }
		oListaProd:bChange  := {|| A220FilLot(oListaProd:aArray[oListaProd:nAt,1],oListaProd:aArray[oListaProd:nAt,2]) }

		// Montagem e exibicao da tela
		oGet := MSGetDados():New(025,160,156,405,001,"A220GrOK","A220GrTdOK","",.T.,aAlter,,,999)
		ACTIVATE MSDIALOG oDlg CENTERED ON INIT EnchoiceBar(oDlg,{||nOpca:=1,If(oGet:TudoOk(),oDlg:End(),nOpca := 0)},{||oDlg:End()})

		If (nOpca == 0) // Cancelar
			aLotesIni := aClone(aLotBack)
		EndIf
	Else
		If lTemRastro
			Help(" ",1,"A220LTZERO")
		Else
			Help(" ",1,"NAORASTRO")
		EndIf
	EndIf

	aRotina := aClone(aRotBack)
	RestArea(aArea)
EndIf

//Ŀ
//Habilita novamente a tecla de atalho para a funcao A220GetLot()         
//
SetKey( VK_F7 , { || A220GetLot() } )

aHeadBk := aClone(aHeader)

Return Nil

/*


ͻ
Funcao    A220LnOK  Autor  Emerson R. Oliveira  Data   10/11/09   
͹
Descricao  Funcao de validacao da linha informada na GetDados.        
͹
Uso        MATA220                                                    
ͼ


*/
Function A220LnOK()
Local lRet      := .T.
Local nX        := 0
Local nPosQtd   := aScan(aHeader, {|x| x[2] == 'D5_QUANT'})
Local nPosLote  := aScan(aHeader, {|x| x[2] == 'D5_LOTECTL'})
Local nPosDtVal := aScan(aHeader, {|x| x[2] == 'D5_DTVALID'})
Local nPosData	:= aScan(aHeader, {|x| x[2] == 'D5_DATA'})

If !(aCols[n, Len(aCols[n])])
	If lRet .And. Empty(aCols[n, nPosData])
		Help(" ",1,"A220DATA",,STR0034,1,0) // "Data de emisso invlida."
		lRet := .F.
	EndIf

	If lRet .And. (QtdComp(aCols[n, nPosQtd]) <= QtdComp(0))
		Help(" ",1,"A220QTLOTE")
		lRet := .F.
	EndIf

	If lRet .And. Empty(aCols[n, nPosLote])
		Help(" ",1,"A220LOTEBR")
		lRet := .F.
	EndIf

	If lRet .And. Empty(aCols[n, nPosDtVal])
		Help(" ",1,"A220DTLOTE")
		lRet := .F.
	EndIf
EndIf

Return lRet

/*


ͻ
Funcao    A220LtTdOKAutor  Emerson R. Oliveira  Data   10/11/09   
͹
Descricao  Funcao de validacao das linhas informadas na GetDados.     
͹
Uso        MATA220                                                    
ͼ


*/
Function A220LtTdOK()
Local lRet      := .T.
Local nX        := 0
Local nQtdSoma  := 0
Local nQtd2um   := 0
Local nPosQtd   := aScan(aHeader, {|x| x[2] == 'D5_QUANT'})
Local nPosQt2um := aScan(aHeader, {|x| x[2] == 'D5_QTSEGUM'})

For nX := 1 to Len(aCols)
	If !(aCols[nX, Len(aCols[nX])])
		nQtdSoma += aCols[nX, nPosQtd]
		nQtd2um  += aCols[nX, nPosQt2um]
	EndIF
Next nX

If QtdComp(nQtdSoma) != QtdComp(M->B9_QINI)
	Help(" ",1,"A220QTLOTE")
	lRet := .F.
EndIf
If lRet
	If QtdComp(M->B9_QISEGUM) != QtdComp(0)
		If QtdComp(nQtd2um) != QtdComp(M->B9_QISEGUM)
			Help(" ",1,"A220QTLOTES")
			lRet := .F.
		Else
			//.. Verificar se todos os lotes informados no aCols, estao com a 2.um > 0.
			//.. Se encontrar ao menos 1 lote com 2um zerada, entao enviar mensagem de erro
			For nX := 1 to Len(aCols)
				If aCols[nX, nPosQt2um]<=0
					Help(" ",1,"A220QTLOTES")
					lRet:=.F.
					Exit
				EndIf
			Next
		Endif
	Else
		If QtdComp(nQtd2um) <> QtdComp(0)
			Help(" ",1,"A220QTLOTES")
			lRet:=.F.
		Endif
	EndIf
EndIf

Return lRet

/*


ͻ
Funcao    A220GrOK  Autor  Emerson R. Oliveira  Data   16/11/09   
͹
Descricao  Funcao de validacao da linha informada na GetDados quando  
           for utilizada a funcao de Grade.                           
͹
Uso        MATA220                                                    
ͼ


*/
Function A220GrOK()
Local lRet      := .T.
Local nX        := 0
Local nPosQtd   := aScan(aHeader, {|x| x[2] == 'D5_QUANT'})
Local nPosQtd2UM:= aScan(aHeader, {|x| x[2] == 'D5_QTSEGUM'})
Local nPosLote  := aScan(aHeader, {|x| x[2] == 'D5_LOTECTL'})
Local nPosDtVal := aScan(aHeader, {|x| x[2] == 'D5_DTVALID'})

If !(aCols[n, Len(aCols[n])])
	If (QtdComp(aCols[n, nPosQtd]) <= QtdComp(0))
		Help(" ",1,"A220QTLOTE",,STR0021+AllTrim(Str(oListaProd:nAt))+" / "+oListaProd:aArray[oListaProd:nAt,1],5,11)
		lRet := .F.
	EndIf

	If lRet .And. Empty(aCols[n, nPosLote])
		Help(" ",1,"A220LOTEBR",,STR0021+AllTrim(Str(oListaProd:nAt))+" / "+oListaProd:aArray[oListaProd:nAt,1],5,11)
		lRet := .F.
	EndIf

	If lRet .And. Empty(aCols[n, nPosDtVal])
		Help(" ",1,"A220DTLOTE",,STR0021+AllTrim(Str(oListaProd:nAt))+" / "+oListaProd:aArray[oListaProd:nAt,1],5,11)
		lRet := .F.
	EndIf
EndIf

Return lRet

/*


ͻ
Funcao    A220GrTdOKAutor  Emerson R. Oliveira  Data   16/11/09   
͹
Descricao  Funcao de validacao das linhas informadas na GetDados qdo  
           for utilizada a funcao de Grade.                           
͹
Uso        MATA220                                                    
ͼ


*/
Function A220GrTdOK()
Local lRet      := .T.
Local nP        := 0
Local nL        := 0
Local nQtdSoma  := 0
Local nQtd2UM   := 0

// Para evitar que o evento bChange do listbox nao seja executado, deixando o vetor aLotesIni vazio
A220FilLot(oListaProd:aArray[oListaProd:nAt,1],oListaProd:aArray[oListaProd:nAt,2])

For nP := 1 to Len(oListaProd:aArray)
	nQtdSoma := 0
	nQtd2UM  := 0
	For nL := 1 to Len(aLotesIni)
		If aLotesIni[nL,1] == oListaProd:aArray[nP,1] .And. aLotesIni[nL,2] == oListaProd:aArray[nP,2]
			nQtdSoma += aLotesIni[nL, 4]
			nQtd2UM  += aLotesIni[nL, 5]
		EndIf
	Next nL

	If QtdComp(nQtdSoma) != QtdComp(A220FmtVal(oListaProd:aArray[nP,3]))
		Help(" ",1,"A220QTLOTE",,STR0021+AllTrim(Str(nP))+" / "+oListaProd:aArray[nP,1],5,11)
		lRet := .F.
		Exit
	EndIf
	If QtdComp(nQtd2UM) != QtdComp(A220FmtVal(oListaProd:aArray[nP,4]))
		Help(" ",1,"A220QTLOTES",,STR0021+AllTrim(Str(nP))+" / "+oListaProd:aArray[nP,1],5,11)
		lRet := .F.
		Exit
	EndIf
Next nP

Return lRet

/*


ͻ
Funcao    A220VldLotAutor  Emerson R. Oliveira  Data   06/11/09   
͹
Descricao  Funcao de validacao dos lotes informados.                  
͹
Uso        MATA220                                                    
ͼ


*/
Function A220VldLot(nTipo)
Local aArea     := GetArea()
Local cLote     := &(ReadVar())
Local cVar      := ReadVar()
Local cCod      := ""
Local cLocal    := ""
Local lRet      := .T.
Local nPosNumLt := aScan(aHeader, {|x| x[2] == 'D5_NUMLOTE'})

Default nTipo   := 1

If nTipo == 1 // Produto no eh referencia de grade
	cCod   := M->B9_COD
	cLocal := M->B9_LOCAL
Else // Produto eh referencia de grade
	cCod   := oListaProd:aArray[oListaProd:nAt,1]
	cLocal := oListaProd:aArray[oListaProd:nAt,2]
EndIf

If !Rastro(cCod)
	Help(" ",1,"NAORASTRO")
	lRet := .F.
EndIf

If lRet
	If Rastro(cCod,"S")
		//-- Acrescenta o Sub-Lote a Pesquisa
		cLote += If(!Empty(aCols[n, nPosNumLt]),aCols[n, nPosNumLt],'')

		dbSelectArea("SB8")
		dbSetOrder(3)
		If dbSeek(xFilial("SB8")+cCod+cLocal+cLote)
			Help(" ",1,"A240CTLEX")
			lRet := .F.
		EndIf
		RestArea(aArea)
	Else
		If cVar == "M->D5_NUMLOTE"
			aCols[n, nPosNumLt] := CriaVar("D5_NUMLOTE")
			M->D5_NUMLOTE       := CriaVar("D5_NUMLOTE")
		EndIf
	EndIf
EndIf

Return lRet

/*


ͻ
Funcao    A220VLtIniAutor  Emerson R. Oliveira  Data   10/11/09   
͹
Descricao  Verifica se os lotes foram informados corretamente         
͹
Uso        MATA220                                                    
ͼ


*/
Function A220VLtIni()
Local aLotes	 := {}
Local cRefer     := M->B9_COD
Local cLocal     := M->B9_LOCAL
Local cProduto   := ""
Local cPictSB9   := PesqPict('SB9', 'B9_QINI')
Local lRet       := .T.
Local lTemRastro := .F.
Local nX         := 0
Local nY         := 0
Local nQtdSoma   := 0
Local nQtdItem   := 0

If (QtdComp(M->B9_QINI) > QtdComp(0))
	//Ŀ
	//Verifica se a grade esta ativa e se o produto digitado eh uma referencia
	//
	If !MatGrdPrrf(@cRefer)

		If Rastro(M->B9_COD)
			For nX := 1 to Len(aLotesIni)
				If !(aLotesIni[nX, Len(aLotesIni[nX])])
					nQtdSoma += aLotesIni[nX, 4]
				EndIF
			Next nX

			If QtdComp(nQtdSoma) != QtdComp(M->B9_QINI)
				Help(" ",1,"A220CRIALT",, RetTitle("B9_QINI")+": "+AllTrim(Transform(M->B9_QINI, cPictSB9)), 5, 11)
				lRet := .F.
			EndIf
		EndIf

	Else // Produto eh referencia de grade

		For nY := 1 to Len(oGrade:aColsGrade[1])
			For nX := 2 to Len(oGrade:aHeadGrade[1])
				cProduto := oGrade:GetNameProd(cRefer,nY,nX)
				If Rastro(cProduto)
					lTemRastro := .T.
					If oGrade:aColsFieldByName("B9_QINI",1,nY,nX) > 0
						lRet       := .T.
						SB8->(dbSelectArea("SB8"))
						SB8->(dbSetOrder(1))
						If SB8->(dbSeek(xFilial("SB8")+cProduto+cLocal))
							If SB8->B8_SALDO > 0
								Help(' ', 1, 'A220EXISLT')
								lRet := .F.
							EndIf
						EndIf

						If lRet
							aAdd(aLotes, {	cProduto,;									// Produto
											cLocal, ;										// Local
											oGrade:aColsFieldByName("B9_QINI",1,nY,nX),;	// Quantidade
											.F.})											// controle interno
						EndIf
					EndIf
				EndIf
			Next nX
		Next nY

		// Reordenar o vetor: Produto + Local + Lote + Sub-lote + Dt.Validade
		aSort( aLotesIni,,,{|x,y| x[1] + x[2] + x[6] + x[7] + DtoS(x[8]) < y[1] + y[2] + y[6] + y[7] + DtoS(y[8])} )

		If Len(aLotes) > 0
			For nY := 1 to Len(aLotes)
				nQtdItem := 0
				For nX := 1 to Len(aLotesIni)
					If aLotesIni[nX,1] == aLotes[nY,1] .And. aLotesIni[nX,2] == aLotes[nY,2]
						nQtdItem += aLotesIni[nX, 4]
						nQtdSoma += aLotesIni[nX, 4]
					EndIf
				Next nX

				If QtdComp(nQtdItem) != QtdComp(aLotes[nY,3])
					Help(" ",1,"A220CRIALT",,STR0021+AllTrim(Str(nY))+" / "+aLotes[nY,1]+" - "+;
											RetTitle("B9_QINI")+": "+AllTrim(Transform(aLotes[nY,3], cPictSB9)), 5, 1)
					lRet := .F.
					Exit
				EndIf
			Next nY

			If lRet .And. QtdComp(nQtdSoma) != QtdComp(M->B9_QINI)
				Help(" ",1,"A220CRIALT",, RetTitle("B9_QINI")+": "+AllTrim(Transform(M->B9_QINI, cPictSB9)), 5, 11)
				lRet := .F.
			EndIf
		Else
			If lTemRastro
				Aviso(STR0010,STR0012 +RetTitle("B9_QINI") +STR0013,{"Ok"})
				lRet := .F.
			Else
				lRet := .T.
			EndIf
		EndIf
	EndIf
Else
	// Protecao quando o parametro e alterado durante a rotina
	// Caso sejam informados lotes e depois zerada a quantidade inicial
	aLotesIni := {}
EndIf

Return lRet

/*


Ŀ
Funao     A220Potenc  AutorEmerson R. Oliveira    Data  11/11/09 
Ĵ
Descriao  Validacao da potencia do lote                              
Ĵ
 Uso       Mata220                                                    
ٱ


*/
Function A220Potenc(nTipo)
Local lRet := .T.
Local cCod := ""

Default nTipo := 1

If nTipo == 1 // Produto no eh referencia de grade
	cCod := M->B9_COD
Else // Produto eh referencia de grade
	cCod := oListaProd:aArray[oListaProd:nAt,1]
EndIf

If !Rastro(cCod)
	Help(" ",1,"NAORASTRO")
	lRet:=.F.
EndIf

If lRet .And. !PotencLote(cCod)
	Help(" ",1,"NAOCPOTENC")
	lRet:=.F.
EndIf

Return lRet

/*/


Ŀ
Funcao    |A220FilLot Autor  Emerson Rony Oliveira  Data 16/11/2009
Ĵ
Descrio Filtrar os lotes a serem exibidos de acordo com o produto   
          selecionado na listagem de produtos (oListaProd)            
Ĵ
ParametrosExpC1: Codigo do produto selecionado                        
          ExpC2: Local do produto selecionado                         
Ĵ
Retorno   Nil                                                         
Ĵ
Uso       Mata220                                                     
ٱ


/*/
Function A220FilLot(cProduto, cLocal)
Local aLotes    := {}
Local nX        := 0

// Reordenar o vetor: Produto + Local + Lote + Sub-lote + Dt.Validade
aSort( aLotesIni,,,{|x,y| x[1] + x[2] + x[6] + x[7] + DtoS(x[8]) < y[1] + y[2] + y[6] + y[7] + DtoS(y[8])} )

// Apagar do vetor aLotesIni todos os lotes referentes ao aCols atual
For nX := 1 to Len(aLotesIni)
	If nX > Len(aLotesIni)
		Exit
	EndIF
	If aLotesIni[nX,1] == cProdAtu .And. aLotesIni[nX,2] == cLocAtu
		aDel(aLotesIni, nX)
		aSize(aLotesIni, Len(aLotesIni)-1)
		nX--
		Loop
	EndIf
Next nX

// Gravar no aLotesIni o aCols atualmente editado
For nX := 1 to Len(aCols)
	If !(aCols[nX, Len(aCols[nX])])
		If QtdComp(aCols[nX,2]) != QtdComp(0) .And. !Empty(aCols[nX,4])
			aAdd(aLotesIni, {	cProdAtu,; 	// Cdigo do Produto
								cLocAtu,; 		// Local
								aCols[nX,1],; 	// Data base
								aCols[nX,2],; 	// Quantidade
								aCols[nX,3],; 	// Quantidade 2a UM
								aCols[nX,4],; 	// Numero do lote (LOTECTL)
								aCols[nX,5],; 	// Sub-lote (NUMLOTE)
								aCols[nX,6],; 	// Dt. Validade
								aCols[nX,7],;  // Potencia
								.F.}) 			// Controle interno
		EndIf
	EndIf
Next nX

// Reordenar o vetor: Produto + Local + Lote + Sub-lote + Dt.Validade
aSort( aLotesIni,,,{|x,y| x[1] + x[2] + x[6] + x[7] + DtoS(x[8]) < y[1] + y[2] + y[6] + y[7] + DtoS(y[8])} )

// Mudar o produto atualmente selecionado
cProdAtu := cProduto
cLocAtu  := cLocal

// Encontrar no vetor aListaProd os lotes do novo produto selecionado no listbox "oListaProd"
For nX := 1 to Len(aLotesIni)
	If  Alltrim(aLotesIni[nX, 1]) ==  Alltrim(cProduto) .And. aLotesIni[nX, 2] == cLocal
		aAdd(aLotes, {aLotesIni[nX,3], aLotesIni[nX,4], aLotesIni[nX,5], aLotesIni[nX,6], aLotesIni[nX,7], aLotesIni[nX,8], aLotesIni[nX,9], .F.})
	EndIf
Next nX

// Limpar o aCols e carrega-lo com os dados do novo produto selecionado no listbox "oListaProd"
If Len(aLotes) # 0
	aCols := aClone(aLotes)
Else
	aCols := {}
	aAdd(aCols,{dDataBase, A220FmtVal(oListaProd:aArray[oListaProd:nAt,3]), A220FmtVal(oListaProd:aArray[oListaProd:nAt,4]), CriaVar("D5_LOTECTL"), Criavar("D5_NUMLOTE"), dDataBase, Criavar("D5_POTENCI"),.F.})
EndIf
oGet:oBrowse:Refresh()

Return Nil

/*/


Ŀ
Funcao    |A220FmtVal Autor  Emerson Rony Oliveira  Data 24/11/2009
Ĵ
Descrio Retorna um valor numerico no formato americano a partir     
          de uma string pre-formatada com pontos separadores de milhar
          e virgula.                                                  
Ĵ
ParametrosExpC1: String no formato 9.999.999,99                       
Ĵ
Retorno   Numerico no formato 99999.99                                
Ĵ
Uso       Mata220                                                     
ٱ


/*/
Static Function A220FmtVal(cString)
Local n := 0

// Retirar os espacos em branco
cString := AllTrim(cString)

// Retirar os pontos separadores de milhar e trocar a virgula por ponto
For n := 1 to Len(cString)
	If Substr(cString, n, 1) == "."
		cString := Stuff(cString, n, 1, "")
	EndIf
	If Substr(cString, n, 1) == ","
		cString := Stuff(cString, n, 1, ".")
	EndIf
Next n

Return Val(cString)

/*/


Ŀ
Funcao    |A220AtuSD5 Autor  Emerson Rony Oliveira  Data 06/11/2009
Ĵ
Descrio Inclui a movimentacao dos lotes iniciais informados.        
Ĵ
ParametrosExpC1: Codigo do produto que esta sendo atualizado          
          ExpC2: Local do produto que esta sendo atualizado           
Ĵ
Retorno   Nil                                                         
Ĵ
Uso       Mata220                                                     
ٱ


/*/
Function A220AtuSD5(cProduto, cLocal)
Local aArea		:= GetArea()
Local aLotes	:= {}
Local nX		:= 0
Local cDoc		:= ""
Local aCtoLote	:= {}
Local lMT220GRL := ExistBlock("MT220GRL")

// protecao para execucao em modo automatico ou pela rotina de importacao MatImpProc()
If ( Type("aLotesIni") == "U" )
	Private aLotesIni := {}
EndIf

// Protecao para nao gravar lotes quando quantidade for zerada
If Len(aLotesIni) > 0 .And. QtdComp(SB9->B9_QINI) > QtdComp(0)
	cDoc := StrZero( 0, TamSX3("D5_DOC")[1] )

	// Reordenar o vetor: Produto + Local + Lote + Sub-lote + Dt.Validade
	aSort( aLotesIni,,,{|x,y| x[1] + x[2] + x[6] + x[7] + DtoS(x[8]) < y[1] + y[2] + y[6] + y[7] + DtoS(y[8])} )

	For nX := 1 to Len(aLotesIni)
		// Criar lotes apenas para o produto produto enviado nos parametros (cProduto+cLocal)
		If Alltrim(aLotesIni[nX, 1]) + Alltrim(aLotesIni[nX,2]) ==  Alltrim(cProduto) + AllTrim(cLocal)
			If Rastro(aLotesIni[nX, 1])
				If !(aLotesIni[nX,Len(aLotesIni[nX])])
					cDoc := Soma1(cDoc)
					aAdd(aLotes, {	{"D5_DOC"		, cDoc				, Nil} ,;
									{"D5_PRODUTO"	, aLotesIni[nX, 1]	, NIL} ,;
									{"D5_LOCAL"		, aLotesIni[nX, 2]	, NIL} ,;
									{"D5_DATA"		, aLotesIni[nX, 3]	, NIL} ,;
									{"D5_QUANT"		, aLotesIni[nX, 4]	, NIL} ,;
									{"D5_QTSEGUM"	, aLotesIni[nX, 5]	, NIL} ,;
									{"D5_LOTECTL"	, aLotesIni[nX, 6]	, NIL} ,;
									{"D5_NUMLOTE"	, aLotesIni[nX, 7]	, NIL} ,;
									{"D5_DTVALID"	, aLotesIni[nX, 8]	, NIL} ,;
									{"D5_POTENCI"	, aLotesIni[nX, 9]	, NIL} ,;
									{"D5_SLDINI"	, "B9"				, NIL} })

					If lMT220GRL
						aCtoLote := ExecBlock("MT220GRL",.F.,.F.,{aLotes, aHeadBk})
					EndIf

					If Len(aCtoLote) != 0
						aLotes := aClone(aCtoLote)
					EndIf
				EndIf
			EndIf
		EndIf
	Next nX

	// Inclusao da movimentacao na SD5 - Criacao dos lotes //
	For nX := 1 to Len(aLotes)
		MSExecAuto({|x,y| Mata390(x,y)}, aLotes[nX], 3)
	Next nX

EndIf

RestArea(aArea)
Return

/*/


Ŀ
Funcao    |ExistMov   Autor  Emerson Rony Oliveira  Data 18/02/2010
Ĵ
Descrio Verifica a existencia de movimentacao na SD5 que impecam a  
          exclusao do saldo inicial.                                  
          Se nao houver movimentos impedindo a exclusao, sera feita   
          uma busca pelos lotes iniciais gerados pela rotina MATA220. 
Ĵ
ParametrosExpC1: Codigo do produto                                    
          ExpC2: Local do produto                                     
          ExpA1: Vetor que armazenara os registros de lotes iniciais  
Ĵ
Retorno   Logico: .T./.F.                                             
Ĵ
Uso       Mata220                                                     
ٱ


/*/
Static Function ExistMov(cProduto, cLocal, aDelSD5)
Local aArea     := {}
Local lRet      := .F.
Local cAliasTmp := ''
Local cQuery    := ''

cQuery := "SELECT COUNT(SD5.D5_PRODUTO) RECS "
cQuery += "  FROM "+RetSqlName("SD5")+" SD5 "
cQuery += " WHERE SD5.D5_FILIAL    = '"+xFilial("SD5")+"' "
cQuery += "   AND SD5.D5_PRODUTO   = '"+cProduto+"' "
cQuery += "   AND SD5.D5_LOCAL     = '"+cLocal+"' "
cQuery += "   AND (SD5.D5_ORIGLAN <> 'MAN' OR (SD5.D5_ORIGLAN = 'MAN' AND SD5.D5_SLDINI = '  ')) "
cQuery += "   AND SD5.D5_ESTORNO  <> 'S' "
cQuery += "   AND SD5.D_E_L_E_T_   = ' ' "

cAliasTmp := GetNextAlias()
cQuery    := ChangeQuery(cQuery)
dbUseArea( .T., 'TOPCONN', TcGenQry(,,cQuery), cAliasTmp, .T., .F. )

If !(cAliasTmp)->(Eof()) .And. (cAliasTmp)->RECS > 0
	lRet := .T.
EndIf
(cAliasTmp)->( DbCloseArea() )

// Obtem os registros referentes aos lotes criados para o saldo
// inicial quando nao ha movimentacoes que impecam a exclusao
If !lRet
	cQuery := "SELECT D5_PRODUTO, D5_LOCAL, D5_LOTECTL, D5_NUMLOTE, D5_NUMSEQ, D5_DTVALID "
	cQuery += "  FROM "+RetSqlName("SD5")+" SD5 "
	cQuery += " WHERE SD5.D5_FILIAL   = '"+xFilial("SD5")+"' "
	cQuery += "   AND SD5.D5_PRODUTO  = '"+cProduto+"' "
	cQuery += "   AND SD5.D5_LOCAL    = '"+cLocal+"' "
	cQuery += "   AND SD5.D5_ORIGLAN  = 'MAN' "
	cQuery += "   AND SD5.D5_SLDINI   = 'B9' "
	cQuery += "   AND SD5.D5_ESTORNO <> 'S' "
	cQuery += "   AND SD5.D_E_L_E_T_  = ' ' "

	cAliasTmp := GetNextAlias()
	cQuery    := ChangeQuery(cQuery)
	dbUseArea( .T., 'TOPCONN', TcGenQry(,,cQuery), cAliasTmp, .T., .F. )

	While !(cAliasTmp)->(Eof())
		aAdd(aDelSD5, {	{"D5_PRODUTO" , (cAliasTmp)->D5_PRODUTO , NIL} ,;
						{"D5_LOCAL"	  , (cAliasTmp)->D5_LOCAL	, NIL} ,;
						{"D5_LOTECTL" , (cAliasTmp)->D5_LOTECTL , NIL} ,;
						{"D5_NUMLOTE" , (cAliasTmp)->D5_NUMLOTE , NIL} ,;
						{"D5_NUMSEQ"  , (cAliasTmp)->D5_NUMSEQ	, NIL} ,;
						{"D5_DTVALID" , (cAliasTmp)->D5_DTVALID	, NIL} })

		(cAliasTmp)->(dbSkip())
	EndDo
	(cAliasTmp)->( DbCloseArea() )
EndIf

Return lRet

/*

Ŀ
Funao    A220CONV   Autor Moises Nunes           Data  11/03/2011
Ĵ
Descriao Converte para 2a Unidade de Medida                          
ٱ

*/
Function A220CONV()
Local nPosQtd   := aScan(aHeader, {|x| x[2] == 'D5_QUANT'})
Local nPosQtd2UM:= aScan(aHeader, {|x| x[2] == 'D5_QTSEGUM'})

If !(aCols[n, Len(aCols[n])])
	aCols[n, nPosQtd2um] := ConvUM(M->B9_COD,M->D5_QUANT,aCols[n,nPosQtd2um], 2 )
EndIf

Return .T.

/*

Ŀ
Funao    A220CONV2  Autor Gustavo Della Giustina Data  02/01/2017
Ĵ
Descriao Converte para 1a Unidade de Medida                          
ٱ

*/
Function A220CONV2()
Local nPosQtd   := aScan(aHeader, {|x| x[2] == 'D5_QUANT'})
Local nPosQtd2UM:= aScan(aHeader, {|x| x[2] == 'D5_QTSEGUM'})

If !(aCols[n, Len(aCols[n])])
	aCols[n, nPosQtd] := ConvUM(M->B9_COD, aCols[n, nPosQtd], M->D5_QTSEGUM, 1)
EndIf

Return .T.

/*

Ŀ
Funao    A220PPI    Autor Samantha Preima        Data  13/05/2016
Ĵ
Descriao Integrao PPI                                              
ٱ

*/
Static Function A220PPI(cCod, cLocal, nQuant, cEvent, aDelete)
Local nI := 0

Default cEvent := 'upsert'

// Integrao com TOTVS MES
if PCPIntgPPI()
	dbSelectArea("SOE")
	SOE->(dbSetOrder(1))
	If SOE->(dbSeek(xFilial("SOE")+"SB2")) .AND. ALLTRIM(SOE->OE_VAR3) == '1'
		if !Empty(aLotesIni)
			For nI := 1 to Len(aLotesIni)
				MATA225PPI( cCod,; // Produto
							cLocal,; // Armazm
							'',; // Localizao
							'',; // Nmero de srie
							aLotesIni[nI][6],; // Lote
							aLotesIni[nI][7],; // Sub-lote
							aLotesIni[nI][8],;  // Data
							aLotesIni[nI][4],; // Quantidade
							'1',; // Tipo de movimento
							'',; // Sequencia
							'',; // Documento
							aDelete,;
							cEvent) // Ao
			Next
		Else
			MATA225PPI( cCod,; // Produto
						cLocal,; // Armazm
						'',; // Localizao
						'',; // Nmero de srie
						'',; // Lote
						'',; // Sub-lote
						dDataBase,;  // Data
						nQuant,; // Quantidade
						'1',; // Tipo de movimento
						'',; // Sequencia
						'',; // Documento
						aDelete,;
						cEvent) // Ao
		Endif
	Endif
Endif

Return

/*/{Protheus.doc} A220VFanta
Verifica se o produto  fantasma
@author Yuri Porto
@since 20/02/2017
@version 1.0
@return ${return}, ${return_description}
@param cProduto, characters, descricao
@type function
/*/
Static Function A220VFanta(cProduto)
Local lRet		:= .T.
Local aArea		:= GetArea()
Local aAreaSB1	:= {}

dbSelectArea( "SB1" )
aAreaSB1 := GetArea()
dbSetOrder(1)
If MSSeek( xFilial("SB1")+cProduto )
	If RetFldProd(cProduto,"B1_FANTASM") == "S"
		lRet := .F.
		Help('',1,STR0032,,STR0033,1,0)  //'PRODUTO FANTASMA' //'No  possvel incluir saldos em produtos fantasmas'
	EndIf
EndIf
RestArea(aAreaSB1)
RestArea(aArea)
Return lRet
