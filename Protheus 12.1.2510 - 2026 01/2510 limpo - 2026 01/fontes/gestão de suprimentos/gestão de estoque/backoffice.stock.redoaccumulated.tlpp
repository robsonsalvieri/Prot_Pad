#INCLUDE "MATA215.CH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "FWLIBVERSION.CH"
#INCLUDE "FWEVENTVIEWCONSTS.CH"

namespace BackOffice.Stock.RedoAccumulated

//Posições das tabelas no array aFilTabs
#DEFINE TabelaSA1 1
#DEFINE TabelaSB2 2
#DEFINE TabelaSB8 3
#DEFINE TabelaSBF 4
#DEFINE TabelaSC1 5
#DEFINE TabelaSC7 6
#DEFINE TabelaSC2 7
#DEFINE TabelaSD4 8
#DEFINE TabelaSDD 9
#DEFINE TabelaSCQ 10
#DEFINE TabelaSDA 11
#DEFINE TabelaSD1 12
#DEFINE TabelaSC0 13
#DEFINE TabelaSC6 14
#DEFINE TabelaSB6 15
Static lMA215SD1
Static lMT215EXC
Static lMT215PRO
Static lM215SC
Static lMA215SD2

/*/{Protheus.doc} stkRedoAccm
	Rotina de atualizacao dos acumulados do MRP
	@type Function
	@author Eduardo Riera
	@since 30/03/2001
	@param lBat, Boolean, Indica se o processo sera batch
	@param aParams, array, array com os parametros de filtro em caso de execauto
	@additional
	Esta rotina tem como objetivo atualizar os acumulados do MRP 
    das seguintes tabelas:                                       
    A) SA1 -> Cadastro de Clientes - Saldo de pedidos.           
    B) SB2 -> Saldos fisico e financeiro - Dados do MRP   			
/*/
Function stkRedoAccm(lBat,aParams)                                          
Local cCadastro	  := OemtoAnsi(STR0001) as character //"Refaz Acumulados" 
Local bBlNewProc  := {|oTProces|MA215Do(lBat,oTProces)} as codeblock
Local oTProces 	  as object
Local aInfoCustom := {} as array
Local cPerg   	  := "MTA215FF" as character
private aMTA215   := {}  as array
private lRfzVnd   := .F. as logical

Default lBat      := .F. 
Default aParams   := {} 
	
If lBat .and. len(aParams) > 0
	aMTA215 := aParams
EndIf

If FindFunction('CV8LogView') //Função que apresenta log de execução(CV8) na tNewProcess
	Aadd(aInfoCustom,{OemToAnsi(STR0031),{|oTProces| CV8LogView("MATA215", oTProces)},"OPERACAO"}) //"Log de Execução"
EndIf
		
If !lBat		
	//Este programa tem como objetivo refazer os Saldos de Pedidos, Solicitações e Ordens de Produção dos Produtos com base nos seus respectivos movimentos.
	oTProces := tNewProcess():New("MATA215",cCadastro,bBlNewProc,OemtoAnsi(STR0002)+chr(13),cPerg,aInfoCustom,nil,nil,nil,nil,nil,.t.)	
ElseIf IsBlind()
	BatchProcess(cCadastro,STR0002+CRLF+STR0008,NIL,{|| Processa({|lEnd| MA215Do(.T.)},,,.F.)})
EndIf

Return

/*/{Protheus.doc} Ma215Do
	Rotina de chamada do MATA215
	@type Static Function
	@author Rodrigo de A. Sartorio
	@since 04/07/2002	
	@param lBat, Boolean, Indica se o processo sera batch
	@param oCenterPanel, Object, Objeto da regua de processamento		
/*/
Static Function MA215Do(lBat,oCenterPanel)
Local oObj
Local lNewProc := .F.
Private lSchedule := FWGetRunSchedule()
Default oCenterPanel := nil
//Verifico se o pergunte ainda não foi preenchido
if len(aMTA215) == 0
	aMTA215 := {MV_PAR01,MV_PAR02,MV_PAR03,MV_PAR04,MV_PAR05,MV_PAR06,MV_PAR07}
endIf
//Coloco para executar apenas a filial corrente da Thread
if lSchedule .and. empty(MV_PAR01) .and. empty(MV_PAR02)
	aMTA215[1] := cFilAnt
	aMTA215[2] := cFilAnt
EndIf

If oCenterPanel <> NIL
	oObj     := oCenterPanel
	lNewProc := .T.
EndIf

If lBat
	Ma215Proc(lBat,oObj)
Else
	Ma215Proc(lBat,oObj,lNewProc)
EndIf

Return .T.

/*/{Protheus.doc} Ma215Proc
	Rotina de Processamento do MATA215 
	Esta rotina tem como objetivo processar os acumulados do MRP
	@type Function
	@author Eduardo Riera
	@since 30/03/2001	
	@param lBat, Boolean, Indica se o processo sera batch
	@param oObj, Object, Objeto da regua de processamento
	@param lNewProc, Boolean, Indica se utiliza o tNewProcess	
/*/
Static Function Ma215Proc(lBat,oObj,lNewProc)
Local cFirst    := "" as character
Local nTempoIni := 0 as numeric
Local nTempoFim := 0 as numeric
Local nMaxReg	:= 0 as numeric
Local cTempo    := "" as character
Local dDataIni  := StoD("") as date
Local dDataFim  := StoD("") as date
Local nElaptime as numeric
Local cTitle    as character
Local cMessage  as character
Local aFils     := {} as array
Local nFil      := 0 as numeric
Local aFilTabs  := {{'SA1', "" /*cFilAnterior*/},;
					{'SB2', "" /*cFilAnterior*/},;
					{'SB8', "" /*cFilAnterior*/},;
					{'SBF', "" /*cFilAnterior*/},;
					{'SC1', "" /*cFilAnterior*/},;
					{'SC7', "" /*cFilAnterior*/},;
					{'SC2', "" /*cFilAnterior*/},;
					{'SD4', "" /*cFilAnterior*/},;
					{'SDD', "" /*cFilAnterior*/},;
					{'SCQ', "" /*cFilAnterior*/},;
					{'SDA', "" /*cFilAnterior*/},;
					{'SD1', "" /*cFilAnterior*/},;
					{'SC0', "" /*cFilAnterior*/},;
					{'SC6', "" /*cFilAnterior*/},;
					{'SB6', "" /*cFilAnterior*/}} as array
Local lRet      := .T. as logical
Local cChkSC6   := ''  as character
local xDifDate  := 0   as variant

Private nStep      := 8192 as numeric
Private cQryOPEmp  as character
Private cQrySD2    as character
Private cQrySDC    as character
Private cQrySC6    as character
Private cTmpAlias  as character
Private nPulseLife as numeric

Private oQuerySC6  as object
Private oQuerySC9  as object
Private oQuerySL2  as object
Private oQueryAFJ  as object
Private oQuerySB6  as object
Private oQuerySC0  as object
Private oQuerySD1  as object
Private oQuerySDA  as object
Private oQueryD0G  as object
Private oQueryDH1  as object
Private oQuerySCQ  as object
Private oQuerySDD  as object
Private oQuerySDC  as object
Private oQuerySC7  as object
Private oQuerySBF  as object
Private oQuerySB8  as object
Private oQuerySB2  as object
Private oQuerySA1  as object
Private oQueryNNT  as object
private oQuerySC1  as object
private oQuerySC2  as object
private oQuerySD4  as object
Private oQueryDHQ  as object
Private oRegSC9    as object
Private oQrySD1    as object
Private oQry215RES as object
Private oQrySDCOP  as object 
Private oChkSC6    as object
Private oQrySC6    as object
private oQrySDC    as object
private oQrySD2    as object
private oQCntSB2   as object

//Tabelas temporarias
Private oTmpSB2 as object
Private oTmpSB8 as object
Private oTmpSBF as object
Private oTmpSA1 as object
Private oTmpPrd as object

Private cSavFil    := cFilAnt
Private cFilProc   as character
Private l215Regua  as logical
private lFilProd   := .F. as logical
private lFilArmz   := .F. as logical
Private lSc6Prod   := .F. as logical
Private lAlertShow := .T. as logical
Private xSavNEstr  := Nil 
private lVerbose   := SuperGetMv("MV_MT215LG",.f.,.f.)//Habilita o modo verboso de log do MATA215
Private cProduto   := "" as character //Produto Unico
Private cArmazem   := "" as character //Armazem Unico
Private cCliente   := "" as character //Cliente Unico
Private cLOja      := "" as character //Loja Unico
Private lPCFilEnt  := SuperGetMv("MV_PCFILEN",.F.,.F.) as logical

Static __oTmpTSC9 as object
Static __oTmpTSC6 as object

DEFAULT lNewProc := .F.

lMT215PRO   := If(lMT215PRO==nil,ExistBlock("MT215PRO"),lMT215PRO)
lMA215SD1	:= If(lMA215SD1==nil,ExistBlock("MA215SD1"),lMA215SD1)
lMT215EXC	:= If(lMT215EXC==nil,ExistBlock("MT215EXC"),lMT215EXC)
l215Regua   := !lBat .And. lNewProc // Atualiza a regua de processamento

//Verificar se deve filtrar produto e/ou armazem e refaz pedido de venda
a215Conf()

//Ponto de entrada para controlar execucao da rotina de acumuladores
If lMT215PRO
	lRet := ExecBlock("MT215PRO",.F.,.F.)
	If ValType(lRet) <> "L"
		lRet:=.T.
	EndIf

	If !lRet
		Return
	EndIf
Endif

// Atualiza o log de processamento   
ProcLogAtu("INICIO")

//Inicia tempo
nTempoIni := Seconds()
dDataIni  := Date()
nPulseLife := Seconds()

IF FINDFUNCTION( 'SetAvalSc5' )
	SetAvalSc5(.F.)//- INDICA PARA NÃO ALIMENTAR AS MÉTRICAS
EndIf

//Seleciona as filiais que vai rodar
aFils := slctEmp(aMTA215[1],aMTA215[2])
if len(aFils) > 0
	nMaxReg := ((2*len(aFils))+1)//2 processos executados ( zera por produto e atualiza com base no ped venda) * a quantidade de filiais a ser executado
	//Indico a primeira filial a ser executada da empresa
	cFirst := aFils[1][2]
	cFilAnt := cFirst
	// Cria régua de processamento para execução via Schedule
	If !lBat
		If lNewProc
			oObj:SetRegua1(nMaxReg)			
			oObj:IncRegua1(STR0030) //"Iniciando Processamento"			
		EndIf	
	EndIf
EndIf

For nFil := 1 to len(aFils)
	cFilAnt := aFils[nFil][2]
	
	cFilProc := STR0007+" - "+ AllTrim(aFils[nFil][6])+"/"+AllTrim(aFils[nFil][7])//"Atualizando acumulados"	
	
	PulseLife(oObj) //- pulso de conexão

	If !lBat
		If (oObj <> NIL) .And. lNewProc
			oObj:SaveLog(OemToAnsi(STR0009))			
		EndIf
	EndIf
	//Semaforo para controle de execucao da rotina
 	if FtVldJobFt() .and. StkRedoAccmLock(cEmpAnt,cFilAnt,oObj)

		//Atualiza o log de processamento
		ProcLogAtu("MENSAGEM",STR0012+cFilAnt,STR0012+cFilAnt,,,cSavFil) // "Inicio Filial: "

		//BLOCO DE CONSULTA PEDIDO DE VENDA
		cChkSC6 := checkSC6()	
		if (cChkSC6)->(!Eof()) 
			if (oObj <> NIL) .and. !lRfzVnd .and. (lFilProd .or. lFilArmz)
				cMessage := OemToAnsi(STR0006)//Atenção
				cMessage += CRLF + OemToAnsi(STR0032)//Identificamos que um ou mais produtos que atendem aos filtros informados contém saldo em pedidos de venda em aberto. 
				cMessage += CRLF + OemToAnsi(STR0033)//Para garantir a integridade das informações, a seleção de produtos será expandida contemplando todos os produtos e armazéns envolvidos nestes pedidos.
				if lAlertShow .and. !lBat 	
					aviso(OemToAnsi(OemToAnsi(STR0034)),cMessage,{},/*nSize*/,,,,,30,)	//'Refaz Acumulados de Pedido e Reserva'								
					lAlertShow := .f.				
					oObj:SaveLog(OemToAnsi(STR0032))
					oObj:SaveLog(OemToAnsi(STR0033))				
				EndIf
			EndIf
		endIf

		if !lRfzVnd .and. (cChkSC6)->(!Eof())  // Apenas deve atualizar os saldos da SA1 se habilitado refazer pedido de venda e tiver achado algo na tabela de pedidos		
			a215AtuSC6(oObj,aFilTabs,cFirst)//Analisa SC6 para atualizar os dados acumulados do PV e seus anexos
		else
			A215AtuReg(oObj)//Pulo registro
		endIf		
		// Realiza os processamentos e zeramentos	
		A215AtuReg(oObj)
		a215Zer(oObj,aFilTabs,cFirst)	
		
	EndIf 

	If !lBat
		If (oObj <> NIL) .And. lNewProc
			oObj:SaveLog(OemToAnsi(STR0010))
		EndIf
	EndIf
	// Atualiza o log de processamento
	ProcLogAtu("MENSAGEM",STR0013+cFilAnt,STR0013+cFilAnt,,,cSavFil) //"Final Filial: "
	
	//Ponto de entrada executado após o calculo para validações
	If lMT215EXC
		ExecBlock("MT215EXC",.F.,.F.)
	EndIf

	//Fecha o semaforo de execucao da rotina pela filial
	StkRedoAccmLock(cEmpAnt,cFilAnt,oObj,.f.)
		
Next

//Fecha todos os arquivos e reabre-os de forma compartilhada
nTempoFim := Seconds()
dDataFim  := Date()
cFilAnt := cSavFil
xDifDate := dDataFim-dDataIni


// Envia mensagem de aviso apos termino da rotina
cTempo := StrZero(((nTempoFim+((xDifDate)*86400))-nTempoIni)/60,5,0)
If GetRPORelease() < '12.1.2410'
	MEnviaMail("021",{CUSERNAME,SubStr(cNumEmp,1,2),SubStr(cNumEmp,3,2),cTempo})
EndIf

//EventViewer
cTitle	 := STR0025 // "Término de processamento do refaz acumulados "
cMessage := STR0026+cTempo+STR0027+CRLF // "Tempo de Execução: "###" Min"
cMessage += STR0028+cUserName+CRLF // "Usuário: "
EventInsert( FW_EV_CHANEL_ENVIRONMENT, FW_EV_CATEGORY_MODULES, "021", FW_EV_LEVEL_INFO, "", cTitle, cMessage, .T. )

//Atualiza o log de processamento
ProcLogAtu("FIM")

IF FINDFUNCTION( 'SetAvalSc5' )
	SetAvalSc5(.T.)//- VOLTA A ALIMENTAR AS METRICAS
EndIf

//Realiza a limpeza de todas as queries
//Fecho a tabela
dbSelectArea("SB2")
SB2->(dbCloseArea())
a215ClnQry(.t.)
FWFreeArray(aMTA215)

// calcula a duracao em segundos
nElaptime := ((Seconds()+((xDifDate)*86400))-nTempoIni)

//Telemetria - Uso da classe FwCustomMetrics         
//Metrica - setAverageMetric                         
//Grava o tempo medio de processamento do Saldo Atual
If FWLibVersion() >= "20210517"
	FWCustomMetrics():setAverageMetric(	"MATA215"/*cSubRoutine*/,;
										"estoque-protheus_refaz-acumulados-tempo-medio-mensal_seconds" /*cIdMetric*/,;
										nElaptime /*nValue*/,;
										/*dDateSend*/,/*nLapTime*/)
EndIf

Return

/*/{Protheus.doc} Ma215Res
	Avaliacao da reserva por pedido de venda ou SC9
	@type function
	@author Henry Fila
	@since 19/05/2003
	@version 1.0
	@param 	cAliasSC0,character, Alias da tabela SC0
	@param 	nQtdRes,numeric, Quantidade a reservar
	@param 	nQtdPed,numeric, Quantidade do pedido
/*/
Static Function Ma215Res(cAliasSC0,nQtdRes,nQtdPed)

Local aArea    := GetArea()
Local aAreaSC0 := SC0->(GetArea())
Local aAreaSDC := SDC->(GetArea())
Local cQryMa215Res := '' as character
Local cAliasSDC := "SDCMA215PROC1" as character
Local cItem as character
Local aBind    := {} as array

DEFAULT nQtdPed  := 0

If Localiza((cAliasSC0)->C0_PRODUTO) .And. !IntWms((cAliasSC0)->C0_PRODUTO)

	cItem := CriaVar("DC_ITEM")

	SDC->(dbSetOrder(1))

	If oQry215RES == nil
		cQryMa215Res := "SELECT DC_PRODUTO,DC_LOCAL,DC_QUANT,DC_QTSEGUM,DC_LOTECTL,DC_NUMLOTE,DC_LOCALIZ,DC_NUMSERI,DC_PEDIDO,DC_ORIGEM"
		cQryMa215Res += "FROM "+RetSqlName("SDC")+" SDC "
		cQryMa215Res += "WHERE SDC.DC_FILIAL = ? AND "
		cQryMa215Res += "SDC.DC_PRODUTO = ? AND "
		cQryMa215Res += "SDC.DC_LOCAL = ?  AND "
		cQryMa215Res += "SDC.DC_ORIGEM = ? AND "
		cQryMa215Res += "SDC.DC_PEDIDO = ? AND "
		cQryMa215Res += "SDC.DC_ITEM = ? AND "
		cQryMa215Res += "SDC.DC_SEQ = ? AND "
		cQryMa215Res += "SDC.DC_LOTECTL =? AND "
		cQryMa215Res += "SDC.DC_NUMLOTE = ? AND "
		cQryMa215Res += "SDC.D_E_L_E_T_ = ?"
		cQryMa215Res += "ORDER BY "+SqlOrder(SDC->(IndexKey()))
		cQryMa215Res := ChangeQuery(cQryMa215Res)		
		oQry215RES := FwExecStatement():New(cQryMa215Res)				
		oQry215RES:setString(4,'SC0')		
		oQry215RES:setString(6,Criavar("DC_ITEM"))
		oQry215RES:setString(7,Criavar("DC_SEQ"))		
		oQry215RES:setString(10,' ')
	endIf
	oQry215RES:setString(1,FWxFilial( 'SDC' ))
	oQry215RES:setString(2,(cAliasSC0)->C0_PRODUTO)
	oQry215RES:setString(3,(cAliasSC0)->C0_LOCAL)
	oQry215RES:setString(5,(cAliasSC0)->C0_NUM)
	oQry215RES:setString(8,(cAliasSC0)->C0_LOTECTL)
	oQry215RES:setString(9,(cAliasSC0)->C0_NUMLOTE)
	oQry215RES:OpenAlias(cAliasSDC)

	M215Comp('SDC',cAliasSDC)

	While (cAliasSDC)->(!Eof() )
		GravaEmp(	(cAliasSDC)->DC_PRODUTO,;
					(cAliasSDC)->DC_LOCAL,;
					(cAliasSDC)->DC_QUANT,;
					(cAliasSDC)->DC_QTSEGUM,;
					(cAliasSDC)->DC_LOTECTL,;
					(cAliasSDC)->DC_NUMLOTE,;
					(cAliasSDC)->DC_LOCALIZ,;
					(cAliasSDC)->DC_NUMSERI,;
					Nil,;
					Nil,;
					(cAliasSDC)->DC_PEDIDO,;
						cItem,;
					"SC0",;
					Nil,;
					Nil,;//15
					Nil,;
					.F.,;
					.F.,;
					.T.,;
					.F.,;
					NIL,;
					.T.,;
					.F.)
		(cAliasSDC)->(dbSkip())
	EndDo
	(cAliasSDC)->(dbCloseArea())
	dbSelectArea("SDC")
Else
	GravaEmp(	(cAliasSC0)->C0_PRODUTO,;
				(cAliasSC0)->C0_LOCAL,;
				nQtdRes,;
				NIL,;
				(cAliasSC0)->C0_LOTECTL,;
				(cAliasSC0)->C0_NUMLOTE,;
				(cAliasSC0)->C0_LOCALIZ,;
				(cAliasSC0)->C0_NUMSERI,;
				Nil,;
				Nil,;
				(cAliasSC0)->C0_NUM,;
					cItem,;
				"SC0",;
				Nil,;
				Nil,;
				Nil,;
				.F.,;
				.F.,;
				.T.,;
				.F.,;
				Nil,;
				!Empty((cAliasSC0)->C0_LOTECTL+(cAliasSC0)->C0_NUMLOTE+(cAliasSC0)->C0_LOCALIZ+(cAliasSC0)->C0_NUMSERI),; //22
				.F.)
EndIf

RestArea(aAreaSC0)
RestArea(aAreaSDC)
RestArea(aArea)

aSize(aAreaSC0,0)
aSize(aAreaSDC,0)
aSize(aArea,0)
aSize(aBind,0)

aAreaSC0 := NIL
aAreaSDC := nil
aArea    := nil
aBind    := nil

Return

/*/{Protheus.doc} Ma215LjAtuRes
	Realiza a atualizacao do campo B2_RESERVA, para o modulo SIGALOJA.
	@type function
	@author Marcio Lopes
	@since 15/05/2007
	@version 1.0
	@param 	cAliasSL2,character, Alias do arquivos a ser utilizado
/*/
Static Function Ma215LjAtuRes( cAliasSL2 )
	Local aAreaSB2 := SB2->(GetArea())			// Guarda a area atual do SB2

	SB2->(dbSetOrder(1))
	If SB2->( MsSeek(xFilial("SB2") + (cAliasSL2)->L2_PRODUTO + (cAliasSL2)->L2_LOCAL ) )	
		//Verifica se o produto é uma reserva na base do SIGALOJA
		RecLock("SB2", .F.)
		SB2->B2_RESERVA += (cAliasSL2)->L2_QUANT
		MsUnlock()
	EndIf
	Restarea(aAreaSB2)
	dbSelectArea(cAliasSL2)
	aSize(aAreaSB2,0)
	aAreaSB2 := nil
Return(.T.)

/*/{Protheus.doc} StkRedoAccmLock
	Bloqueio de Empresas para o processamento da rotina Refaz Empenhos
	@type function
	@author TOTVS s/a
	@since 20/01/2014
	@version 1.0
	@param cEmpresa, character, Codigo da Empresa	
/*/
Static Function StkRedoAccmLock(cEmpresa,cFilProc,oObj,lLock)
Local lRet       := .T. as logical
Local nTentativa := 0 as numeric
Local cLockName  := '' as character
local cLockMsg   := '' as character
Local cFilTrat  := '' as character
Default cFilproc := ''
Default lLock    := .t. 
nTentativa := 0
cFilTrat := Alltrim(strtran(cFilProc,' ','_'))
cLockName := "MT215"+AllTrim(cEmpresa)+Alltrim(cFilTrat)

if lLock
	// Trava arquivo para somente este usuario utilizar rotina
	While !LockByName(cLockName,.T.,.F.) .And. nTentativa <= 50
		nTentativa++
		Sleep(100)
	EndDo

	// Tenta travar somente 50 vezes, e se nao conseguir coloca na lista de filiais com concorrencia
	If nTentativa > 50
		cLockMsg := OemToAnsi(STR0015)+":"+cFilProc //'Concorrencia '+ Filial
		If !IsBlind()
			Aviso(STR0015,cLockMsg,{"Ok"},2) // ##"Concorrência"##"
		EndIf
		if oobj <> nil
			oobj:SaveLog(cLockMsg) 
		EndIf
		lRet := .F.
	EndIf
else
	UnLockByName(cLockName,.T.,.F.)
	lRet := .t.
EndIf

Return lRet

/*/{Protheus.doc} m215NNS
	Atualizacao dos empenhos efetuados na rotina MATA311.
	@type function
	@author reynaldo
	@since 24/11/2017
	@version 1.0
	@param oObj, object, objeto da regua de progresso
	@param cFirst, character, primeira filial executada
/*/
Static Function m215NNS(oObj,cFirst)
Local cMensagem := ""
Local cAliasNNT := "NNTMA215PROC" as character
Local cQryNNT := '' as character
Local nBind := 1
	//Atualiza os dados acumulados dos empenhos da MATA311
	If (!Empty(xFilial("NNS")) .Or. cFilAnt == cFirst )
		
		cMensagem := getMsg("NNS")			
		//A215(oObj, cFilProc, cMensagem)
		
		NNT->(dbSetOrder(1))
		SB2->( DbSetOrder(1))
		
		If oQueryNNT == nil
			cQryNNT := "SELECT NNT_FILORI,NNT_LOCAL,NNT_LOCALI,NNT_PROD,NNT_NSERIE,NNT_LOTECT,NNT_PRODD,"
			cQryNNT += " NNT_NUMLOT,NNT_QUANT,NNT_QTSEG,NNT_LOCLD,NNT_FILDES "
			cQryNNT += " FROM "+RetSqlName("NNT")+" NNT "
			cQryNNT += " INNER JOIN " + RetSqlName("NNS")+" NNS "
			cQryNNT += " ON NNS.NNS_FILIAL = ? "			
			cQryNNT += " AND NNS.NNS_COD = NNT.NNT_COD "
			cQryNNT += " AND NNS.NNS_STATUS IN (?) "
			cQryNNT += " AND NNS.D_E_L_E_T_= ? "
			cQryNNT += " WHERE NNT.NNT_FILIAL = ? "
			if lFilProd //FILTRO DE PRODUTO
				cQryNNT += " AND NNT.NNT_PROD BETWEEN ? AND ? "				
			EndIf
			if lFilArmz //FILTRO DE ARMAZEM
				cQryNNT += " AND NNT.NNT_LOCAL BETWEEN ? AND ? "				
			EndIf
			cQryNNT += " AND NNT.D_E_L_E_T_ = ? "			
			cQryNNT := changeQuery(cQryNNT)
			oQueryNNT := FwExecStatement():New(cQryNNT)			
		EndIf						
		oQueryNNT:setString(nBind++,FWxFilial('NNS'))		
		oQueryNNT:setIn(nBind++,{'1','3','4'})
		oQueryNNT:setString(nBind++,' ')
		oQueryNNT:setString(nBind++,FWxFilial('NNT'))
		injectPerg(oQueryNNT,@nBind)
		injectPerg(oQueryNNT,@nBind,.f.)					
		oQueryNNT:setString(nBind++,' ')
		oQueryNNT:OpenAlias(cAliasNNT)
		
		M215Comp('NNT',cAliasNNT)
		
		
		
		While (cAliasNNT)->(!Eof())
			//Atualiza arquivo de empenhos               
			If Localiza((cAliasNNT)->NNT_PROD)
				//Gera empenho do produto por endereço
				SBF->( DbSetOrder(1) ) //BF_FILIAL+BF_LOCAL+BF_LOCALIZ+BF_PRODUTO+BF_NUMSERI+BF_LOTECTL+BF_NUMLOTE
				If SBF->( DbSeek(xFilial('SBF',(cAliasNNT)->NNT_FILORI)+(cAliasNNT)->(NNT_LOCAL+NNT_LOCALI+NNT_PROD+NNT_NSERIE+NNT_LOTECT+NNT_NUMLOT)) )
					GravaBFEmp("+",(cAliasNNT)->NNT_QUANT,"F",,(cAliasNNT)->NNT_QTSEG)
				Endif
			EndIf
			If Rastro((cAliasNNT)->NNT_PROD)
				//Gera empenho do produto por lote ou sub-lote
				SB8->( DbSetOrder(3) )
				If SB8->( DbSeek(xFilial('SB8',(cAliasNNT)->NNT_FILORI)+(cAliasNNT)->(NNT_PROD+NNT_LOCAL+NNT_LOTECT+NNT_NUMLOT)) )
					GravaB8Emp("+",(cAliasNNT)->NNT_QUANT,"F",NIL,(cAliasNNT)->NNT_QTSEG)
				Endif
			EndIf
			//Gera do produto por armazém
			If SB2->( MsSeek(xFilial('SB2',(cAliasNNT)->NNT_FILORI)+(cAliasNNT)->(NNT_PROD+NNT_LOCAL)) )
				GravaB2Emp("+",(cAliasNNT)->NNT_QUANT,"F",NIL,(cAliasNNT)->NNT_QTSEG)
			Endif
			//Gera previsão de Entrada na Filial de Destino
			If SB2->( MsSeek(xFilial("SB2",(cAliasNNT)->NNT_FILDES)+(cAliasNNT)->(NNT_PRODD+NNT_LOCLD)) )
				GravaB2Pre('+',(cAliasNNT)->NNT_QUANT,"F",(cAliasNNT)->NNT_QTSEG)
			Endif
			(cAliasNNT)->(dbSkip())
			
			
		EndDo
		(cAliasNNT)->(dbCloseArea())
		dbSelectArea("NNT")
	EndIf	
	
Return

/*/{Protheus.doc} a215AtuSC1
	Atualiza os dados acumulados da Solicitacao de Compra
	@type  Function
	@author reynaldo
	@since 23/12/2020
	@version 1.0
/*/
Static Function a215AtuSC1(oObj,aFilTabs,cFirst)
Local cMensagem := '' as character
Local cAliasSC1 := "SC1MA215PROC" as character
Local cQryAtuSC1 := '' as character
Local lContinua := .t. as logical
Local lSCSldBl := .f. as logical
Local nBind := 1 as numeric

	lM215SC	:= If(lM215SC==nil,ExistBlock("M215SC"),lM215SC)
	lSCSldBl := SuperGetMv("MV_SCSLDBL",.F.,.F.)

	if vldProc('SC1',aFilTabs,TabelaSC1,cFirst)	
		cMensagem := getMsg('SC1')
		
		
		
		dbSelectArea("SC1")
		SC1->(dbSetOrder(1))
		
		

		If oQuerySC1 == nil						
			cQryAtuSC1 := " SELECT SC1.C1_FILIAL,SC1.C1_NUM,SC1.C1_PRODUTO,SC1.C1_LOCAL,SC1.C1_ITEM,SC1.C1_APROV,SC1.C1_TPOP, "
			cQryAtuSC1 += " SC1.C1_FORNECE,SC1.C1_LOJA,SC1.C1_IMPORT,SC1.C1_TIPO,SC1.C1_IDENT,SC1.C1_CLASS,SC1.C1_RESIDUO, "
			cQryAtuSC1 += " SC1.C1_FLAGSC,SC1.C1_COTACAO,SC1.C1_QUANT,SC1.C1_QTSEGUM,SC1.C1_QUJE,SC1.C1_QUJE2,SC1.C1_CODCOMP, " 
			cQryAtuSC1 += " SC1.C1_PEDIDO,SC1.C1_ITEMPED,SC1.C1_ACCPROC,SC1.C1_SCORI,SC1.C1_FISCORI,SC1.C1_ESTOQUE,SC1.C1_FILENT, "
			cQryAtuSC1 += " SC1.C1_USER,SC1.C1_GRUPCOM,SC1.C1_ITSCORI,SC1.R_E_C_N_O_ SC1RECNO "			
			cQryAtuSC1 += " FROM "+RetSqlName("SC1")+" SC1 "
			cQryAtuSC1 += " INNER JOIN "+RetSqlName("SB1")+" SB1 "
			cQryAtuSC1 += " ON SB1.B1_FILIAL = ? "
			cQryAtuSC1 += " AND SB1.B1_COD = SC1.C1_PRODUTO "
			cQryAtuSC1 += " AND SB1.D_E_L_E_T_ = ? "
			cQryAtuSC1 += " WHERE SC1.C1_FILIAL = ?  "
			if lFilProd //FILTRO DE PRODUTO
				cQryAtuSC1 +=  " AND SC1.C1_PRODUTO BETWEEN ? AND ? "				
			EndIf			
			if lFilArmz //FILTRO DE ARMAZEM
				cQryAtuSC1 += " AND SC1.C1_LOCAL BETWEEN ? AND ? "				
			EndIf
			cQryAtuSC1 += " AND SC1.C1_QUJE < SC1.C1_QUANT  "
			cQryAtuSC1 += " AND SC1.C1_RESIDUO = ? "											
			cQryAtuSC1 += " AND SC1.D_E_L_E_T_= ? "			
			cQryAtuSC1 += "ORDER BY SC1.C1_FILIAL,SC1.C1_PRODUTO,SC1.C1_LOCAL "
			cQryAtuSC1 := ChangeQuery(cQryAtuSC1)
			oQuerySC1 := FwExecStatement():New(cQryAtuSC1)						
		EndIf
		oQuerySC1:setString(nBind++,FWxFilial( 'SB1' ))
		oQuerySC1:setString(nBind++,' ')
		oQuerySC1:setString(nBind++,FWxFilial( 'SC1' ))		
		injectPerg(oQuerySC1,@nBind)
		injectPerg(oQuerySC1,@nBind,.f.)
		oQuerySC1:setString(nBind++,Space(TamSx3('C1_RESIDUO')[1]))
		oQuerySC1:setString(nBind++,' ')		
		oQuerySC1:OpenAlias(cAliasSC1)

		M215Comp('SC1',cAliasSC1)

		//Atualiza os dados acumulados da Solicitacao de compra         
		While (cAliasSC1)->(!Eof())
			lContinua := .T.			

			// Ponto de Entrada para Tratamentos Especiais         			
			If lM215SC
				dbSelectArea("SC1")
				SC1->(DbGoto((cAliasSC1)->SC1RECNO))
				If ExecBlock("M215SC",.f.,.f.)
					lContinua := .F.
				EndIf
			EndIf
			If lContinua
				MaAvalSC(cAliasSC1,1,,,.T.)

				If (cAliasSC1)->C1_APROV == "R" .AND. lSCSldBl
					dbSelectArea("SC1")
					SC1->(DbGoto((cAliasSC1)->SC1RECNO))
					MaAvalSC(cAliasSC1,8,,,,,," ")
				EndIf
			EndIf
			(cAliasSC1)->(dbSkip())
			
		EndDo

		(cAliasSC1)->(dbCloseArea())
		dbSelectArea("SC1")

	EndIf	

	

Return

/*/{Protheus.doc} a215AtuOP
	Atualiza os dados acumulados das Ordens de Producao
	@type  Function
	@author reynaldo
	@since 23/12/2020
	@version 1.0
	@param oObj, object, objeto da regua de progresso
	@param aFilTabs, array, array das filiais
	@param cFirst, character, primeira filial lida	
/*/
Static Function a215AtuOP(oObj,aFilTabs,cFirst)
Local cMensagem := '' as character
Local cAliasSC2 := "SC2MA215PROC" as character
Local nQuant := 0 as numeric
Local cQryAtuOP := '' as character
Local nBind := 1 as numeric 

	if vldProc('SC2',aFilTabs,TabelaSC2,cFirst)	
		//Atualiza os dados acumulados das Ordens de Producao		
		cMensagem := getMsg('SC2')		
		

		dbSelectArea("SC2")
		SC2->(dbSetOrder(1))
		SB2->(dbSetOrder(1))

		If oQuerySC2 == nil
			cQryAtuOP := "SELECT SC2.C2_PRODUTO,SC2.C2_LOCAL,SC2.C2_TPOP ,SB1.R_E_C_N_O_ RECNOSB1 , "
			cQryAtuOP += " MAX(SC2.C2_DATRF) C2_DATRF, SUM(SC2.C2_QUANT) C2_QUANT, SUM(SC2.C2_QUJE) C2_QUJE, SUM(SC2.C2_PERDA) C2_PERDA "
			cQryAtuOP += " FROM "+RetSQLName("SC2")+" SC2, "
			cQryAtuOP += " "+RetSQLName("SB1")+ " SB1 "
			cQryAtuOP += " WHERE SC2.C2_FILIAL= ? AND "
			cQryAtuOP += " (SC2.C2_DATRF= ? AND "
			cQryAtuOP += " SC2.C2_QUANT-SC2.C2_QUJE-SC2.C2_PERDA>0) AND "
			cQryAtuOP += " SC2.D_E_L_E_T_= ? AND "
			cQryAtuOP += " SB1.B1_FILIAL= ? AND "			
			if lFilProd //FILTRO DE PRODUTO
				cQryAtuOP += " SB1.B1_COD BETWEEN ? AND ? AND "				
			EndIf
			cQryAtuOP += " SB1.B1_COD=SC2.C2_PRODUTO AND "			
			if lFilArmz //FILTRO DE ARMAZEM
				cQryAtuOP += " SC2.C2_LOCAL BETWEEN ? AND ? AND "				
			EndIf
			cQryAtuOP += " SB1.D_E_L_E_T_= ? "
			cQryAtuOP += " GROUP BY SC2.C2_PRODUTO,SC2.C2_LOCAL,SC2.C2_TPOP ,SB1.R_E_C_N_O_ "
			cQryAtuOP += " UNION ALL "
			cQryAtuOP += " SELECT SC2.C2_PRODUTO,SC2.C2_LOCAL,SC2.C2_TPOP ,SB1.R_E_C_N_O_ RECNOSB1 , "
			cQryAtuOP += " MAX(SC2.C2_DATRF) C2_DATRF, SUM(SC2.C2_QUANT) C2_QUANT, SUM(SC2.C2_QUJE) C2_QUJE, SUM(SC2.C2_PERDA) C2_PERDA "
			cQryAtuOP += " FROM "+RetSQLName("SC2")+" SC2, "
			cQryAtuOP += " "+RetSQLName("SB1")+ " SB1 "
			cQryAtuOP += " WHERE SC2.C2_FILIAL= ? AND "
			cQryAtuOP += " SC2.C2_DATRF<> ? AND "
			cQryAtuOP += " SC2.D_E_L_E_T_= ? AND "
			cQryAtuOP += " SB1.B1_FILIAL= ? AND "			
			if lFilProd //FILTRO DE PRODUTO
				cQryAtuOP += " SB1.B1_COD BETWEEN ? AND ? AND "				
			EndIf
			cQryAtuOP += " SB1.B1_COD=SC2.C2_PRODUTO AND "			
			if lFilArmz //FILTRO DE ARMAZEM
				cQryAtuOP += " SC2.C2_LOCAL BETWEEN ? AND ? AND "				
			EndIf
			cQryAtuOP += " SB1.D_E_L_E_T_= ? "
			cQryAtuOP += " GROUP BY SC2.C2_PRODUTO,SC2.C2_LOCAL,SC2.C2_TPOP ,SB1.R_E_C_N_O_ "
			cQryAtuOP += " ORDER BY C2_PRODUTO, C2_LOCAL, C2_TPOP "

			cQryAtuOP := ChangeQuery(cQryAtuOP)
			oQuerySC2 := FwExecStatement():New(cQryAtuOP)
			
		EndIf
		oQuerySC2:setString(nBind++,FWxFilial( 'SC2' ))
		oQuerySC2:setString(nBind++,space(8))
		oQuerySC2:setString(nBind++,space(1))
		oQuerySC2:setString(nBind++,FWxFilial( 'SB1' ))
		injectPerg(oQuerySC2,@nBind)
		injectPerg(oQuerySC2,@nBind,.f.)		
		oQuerySC2:setString(nBind++,space(1))
		oQuerySC2:setString(nBind++,FWxFilial( 'SC2' ))
		oQuerySC2:setString(nBind++,space(8))
		oQuerySC2:setString(nBind++,space(1))
		oQuerySC2:setString(nBind++,FWxFilial( 'SB1' ))
		injectPerg(oQuerySC2,@nBind)
		injectPerg(oQuerySC2,@nBind,.f.)
		oQuerySC2:setString(nBind++,space(1))
		
		oQuerySC2:OpenAlias(cAliasSC2)

		M215Comp('SC2',cAliasSC2)

		
		
		While (cAliasSC2)->(!Eof())			
			SB1->(DbGoto((cAliasSC2)->RECNOSB1))				
			chkSb2(xFilial("SB2")+(cAliasSC2)->C2_PRODUTO+(cAliasSC2)->C2_LOCAL,(cAliasSC2)->C2_PRODUTO,(cAliasSC2)->C2_LOCAL)
			If Empty((cAliasSC2)->C2_DATRF)
				nQuant := aSC2Sld(cAliasSC2) //Saldo real da OP
			Else
				nQuant := 0
			EndIf
			GravaB2Pre("+",nQuant,(cAliasSC2)->C2_TPOP)
			
			(cAliasSC2)->(dbSkip())
			
		EndDo

		(cAliasSC2)->(dbCloseArea())
		dbSelectArea("SC2")

	EndIf	
	
Return 


/*/{Protheus.doc} a215OPEmp
	Atualiza os dados acumulados de empenho das Ordens de Producao.
	Somente separado da funcao Ma215Proc "especializando" o processo
	@type Function
	@author reynaldo
	@since 12/02/2021
	@version 1.0
	@param oObj, object, objeto da regua de progresso
	@param aFilTabs, array, array das filiais
	@param cFirst, character, primeira filial lida		
	@return nenhum	
/*/
Static Function a215OPEmp(oObj,aFilTabs,cFirst)
Local cMensagem as character
Local cAliasSD4 := "SD4MA215PROC" as character
Local cQuerySD4 := '' as character
local cQryOPEmp := '' as character
Local lNegEstr := SuperGetMV("MV_NEGESTR",.F.,.F.) as logical
Local nQuantDc := 0 as numeric
Local nQtdDifDc := 0 as numeric
Local cAliasSDC := "SDCMA215PROC3" as character
Local lAchou := .f. as logical
Local cLocaliza := '' as character
Local cNumSerie := '' as character
Local cPedido := '' as character
Local cItem := '' as character
Local aTravas := {} as array
Local nBind := 1 as numeric

	if vldProc('SD4',aFilTabs,TabelaSD4,cFirst)	

		cLocaliza := CriaVar("BF_LOCALIZ")
		cNumSerie := CriaVar("BF_NUMSERI")
		cPedido   := CriaVar("DC_PEDIDO")
		cItem     := CriaVar("DC_ITEM")

		cMensagem := getMsg("SD4")
	
		
		
		dbSelectArea("SD4")
		dbSetOrder(1)

		if oQuerySD4 == nil .and. lNegEstr <> xSavNEstr 
			cQuerySD4 := "SELECT D4_COD,D4_LOCAL,D4_QUANT,D4_QTSEGUM,D4_LOTECTL,"
			cQuerySD4 += " D4_NUMLOTE,D4_OP,D4_TRT,D4_OPORIG,D4_DATA,SB1.R_E_C_N_O_ SB1RECNO "
			cQuerySD4 += "FROM "+RetSqlName("SD4")+" SD4,"
			cQuerySD4 += RetSqlName("SB1")+" SB1 "
			cQuerySD4 += "WHERE SD4.D4_FILIAL= ? AND "			
			if lFilArmz //FILTRO DE ARMAZEM
				cQuerySD4 += " SD4.D4_LOCAL BETWEEN ? AND ? AND "				
			EndIf
			// MV_NEGESTR - Parametro utilizado para considerar empenho negativo
			If lNegEstr
				cQuerySD4 += " SD4.D4_QUANT <> ? AND "
			Else
				cQuerySD4 += "SD4.D4_QUANT > ? AND "
			EndIf
			cQuerySD4 += "SD4.D_E_L_E_T_= ? AND "
			cQuerySD4 += "SB1.B1_FILIAL= ? AND "			
			if lFilProd //FILTRO DE PRODUTO
				cQuerySD4 += " SB1.B1_COD BETWEEN ? AND ? AND "				
			EndIf
			cQuerySD4 += "SB1.B1_COD=SD4.D4_COD AND "
			cQuerySD4 += "SB1.D_E_L_E_T_= ? "
			cQuerySD4 += "ORDER BY D4_FILIAL,D4_COD,D4_LOCAL"

			cQuerySD4 := ChangeQuery(cQuerySD4)
			oQuerySD4 := FwExecStatement():New(cQuerySD4)
			
			xSavNEstr := lNegEstr
		endIf			
		oQuerySD4:setString(nBind++,FWxFilial('SD4'))
		injectPerg(oQuerySD4,@nBind,.f.)		
		oQuerySD4:setNumeric(nBind++,0)
		oQuerySD4:setString(nBind++,' ')
		oQuerySD4:setString(nBind++,FWxFilial('SB1'))
		injectPerg(oQuerySD4,@nBind)		
		oQuerySD4:setString(nBind++,' ')
		oQuerySD4:OpenAlias(cAliasSD4)		
		
		M215Comp('SD4',cAliasSD4)

		

		While (cAliasSD4)->(!Eof() )
			nQuantDc :=0
			nQtdDifDc:=0

			SB1->(DbGoto((cAliasSD4)->SB1RECNO))

			If Localiza((cAliasSD4)->D4_COD)				

				If oQrySDCOP == nil
					cQryOPEmp := "SELECT DC_PRODUTO,DC_LOCAL,DC_QUANT,DC_QTSEGUM,"
					cQryOPEmp += " DC_LOTECTL,DC_NUMLOTE,DC_LOCALIZ,DC_NUMSERI,DC_OP,DC_TRT "
					cQryOPEmp += "FROM "+RetSqlName("SDC")+" SDC "
					cQryOPEmp += "WHERE SDC.DC_FILIAL= ? AND "
					cQryOPEmp += "SDC.DC_PRODUTO= ? AND "
					cQryOPEmp += "SDC.DC_LOCAL= ? AND "
					cQryOPEmp += "SDC.DC_OP= ? AND "
					cQryOPEmp += "SDC.DC_TRT= ? AND "
					cQryOPEmp += "SDC.DC_LOTECTL= ? AND "
					cQryOPEmp += "SDC.DC_NUMLOTE= ? AND "
					cQryOPEmp += "SDC.D_E_L_E_T_= ? "
					cQryOPEmp += "ORDER BY "+SqlOrder(SDC->(IndexKey()))
					cQryOPEmp := ChangeQuery(cQryOPEmp)
					oQrySDCOP := FwExecStatement():New(cQryOPEmp)
					oQrySDCOP:setString(8,' ')				
				EndIf			
								
				oQrySDCOP:setString(1,FWxFilial( 'SDC' ))
				oQrySDCOP:setString(2,(cAliasSD4)->D4_COD)
				oQrySDCOP:setString(3,(cAliasSD4)->D4_LOCAL)
				oQrySDCOP:setString(4,(cAliasSD4)->D4_OP)
				oQrySDCOP:setString(5,(cAliasSD4)->D4_TRT)
				oQrySDCOP:setString(6,(cAliasSD4)->D4_LOTECTL)
				oQrySDCOP:setString(7,(cAliasSD4)->D4_NUMLOTE)
				oQrySDCOP:OpenAlias(cAliasSDC)		

				M215Comp('SDC',cAliasSDC)

				lAchou := .F.
				While (cAliasSDC)->(!Eof() )
					
					//Atualiza arquivo de empenhos					
					nQuantDc+=(cAliasSDC)->DC_QUANT
					lAchou := .T.
					GravaEmp(	(cAliasSDC)->DC_PRODUTO,;
									(cAliasSDC)->DC_LOCAL,;
									(cAliasSDC)->DC_QUANT,;
									(cAliasSDC)->DC_QTSEGUM,;
									(cAliasSDC)->DC_LOTECTL,;
									(cAliasSDC)->DC_NUMLOTE,;
									(cAliasSDC)->DC_LOCALIZ,;
									(cAliasSDC)->DC_NUMSERI,;
									(cAliasSDC)->DC_OP,;
									(cAliasSDC)->DC_TRT,;
									cPedido,;
									cItem,;
									"SC2",;
									NIL,;
									NIL,;
									NIL,;
									.F.,;
									.F.,;
									.T.,;
									.F.,;
									NIL,;
									.T.,;
									.F.)
					(cAliasSDC)->(dbSkip())
				EndDo			
				//Tratamento para verificar se existe diference entre valores da SDC e SD4				
				If nQuantDc < (cAliasSD4)->D4_QUANT
					nQtdDifDc := (cAliasSD4)->D4_QUANT - nQuantDc
					lAchou :=.F.
				EndIf

				(cAliasSDC)->(dbCloseArea())
				dbSelectArea("SDC")

				If !lAchou
					
					//Atualiza arquivo de empenhos					
					GravaEmp(	(cAliasSD4)->D4_COD,;
									(cAliasSD4)->D4_LOCAL,;
									IIf(QtdComp((cAliasSD4)->D4_QUANT) <> QtdComp(nQuantDc),nQtdDifDc,(cAliasSD4)->D4_QUANT),;
									(cAliasSD4)->D4_QTSEGUM,;
									(cAliasSD4)->D4_LOTECTL,;
									(cAliasSD4)->D4_NUMLOTE,;
									cLocaliza,;
									cNumSerie,;
									(cAliasSD4)->D4_OP,;
									(cAliasSD4)->D4_TRT,;
									cPedido,;
									cItem,;
									"SC2",;
									(cAliasSD4)->D4_OPORIG,;
									(cAliasSD4)->D4_DATA,;
									@aTravas,;
									.F.,;
									.F.,;
									.T.,;
									.F.,;
									NIL,;
									.T.,;
									.F.)
				EndIf
			Else
				
				//Atualiza arquivo de empenhos				
				GravaEmp(	(cAliasSD4)->D4_COD,;
								(cAliasSD4)->D4_LOCAL,;
								(cAliasSD4)->D4_QUANT,;
								(cAliasSD4)->D4_QTSEGUM,;
								(cAliasSD4)->D4_LOTECTL,;
								(cAliasSD4)->D4_NUMLOTE,;
								cLocaliza,;
								cNumSerie,;
								(cAliasSD4)->D4_OP,;
								(cAliasSD4)->D4_TRT,;
								cPedido,;
								cItem,;
								"SC2",;
								(cAliasSD4)->D4_OPORIG,;
								(cAliasSD4)->D4_DATA,;
								NIL,;
								.F.,;
								.F.,;
								.T.,;
								.F.,;
								NIL,;
								.T.,;
								.F.)
			EndIf
			(cAliasSD4)->(dbSkip())	
			
		EndDo

		aSize(aTravas,0)
		aTravas := nil	

		(cAliasSD4)->(dbCloseArea())
		dbSelectArea("SD4")
	EndIf
	
Return

/*/{Protheus.doc} a215AtuSC6
	Atualizacao referente ao itens do pedido de vendas
	Somente separado da funcao Ma215Proc "especializando" o processo
	@type  Function
	@author reynaldo
	@since 17/02/2021
	@version 1.0
	@param oObj, Object, Objeto da Regua
	@param aFilTabs, Array, Tabela de filiais
	@param cFirst, Character, indica a primeira filial executada	
/*/
Static Function a215AtuSC6(oObj,aFilTabs,cFirst)
Local cMensagem as character
Local cAliasSC6 := "SC6MA215PROC" as character
Local cQuery as character
Local lLiberOk as logical
Local lResidOk as logical
Local lFaturOk as logical
Local cFilialSD2 as character
Local cQuebra as character
Local aSaldos as array
Local nBind := 1 as numeric
Local aBind := {} as array
Local lBFilArmz  := lFilArmz as logical
Local lBFilProd  := lFilProd as logical
Local nLenC6_BLQ := Len(SC6->C6_BLQ) as numeric

	lMA215SD2	:= If(lMA215SD2==nil,ExistBlock("MA215SD2"),lMA215SD2)

	if vldProc('SC6',aFilTabs,TabelaSC6,cFirst,.f.,.t.)	

		//Atualiza os dados acumulados do PV e seus anexos		
		cMensagem := getMsg('SC6')

		dbSelectArea("SC6")
		SC6->(dbSetOrder(1))
	
	If oQuerySC6 == nil
		cQuery := " SELECT DISTINCT C6_FILIAL,C6_NUM,C6_ITEM,C6_PRODUTO, "
		cQuery += " SC6.R_E_C_N_O_ RECNOSC6 "
		cQuery += " ,ISNULL(SB1.R_E_C_N_O_,0) RECNOSB1 "		
		cQuery += " FROM "+RetSqlName("SC6")+" SC6 "
		cQuery += " LEFT JOIN "+RetSqlName("SB1")+" SB1 "
		cQuery += " ON "
		cQuery += " SB1.B1_FILIAL= ? AND "		
		cQuery += " SB1.B1_COD = SC6.C6_PRODUTO AND "
		cQuery += " SB1.D_E_L_E_T_= ? "
		cQuery += " LEFT JOIN "+RetSqlName("SD2")+" SD2 "
		cQuery += " ON "
		cQuery += " SD2.D2_DOC = SC6.C6_NOTA AND SD2.D2_SERIE = SC6.C6_SERIE AND "
		cQuery += " SD2.D2_PEDIDO = SC6.C6_NUM AND SD2.D2_ITEMPV =  SC6.C6_ITEM AND " 
		cQuery += " SD2.D2_CLIENTE = SC6.C6_CLI AND SD2.D2_LOJA =  SC6.C6_LOJA AND " 
		cQuery += " SD2.D2_FILIAL = ? AND "
		cQuery += " SD2.D_E_L_E_T_ = ? "
		cQuery += " WHERE "
		cQuery += " ((SC6.C6_FILIAL <> ? AND SC6.C6_FILIAL= ? ) OR "
		cQuery += " COALESCE (SD2.R_E_C_N_O_,0) > ? ) AND " 		
		//FILTRO DE CLIENTE
		if !Empty(cCliente)
			cQuery += " SC6.C6_CLI = ? AND "				
		EndIf
		//FILTRO DE LOJA
		if !empty(cLoja)
			cQuery += " SC6.C6_LOJA = ? AND  "						
		EndIf
		cQuery += " SC6.C6_BLQ <> ? AND "
		cQuery += " SC6.C6_BLQ <> ? AND "
		cQuery += " (SC6.C6_QTDVEN > SC6.C6_QTDENT OR (SC6.C6_QTDVEN <= SC6.C6_QTDENT AND SC6.C6_ENTREG>= ?)) AND "
		cQuery += " SC6.D_E_L_E_T_= ? "
		cQuery += " ORDER BY C6_FILIAL,C6_NUM,C6_ITEM,C6_PRODUTO "
		
		cQuery := ChangeQuery(cQuery)

		oQuerySC6 := FwExecStatement():New(cQuery)
	EndIf

	oQuerySC6:SetString(nBind++,xFilial( "SB1" ))
	oQuerySC6:SetString(nBind++,Space(1))
	oQuerySC6:SetString(nBind++,xFilial("SD2"))
	oQuerySC6:SetString(nBind++,Space(1))
	oQuerySC6:SetString(nBind++,Space(1))
	oQuerySC6:SetString(nBind++,xFilial("SC6"))
	oQuerySC6:setNumeric(nBind++,0)	
	if !empty(cCliente)
		oQuerySC6:SetString(nBind++,cCliente)
	EndIf	
	if !empty(cLoja)
		oQuerySC6:SetString(nBind++,cLoja)
	EndIf
	oQuerySC6:SetString(nBind++,PadR('S',nLenC6_BLQ))
	oQuerySC6:SetString(nBind++,PadR('R',nLenC6_BLQ))
	oQuerySC6:SetString(nBind++,DTOS(dDataBase-31))
	oQuerySC6:SetString(nBind++,Space(1))
	oQuerySC6:OpenAlias(cAliasSC6)
		
		M215Comp('SC6',cAliasSC6)

 		lLiberOk  := .T.
		lResidOk  := .T.
		lFaturOk  := .F.
				
		dbSelectArea("SC6")
		SC6->(dbSetOrder(1))

		
		While !(cAliasSC6)->(Eof()) 
			//Processo o produto zerando ele e fazendo as movimentações
			SC6->(DbGoto((cAliasSC6)->RECNOSC6))
			SB1->(DbGoto((cAliasSC6)->RECNOSB1))

			lFilArmz := .t.
			lFilProd := .t.
			cProduto := SC6->C6_PRODUTO
			cArmazem := SC6->C6_LOCAL
			cCliente := SC6->C6_CLI
			cLoja    := SC6->C6_LOJA
			zerSC6((cAliasSC6)->RECNOSC6)
			A215Zer(oObj,aFiltabs,cFirst)
			
			cQuebra   := SC6->C6_NUM
			
			//Atualiza os acumulados dos pedidos de venda entregue	
			//D2_REMITO <> '' = C6_QTDENT,C6_QTDENT2 | C6_NOTA,C6_SERIE,C6_DATFAT | SE C6_QTDRESE==0 ENTAO C6_RESERVA = ''
			procSD2("SC6",lLiberOk,lResidOk,lFaturOk)			
										
			//Passa as variaveis lLiberok, lResidOk e lFaturOk sem referencia para nao modificar o conteudo
			If !Empty(SC6->C6_RESERVA) .And. SC6->C6_QTDRESE > 0
				SC0->(dbSetOrder(1))
				If SC0->(MsSeek(xFilial("SC0")+SC6->C6_RESERVA+SC6->C6_PRODUTO+SC6->C6_LOCAL))
					Ma215Res("SC0",SC6->C6_QTDRESE)
				Endif
			Endif
					
			//Aqui é onde ele atualiza os dados do cliente
			//B2_QPEDVEN,B2_QPEDVEN2,A1_SALPED mas pode B2_QEMPN,B2_QEMPN2,B2_QEMPPRE,B2_QEPRE2
			MaAvalSC6("SC6",1,"SC5",.F.,.F.,lLiberOk,lResidOk,lFaturOk,.T.)

			//Processa pedidos liberados
			procSC9()
					
			//Verificacao dos acumulados do SC5                                      					
			If ( SC6->C6_QTDVEN > (SC6->C6_QTDEMP+SC6->C6_QTDENT) .And. AllTrim(SC6->C6_BLQ)<>"R")
				lLiberOk := .F.
			EndIf
			If (! "R" $ SC6->C6_BLQ )
				lResidOk := .F.
			EndIf
			If ( SC6->C6_QTDVEN > SC6->C6_QTDENT .And. AllTrim(SC6->C6_BLQ)<>"R")
				lFaturOk := .T.//C5_NOTA = '',SENAO C5_NOTA = 'XXXXXX'
			EndIf

			
			dbSelectArea("SC9")
			
			(cAliasSC6)->(dbSkip())				
			
			//Somente entra uma vez por pedido
			If cQuebra <> SC6->C6_NUM
				SC5->(dbSetOrder(1))
				If SC5->(MsSeek(xFilial("SC5")+cQuebra))
					//C5_LIBEROK,C5_NOTA
					SC5->(MaAvalSC5("SC5",1,.F.,.F.,@lLiberOk,@lResidOk,@lFaturOk,.T.))
				EndIf
				lLiberOk  := .T.
				lResidOk  := .T.
				lFaturOk  := .F.
			EndIf			
		EndDo


		FWFreeArray(aSaldos)

		If Empty(xFilial("SC6"))
			aFilTabs[TabelaSC6][2] := cfilialSD2
		EndIF
		(cAliasSC6)->(dbCloseArea())
		dbSelectArea("SC6")
	EndIf
	aSize(aBind,0)
	aBind := nil
	lFilArmz := lBFilArmz
	lFilProd := lBFilProd
	cProduto := ''
	cArmazem := ''
	cCliente := ''
	cLoja	 := ''
	
Return

/*/{Protheus.doc} procSC9
	Processa pedidos liberados
	@type  Static Function
	@author user
	@since 26/12/2025
	@version version
	@param param_name, param_type, param_descr
	@return return_var, return_type, return_description
	@example
	(examples)
	@see (links_or_references)
/*/
Static Function procSC9()
Local cQuery := '' as character
Local cAliasSC9 := "SC9MA215PROC" as character
Local aSaldos := {} as array
Local aArea  := getArea() 
local nLenC9_Nf  := len(SC9->C9_NFISCAL) as numeric
Local nQtdLib2 as numeric

// Busca do pedido, item e produto
If oRegSC9 == nil
	cQuery := " SELECT SC9.R_E_C_N_O_ RECNOSC9 "
	cQuery += " FROM "+RetSqlName("SC9")+" SC9 "
	cQuery += " WHERE SC9.C9_FILIAL = ? "//xFilial(SC9) 
	cQuery += " AND SC9.C9_PEDIDO = ? " //c6_pedido
	cQuery += " AND SC9.C9_ITEM = ? " //c6_item
	cQuery += " AND SC9.C9_PRODUTO = ? " //c6_produto
	cQuery += " AND SC9.C9_NFISCAL = ? " //nLenC9_Nf
	cQuery += " AND SC9.D_E_L_E_T_= ? " //' '
	cQuery := ChangeQuery(cQuery)
	oRegSC9	:= FwExecStatement():New(cQuery)		
EndIf

	dbSelectArea("SC9")
	dbSetOrder(1)
	oRegSC9:SetString(1 ,xFilial('SC9'))
	oRegSC9:SetString(2 ,SC6->C6_NUM)
	oRegSC9:SetString(3 ,SC6->C6_ITEM)
	oRegSC9:SetString(4 ,SC6->C6_PRODUTO)
	oRegSC9:SetString(5 ,space(nLenC9_Nf))
	oRegSC9:SetString(6 ,space(1))		
	oRegSC9:OpenAlias(cAliasSC9)
	dbSelectArea(cAliasSC9)

	While (cAliasSC9)->(!Eof())
		SC9->(DbGoto((cAliasSC9)->RECNOSC9))
		aSaldos := {}
		If Localiza(SC9->C9_PRODUTO) .And. ;
			(!IntWms(SC9->C9_PRODUTO) .Or. ;
			!(SC9->C9_BLWMS$'01;02;03'))
			aSaldos := procSDC((cAliasSC9)->RECNOSC9)
		Else
			nQtdLib2 := If(Empty(SC9->C9_QTDLIB2),ConvUm(SC9->C9_PRODUTO,SC9->C9_QTDLIB,0,2),SC9->C9_QTDLIB2)
			aSaldos := {{ "","","","",SC9->C9_QTDLIB,nQtdLib2,	Ctod(""),"","","",SC9->C9_LOCAL}}
		EndIf	

		//Atualiza os acumulados da liberacao do pedido de venda
		//C6_QTDEMP,C6_QTDEMP2,B2_QPEDVEN,B2_QPEDVEN2,A1_SALPED,A1_SALPEDL,A1_SALPEDB						
		MaAvalSC9("SC9",1,aSaldos,,.T.)//GravaEmp
		dbSelectArea(cAliasSC9)
		(cAliasSC9)->(dbSkip())
	EndDo
	dbSelectArea(cAliasSC9)
	(cAliasSC9)->(dbCloseArea())	

restArea(aArea)

Return 

/*/{Protheus.doc} procSD2
	processa SD2
	@type  Static Function
	@author user
	@since 22/12/2025
	@version version
	@param param_name, param_type, param_descr
	@return return_var, return_type, return_description
	@example
	(examples)
	@see (links_or_references)
/*/
Static Function procSD2(cAliasSC6,lLiberOk,lResidOk,lFaturOk)
Local cAliasSD2 := "SD2MA215PROC1" as character
//Local oQuery as object
Local cQrySD2 as character
Local cFilialSD2:= xFilial('SD2')
Local nBind  := 1 as numeric


If lMA215SD2
	if oQrySD2 == nil
		cQrySD2 := "SELECT SD2.R_E_C_N_O_ SD2RECNO "
		cQrySD2 += "FROM " +RetSqlName("SD2")+ " SD2 "
		cQrySD2 += "WHERE "
		If !Empty(xFilial("SC6"))
			cQrySD2 += "SD2.D2_FILIAL= ? AND " //XFilial(Sd2)
		EndIf
		cQrySD2 += " SD2.D2_PEDIDO = ? "//C6_NUM
		cQrySD2 += " AND SD2.D2_ITEMPV = ? "//C6_ITEM
		cQrySD2 += " AND SD2.D2_COD = ? "//C6_PRODUTO
		cQrySD2 := ExecBlock("MA215SD2",.F.,.F.,cQrySD2)
		cQrySD2 += " AND SD2.D_E_L_E_T_= ? " //' '
		cQrySD2 += "ORDER BY "+SqlOrder(SD2->(IndexKey()))
		cQrySD2 := ChangeQuery(cQrySD2)
		oQrySD2 := FwExecStatement():New(cQrySD2)
	endIf
	If !Empty(xFilial("SC6"))
		oQrySD2:setString(nBind++,cFilialSD2)
	EndIf
	oQrySD2:setString(nBind++,(cAliasSC6)->C6_NUM)
	oQrySD2:setString(nBind++,(cAliasSC6)->C6_ITEM)
	oQrySD2:setString(nBind++,(cAliasSC6)->C6_PRODUTO)
	oQrySD2:setString(nBind++,' ')	
Else
	if oQrySD2 == nil
		cQrySD2 := " SELECT SD2.R_E_C_N_O_ SD2RECNO  "
		cQrySD2 += " FROM " +RetSqlName("SD2")+ " SD2 "
		cQrySD2 += " INNER JOIN  "+RetSQLName('SC6')+" SC6 "
		cQrySD2 += " ON SC6.C6_NUM      = SD2.D2_PEDIDO "
		cQrySD2 += " AND SC6.C6_ITEM    = SD2.D2_ITEMPV"
		cQrySD2 += " AND SC6.C6_PRODUTO = SD2.D2_COD "		
		cQrySD2 += "WHERE SD2.D2_FILIAL= ?"
		cQrySD2 += " AND SD2.D2_PEDIDO = ?"
		cQrySD2 += " AND SD2.D2_ITEMPV = ?"
		cQrySD2 += " AND SD2.D2_COD    = ?"
		cQrySD2 += " AND SD2.D_E_L_E_T_= ?"
		cQrySD2 += "ORDER BY "+SqlOrder(SD2->(IndexKey()))
		cQrySD2 := ChangeQuery(cQrySD2)
		oQrySD2 := FwExecStatement():New(cQrySD2)
	EndIf
	oQrySD2:setString(nBind++,xFilial("SD2"))
	oQrySD2:setString(nBind++,(cAliasSC6)->C6_NUM)
	oQrySD2:setString(nBind++,(cAliasSC6)->C6_ITEM)
	oQrySD2:setString(nBind++,(cAliasSC6)->C6_PRODUTO)
	oQrySD2:setString(nBind++,' ')		
EndIf

oQrySD2:OpenAlias(cAliasSD2)
DbSelectArea("SD2")
M215Comp('SD2',cAliasSD2)

	While (cAliasSD2)->(!Eof()) 
		//SC6->(DbGoto((cAliasSC6)->SC6RECNO))
		SD2->(DbGoto((cAliasSD2)->SD2RECNO))
		//D2_REMITO <> '' = C6_QTDENT,C6_QTDENT2 | C6_NOTA,C6_SERIE,C6_DATFAT | SE C6_QTDRESE==0 ENTAO C6_RESERVA = ''
		MaAvalSC6("SC6",5,"SC5",.F.,.F.,@lLiberOk,@lResidOk,@lFaturOk,.T.,,"SD2")						
		dbSelectArea(cAliasSD2)
		(cAliasSD2)->(dbSkip())
	EndDo
	(cAliasSD2)->(dbCloseArea())

	dbSelectArea("SD2")
Return 

/*/{Protheus.doc} procSDC
	(long_description)
	@type  Static Function
	@author user
	@since 22/12/2025
	@version version
	@param param_name, param_type, param_descr
	@return return_var, return_type, return_description
	@example
	(examples)
	@see (links_or_references)
/*/
Static Function procSDC(cRecnoSC9)
local aSaldos := {}
Local cAliasSDC := "SDCMA215PROC2"
Local aArea := getArea() 
Local cQrySDC := '' as character
Local nBind   := 1 as numeric

dbSelectArea("SC9")
SC9->(DbGoto(cRecnoSC9))

If oQrySDC == nil
	cQrySDC := "SELECT DC_PRODUTO, DC_LOCAL, DC_LOCALIZ, DC_LOTECTL, DC_NUMLOTE, DC_NUMSERI, "
	cQrySDC += " DC_QUANT, DC_QTSEGUM, DC_SEQ, DC_ITEM, DC_FILIAL"
	cQrySDC += "FROM "+RetSqlName("SDC")+" SDC "
	cQrySDC += "WHERE SDC.DC_FILIAL= ? AND "
	cQrySDC += "SDC.DC_PRODUTO = ? AND "
	cQrySDC += "SDC.DC_LOCAL = ? AND "
	cQrySDC += "SDC.DC_ORIGEM = ? AND "
	cQrySDC += "SDC.DC_PEDIDO = ? AND "
	cQrySDC += "SDC.DC_ITEM = ? AND "
	cQrySDC += "SDC.DC_SEQ = ? AND "
	cQrySDC += "SDC.D_E_L_E_T_= ? "
	cQrySDC += "ORDER BY "+SqlOrder(SDC->(IndexKey()))
	cQrySDC := ChangeQuery(cQrySDC)
	oQrySDC := FwExecStatement():New(cQrySDC)
EndIF
	oQrySDC:setString(nBind++,FWxFilial( 'SDC' ))
	oQrySDC:setString(nBind++,SC9->C9_PRODUTO)
	oQrySDC:setString(nBind++,SC9->C9_LOCAL)
	oQrySDC:setString(nBind++,'SC6')	
	oQrySDC:setString(nBind++,SC9->C9_PEDIDO)
	oQrySDC:setString(nBind++,SC9->C9_ITEM)
	oQrySDC:setString(nBind++,SC9->C9_SEQUEN)
	oQrySDC:setString(nBind++,' ')	
	oQrySDC:OpenAlias(cAliasSDC)
	M215Comp('SDC',cAliasSDC)

	While (cAliasSDC)->(!Eof())
			//Atualiza arquivo de empenhos               								
			aadd(aSaldos,{	(cAliasSDC)->DC_LOTECTL,;
							(cAliasSDC)->DC_NUMLOTE,;
							(cAliasSDC)->DC_LOCALIZ,;
							(cAliasSDC)->DC_NUMSERI,;
							(cAliasSDC)->DC_QUANT,;
							If( Empty( (cAliasSDC)->DC_QTSEGUM ), ConvUm((cAliasSDC)->DC_PRODUTO,(cAliasSDC)->DC_QUANT,0,2),(cAliasSDC)->DC_QTSEGUM ),;
							SC9->C9_DTVALID,;
							"",;
							"",;
							"",;
							(cAliasSDC)->DC_LOCAL})
	(cAliasSDC)->(dbSkip())
	EndDo
	(cAliasSDC)->(dbCloseArea())
	dbSelectArea("SDC")

restArea(aArea)

Return aSaldos


/*/{Protheus.doc} zerSC6
	Limpa registros da SC6
	@type  Static Function
	@author user
	@since 22/12/2025
	@version version
	@param param_name, param_type, param_descr
	@return return_var, return_type, return_description
	@example
	(examples)
	@see (links_or_references)
/*/
Static Function zerSC6(c6Recno)
Local aArea := getArea()
	dbSelectArea('SC6')
	SC6->(DbGoto(c6Recno))

	if Reclock('SC6',.f.)				
		SC6->C6_QTDEMP := 0
		SC6->C6_QTDENT := 0
		SC6->C6_QTDEMP2 := 0
		SC6->C6_QTDENT2 := 0				
		MsUnlock()		
	Endif

Restarea(aArea)

Return 

/*/{Protheus.doc} a215AtuSA1
	Encontra os registros e atualiza os campos da SA1
	@type  Function
	@author Rodrigo Lombardi
	@since 12/02/2025
	@version 1.0
	@param oObj,object,Regua de processamento
	@param aFilTabs,array,Tabela de filiais
	@param cFirst,character,Primeira Filial analisada
/*/
static Function a215AtuSA1(oObj,aFilTabs,cFirst)
	Local cMensagem := "" as character	
	Local cQuerySA1 := "" as character	
	Local cAliasSA1 := "SA1MA215PROC" as character
	Local nBind := 1 as numeric
	if vldProc('SA1',aFilTabs,TabelaSA1,cFirst)
		cMensagem := getMsg('SA1')			
		
		if oQuerySA1 == nil			
			cQuerySA1 := " SELECT SA1.R_E_C_N_O_ RECNO "			
			cQuerySA1 += " FROM "+RetSqlName("SA1")+" SA1 "
			cQuerySA1 += " WHERE SA1.A1_FILIAL= ? AND "	
			if !empty(cCliente)
				cQuerySA1 += " SA1.A1_COD = ? AND "			
			Endif
			if !empty(cLoja)
				cQuerySA1 += " SA1.A1_LOJA = ? AND "			
			EndIf
			cQuerySA1 += " SA1.D_E_L_E_T_= ? "			
			cQuerySA1 := ChangeQuery(cQuerySA1)			
			oQuerySA1 := FwExecStatement():New(cQuerySA1)				
		endIf
		oQuerySA1:setString(nBind++,FWxFilial( 'SA1' ))
		if !empty(cCliente)
			oQuerySA1:setString(nBind++,cCliente)
		endIf
		if !empty(cLoja)
			oQuerySA1:setString(nBind++,cLoja)
		EndIf
		oQuerySA1:setString(nBind++,' ')	
		oQuerySA1:OpenAlias(cAliasSA1)
				
		
		dbSelectArea("SA1")
		//ZERAMENTO VIA RECLOCK
		while (cAliasSA1)->(!Eof()) 
			SA1->(DbGoto((cAliasSA1)->(RECNO)))
			if checkRecno(@oTmpSA1,'SA1',(cAliasSA1)->(RECNO))
				if Reclock('SA1',.f.)
					SA1->A1_SALPED := 0
					SA1->A1_SALPEDL := 0
					SA1->A1_SALPEDB := 0
					MsUnlock()
									
				Endif
			EndIf
			(cAliasSA1)->(dbSkip())
		end
		(cAliasSA1)->(dbCloseArea())		

		//Fecho a tabela
		dbSelectArea("SA1")		
	EndIf
	//SA1 -- FIM
	

Return 

/*/{Protheus.doc} a215Zer
	Encontra os registros da SB2 e processa item a item os empenhos
	@type  Function
	@author Rodrigo Lombardi
	@since 12/02/2025
	@version 1.0
	@param oObj,object,Regua de processamento
	@param aFilTabs,array,Tabela de filiais
	@param cFirst,character,Primeira Filial analisada
/*/
static Function a215Zer(oObj,aFilTabs,cFirst)
	Local cMensagem := "" as character		
	Local cQuerySB2 := "" as character
	local lBFilProd := lFilProd as logical //salva o estado anterior desses parametros
	Local lBFilArmz := lFilArmz as logical //salve o estado anterior desses parametros
	
	Local nMax := 0	as numeric	
	Local nBind := 1 as numeric	
	local cAliasSB2 := "SB2MA215PROC" as character	
	Local nRecnoSb2 := 0 as numeric

	if vldProc('SB2',aFiltabs,TabelaSB2,cFirst,lPCFilEnt)//<-olhar o pcfilent pois ele não funciona quando há filtro de filial
		
		cMensagem := getMsg("SB2")			
		
		if oQuerySB2 == nil			
			cQuerySB2 := " SELECT SB2.R_E_C_N_O_ RECNSB2 " 
			cQuerySB2 += " FROM "+RetSqlName("SB2")+" SB2 "			
			cQuerySB2 += " WHERE  "
			cQuerySB2 += " SB2.B2_FILIAL= ? AND "
			if lFilProd //FILTRO DE PRODUTO
				cQuerySB2 += " SB2.B2_COD BETWEEN ? AND ? AND "				
			EndIf						
			if lFilArmz //FILTRO DE ARMAZEM
				cQuerySB2 += " SB2.B2_LOCAL BETWEEN ? AND ? AND "				
			EndIf
			cQuerySB2 += " SB2.D_E_L_E_T_= ? "
			cQuerySB2 += " ORDER BY RECNSB2 "						
			cQuerySB2 := ChangeQuery(cQuerySB2)		
			oQuerySB2 := FwExecStatement():New(cQuerySB2)					
		endIf		
		oQuerySB2:setString(nBind++,FWxFilial( 'SB2' ))						
		injectPerg(oQuerySB2,@nBind)//Produto
		injectPerg(oQuerySB2,@nBind,.f.)//Armazem		
		oQuerySB2:setString(nBind++,' ')
		oQuerySB2:OpenAlias(cAliasSB2)
		
		nMax := contaSb2()
			
		A215AtuReg(oObj,nMax,cMensagem)
		dbSelectArea("SB2")
		//ZERAMENTO VIA RECLOCK
		while (cAliasSB2)->(!Eof())
		BEGIN TRANSACTION
			SB2->(DbGoto((cAliasSB2)->(RECNSB2)))
			if nRecnoSb2 <> (cAliasSB2)->(RECNSB2) .and. checkRecno(@oTmpSB2,'SB2',(cAliasSB2)->(RECNSB2))
				nRecnoSb2 := (cAliasSB2)->(RECNSB2)									
				if Reclock('SB2',.f.)
					if !lRfzVnd
						SB2->B2_QPEDVEN := 0
						SB2->B2_QPEDVE2 := 0 
					EndIf
					SB2->B2_RESERVA := 0
					SB2->B2_RESERV2 := 0				
					SB2->B2_QEMP    := 0
					SB2->B2_QEMP2   := 0
					SB2->B2_QEMPN   := 0
					SB2->B2_QEMPN2  := 0
					SB2->B2_NAOCLAS := 0
					SB2->B2_SALPEDI := 0
					SB2->B2_SALPED2 := 0				
					SB2->B2_QTNP    := 0
					SB2->B2_QNPT    := 0
					SB2->B2_QTER    := 0
					SB2->B2_QEMPPRE := 0
					SB2->B2_SALPPRE := 0
					SB2->B2_QACLASS := 0
					SB2->B2_QEMPPRJ := 0
					SB2->B2_QEMPPR2 := 0
					SB2->B2_QEMPSA  := 0
					MsUnlock()	

					//Zero todos os lotes que tiver
					zerSB8()
				
					//Zero todos os endereços que tiver
					zerSBF()					

					A215AtuReg(oObj,,SB2->B2_COD)

					//Reprocessamento dos acumulados
					//Processa o produto					
					procProd(SB2->B2_COD,SB2->B2_LOCAL,oObj,aFilTabs,cFirst)					
					
				Endif
			//EndIf
			EndIf
			END TRANSACTION
			(cAliasSB2)->(dbSkip())
		end
		(cAliasSB2)->(dbCloseArea())			
		
	EndIf
	
	lFilProd := lBFilProd
	lFilArmz := lBFilArmz
	cProduto := ''
	cArmazem := ''

Return 

/*/{Protheus.doc} zerSB8
	Realiza o zeramento dos empenhos de lote
	@type  Static Function
	@author user
	@since 26/12/2025
	@version version
	@param cAliasSB8, character, Alias da tabela com os recnos de SB8
	@return return_var, return_type, return_description
	@example
	(examples)
	@see (links_or_references)
/*/
Static Function zerSB8()
Local aArea := getArea()
Local nBind   := 1 as numeric
Local cQuerySB8 := '' as character
Local cAliasSB8 := 'A215SB8ZER' as character

if rastro(SB2->B2_COD)//Verificar se o produto tem controle de lote
	if oQuerySB8 == nil
		cQuerySB8 := " SELECT SB8.R_E_C_N_O_ RECNSB8 "
		cQuerySB8 += " FROM "+RetSqlName("SB8")+" SB8 "
		cQuerySB8 += " WHERE SB8.B8_FILIAL= ? AND "
		cQuerySB8 += " SB8.B8_PRODUTO = ? AND "
		cQuerySB8 += " SB8.B8_LOCAL  = ? AND "
		cQuerySB8 += " SB8.D_E_L_E_T_= ? "
		cQuerySB8 := ChangeQuery(cQuerySB8)
		oQuerySB8 := FwExecStatement():New(cQuerySB8)
	EndIf
	oQuerySB8:setString(nBind++,FWxFilial( 'SB8' ))
	oQuerySB8:setString(nBind++, SB2->B2_COD)
	oQuerySB8:setString(nBind++, SB2->B2_LOCAL)
	oQuerySB8:setString(nBind++,' ')
	oQuerySB8:OpenAlias(cAliasSB8)

	dbSelectArea("SB8")
	//Zero todos os lotes que tiver
	while (cAliasSB8)->(!Eof())
		SB8->(DbGoto((cAliasSB8)->(RECNSB8)))
			if Reclock('SB8',.f.)
				SB8->B8_EMPENHO := 0
				SB8->B8_EMPENH2 := 0
				SB8->B8_QACLASS := 0
				SB8->B8_QACLAS2 := 0
				SB8->B8_QEMPPRE := 0				
				MsUnlock()
			Endif	
		(cAliasSB8)->(dbSkip())
	EndDo
	
EndIf

restArea(aArea)

Return 


/*/{Protheus.doc} zerSBF
	Realiza o zeramento dos empenhos de endereço
	@type  Static Function
	@author user
	@since 26/12/2025
	@version version
	@param param_name, param_type, param_descr
	@return return_var, return_type, return_description
	@example
	(examples)
	@see (links_or_references)
/*/
Static Function zerSBF()
local aArea := getArea()
Local nBind     := 1 as numeric
Local cQuerySBF := '' as character
Local cAliasSBF := 'A215SBFZER' as character

if Localiza(SB2->B2_COD)//Verificar se o produto tem controle de endereço
	if oQuerySBF == nil
		cQuerySBF := " SELECT SBF.R_E_C_N_O_ RECNSBF "
		cQuerySBF += " FROM "+RetSqlName("SBF")+" SBF "
		cQuerySBF += " WHERE SBF.BF_FILIAL= ? AND "
		cQuerySBF += " SBF.BF_PRODUTO = ? AND "
		cQuerySBF += " SBF.BF_LOCAL  = ? AND "
		cQuerySBF += " SBF.D_E_L_E_T_= ? "
		cQuerySBF := ChangeQuery(cQuerySBF)
		oQuerySBF := FwExecStatement():New(cQuerySBF)
	EndIf
	oQuerySBF:setString(nBind++,FWxFilial( 'SBF' ))
	oQuerySBF:setString(nBind++, SB2->B2_COD)
	oQuerySBF:setString(nBind++, SB2->B2_LOCAL)
	oQuerySBF:setString(nBind++,' ')
	oQuerySBF:OpenAlias(cAliasSBF)

	dbSelectArea("SBF")

	//Zero todos os endereços que tiver
	while (cAliasSBF)->(!Eof())
		SBF->(DbGoto((cAliasSBF)->(RECNSBF)))
		if Reclock('SBF',.f.)
			SBF->BF_EMPENHO := 0
			SBF->BF_EMPEN2 := 0
			SBF->BF_QEMPPRE := 0
			SBF->BF_QEPRE2 := 0						
			MsUnlock()
		Endif		
		(cAliasSBF)->(dbSkip())
	EndDo	
	
EndIf

restArea(aArea)
Return 

/*/{Protheus.doc} a215AtuSC7
	Atualiza os dados acumulados do Pedido de Compra
	@type  Function
	@author Rodrigo Lombardi
	@since 17/03/2025
	@version 1.0
	@param oObj,object,Regua de processamento
	@param aFilTabs,array,Tabela de filiais
	@param cFirst,character,Primeira Filial analisada
/*/
static Function a215AtuSC7(oObj,aFilTabs,cFirst)
	Local cMensagem := "" as character
	Local cQrySC7 := ""	as character
	Local cAliasSC7 := "SC7MA215PROC" as character	
	Local c7Filent := Space(TamSx3('C7_FILENT')[1]) as character
	Local c7Residuo := Space(TamSx3('C7_RESIDUO')[1]) as character
	Local nBind := 1 as numeric
	
	
	if vldProc('SC7',aFilTabs,TabelaSC7,cFirst)		
		cMensagem := getMsg("SC7")
		
		SC7->(dbSetOrder(1))
		if oQuerySC7 == nil
			cQrySC7 := "SELECT C7_FILIAL,C7_PRODUTO,C7_LOCAL,C7_QUJE,C7_QUANT,C7_RESIDUO,C7_FILENT,C7_TPOP,C7_QTSEGUM,"
			cQrySC7 += " C7_FORNECE,C7_LOJA,C7_NUM,C7_ITEM,C7_OP,C7_SEQMRP,C7_DATPRF,C7_TIPO,C7_NUMCOT,C7_TES,C7_ESTOQUE,SB1.B1_FILIAL "
			cQrySC7 += " FROM "+RetSqlName("SC7")+" SC7,"
			cQrySC7 += RetSqlName("SB1")+" SB1 "
			cQrySC7 += "WHERE SC7.C7_FILIAL= ? "
			if lFilProd //FILTRO DE PRODUTO
				cQrySC7 += " AND SC7.C7_PRODUTO BETWEEN ? AND ? "				
			EndIf			
			if lFilArmz //FILTRO DE ARMAZEM
				cQrySC7 += " AND SC7.C7_LOCAL BETWEEN ? AND ? "				
			EndIf
			cQrySC7 += " AND SC7.C7_FILENT IN (?) "
			cQrySC7 += " AND SC7.C7_QUJE < C7_QUANT "
			cQrySC7 += " AND SC7.C7_RESIDUO = ? "
			cQrySC7 += " AND SC7.D_E_L_E_T_ = ? "
			cQrySC7 += " AND SB1.B1_FILIAL  = ? "
			cQrySC7 += " AND SB1.B1_COD = SC7.C7_PRODUTO "
			cQrySC7 += " AND SB1.D_E_L_E_T_ = ?"
			cQrySC7 += " UNION ALL "
			cQrySC7 += " SELECT C7_FILIAL,C7_PRODUTO,C7_LOCAL,C7_QUJE,C7_QUANT,C7_RESIDUO,C7_FILENT,C7_TPOP,C7_QTSEGUM, "
			cQrySC7 += " C7_FORNECE,C7_LOJA,C7_NUM,C7_ITEM,C7_OP,C7_SEQMRP,C7_DATPRF,C7_TIPO,C7_NUMCOT,C7_TES,C7_ESTOQUE,SB1.B1_FILIAL "
			cQrySC7 += " FROM "+RetSqlName("SC7")+" SC7, "
			cQrySC7 += RetSqlName("SB1")+" SB1 "
			cQrySC7 += " WHERE SC7.C7_FILENT = ? "
			cQrySC7 += " AND SC7.C7_FILIAL <> ? "			
			if lFilProd //FILTRO DE PRODUTO
				cQrySC7 += " AND SC7.C7_PRODUTO BETWEEN ? AND ? "				
			EndIf			
			if lFilArmz //FILTRO DE ARMAZEM
				cQrySC7 += " AND SC7.C7_LOCAL BETWEEN ? AND ? "				
			EndIf
			cQrySC7 += " AND SC7.C7_QUJE < C7_QUANT  "
			cQrySC7 += " AND SC7.C7_RESIDUO = ? "
			cQrySC7 += " AND SC7.D_E_L_E_T_ = ? "
			cQrySC7 += " AND SB1.B1_FILIAL = ?  "
			cQrySC7 += " AND SB1.B1_COD = SC7.C7_PRODUTO "
			cQrySC7 += " AND SB1.D_E_L_E_T_ = ? "
			cQrySC7 += " ORDER BY 1,2,3 "
			cQrySC7 := ChangeQuery(cQrySC7)
			oQuerySC7 := FwExecStatement():New(cQrySC7)			
		EndiF			
		oQuerySC7:setString(nBind++,FWxFilial( 'SC7' ))	
		injectPerg(oQuerySC7,@nBind)
		injectPerg(oQuerySC7,@nBind,.f.)	
		oQuerySC7:setIn(nBind++,{c7Filent,FWxFilial( 'SC7' )})
		oQuerySC7:setString(nBind++,c7Residuo)
		oQuerySC7:setString(nBind++,' ')
		oQuerySC7:setString(nBind++,FWxFilial( 'SB1' ))		
		oQuerySC7:setString(nBind++,' ')
		oQuerySC7:setString(nBind++,FWxFilial( 'SC7' ))	
		oQuerySC7:setString(nBind++,FWxFilial( 'SC7' ))
		injectPerg(oQuerySC7,@nBind)
		injectPerg(oQuerySC7,@nBind,.f.)
		oQuerySC7:setString(nBind++,c7Residuo)	
		oQuerySC7:setString(nBind++,' ')				
		oQuerySC7:setString(nBind++,FWxFilial( 'SB1' ))								
		oQuerySC7:setString(nBind++,' ')	

		oQuerySC7:OpenAlias(cAliasSC7)	

		M215Comp('SC7',cAliasSC7)
	
		
		While (cAliasSC7)->(!Eof())
			MaAvalPC(cAliasSC7,1,,.T.)			
			(cAliasSC7)->(dbSkip())				
		EndDo		
		//Fecho a tabela
		(cAliasSC7)->(dbCloseArea())
		dbSelectArea("SC7")
	EndIf
		
Return 

/*/{Protheus.doc} a215AtuSDD
	Atualiza os dados acumulados do Bloqueio de lotes
	@type  Function
	@author Rodrigo Lombardi
	@since 17/03/2025
	@version 1.0
	@param oObj,object,Regua de processamento
	@param aFilTabs,array,Tabela de filiais
	@param cFirst,character,Primeira Filial analisada
/*/
static Function a215AtuSDD(oObj,aFilTabs,cFirst)
	Local cMensagem := ""
	Local cQrySDD := ""
	Local cQrySDDSDC := ""
	local aBind := {}		
	Local cAliasSDD := "SDDMA215PROC"
	Local cAliasSDC := "SDCMA215PROC"
	Local aTravas     := {}	
	Local lGravaEmp   := .F.
	Local nPosPrepared
	Local __aPrepared := {}
	Local cMD5
	Local nBind := 1 as numeric
	
	cMensagem := getMsg("SDD")

	if vldProc('SDD',aFilTabs,TabelaSDD,cFirst)			
				
			SDD->(dbSetOrder(1))
			if oQuerySDD == nil
				cQrySDD := "SELECT DD_PRODUTO, DD_SALDO, DD_NUMLOTE,DD_NUMSERI,DD_LOTECTL,DD_IDSDD, "
				cQrySDD += " DD_LOCALIZ, DD_LOCAL, DD_DOC, SDD.R_E_C_N_O_ RECSDD "
				cQrySDD += " FROM "+RetSqlName("SDD")+" SDD "
				cQrySDD += " INNER JOIN "+RetSqlName("SB1")+" SB1 "
				cQrySDD += " ON SB1.B1_FILIAL = ? "				
				if lFilProd //FILTRO DE PRODUTO
					cQrySDD += " AND SB1.B1_COD BETWEEN ? AND ? "				
				EndIf
				cQrySDD += " AND SB1.B1_COD = DD_PRODUTO "
				cQrySDD += " AND SB1.D_E_L_E_T_ = ? "
				cQrySDD += " WHERE SDD.DD_FILIAL = ? "				
				if lFilArmz //FILTRO DE ARMAZEM
					cQrySDD += " AND SDD.DD_LOCAL BETWEEN ? AND ? "				
				EndIf
				cQrySDD += " AND SDD.DD_SALDO > ? "
				cQrySDD += " AND SDD.D_E_L_E_T_ = ? "
				cQrySDD := ChangeQuery(cQrySDD)						
				oQuerySDD := FwExecStatement():New(cQrySDD)							
			endIf
			oQuerySDD:setString(nBind++,FWxFilial( 'SB1' ))
			injectPerg(oQuerySDD,@nBind)//PRODUTO			
			oQuerySDD:setString(nBind++,' ')
			oQuerySDD:setString(nBind++,FWxFilial( 'SDD' ))			
			injectPerg(oQuerySDD,@nBind,.f.)//ARMAZEM
			oQuerySDD:setNumeric(nBind++,0)
			oQuerySDD:setString(nBind++,' ')			
			oQuerySDD:OpenAlias(cAliasSDD)
			nBind := 2

			M215Comp('SDD',cAliasSDD)
						
			While (cAliasSDD)->(!Eof())
				DbSelectArea('SDD')
				SDD->(DbGoto((cAliasSDD)->RECSDD))
				if RecLock('SDD',.f.)
					SDD->DD_QUANT := SDD->DD_SALDO
					MsUnlock()
				EndIf		

				aTravas  := {}

				If Localiza((cAliasSDD)->DD_PRODUTO) 
					cQrySDDSDC := "SELECT DC_PRODUTO,DC_LOCAL,DC_QUANT,DC_QTSEGUM,DC_LOTECTL,"
					cQrySDDSDC += " DC_NUMLOTE,DC_LOCALIZ,DC_NUMSERI,DC_PEDIDO,DC_IDSDD"
					cQrySDDSDC += " FROM "+RetSqlName("SDC")
					cQrySDDSDC += " WHERE DC_FILIAL = ?"
					cQrySDDSDC += " AND DC_PRODUTO  = ?"
					cQrySDDSDC += " AND DC_LOCAL    = ?"
					cQrySDDSDC += " AND DC_LOTECTL  = ?"
					If !Empty((cAliasSDD)->DD_NUMLOTE)
						cQrySDDSDC += " AND DC_NUMLOTE  = ?"
					EndIf
					If !Empty((cAliasSDD)->DD_LOCALIZ) 
						cQrySDDSDC += " AND DC_LOCALIZ  = ?"
					EndIf
					If !Empty((cAliasSDD)->DD_NUMSERI)
						cQrySDDSDC += " AND DC_NUMSERI  = ?"
					EndIf
					cQrySDDSDC += " AND DC_ORIGEM   = ?"
					cQrySDDSDC += " AND D_E_L_E_T_  = ?"
					cMD5 := MD5(cQrySDDSDC)
					If (nPosPrepared := Ascan(__aPrepared,{|x| x[2] == cMD5})) == 0
						Aadd(__aPrepared,{ChangeQuery(cQrySDDSDC),cMD5})
						nPosPrepared := Len(__aPrepared)
					Endif						
					aBind := {}
					AADD(aBind,xFilial("SDC"))
					AADD(aBind,(cAliasSDD)->DD_PRODUTO)
					AADD(aBind,(cAliasSDD)->DD_LOCAL)
					AADD(aBind,(cAliasSDD)->DD_LOTECTL)
					If !Empty((cAliasSDD)->DD_NUMLOTE)
						AADD(aBind,(cAliasSDD)->DD_NUMLOTE)
					EndIf
					If !Empty((cAliasSDD)->DD_LOCALIZ) 
						AADD(aBind,(cAliasSDD)->DD_LOCALIZ)
					EndIf
					If !Empty((cAliasSDD)->DD_NUMSERI)
						AADD(aBind,(cAliasSDD)->DD_NUMSERI)
					EndIf
					AADD(aBind,'SDD')
					AADD(aBind,Space(1))
										
					oQuerySDC := FwExecStatement():New(__aPrepared[nPosPrepared][1])
					oQuerySDC:setString(1,FWxFilial( 'SDC' ))
					for nBind := 2 to len(aBind)
						oQuerySDC:setString(nBind,aBind[nBind])
					next					
					oQuerySDC:OpenAlias(cAliasSDC)
										
					M215Comp('SDC',cAliasSDC)
				
					While (cAliasSDC)->(!Eof())	
						lGravaEmp := .F.
						If !Empty((cAliasSDD)->DD_IDSDD) .And. !Empty((cAliasSDC)->DC_IDSDD)
							If AllTrim((cAliasSDD)->DD_IDSDD) == AllTrim((cAliasSDC)->DC_IDSDD)
								lGravaEmp := .T.
							Else
								lGravaEmp := .F.
							EndIf
						ElseIf Len(AllTrim((cAliasSDD)->DD_DOC)) == Len(AllTrim((cAliasSDC)->DC_PEDIDO))
							If AllTrim((cAliasSDD)->DD_DOC) == AllTrim((cAliasSDC)->DC_PEDIDO)
								lGravaEmp := .T.
							Else
								lGravaEmp := .F.
							EndIf
						ElseIf Len(AllTrim((cAliasSDD)->DD_DOC)) <> Len(AllTrim((cAliasSDC)->DC_PEDIDO))
							lGravaEmp := .T.
						EndIf

						If lGravaEmp
							// Atualiza arquivo de empenhos               
							GravaEmp(	(cAliasSDC)->DC_PRODUTO,;
										(cAliasSDC)->DC_LOCAL,;
										(cAliasSDC)->DC_QUANT,;
										(cAliasSDC)->DC_QTSEGUM,;
										(cAliasSDC)->DC_LOTECTL,;
										(cAliasSDC)->DC_NUMLOTE,;
										(cAliasSDC)->DC_LOCALIZ,;
										(cAliasSDC)->DC_NUMSERI,;
										Nil,;
										Nil,;
										(cAliasSDC)->DC_PEDIDO,;
										Nil,;
										"SDD",;
										Nil,;
										Nil,;
										Nil,;
										.F.,;
										.F.,;
										.T.,;
										.F.,;
										.T.,;
										.T.,;
										.F.)
						EndIf
						(cAliasSDC)->(dbSkip())
					EndDo
					(cAliasSDC)->(dbCloseArea())
				Else
					ProcSDD(.F.)
				EndIf

				(cAliasSDD)->(dbSkip())

				
			EndDo
			//Fecho a tabela
			(cAliasSDD)->(dbCloseArea())			

		EndIf
	
	

Return 

/*/{Protheus.doc} a215AtuSCQ
	 Corre SCQ para Atualizar B2_QEMP  em Produtos SB2
	@type  Function
	@author Rodrigo Lombardi
	@since 17/03/2025
	@version 1.0
	@param oObj,object,Regua de processamento
	@param aFilTabs,array,Tabela de filiais
	@param cFirst,character,Primeira Filial analisada
/*/
static Function a215AtuSCQ(oObj,aFilTabs,cFirst)
	Local cMensagem := ""
	Local cQrySCQ := ""
	Local cAliasSCQ := "SCQMA215PROC"
	Local nBind := 1	
	

	if vldProc('SCQ',aFilTabs,TabelaSCQ,cFirst)	
		cMensagem := getMsg("SCQ")
		
		if oQuerySCQ == nil					
			cQrySCQ := "SELECT CQ_PRODUTO,CQ_LOCAL,SUM(CQ_QTDISP) CQ_QTDISP FROM "
			cQrySCQ += RetSqlName("SCQ")+ " SCQ "
			cQrySCQ += " INNER JOIN "+RetSqlName("SB1")+" SB1 "
			cQrySCQ += " ON SB1.B1_FILIAL = ? "			
			if lFilProd //FILTRO DE PRODUTO
				cQrySCQ += "AND SB1.B1_COD BETWEEN ? AND ? "				
			EndIf
			cQrySCQ += " AND SB1.B1_COD = CQ_PRODUTO "
			cQrySCQ += " AND SB1.D_E_L_E_T_ = ? "
			cQrySCQ += " WHERE SCQ.CQ_FILIAL = ? "			
			if lFilArmz //FILTRO DE ARMAZEM
				cQrySCQ += "AND SCQ.CQ_LOCAL BETWEEN ? AND ? "				
			EndIf
			cQrySCQ += " AND SCQ.CQ_QTDISP   > ? "
			cQrySCQ += " AND SCQ.CQ_NUMREQ = ? "
			cQrySCQ += " AND SCQ.D_E_L_E_T_  = ? "
			cQrySCQ += " GROUP BY CQ_PRODUTO,CQ_LOCAL"				
			oQuerySCQ := FwExecStatement():New(cQrySCQ)						
		Endif
		oQuerySCQ:setString(nBind++,FWxFilial( 'SB1' ))
		injectPerg(oQuerySCQ,@nBind)//PRODUTO		
		oQuerySCQ:setString(nBind++,' ')			
		oQuerySCQ:setString(nBind++,FWXFilial( 'SCQ' ))		
		injectPerg(oQuerySCQ,@nBind,.f.)//ARMAZEM
		oQuerySCQ:setNumeric(nBind++,0)	
		oQuerySCQ:setString(nBind++,Space(TamSX3("CQ_NUMREQ")[1]))
		oQuerySCQ:setString(nBind++,' ')	
		oQuerySCQ:OpenAlias(cAliasSCQ)
		M215Comp('SCQ',cAliasSCQ)

		
		While (cAliasSCQ)->(!Eof())				
			//Atualizar Qtde Empenhada  em Produtos SB2.			
			chkSb2(xFilial('SB2')+(cAliasSCQ)->CQ_PRODUTO+(cAliasSCQ)->CQ_LOCAL,(cAliasSCQ)->CQ_PRODUTO,(cAliasSCQ)->CQ_LOCAL)
			RecLock("SB2",.F.)
			SB2->B2_QEMPSA += (cAliasSCQ)->CQ_QTDISP
			SB2->(MsUnLock())
			(cAliasSCQ)->(dbSkip())			
			
		EndDo
		//Encerro a tabela
		(cAliasSCQ)->(dbCloseArea())		
	EndIf
	

Return 

/*/{Protheus.doc} a215AtuDH1
	Analisa DH1 para Atualizar o campo B2_RESERV  em Produtos SB2.
	@type  Function
	@author Rodrigo Lombardi
	@since 17/03/2025
	@version 1.0
	@param oObj,object,Regua de processamento	
	@param cFirst,character,Primeira Filial analisada
/*/
static Function a215AtuDH1(oObj,cFirst)
	Local cMensagem := "" as character
	Local cQryDH1 := ""	 as character
	Local cAliasDH1 := "DH1MA215PROC" as character
	Local cSeek := "" as character
	Local nBind := 1 as numeric
	
	If (!Empty(xFilial("DH1")) .Or. cFilAnt == cFirst ) //-- Corre DH1 para Atualizar B2_RESERV  em Produtos SB2.
			cMensagem := getMsg("DH1")
						
			SB8->(dbSetOrder(3))
			if oQueryDH1 == nil
				cQryDH1 := "SELECT DH1_PRODUT,DH1_LOCAL,DH1_QUANT,DH1_LOTECT,DH1_NUMLOT, DH1_QTSEGU "
				cQryDH1 += " FROM "+RetSqlName("DH1")+ " DH1 "
				cQryDH1 += " INNER JOIN "+RetSqlName("SB1")+" SB1 "
				cQryDH1 += " ON SB1.B1_FILIAL = ? "				
				if lFilProd //FILTRO DE PRODUTO
					cQryDH1 += " AND SB1.B1_COD BETWEEN ? AND ? "				
				EndIf
				cQryDH1 += " AND SB1.B1_COD = DH1.DH1_PRODUT "				
				cQryDH1 += " AND SB1.D_E_L_E_T_ = ? "
				cQryDH1 += " WHERE DH1.DH1_FILIAL = ? "					
				if lFilArmz //FILTRO DE ARMAZEM
					cQryDH1 += " AND DH1.DH1_LOCAL BETWEEN ? AND ? "				
				EndIf			
				cQryDH1 += " AND DH1.DH1_TM > ? "
				cQryDH1 += " AND DH1.DH1_QUANT > ? "
				cQryDH1 += " AND DH1.DH1_STATUS = ? "
				cQryDH1 += " AND DH1.D_E_L_E_T_ = ? "
				cQryDH1 := ChangeQuery(cQryDH1)				
				oQueryDH1 := FwExecStatement():New(cQryDH1)								
			endIf	
			oQueryDH1:setString(nBind++,FWxFilial( 'SB1' ))
			injectPerg(oQueryDH1,@nBind)//PRODUTO		
			oQueryDH1:setString(nBind++,' ')				
			oQueryDH1:setString(nBind++,FWxFilial( 'DH1' ))		
			injectPerg(oQueryDH1,@nBind,.f.)//ARMAZEM
			oQueryDH1:setString(nBind++,'500')
			oQueryDH1:setNumeric(nBind++,0)
			oQueryDH1:setString(nBind++,'1')
			oQueryDH1:setString(nBind++,' ')			
			oQueryDH1:OpenAlias(cAliasDH1)

			M215Comp('DH1',cAliasDH1)

			

			While (cAliasDH1)->(!Eof()) //--  Atualizar Qtde Empenhada  em Produtos SB2.
				chkSb2(xFilial("SB2")+(cAliasDH1)->DH1_PRODUT+(cAliasDH1)->DH1_LOCAL,(cAliasDH1)->DH1_PRODUT,(cAliasDH1)->DH1_LOCAL)
				RecLock("SB2",.F.)
				SB2->B2_RESERVA += (cAliasDH1)->DH1_QUANT				
				SB2->B2_RESERV2 += (cAliasDH1)->DH1_QTSEGU				
				SB2->(MsUnLock())
				//-- Caso use rastreabilidade, GRAVA a quantidade do DH1
				//-- no SB8 para que o Saldo por Sub-Lote fique bloqueado
				If Rastro((cAliasDH1)->DH1_PRODUT)
					If Rastro((cAliasDH1)->DH1_PRODUT,"S")
						cSeek:=xFilial("SB8")+(cAliasDH1)->DH1_PRODUT+(cAliasDH1)->DH1_LOCAL+(cAliasDH1)->DH1_LOTECT+(cAliasDH1)->DH1_NUMLOT
					Else
						cSeek:=xFilial("SB8")+(cAliasDH1)->DH1_PRODUT+(cAliasDH1)->DH1_LOCAL+(cAliasDH1)->DH1_LOTECT
					EndIf
					If SB8->(MsSeek(cSeek))
						RecLock("SB8",.F.)
						SB8->B8_EMPENHO += (cAliasDH1)->DH1_QUANT
						SB8->B8_EMPENH2 += (cAliasDH1)->DH1_QTSEGU
						MsUnlock()
					EndIf
				EndIf				
				(cAliasDH1)->(dbSkip())				
				
			EndDo
			//Encerro a tabela
			(cAliasDH1)->(dbCloseArea())			

		EndIf
	

Return 

/*/{Protheus.doc} a215AtuD0G
	Analisa D0G para Atualizar o campo B2_QACLASS e B8_QACLASS,
	@type  Function
	@author Rodrigo Lombardi
	@since 20/03/2025
	@version 1.0
	@param oObj,object,Regua de processamento	
	@param cFirst,character,Primeira Filial analisada
/*/
static Function a215AtuD0G(oObj,cFirst)
	Local cMensagem := "" as character
	Local cQryD0G := ""	 as character
	Local cAliasD0G := 'D0GMA215PROC' as character
	Local cSeek       := "" as character
	Local cCompara    := "" as character
	Local nEmpenho    := 0 as numeric
	Local nEmpenh2    := 0 as numeric
	Local nBaixaEmp   := 0 as numeric
	Local nBaixaEm2   := 0 as numeric
	Local lEmpPrev    := If(SuperGetMV("MV_QTDPREV")== "S",.T.,.F.) as logical	
	Local nBind := 1 as numeric
	
	If AliasIndic("D0G")
		If (!Empty(xFilial("D0G")) .Or. cFilAnt == cFirst ) //-- Corre D0G para Atualizar B2_QACLASS em Produtos SB2.
			cMensagem := getMsg("D0G")
						
			SB8->(dbSetOrder(3))
			if oQueryD0G == nil
				cQryD0G := "SELECT D0G_PRODUT,D0G_LOCAL,D0G_LOTECT,D0G_NUMLOT, D0G_SALDO, D0G_QTSEUM "
				cQryD0G += " FROM " + RetSqlName("D0G") + " D0G "
				cQryD0G += " INNER JOIN "+RetSqlName("SB1")+" SB1 "
				cQryD0G += " ON SB1.B1_FILIAL = ? "				
				if lFilProd //FILTRO DE PRODUTO
					cQryD0G += " AND SB1.B1_COD BETWEEN ? AND ? "				
				EndIf
				cQryD0G += " AND SB1.B1_COD = D0G.D0G_PRODUT "
				cQryD0G += " AND SB1.D_E_L_E_T_ = ? "
				cQryD0G += " WHERE D0G.D0G_FILIAL = ? "				
				if lFilArmz //FILTRO DE ARMAZEM
					cQryD0G += " AND D0G.D0G_LOCAL BETWEEN ? AND ? "				
				EndIf
				cQryD0G += " AND D0G.D0G_SALDO > ? "
				cQryD0G += " AND D0G.D_E_L_E_T_ = ? "
				cQryD0G := ChangeQuery(cQryD0G)
				oQueryD0G := FwExecStatement():New(cQryD0G)				
			endIf		
				
			oQueryD0G:setString(nBind++,FWxFilial( 'SB1' ))
			injectPerg(oQueryD0G,@nBind)//PRODUTO		
			oQueryD0G:setString(nBind++,' ')
			oQueryD0G:setString(nBind++,FWxFilial( 'D0G' ))			
			injectPerg(oQueryD0G,@nBind,.f.)//ARMAZEM
			oQueryD0G:setNumeric(nBind++,0)
			oQueryD0G:setString(nBind++,' ')
			oQueryD0G:OpenAlias(cAliasD0G)
			M215Comp('D0G',cAliasD0G)
				
			
				
			While (cAliasD0G)->(!Eof())
				//Atualizar Qtde Prevista de Produtos SB2.            				
				chkSb2(xFilial('SB2')+(cAliasD0G)->D0G_PRODUT+(cAliasD0G)->D0G_LOCAL,(cAliasD0G)->D0G_PRODUT,(cAliasD0G)->D0G_LOCAL)
				Reclock("SB2",.F.)
				SB2->B2_QACLASS += (cAliasD0G)->D0G_SALDO				
				SB2->(MsUnlock())
				// Caso use rastreabilidade, GRAVA a quantidade do D0G   
				// no SB8 para que o Saldo por Sub-Lote fique bloqueado  
				If Rastro((cAliasD0G)->D0G_PRODUT)
					If Rastro((cAliasD0G)->D0G_PRODUT,"S")
						cSeek := xFilial('SB8')+(cAliasD0G)->D0G_PRODUT+(cAliasD0G)->D0G_LOCAL+(cAliasD0G)->D0G_LOTECT+(cAliasD0G)->D0G_NUMLOT
						cCompara := "B8_FILIAL+B8_PRODUTO+B8_LOCAL+B8_LOTECTL+B8_NUMLOTE"
					Else
						cSeek := xFilial('SB8')+(cAliasD0G)->D0G_PRODUT+(cAliasD0G)->D0G_LOCAL+(cAliasD0G)->D0G_LOTECT
						cCompara := "B8_FILIAL+B8_PRODUTO+B8_LOCAL+B8_LOTECTL"
					EndIf
					SB8->(dbSeek(cSeek))
					nEmpenho := (cAliasD0G)->D0G_SALDO
					nEmpenh2 := (cAliasD0G)->D0G_QTSEUM
					While SB8->(!Eof()) .And. nEmpenho > 0 .And. cSeek == SB8->(&(cCompara))
						nBaixaEmp := Min(nEmpenho,SB8Saldo(Nil,.T.,Nil,Nil,Nil,lEmpPrev))
						nBaixaEm2 := Min(nEmpenh2,SB8Saldo(Nil,.T.,Nil,.T.,Nil,lEmpPrev))
						RecLock("SB8",.F.)
						SB8->B8_QACLASS += nBaixaEmp
						SB8->B8_QACLAS2 += nBaixaEm2
						nEmpenho -= nBaixaEmp
						nEmpenh2 -= nBaixaEm2
						SB8->(MsUnlock())
						SB8->(dbSkip())
					EndDo
				EndIf					
				(cAliasD0G)->(dbSkip())			
				
			EndDo
			(cAliasD0G)->(dbCloseArea())			
		EndIf		
	EndIf
	
Return 

/*/{Protheus.doc} a215AtuSDA
	 Corre SDA para Atualizar B2_QACLASS e B8_QACLASS
	@type  Function
	@author Rodrigo Lombardi
	@since 20/03/2025
	@version 1.0
	@param oObj,object,Regua de processamento
	@param aFilTabs,array,Tabela de filiais
	@param cFirst,character,Primeira Filial analisada
/*/
static Function a215AtuSDA(oObj,aFilTabs,cFirst)
	Local cMensagem := "" as character
	Local cQrySDA := "" as character
	Local cAliasSDA := "QSDAMA215" as character
	Local cSeek       := "" as character
	Local cCompara    := "" as character
	Local nEmpenho    := 0 as numeric
	Local nEmpenh2    := 0 as numeric
	Local nBaixaEmp   := 0 as numeric
	Local nBaixaEm2   := 0 as numeric
	Local lEmpPrev    := If(SuperGetMV("MV_QTDPREV")== "S",.T.,.F.) as logical
	Local nBind := 1	as numeric

	if vldProc('SDA',aFilTabs,TabelaSDA,cFirst)	
		cMensagem := getMsg("SDA")
		SB8->(dbSetOrder(3))
		
		
		if oQuerySDA == nil
			cQrySDA := "SELECT DA_PRODUTO, DA_LOCAL, DA_SALDO, SDA.R_E_C_N_O_ RECSDA,"
			cQrySDA += " DA_LOTECTL, DA_NUMLOTE, DA_QTSEGUM FROM "
			cQrySDA += RetSqlName("SDA")+ " SDA "
			cQrySDA += " INNER JOIN "+REtSqlName("SB1")+" SB1 "
			cQrySDA += " ON SB1.B1_FILIAL = ? "			
			if lFilProd //FILTRO DE PRODUTO
				cQrySDA += " AND SB1.B1_COD BETWEEN ? AND ? "				
			EndIf
			cQrySDA += " AND SB1.B1_COD = SDA.DA_PRODUTO "
			cQrySDA += " AND SB1.D_E_L_E_T_ = ? "
			cQrySDA += " WHERE SDA.DA_FILIAL    = ? "			
			if lFilArmz //FILTRO DE ARMAZEM
				cQrySDA += " AND SDA.DA_LOCAL BETWEEN ? AND ? "				
			EndIf
			cQrySDA += " AND SDA.DA_SALDO       > ? "
			cQrySDA += " AND SDA.D_E_L_E_T_ = ? "
			cQrySDA := ChangeQuery(cQrySDA)
					
			oQuerySDA := FwExecStatement():New(cQrySDA)			
			
		endIf				
		oQuerySDA:setString(nBind++,FWxFilial( 'SB1' ))
		injectPerg(oQuerySDA,@nBind)//PRODUTO		
		oQuerySDA:setString(nBind++,' ')		
		oQuerySDA:setString(nBind++,FWxFilial( 'SDA' ))		
		injectPerg(oQuerySDA,@nBind,.f.)//ARMAZEM
		oQuerySDA:setNumeric(nBind++,0)
		oQuerySDA:setString(nBind++,' ')	
		oQuerySDA:OpenAlias(cAliasSDA)

				
		While (cAliasSDA)->(!Eof())
			// Atualizar Qtde Prevista de Produtos SB2.            
			chkSb2(xFilial('SB2')+(cAliasSDA)->DA_PRODUTO+(cAliasSDA)->DA_LOCAL,(cAliasSDA)->DA_PRODUTO,(cAliasSDA)->DA_LOCAL)
			Reclock("SB2",.F.)
			SB2->B2_QACLASS +=  (cAliasSDA)->DA_SALDO			
			SB2->(MsUnlock())
			// Caso use rastreabilidade, GRAVA a quantidade do SDA   
			// no SB8 para que o Saldo por Sub-Lote fique bloqueado  
			If Rastro((cAliasSDA)->DA_PRODUTO)
				If Rastro((cAliasSDA)->DA_PRODUTO,"S")
					cSeek := xFilial('SB8')+(cAliasSDA)->DA_PRODUTO+(cAliasSDA)->DA_LOCAL+(cAliasSDA)->DA_LOTECTL+(cAliasSDA)->DA_NUMLOTE
					cCompara := "B8_FILIAL+B8_PRODUTO+B8_LOCAL+B8_LOTECTL+B8_NUMLOTE"
				Else
					cSeek := xFilial('SB8')+(cAliasSDA)->DA_PRODUTO+(cAliasSDA)->DA_LOCAL+(cAliasSDA)->DA_LOTECTL
					cCompara := "B8_FILIAL+B8_PRODUTO+B8_LOCAL+B8_LOTECTL"
				EndIf
				SB8->(dbSeek(cSeek))
				nEmpenho := (cAliasSDA)->DA_SALDO
				nEmpenh2 := (cAliasSDA)->DA_QTSEGUM
				While SB8->(!Eof()) .And. nEmpenho > 0 .And. cSeek == SB8->(&(cCompara))
					nBaixaEmp := Min(nEmpenho,SB8Saldo(Nil,.T.,Nil,Nil,Nil,lEmpPrev))
					nBaixaEm2 := Min(nEmpenh2,SB8Saldo(Nil,.T.,Nil,.T.,Nil,lEmpPrev))
					RecLock("SB8",.F.)
					Replace B8_QACLASS With B8_QACLASS + nBaixaEmp
					Replace B8_QACLAS2 With B8_QACLAS2 + nBaixaEm2
					nEmpenho -= nBaixaEmp
					nEmpenh2 -= nBaixaEm2
					SB8->(MsUnlock())
					SB8->(dbSkip())
				EndDo
			EndIf
			(cAliasSDA)->(dbSkip())			
			
		EndDo
		(cAliasSDA)->(dbCloseArea())		
	EndIf
	
Return

/*/{Protheus.doc} a215AtuSD1
	 Corre SD1 e atualiza os dados acumulados da Pre-Nota de Entrada
	@type  Function
	@author Rodrigo Lombardi
	@since 20/03/2025
	@version 1.0
	@param oObj,object,Regua de processamento
	@param aFilTabs,array,Tabela de filiais
	@param cFirst,character,Primeira Filial analisada
/*/
static Function a215AtuSD1(oObj,aFilTabs,cFirst)
	Local cMensagem := "" as character
	Local cQrySD12 := ""	as character
	Local cAliasSD1 := "SD1MA215PROC" as character	
	Local cQuery    := ""	as character
	Local nBind := 1	as numeric
	
	if vldProc('SD1',aFilTabs,TabelaSD1,cFirst)	
		cMensagem := getMsg("SD1")	
						
		zerSD1() //ZERA CAMPOS DE DEVOLUÇÃO EM SD1		
		
		SB2->(dbSetOrder(1))
		if oQuerySD1 == nil
			If lMA215SD1
				cQuery := "SELECT SD1.D1_FILIAL, D1_COD, D1_LOCAL, D1_QUANT "
				cQuery += "FROM "+RetSqlName("SD1")+" SD1,"
				cQuery += RetSqlName("SB1")+" SB1 "
				cQuery += "WHERE SD1.D1_FILIAL= ? AND "//1				
				if lFilArmz //FILTRO DE ARMAZEM
					cQuery += " SD1.D1_LOCAL BETWEEN ? AND ? AND "				
				EndIf
				cQuery += "SD1.D1_TES = ? AND "//2
				cQuery += "SD1.D_E_L_E_T_= ? AND "//3
				cQuery += "SB1.B1_FILIAL= ? AND "//4				
				if lFilProd //FILTRO DE PRODUTO
					cQuery += " SB1.B1_COD BETWEEN ? AND ? AND "				
				EndIf
				cQuery += "SB1.B1_COD = SD1.D1_COD AND "
				cQuery += "SB1.D_E_L_E_T_= ? "//5
				cQuery := ExecBlock("MA215SD1",.F.,.F.,cQuery)
				cQuery += " ORDER BY D1_FILIAL,D1_COD,D1_LOCAL"
				cQuery := ChangeQuery(cQuery)
			Else
				cQrySD12 := "SELECT SD1.D1_FILIAL, D1_COD, D1_LOCAL,SUM(D1_QUANT) D1_QUANT "
				cQrySD12 += "FROM "+RetSqlName("SD1")+" SD1 "
				cQrySD12 += "INNER JOIN "+RetSqlName("SB1")+" SB1 "
				cQrySD12 += "ON SB1.B1_FILIAL  = ? AND "//1				
				if lFilProd //FILTRO DE PRODUTO
					cQrySD12 += " SB1.B1_COD BETWEEN ? AND ? AND "				
				EndIf
				cQrySD12 += "SB1.B1_COD         = SD1.D1_COD AND "
				cQrySD12 += "SB1.D_E_L_E_T_     = ? "//2
				cQrySD12 += "WHERE SD1.D1_FILIAL= ? AND "//3				
				if lFilArmz //FILTRO DE ARMAZEM
					cQrySD12 += " SD1.D1_LOCAL BETWEEN ? AND ? AND "				
				EndIf
				cQrySD12 += "SD1.D1_TES         = ? AND "//4
				cQrySD12 += "SD1.D_E_L_E_T_     = ? "//5
				cQrySD12 += " GROUP BY D1_FILIAL, D1_COD, D1_LOCAL"
				cQrySD12 := ChangeQuery(cQrySD12)			
				cQuery := cQrySD12
			EndIf		
			oQuerySD1 := FwExecStatement():New(cQuery)
		endIf
		if lMA215SD1
			oQuerySD1:setString(nBind++,FWxFilial( 'SD1' ))
			injectPerg(oQuerySD1,@nBind,.f.)//ARMAZEM
			oQuerySD1:setString(nBind++,Space(TamSx3('D1_TES')[1]))
			oQuerySD1:setString(nBind++,' ')				
			oQuerySD1:setString(nBind++,FWxFilial( 'SB1' ))
			injectPerg(oQuerySD1,@nBind)//PRODUTO
			oQuerySD1:setString(nBind++,' ')			
		else
			oQuerySD1:setString(nBind++,FWxFilial( 'SB1' ))
			injectPerg(oQuerySD1,@nBind)//PRODUTO
			oQuerySD1:setString(nBind++,' ')				
			oQuerySD1:setString(nBind++,FWxFilial( 'SD1' ))
			injectPerg(oQuerySD1,@nBind,.f.)//ARMAZEM
			oQuerySD1:setString(nBind++,Space(TamSx3('D1_TES')[1]))
			oQuerySD1:setString(nBind++,' ')			
		EndIf
		oQuerySD1:OpenAlias(cAliasSD1)
		

		While (cAliasSD1)->(!Eof()) .And. (cAliasSD1)->D1_FILIAL == xFilial("SD1")
	
			chkSb2(xFilial("SB2")+(cAliasSD1)->D1_COD+(cAliasSD1)->D1_LOCAL,(cAliasSD1)->D1_COD,(cAliasSD1)->D1_LOCAL)
			if RecLock("SB2",.F.)
				SB2->B2_NAOCLAS += (cAliasSD1)->D1_QUANT
				SB2->(MsUnLock())
			EndIf
			(cAliasSD1)->(dbSkip())			
			
		EndDo
		(cAliasSD1)->(dbCloseArea())		
		dbSelectArea("SD1")
	EndIf

Return

/*/{Protheus.doc} zerSD1
	Realiza o zeramento dos campos de devolução em SD1
	@type  Static Function
	@author rodrigo lombardi
	@since 26/12/2025
	@version v1.0
/*/
Static Function zerSD1()
Local nBind := 1 as numeric
local cQuery := "" as character
local cAliasSD1 := "SD1MA215ZER" as character

	if oQrySD1 == nil			
		cQuery := " SELECT R_E_C_N_O_ RECNO "
		cQuery += " FROM "+RetSqlName("SD1")+" SD1 "
		cQuery += " WHERE SD1.D1_FILIAL= ? AND "
		if lFilProd //FILTRO DE PRODUTO
			cQuery += " SD1.D1_COD BETWEEN ? AND ? AND "				
		EndIf
		if lFilArmz //FILTRO DE ARMAZEM
			cQuery += " SD1.D1_LOCAL BETWEEN ? AND ? AND "				
		EndIf
		cQuery += " SD1.D1_IDENTB6 <>  ? AND "
		cQuery += " ( SD1.D1_QTDEDEV > ? OR SD1.D1_VALDEV > ? ) AND "
		cQuery += " SD1.D_E_L_E_T_= ? "
		cQuery := ChangeQuery(cQuery)					
		oQrySD1 := FwExecStatement():New(cQuery)			
	endIf
	oQrySD1:setString(nBind++,FWxFilial( 'SD1' ))
	injectPerg(oQrySD1,@nBind)//PRODUTO	
	injectPerg(oQrySD1,@nBind,.f.)//ARMAZEM		
	oQrySD1:setString(nBind++,Space(TamSx3('D1_IDENTB6')[1]))
	oQrySD1:setNumeric(nBind++,0)
	oQrySD1:setNumeric(nBind++,0)
	oQrySD1:setString(nBind++,' ')
		
	oQrySD1:OpenAlias(cAliasSD1)
	DbSelectArea('SD1')	

	//ZERAMENTO VIA RECLOCK
	while (cAliasSD1)->(!Eof())
		SD1->(DbGoto((cAliasSD1)->(RECNO)))
		if Reclock('SD1',.f.)				
			SD1->D1_QTDEDEV := 0
			SD1->D1_VALDEV := 0				
			MsUnlock()				
		Endif
		(cAliasSD1)->(dbSkip())
	end
	(cAliasSD1)->(dbCloseArea())		

	dbSelectArea("SD1")	

Return 

/*/{Protheus.doc} a215AtuSC0
	Corre SC0 e atualiza os dados acumulados das Reserva de Faturamento
	@type  Function
	@author Rodrigo Lombardi
	@since 20/03/2025
	@version 1.0
	@param oObj,object,Regua de processamento
	@param aFilTabs,array,Tabela de filiais
	@param cFirst,character,Primeira Filial analisada
/*/
static Function a215AtuSC0(oObj,aFilTabs,cFirst)
	Local cMensagem := ""
	Local cAliasSC0 := "SC0MA215PROC"
	Local cQuerySC0    := ""	
	Local nBind := 1 as numeric
	
	cMensagem := getMsg("SC0")

	if vldProc('SC0',aFilTabs,TabelaSC0,cFirst)	
	
		dbSelectArea("SC0")
		dbSetOrder(1)
			
		if oQuerySC0 == nil
			cQuerySC0 := " SELECT C0_PRODUTO,C0_LOCAL,C0_LOTECTL,C0_NUMLOTE,C0_LOCALIZ,C0_QUANT, C0_QTDPED, "
			cQuerySC0 += " C0_NUMSERI,C0_NUM,SB1.B1_FILIAL "
			cQuerySC0 += " FROM "+RetSqlName("SC0")+" SC0, "
			cQuerySC0 +=  RetSqlName("SB1")+" SB1 "
			cQuerySC0 += " WHERE SC0.C0_FILIAL= ? AND "			
			if lFilProd //FILTRO DE PRODUTO
				cQuerySC0 += " SB1.B1_COD BETWEEN ? AND ? AND "				
			EndIf
			cQuerySC0 += " SB1.B1_COD = SC0.C0_PRODUTO AND "			
			if lFilArmz //FILTRO DE ARMAZEM
				cQuerySC0 += " SC0.C0_LOCAL BETWEEN ? AND ? AND "				
			EndIf
			cQuerySC0 += " SC0.C0_QUANT > ? AND "			
			cQuerySC0 += " SC0.C0_TIPO<> ? AND "
			cQuerySC0 += " SC0.D_E_L_E_T_ = ? AND "
			cQuerySC0 += " SB1.B1_FILIAL = ? AND "
			cQuerySC0 += " SB1.D_E_L_E_T_ = ? "
			cQuerySC0 += " ORDER BY C0_FILIAL,C0_PRODUTO,C0_LOCAL "

			cQuerySC0 := ChangeQuery(cQuerySC0)
			oQuerySC0 := FwExecStatement():New(cQuerySC0)			
		endIf
		oQuerySC0:setString(nBind++,FWxFilial( 'SC0' ))
		injectPerg(oQuerySC0,@nBind)//PRODUTO
		injectPerg(oQuerySC0,@nBind,.f.)//ARMAZEM
		oQuerySC0:setNumeric(nBind++,0)
		oQuerySC0:setString(nBind++,'LJ')
		oQuerySC0:setString(nBind++,' ')
		oQuerySC0:setString(nBind++,FWxFilial( 'SB1' ))			
		oQuerySC0:setString(nBind++,' ')

		oQuerySC0:OpenAlias(cAliasSC0)
		M215Comp('SC0',cAliasSC0)

		
			
		While (cAliasSC0)->(!Eof())
			Ma215Res(cAliasSC0, (cAliasSC0)->C0_QUANT, (cAliasSC0)->C0_QTDPED)
			(cAliasSC0)->(dbSkip())			
			
		EndDo

		(cAliasSC0)->(dbCloseArea())		
		dbSelectArea("SC0")
	EndIf
	
Return

/*/{Protheus.doc} a215AtuSB6
	Corre SB6 e atualiza os dados acumulados do PODER de 3 e EM 3
	@type  Function
	@author Squad Entradas
	@since 20/03/2025
	@version 1.0
	@param oObj,object,Regua de processamento
	@param aFilTabs,array,Tabela de filiais
	@param cFirst,character,Primeira Filial analisada
/*/
static Function a215AtuSB6(oObj,aFilTabs,cFirst)
	Local cMensagem := "" as character
	Local cAliasSB6 := "SB6MA215PROC" as character
	Local cQrySB6    := ""	as character
	Local cSB6Filial := xFilial("SB6") as character
	Local cSF4Filial := xFilial("SF4") as character
	Local cSB2Filial := xFilial("SB2") as character
	Local cEstoque    := "" as character
	Local cLocOriSB6  := "" as character
	Local nBind := 1 as numeric
	
	if vldProc('SB6',aFilTabs,TabelaSB6,cFirst)	
		dbSelectArea("SB6")
		dbSetOrder(1)
		cMensagem := getMsg("SB6")
		//A215(oObj, cFilProc, cMensagem)
		if oQuerySB6 == nil
			cQrySB6 := "SELECT B6_FILIAL, B6_PRODUTO,B6_LOCAL, B6_QUANT, B6_TES, B6_ESTOQUE,B6_IDENT "
			cQrySB6 += "FROM "+RetSqlName("SB6")+" SB6 "
			cQrySB6 += "INNER JOIN " +RetSqlName("SB1")+ " SB1 "
			cQrySB6 += "ON SB1.B1_FILIAL= ? AND "			
			if lFilProd //FILTRO DE PRODUTO
				cQrySB6 += " SB1.B1_COD BETWEEN ? AND ? AND "				
			EndIf
			cQrySB6 += "SB1.B1_COD=SB6.B6_PRODUTO AND "
			cQrySB6 += "SB1.D_E_L_E_T_= ? "
			cQrySB6 += "WHERE SB6.B6_FILIAL= ? AND "			
			if lFilArmz //FILTRO DE ARMAZEM
				cQrySB6 += " SB6.B6_LOCAL BETWEEN ? AND ? AND "				
			EndIf
			cQrySB6 += "SB6.B6_QUANT > ? AND "
			cQrySB6 += "SB6.D_E_L_E_T_= ? "
			cQrySB6 += "ORDER BY B6_FILIAL,B6_PRODUTO,B6_LOCAL "

			cQrySB6 := ChangeQuery(cQrySB6)
			oQuerySB6 := FwExecStatement():New(cQrySB6)
			
		endif
		
			
		oQuerySB6:setString(nBind++,FWxFilial( 'SB1' ))
		injectPerg(oQuerySB6,@nBind)//PRODUTO
		oQuerySB6:setString(nBind++,' ')
		oQuerySB6:setString(nBind++,FWxFilial( 'SB6' ))
		injectPerg(oQuerySB6,@nBind,.f.)//ARMAZEM
		oQuerySB6:setNumeric(nBind++,0)		
		oQuerySB6:setString(nBind++,' ')
		oQuerySB6:OpenAlias(cAliasSB6)

		M215Comp('SB6',cAliasSB6)

		
		SF4->(dbSetOrder(1))
		SB6->(dbSetOrder(3))
		SB2->(dbSetOrder(1))
		While (cAliasSB6)->(!Eof())

			cLocOriSB6:= (cAliasSB6)->B6_LOCAL
			SF4->(MsSeek(cSF4Filial+(cAliasSB6)->B6_TES))
			//Quando for devolucao de material que estava em terceiros,    
			//posicionar sempre no local de origem da remessa.
			If SF4->F4_PODER3 == "D" .And. (cAliasSB6)->B6_TES < "501"
				If SB6->(MsSeek(cSB6Filial+(cAliasSB6)->B6_IDENT+(cAliasSB6)->B6_PRODUTO+"R"))
					cLocOriSB6 := SB6->B6_LOCAL //Local de Origem
				EndIf
			EndIf

			chkSb2(cSB2Filial+(cAliasSB6)->B6_PRODUTO+cLocOriSB6,(cAliasSB6)->B6_PRODUTO,(cAliasSB6)->B6_LOCAL)
			RecLock("SB2",.F.)

			cEstoque := (cAliasSB6)->B6_ESTOQUE
			//Atualiza os Campos B2_QTER, B2_QNPT, B2_QTNP.                 
			IF SF4->F4_CODIGO <= "500"   // Documentos de Entrada.
				If ( SF4->F4_PODER3 $ "DR" )
					If ( SF4->F4_PODER3 == "D" ) // Devolucoes.
						If IIf(Empty(cEstoque),SF4->F4_ESTOQUE,cEstoque)=="N"
							SB2->B2_QTER -= (cAliasSB6)->B6_QUANT
						Else
							SB2->B2_QNPT -= (cAliasSB6)->B6_QUANT
						EndIf
					Else  // Remessas.
						If IIf(Empty(cEstoque),SF4->F4_ESTOQUE,cEstoque)=="N"
							SB2->B2_QTER += (cAliasSB6)->B6_QUANT
						Else
							SB2->B2_QTNP += (cAliasSB6)->B6_QUANT
						EndIf
					EndIf
				EndIf
			Else  // Doucmentos de Saida.
				If ( SF4->F4_PODER3 $ "DR" )
					If ( SF4->F4_PODER3 == "D" )  // Devolucoes.
						If IIf(Empty(cEstoque),SF4->F4_ESTOQUE,cEstoque)=="N"
							SB2->B2_QTER -= (cAliasSB6)->B6_QUANT
						Else
							SB2->B2_QTNP -= (cAliasSB6)->B6_QUANT
						EndIf
					Else  //Remessas
						If IIf(Empty(cEstoque),SF4->F4_ESTOQUE,cEstoque)=="N"
							SB2->B2_QTER += (cAliasSB6)->B6_QUANT
						Else
							SB2->B2_QNPT += (cAliasSB6)->B6_QUANT
						EndIf
					EndIf
				EndIf
			Endif

			SB2->(MsUnLock())
			(cAliasSB6)->(dbSkip())			
			
		EndDo
		(cAliasSB6)->(dbCloseArea())
		dbSelectArea("SB6")		
	EndIf
	
Return


/*/{Protheus.doc} a215AtuAFJ
	Corre AFJ e atualiza os dados acumulados dos empenhos do SIGAPMS   
	@type  Function
	@author Rodrigo Lombardi
	@since 20/03/2025
	@version 1.0
	@param oObj,object,Regua de processamento	
	@param cFirst,character,Primeira Filial analisada
/*/
static Function a215AtuAFJ(oObj,cFirst)
	Local cMensagem := "" as character
	Local cAliasAFJ := "AFJMA215PROC" as character
	Local cQryAFJ    := ""	as character
	Local nBind := 1 as numeric
	
	If (!Empty(xFilial("AFJ")) .Or. cFilAnt == cFirst )	
		cMensagem := getMsg("AFJ")
		
		dbSelectArea("AFJ")
		dbSetOrder(1)
		if oQueryAFJ == nil
			cQryAFJ := "SELECT AFJ_FILIAL, AFJ_COD, AFJ_LOCAL, AFJ_PROJET, AFJ_TAREFA, "
			cQryAFJ += " AFJ_QEMP, AFJ_QEMP2, AFJ_QATU, AFJ_EMPEST, AFJ_QATU2, AFJ_EMPES2, "
			cQryAFJ += " AFJ_QEMPPR, AFJ_QEMPP2, AFJ_TRT"
			cQryAFJ += "FROM "+RetSqlName("AFJ")+" AFJ,"
			cQryAFJ += RetSqlName("SB1")+" SB1 "
			cQryAFJ += "WHERE AFJ.AFJ_FILIAL= ? AND "
			cQryAFJ += "AFJ.AFJ_QEMP > (AFJ.AFJ_QATU + AFJ.AFJ_EMPEST) AND "
			cQryAFJ += "AFJ.D_E_L_E_T_= ? AND "
			cQryAFJ += "SB1.B1_FILIAL= ? AND "			
			if lFilProd //FILTRO DE PRODUTO
				cQryAFJ += " SB1.B1_COD BETWEEN ? AND ? AND "				
			EndIf
			cQryAFJ += "SB1.B1_COD=AFJ.AFJ_COD AND "			
			if lFilArmz //FILTRO DE ARMAZEM
				cQryAFJ += " AFJ.AFJ_LOCAL BETWEEN ? AND ? AND "				
			EndIf
			cQryAFJ += "SB1.D_E_L_E_T_= ? "
			cQryAFJ += "ORDER BY AFJ_FILIAL,AFJ_COD,AFJ_LOCAL"

			cQryAFJ := ChangeQuery(cQryAFJ)
			oQueryAFJ := FwExecStatement():New(cQryAFJ)			
			
		endif
		oQueryAFJ:setString(nBind++,FWxFilial( 'AFJ' ))
		oQueryAFJ:setString(nBind++,' ')			
		oQueryAFJ:setString(nBind++,FWxFilial( 'SB1' ))
		injectPerg(oQueryAFJ,@nBind)//PRODUTO
		injectPerg(oQueryAFJ,@nBind,.f.)//ARMAZEM
		oQueryAFJ:setString(nBind++,' ')
		oQueryAFJ:OpenAlias(cAliasAFJ)
		M215Comp('AFJ',cAliasAFJ)
				
		While (cAliasAFJ)->(!Eof())
			//Atualiza arquivo de empenhos
			PmsAtuEmp(	(cAliasAFJ)->AFJ_PROJET,;
							(cAliasAFJ)->AFJ_TAREFA,;
							(cAliasAFJ)->AFJ_COD,;
							(cAliasAFJ)->AFJ_LOCAL,;
							(cAliasAFJ)->AFJ_QEMP-((cAliasAFJ)->AFJ_QATU + (cAliasAFJ)->AFJ_EMPEST),;
							"+",;
							.F.,;
							(cAliasAFJ)->AFJ_QEMP2-((cAliasAFJ)->AFJ_QATU2 + (cAliasAFJ)->AFJ_EMPES2),;
							(cAliasAFJ)->AFJ_TRT)
			PmsAtuEmp(	(cAliasAFJ)->AFJ_PROJET,;
							(cAliasAFJ)->AFJ_TAREFA,;
							(cAliasAFJ)->AFJ_COD,;
							(cAliasAFJ)->AFJ_LOCAL,;
							(cAliasAFJ)->AFJ_QEMPPR,;
							"+",;
							.F.,;
							(cAliasAFJ)->AFJ_QEMPP2,;
							(cAliasAFJ)->AFJ_TRT,;
							,,,;
							.T.)
			(cAliasAFJ)->(dbSkip())			
			
		EndDo
		dbSelectArea(cAliasAFJ)
		(cAliasAFJ)->(dbCloseArea())
		dbSelectArea("AFJ")		
	EndIf
		
Return

/*/{Protheus.doc} a215AtuSL2
	Corre SL2 e atualiza os dados acumulados das Reservas do SigaLoja
	@type  Function
	@author Rodrigo Lombardi
	@since 20/03/2025
	@version 1.0
	@param oObj,object,Regua de processamento	
	@param cFirst,character,Primeira Filial analisada
/*/
static Function a215AtuSL2(oObj,cFirst)
	Local cMensagem := ""
	Local cAliasSL2 := "SL2RES"
	Local cQrySL2    := ""	
	Local lContinua := .f.	
	Local nBind := 1
	
If (!Empty(xFilial("SL2")) .Or. cFilAnt == cFirst )
	cMensagem := getMsg("SL2")
		
	dbSelectArea("SL2")
	SL2->(dbSetOrder(1))
	
	SB1->(DbSetOrder(1))
	if oQuerySL2 == nil
		cQrySL2 := "SELECT SUM(L2_QUANT) L2_QUANT, L2_PRODUTO, L2_FILIAL, L2_LOCAL, L2_NUM, L1_DOC, L1_SERIE , L1_ECFLAG, C5_PEDECOM  "
		cQrySL2 += "FROM " + RetSqlName("SL2") + " SL2 "
		cQrySL2 += "INNER JOIN  " + RetSqlName("SL1") +  " SL1 "
		cQrySL2 += "ON SL1.L1_FILIAL = ? " // 1
		cQrySL2 += "AND SL1.L1_NUM =  SL2.L2_NUM "
		cQrySL2 += "AND SL1.D_E_L_E_T_= ? " // 2
		cQrySL2 += "LEFT OUTER JOIN " + RetSqlName("SC5") + " SC5 "
		cQrySL2 += "ON ( SL1.L1_FILRES = SC5.C5_FILIAL AND SL1.L1_PEDRES = SC5.C5_NUM AND SC5.D_E_L_E_T_= ? ) " //3
		cQrySL2 += "WHERE SL2.L2_FILIAL = ? " // 4		
		if lFilProd //FILTRO DE PRODUTO
			cQrySL2 += " AND SL2.L2_PRODUTO BETWEEN ? AND ? "				
		EndIf		
		if lFilArmz //FILTRO DE ARMAZEM
			cQrySL2 += " AND SL2.L2_LOCAL BETWEEN ? AND ? "				
		EndIf
		cQrySL2 += "AND SL2.L2_RESERVA <> ? " // 6
		cQrySL2 += "AND SL2.L2_PDV = ? " // 5	
		cQrySL2 += "AND SL2.L2_ORCRES = ? " // 7
		cQrySL2 += "AND SL2.L2_PEDRES = ? "  // 8
		cQrySL2 += "AND SL2.L2_VENDIDO <> ? " // 9
		cQrySL2 += "AND SL2.D_E_L_E_T_= ? " // 10
		cQrySL2 += "GROUP BY SL2.L2_FILIAL, SL2.L2_PRODUTO, SL2.L2_LOCAL, SL2.L2_NUM, SL1.L1_DOC, SL1.L1_SERIE, SL1.L1_ECFLAG, SC5.C5_PEDECOM "
				
		cQrySL2 := ChangeQuery(cQrySL2)
		oQuerySL2 := FwExecStatement():New(cQrySL2)	
			
	endIf
	oQuerySL2:setString(nBind++,FWxFilial( 'SL1' ))
	oQuerySL2:setString(nBind++,' ')
	oQuerySL2:setString(nBind++,' ')
	oQuerySL2:setString(nBind++,FWxFilial( 'SL2' ))	
	injectPerg(oQuerySL2,@nBind)//PRODUTO
	injectPerg(oQuerySL2,@nBind,.f.)//ARMAZEM	
	oQuerySL2:setString(nBind++,Space(TamSX3('L2_RESERVA')[1]))
	oQuerySL2:setString(nBind++,Space(TamSX3('L2_PDV')[1]))	
	oQuerySL2:setString(nBind++,Space(TamSX3('L2_ORCRES')[1]))
	oQuerySL2:setString(nBind++,Space(TamSX3('L2_PEDRES')[1]))
	oQuerySL2:setString(nBind++,'S')
	oQuerySL2:setString(nBind++,' ')	
		
	oQuerySL2:OpenAlias(cAliasSL2)
	M215Comp('SL2',cAliasSL2)
	
	While (cAliasSL2)->(!Eof())
		lContinua := .T.		
		If RTrim((cAliasSL2)->L1_ECFLAG)  == "1"
			If !Empty((cAliasSL2)->L1_DOC) .AND. !Empty((cAliasSL2)->L1_SERIE)
				//Pedido e-commerce faturado, não atualiza a reserva
				lContinua := .F.
			ElseIf !Empty((cAliasSL2)->C5_PEDECOM)
					//Pedido e-commerce CiaShop, quantidade em reserva já foi apurada pela SC6
					lContinua := .F.
				EndIf
			EndIf

			If lContinua
				Ma215LjAtuRes( cAliasSL2 )
			EndIf

			(cAliasSL2)->(dbSkip())	
			
		End
		(cAliasSL2)->(dbCloseArea())		
		dbSelectArea("SL2")
EndIf

Return

/*/{Protheus.doc} A215AtuDHQ
	Funcao destinada a reprocessar os saldos acumulados de compra com entrega futura (chamada via rotina MATA215)
	Utiliza de base o A103Refaz do fonte 
	@type  Function
	@author Rodrigo Lombardi
	@since 20/03/2025
	@version 1.0
	@param oObj,object,Regua de processamento	
	@param cFirst,character,Primeira Filial analisada
/*/
Static Function A215AtuDHQ(oObj,cFirst)

Local cMensagem := '' as character
Local cAliasDHQ := "DHQMA215PROC" as character
Local cQuery    := "" as character
Local nBind 	:= 1 as numeric
Local lCompraFut  := AliasInDic("DHQ") .And. SF4->(ColumnPos("F4_EFUTUR") > 0) .And. FindFunction("A103Refaz") as logical //Proteger no fonte MATA103COM

if lCompraFut	// Atualiza os dados acumulados do compras com entrega futura.
	If (!Empty(xFilial("DHQ")) .Or. cFilAnt == cFirst )
		cMensagem := getMsg("DHQ")
		dbSelectArea("DHQ")
		dbSetOrder(1)
		if oQueryDHQ == nil
			cQuery := " SELECT DHQ.DHQ_FILIAL FILIAL, DHQ.DHQ_COD PRODUTO, SD1.D1_LOCAL ALMOX, "
			cQuery += " DHQ.DHQ_QTORI - DHQ.DHQ_QTREC QUANT_UM1 " 
			cQuery += " FROM " + RetSQLName("DHQ") + " DHQ " 
			cQuery += " INNER JOIN " + RetSQLName("SD1") + " SD1 "
			cQuery += " ON SD1.D1_FILIAL  = ?  " 		
			cQuery += " AND SD1.D1_DOC     = DHQ.DHQ_DOC " 
			cQuery += " AND SD1.D1_SERIE   = DHQ.DHQ_SERIE " 
			cQuery += " AND SD1.D1_FORNECE = DHQ.DHQ_FORNEC " 
			cQuery += " AND SD1.D1_LOJA    = DHQ.DHQ_LOJA " 			
			if lFilProd //FILTRO DE PRODUTO
				cQuery += " AND SD1.D1_COD BETWEEN ? AND ? "				
			EndIf			
			if lFilArmz //FILTRO DE ARMAZEM
				cQuery += " AND SD1.D1_LOCAL BETWEEN ? AND ? "				
			EndIf
			cQuery += " AND SD1.D1_COD     = DHQ.DHQ_COD " 
			cQuery += " AND SD1.D1_ITEM    = DHQ.DHQ_ITEM "
			cQuery += " AND SD1.D_E_L_E_T_ = ? "
			cQuery += " WHERE DHQ.DHQ_FILIAL = ? " 		
			cQuery += " AND DHQ.DHQ_TIPO   = ? "   // 1-Compra futura.
			cQuery += " AND DHQ.DHQ_STATUS = ? "   // 1-Aberto.			
			cQuery += " AND DHQ.DHQ_QTORI  <> DHQ.DHQ_QTREC " 
			cQuery += " AND DHQ.DHQ_DESFAZ  = ? " 
			cQuery += " AND DHQ.D_E_L_E_T_ = ? " 
			cQuery += " ORDER by 1, 2, 3 "
			cQuery := ChangeQuery(cQuery)
			oQueryDHQ := FwExecStatement():New(cQuery)		
			
		EndIf	
		oQueryDHQ:setString(nBind++,xFilial("SD1"))
		injectPerg(oQueryDHQ,@nBind)//PRODUTO
		injectPerg(oQueryDHQ,@nBind,.f.)//ARMAZEM		
		oQueryDHQ:setString(nBind++,' ')	
		oQueryDHQ:setString(nBind++,xFilial("DHQ"))
		oQueryDHQ:setString(nBind++,'1')
		oQueryDHQ:setString(nBind++,'1')		
		oQueryDHQ:setString(nBind++,' ')
		oQueryDHQ:setString(nBind++,' ')
		
		oQueryDHQ:OpenAlias(cAliasDHQ)
		M215Comp('DHQ',cAliasDHQ)
		

		Do While (cAliasDHQ)->(!eof())
			MaAvalCF(1, (cAliasDHQ)->PRODUTO, (cAliasDHQ)->ALMOX, (cAliasDHQ)->QUANT_UM1)
			
			(cAliasDHQ)->(dbSkip())
		EndDo
		(cAliasDHQ)->(dbCloseArea())
		dbSelectArea("DHQ")
	EndIf
EndIf


Return

/*/{Protheus.doc} vldProc
	Valida se pode processar a filial
	@type  Function
	@author Rodrigo Lombardi
	@since 17/03/2025
	@version 1.0
	@param cTable,character, nome da tabela
	@param aFilTabs,array,tabela de filiais
	@param nTabela,numeric,numero da tabela
	@param cFirst,character,primeira filial processada
	@param lPCFilEnt,boolean,indica se o parametro MV_PCFILEN esta ativo
	@param lFilAnt,boolean,indica se a filial lida deve ser o cfilant
	@return lRet,boolean,se pode processar ou nao
/*/
Static Function vldProc(cTable,aFilTabs,nTabela,cFirst,lPCFilEnt,lFilAnt)
	Local lRet := .f.
	Local cFilialLida := FWxfilial(cTable)
	default lPCFilEnt := .f.
	default lFilAnt := .f.

	if Empty(cFilialLida) .and. lFilAnt 
		cFilialLida := cFilAnt
	EndIf

	if (!Empty(cFilialLida)) .Or. (cFilAnt == cFirst)
		lRet := .t.
		aFilTabs[nTabela][2] := cFilialLida
	EndIf

Return lRet

/*/{Protheus.doc} slctEmp
	Cria o array de filiais que sera realizado o processamento
	@type  Function
	@author Rodrigo Lombardi
	@since 17/02/2025
	@version 1.0
	@param cde,character, codigo da filial de
	@param cate,character, codigo da filial ate
/*/
Static Function slctEmp(cDe,cAte)
	Local aRet := {}
	Local aArray := {}
	Local aArea := getArea()	
	Local nX := 1
	//Carrego todos os dados das empresas e filiais
	aArray := FWLoadSM0()	
		//Filtro apenas pelas empresas e filiais desejadas
		for nX := 1 to len (aArray)
			if aArray[nX][1] == cEmpAnt
				if !empty(cDe) .or. !(empty(cAte))
					if aArray[nX][2] >= PADR(cDe,aArray[nX][8]," ") .and. aArray[nX][2] <= PADR(cAte,aArray[nX][8]," ") 
						aadd(aRet,aArray[nX])
					EndIf
				else//Caso não seja filtrado ou não exista o pergunte
					aadd(aRet,aArray[nX])
				EndIf
			EndIf
		Next	
	restArea(aArea)
Return aRet

/*/{Protheus.doc} getMsg
	Traz a informacao que sera passada para a mensagem
	@type  Function
	@author Rodrigo Lombardi
	@since 03/02/2025
	@param cTable,character,Tabela que vai ser usada na mensagem	
/*/
Static Function getMsg(cTable)
Local cMensagem as character

	cMensagem := FWX2Nome(cTable)
	cMensagem := Capital(cMensagem)	
	if lVerbose
		cMensagem := alltrim(cMensagem) + " - " + cTable
	EndIf

Return cMensagem

/*/{Protheus.doc} PulseLife
	Envia para o appserver um "pulso" da conexao do smartclient esta vivo.
	Este procedimento evita que a conexao fique presa caso o smartclient caia.
	@type  Function
	@author Nilton Rodrigues
	@since 06/04/2021
	@version 1.0
	@param oObj,object,objeto da regua de progresso
/*/
Static Function PulseLife(oObj)
	//- garante que não exista o objeto de régua
	If oObj == nil .and. Seconds() - nPulseLife > 30
		nPulseLife := Seconds()
		SYSREFRESH()//- sincroniza com o appserver
	EndIf
Return

/*/{Protheus.doc} M215Comp
	Efetua os ajustes dos campos que nao sao Caracter ou Memo
	@type  Function
	@author Nilton Rodrigues
	@since 06/04/2021
	@version 1.0
/*/
Static Function M215Comp(cAliasTab as character,cAliasTMP as character)
Local aStru as Array
Local nX    as numeric

aStru := (cAliasTab)->(dbStruct())

For nX := 1 To Len(aStru)
	If !aStru[nX][2] $ "CM" .AND. FieldPos(aStru[nX][1]) > 0
		TcSetField(cAliasTMP,aStru[nX][1],aStru[nX][2],aStru[nX][3],aStru[nX][4])
	EndIf
Next nX

aSize(aStru,0)
aStru := nil

Return

/*/{Protheus.doc} A215Painel
	Atualiza o texto do painel durante o processamento	
	@type Function	
	@author Squad Entradas
	@since 08/09/2022	
	@param oObj,object,objeto da regua
	@param cFilProc,character, mensagem a ser atualizada na regua
	@param cMensagem,character, mensagem adicional
/*/
Static Function A215Painel(oObj, cFilProc, cMensagem)

	//Validar pois o parametro não atende mais a necessidade
	if lVerbose .and. !lSc6Prod .and. oObj <> nil
		oObj:SaveLog(cFilProc +" / "+ cMensagem)
	EndIf
	
	
Return

/*/{Protheus.doc} A215AtuReg
	Atualiza regua de processamento
	@type Function
	@author Rodrigo Lombardi
	@since 17/03/2025
	@param oObj,object,objeto da regua 2
	@param nSetup,numeric, Numero de registros do da regua 1
	@param cMensagem,character, mensagem a ser exibido na regua 1
/*/
Static Function A215AtuReg(oObj,nSetup,cMensagem) 
default nSetup := 0 
default cMensagem := ""


	If l215Regua
		if !empty(cMensagem)
			if nSetup > 0		 
				oObj:SetRegua2(nSetup)
			EndIf
			oObj:IncRegua2(cMensagem)
		elseif !lSc6Prod			
			oObj:IncRegua1(cFilProc) //"Atualizando acumulados" + AllTrim(SM0->M0_NOME)+"/"+SM0->M0_FILIAL)			
		EndIf
	elseif lSchedule .and. empty(cMensagem)		
		IncProc()		
	EndIf

	PulseLife(oObj) //- pulso de conexão
Return

/*/{Protheus.doc} chkSb2
	Verifica se o SB2 existe, caso negativo chama CriaSb2
	@type  Static Function
	@author Rodrigo Lombardi
	@since 15/05/2025
	@version 1.0	
	@param cFilter, character, Filtro que sera usado no msseek	
	@param cProd, character, Produto que será inserido
	@param cLocal, character, Local que será inserido
/*/
Static Function chkSb2(cFilter,cProd,cLocal)

If SB2->(!MsSeek(cFilter))
	CriaSB2(cProd,cLocal)
EndIf

Return 


/*/{Protheus.doc} a215ClnQry
	Realiza a limpeza das variaveis de query
	@type  Function
	@author Rodrigo Lombardi
	@since 23/04/2025
	@version 1.0	
	@param lEnd,logical, indica se é o final do processo e deve limpar as tabelas temporarias e a query de conferencia da sc6
/*/
Static Function a215ClnQry(lEnd)

	Local aObj :=  {oQuerySB2,oQuerySB8,oQuerySBF,oQuerySC1,oQuerySC7,oQueryDHQ,;
		oQuerySC2,oQuerySD4,oQuerySDD,oQuerySCQ,oQueryD0G,oQuerySDA,oQuerySD1,;
		oQuerySB6,oQueryAFJ,oQuerySC0,oQueryDH1,oQuerySL2,oQueryNNT,;
		oQuerySA1,oQuerySC6,oRegSC9,oQuerySC9,oQuerySDC,oQrySD1,oQry215RES,;
		,oQrySDCOP}
	Local nX := 0
	Local aTab := {__oTmpTSC6,__oTmpTSC9}
	Local aTemp := {oTmpSA1,oTmpSB2,oTmpSB8,oTmpSBF,oTmpPrd}
	default lEnd := .f.

	if lEnd
		Aadd(aObj,oChkSC6)
	EndIf

	//Limpo as queries
	for nX := 1 to len(aObj)
		If !aObj[nX] == nil			
			aObj[nX]:Destroy()
			FWFreeObj(aObj[nX])
			aObj[nX] := nil
		EndIf
	Next
	//Limpo as tabelas
	if lEnd
		for nX := 1 to len(aTab)
			If !aTab[nX] == nil		
				aTab[nX]:Delete()		
				FWFreeObj(aTab[nX])
				aTab[nX] := nil
			EndIf
		Next
		//Limpo as tabelas Temporarias
		for nX := 1 to len(aTemp)
			If !aTemp[nX] == nil		
				aTemp[nX]:Delete()		
				FWFreeObj(aTemp[nX])
				aTemp[nX] := nil
			EndIf
		Next
	EndIf

Return

/*/{Protheus.doc} checkSc6
	Verifico se existe pedido de venda em um dos produtos e gravo quais são seus clientes
	@type  Static Function
	@author Rodrigo Lombardi
	@since 18/06/2025
	@version 1.0
	@return cChkSC6, character, Retorna o alias da tabela de conferencia de pedidos de vendas	
/*/
Static Function checkSC6()
Local cQuery := '' as character	
Local nBind := 1 as numeric
Local nLenC6_BLQ := Len(SC6->C6_BLQ) as numeric
Local cChkSC6 := 'CHKSC6M215' as Character

	If oChkSC6 == nil
		cQuery := " SELECT DISTINCT SC6.C6_FILIAL,SC6.C6_NUM,SC6.C6_ITEM,SC6.C6_PRODUTO,SC6.C6_LOCAL "
		cQuery += " ,SC6.C6_CLI,SC6.C6_LOJA "
		cQuery += " ,SC6.R_E_C_N_O_ RECNOSC6 "
		cQuery += " ,ISNULL(SB1.R_E_C_N_O_,0) RECNOSB1 "
		cQuery += " ,CASE WHEN SB1.R_E_C_N_O_ >0 THEN '1' ELSE '0' END EXISTSB1 "
		cQuery += " FROM "+RetSqlName("SC6")+" SC6 "
		cQuery += " LEFT JOIN "+RetSqlName("SB1")+" SB1 "
		cQuery += " ON "
		cQuery += " SB1.B1_FILIAL= ? AND "		
		cQuery += " SB1.B1_COD = SC6.C6_PRODUTO AND "
		cQuery += " SB1.D_E_L_E_T_= ? "
		cQuery += " LEFT JOIN "+RetSqlName("SD2")+" SD2 "
		cQuery += " ON "
		cQuery += " SD2.D2_DOC = SC6.C6_NOTA AND SD2.D2_SERIE = SC6.C6_SERIE AND "
		cQuery += " SD2.D2_PEDIDO = SC6.C6_NUM AND SD2.D2_ITEMPV =  SC6.C6_ITEM AND " 
		cQuery += " SD2.D2_CLIENTE = SC6.C6_CLI AND SD2.D2_LOJA =  SC6.C6_LOJA AND " 
		cQuery += " SD2.D2_FILIAL = ? AND "
		cQuery += " SD2.D_E_L_E_T_ = ? "
		cQuery += " WHERE "
		cQuery += " ((SC6.C6_FILIAL <> ? AND SC6.C6_FILIAL= ? ) OR "
		cQuery += " COALESCE (SD2.R_E_C_N_O_,0) > ? ) AND " 
		if lFilProd //FILTRO DE PRODUTO
			cQuery += " SC6.C6_PRODUTO BETWEEN ? AND ? AND "				
		EndIf
		if lFilArmz //FILTRO DE ARMAZEM
			cQuery += " SC6.C6_LOCAL BETWEEN ? AND ? AND "				
		EndIf		
		cQuery += " SC6.C6_BLQ <> ? AND "
		cQuery += " SC6.C6_BLQ <> ? AND "
		cQuery += " (SC6.C6_QTDVEN > SC6.C6_QTDENT OR (SC6.C6_QTDVEN <= SC6.C6_QTDENT AND SC6.C6_ENTREG>= ?)) AND "
		cQuery += " SC6.D_E_L_E_T_= ? "
		cQuery += " ORDER BY C6_FILIAL,C6_CLI,C6_LOJA "
		
		cQuery := ChangeQuery(cQuery)

		oChkSC6 := FwExecStatement():New(cQuery)
	EndIf

	oChkSC6:SetString(nBind++,xFilial( "SB1" ))
	oChkSC6:SetString(nBind++,Space(1))
	oChkSC6:SetString(nBind++,xFilial("SD2"))
	oChkSC6:SetString(nBind++,Space(1))
	oChkSC6:SetString(nBind++,Space(1))
	oChkSC6:SetString(nBind++,xFilial("SC6"))
	oChkSC6:setNumeric(nBind++,0)
	injectPerg(oChkSC6,@nBind)//PRODUTO
	injectPerg(oChkSC6,@nBind,.f.)//ARMAZEM	
	oChkSC6:SetString(nBind++,PadR('S',nLenC6_BLQ))
	oChkSC6:SetString(nBind++,PadR('R',nLenC6_BLQ))
	oChkSC6:SetString(nBind++,DTOS(dDataBase-31))
	oChkSC6:SetString(nBind++,Space(1))

	oChkSC6:OpenAlias(cChkSC6)

Return cChkSC6

/*/{Protheus.doc} injectPerg
	Realiza a injecao do pergunte no objeto da query
	@type  Static Function
	@author Rodrigo Lombardi
	@since 23/04/2025
	@version 1.0
	@param oInjQuery,Object, objeto ta query que vai receber o pergunte
	@param nBind,Numeric, sequencia numerica do binda (retorna o valor a origem)
	@param lIsProd,Logical,	verifica se deve bindar produto ou armazem
/*/
Static Function injectPerg(oInjQuery,nBind,lIsProd)
default lIsprod := .t.	
	//Produto
	if lFilProd .and. lIsProd .and. empty(cProduto)
		oInjQuery:setString(nBind++,aMTA215[5])
		oInjQuery:setString(nBind++,aMTA215[6])
	elseif lIsProd .and. !empty(cProduto)
		oInjQuery:setString(nBind++,cProduto)
		oInjQuery:setString(nBind++,cProduto)
	EndIf
	//Armazem
	if lFilArmz .and. !lIsprod .and. empty(cArmazem)
		oInjQuery:setString(nBind++,aMTA215[3])
		oInjQuery:setString(nBind++,aMTA215[4])
	elseif !lIsprod .and. !empty(cArmazem)
		oInjQuery:setString(nBind++,cArmazem)
		oInjQuery:setString(nBind++,cArmazem)
	endIf
Return 

/*/{Protheus.doc} checkRecno
	Confere se o recno ja foi ajustado
	@type Static Function
	@author Rodrigo Lombardi
	@since 16/06/2025
	@version 1.0
	@param oTmpTable, object, objeto da tabela temporaria que vai ser verificado
	@param cTable, character, nome da tabela que deve ser olhada
	@param nRecno, numeric, numero do recno que vai ser verificado
	@return lRet, logical, Indica se deve prosseguir ou não com o processamento	
/*/
Static Function checkRecno(oTmpTable,cTable,nRecno)
Local lRet := .t. as logical
Local aArea := getArea()

	if oTmpTable == nil
		oTmpTable := setTempTable(oTmpTable)//A tabela temporaria não existe portanto deve ser criada e preenchido o registro
		DbSelectArea(oTmpTable:GetAlias())
		if RecLock(oTmpTable:GetAlias(),.t.)
			(oTmpTable:GetAlias())->FILIAL := xFilial(cTable)
			(oTmpTable:GetAlias())->RECNO := nRecno
			MsUnlock()
		EndIf
	else
		if (oTmpTable:GetAlias())->(MsSeek(xFilial(cTable)+cValTochar(nRecno)))
			lRet := .f.//Significa que o recno já existe na tabela ou seja, já foi zerado/Ajustado	
			Return lRet
		else
			DbSelectArea(oTmpTable:GetAlias())//Não existe recno portanto deve gravar na tabela para que não seja avalidado novamente.
			if RecLock(oTmpTable:GetAlias(),.t.)
				(oTmpTable:GetAlias())->FILIAL := xFilial(cTable)
				(oTmpTable:GetAlias())->RECNO := nRecno
				MsUnlock()
			EndIf
		EndIf
	EndIf

RestArea(aArea)	

Return lRet

/*/{Protheus.doc} setTempTable
	Construo a tabela temporaria de Recnos
	@type  Static Function
	@author Rodrigo Lombardi
	@since 16/06/2025
	@version 1.0
	@param oTmpTable, object, objeto da tabela temporaria que vai ser utilizado como base
	@return oTmpTable, object, Retorna a tabela temporaria criada	
/*/
Static Function setTempTable(oTmpTable)
Local cAlias := GetNextAlias()
Local aTmpFields := {}
	aadd(aTmpFields,{"FILIAL","C",8,0})
	aadd(aTmpFields,{"RECNO","N",16,0})
	//Criação do objeto
	oTmpTable := FWTemporaryTable():New( cAlias )
	//Monta os campos da tabela
	oTmpTable:SetFields( aTmpFields )
	//Monta os indices da tabela
	oTmpTable:AddIndex("01", {"FILIAL","RECNO"} )
	//Criação da tabela		
	oTmpTable:Create()

Return oTmpTable

/*/{Protheus.doc} a215Conf
	Verifica se foi preenchido filtro de produto e armazem e refaz pedido de vendas
	@type  Static Function
	@author Rodrigo Lombardi
	@since 23/06/2025
	@version 1.0
/*/
Static Function a215Conf()

//Verifica se vai processar pedido de venda
if ValType(aMTA215[7]) == 'N'//Confere se o parametro existe como numerico
	if aMTA215[7] == 2 // Refaz saldo pedido de venda ? 1-Sim, 2-Não
		lRfzVnd := .t.
	EndIf
EndIf

//FILTRO DE PRODUTO
if !empty(aMTA215[5]) .or. !(Empty(StrTran(Upper(aMTA215[6]),'Z',''))) 
	lFilProd := .t.
EndIf
//FILTRO DE ARMAZEM
if !(empty(aMTA215[3])) .or. !(Empty(StrTran(Upper(aMTA215[4]),'Z','')))
	//Caso o cliente coloque de branco a ZZZ não deve considerar como filtro
	lFilArmz := .t.
EndIf

Return 

/*/{Protheus.doc} procProd
	Processa os ajustes por produto
	@type  Static Function
	@author Rodrigo Lombardi
	@since 17/12/2025
	@version v1.0
	@param cProd, character, Codigo do produto
	@param cLocal, character, Local do Produto
	@param oObj, object, objeto da regua
	@param aFiltabs, array, Array de filiais
	@param cFirst, character, Primeira filial
/*/
Static Function procProd(cProd,cLocal,oObj,aFiltabs,cFirst)
	//Reprocessamento dos acumulados
	lFilProd := .t.
	lFilArmz := .t.			
	cProduto := cProd
	cArmazem := cLocal
	
	if !empty(cCliente) .and. !empty(cLoja)
		a215AtuSA1(oObj,aFilTabs,cFirst)//Atualiza os dados acumulados do cliente do pedido de venda
	EndIf

	//(B2_SALPEDI,B2_SALDPED2,B2_SALPPRE)	
	a215AtuSC1(oObj,aFilTabs,cFirst)//Atualiza dados acumulados solicitação de compras 

	//(B2_SALPEDI,B2_SALDPED2,B2_SALPPRE)	
	a215AtuSC7(oObj,aFilTabs,cFirst)//Atualizado dados acumulados do pedido de compra
	
	//(B2_SALPEDI,B2_SALDPED2)
	A215AtuDHQ(oObj,cFirst)// Atualiza os dados acumulados de compras com entrega futura 
	
	//(B2_SALPEDI,B2_SALDPED2,B2_SALPPRE)
	a215AtuOP(oObj,aFilTabs,cFirst)//Atualiza os dados acumulados das Ordens de Producao
	
	//GravaEmp
	a215OPEmp(oObj,aFilTabs,cFirst)//Atualiza os dados acumulados dos empenhos da OP 
	
	//GravaEmp+(DD_SALDO,DD_QUANT,DD_QTSEGUM,DD_SALDO2)
	a215AtuSDD(oObj,aFilTabs,cFirst)//Varre o SDD e refaz os bloqueios existentes 

	//(B2_QEMPSA)
	a215AtuSCQ(oObj,aFilTabs,cFirst)//Analisa SCQ para atualizar o campo B2_QEMP em produtos SB2 
	
	//(B2_QACLASS,B8_QACLASS,B8_QACLAS2)
	a215AtuD0G(oObj,cFirst)//Analisa D0G para atualizar os campos B2_QACLASS e B8_QACLASS 

	//(B2_QACLASS,B8_QACLASS,B8_QACLAS2)
	a215AtuSDA(oObj,aFilTabs,cFirst)//Analisa SDA para atualizar os campos B2_QACLASS e B8_QACLASS 
	
	//(B2_NAOCLAS)
	a215AtuSD1(oObj,aFilTabs,cFirst)//Analisa SD1 para atualizar os campos Pre-nota de entrada 
	
	//(B2_QTER,B2_QNPT,B2_QTNP)		
	a215AtuSB6(oObj,aFilTabs,cFirst)//Analisa SB6 para atualizar os dados acumulados do PODER de 3 e EM 3 
	
	//(B2_QEMPPRE,B2_QEPRE2,B2_QEMPPRJ,B2_QEMPPR2)
	a215AtuAFJ(oObj,cFirst)//Analisa AFJ para atualizar os dados acumulados dos empenhos do SIGAPMS 
	
	//GravaEmp	//B2_RESERVA	
	a215AtuSC0(oObj,aFilTabs,cFirst)//Analisa SC0 para atualizar os dados acumulados das Reserva de Faturamento 
	
	//(B2_RESERVA,B2_RESERV2,B8_EMPENHO,B8_EMPENH2)
	a215AtuDH1(oObj,cFirst)//Analisa DH1 para Atualizar o campo B2_RESERV  em Produtos SB2. 
	
	//(B2_RESERVA)
	a215AtuSL2(oObj,cFirst)//Analisa SL2 para atualizar os dados acumulados das Reservas do SigaLoja  
	
	//GravaEmp
	M215NNS(oObj,cFirst)// atualiza os acumulados da transferencia de materiais

Return 

/*/{Protheus.doc} contaSB2
	Conta quantos registros tem a ser processado
	@type  Static Function
	@author Rodrigo Lombardi
	@since 26/12/2025
	@version v1.0	
	@return nRegs, numeric, quantidade de registros a serem processados
/*/
Static Function contaSB2()
local cQuery := '' as character
local nRegs := 0 as numeric
Local nBind := 1 as numeric
if oQCntSB2 == nil
	cQuery := " SELECT count(SB2.R_E_C_N_O_) TOTALREG " 
	cQuery += " FROM "+RetSqlName("SB2")+" SB2 "
	cQuery += " WHERE  "
	cQuery += " SB2.B2_FILIAL= ? AND "				
	if lFilProd //FILTRO DE PRODUTO
		cQuery += " SB2.B2_COD BETWEEN ? AND ? AND "				
	EndIf						
	if lFilArmz //FILTRO DE ARMAZEM
		cQuery += " SB2.B2_LOCAL BETWEEN ? AND ? AND "				
	EndIf
	cQuery += " SB2.D_E_L_E_T_= ? "
	cQuery := ChangeQuery(cQuery)		
	oQCntSB2 := FwExecStatement():New(cQuery)				
EndiF
oQCntSB2:setString(nBind++,FWxFilial( 'SB2' ))						
injectPerg(oQCntSB2,@nBind)//Produto
injectPerg(oQCntSB2,@nBind,.f.)//Armazem		
oQCntSB2:setString(nBind++,' ')

nRegs := oQCntSB2:ExecScalar("TOTALREG")

Return nRegs

