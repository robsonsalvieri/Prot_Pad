#include "msobject.ch"
#include "backoffice.sv.est.monthlyconsumption.ch"
#include "totvs.framework.treports.integratedprovider.th"

#DEFINE SX1GRUPO "MTR340"

namespace totvs.protheus.backoffice.est.monthlyconsumption.integratedprovider
using namespace totvs.protheus.backoffice.est.smartView.integratedProvider

@totvsFrameworkTReportsIntegratedProvider(active=.T.,team="SIGAEST",tables="SB3",customtables="SB1,SB3",name="Consumo Medio",country="ALL")

//-------------------------------------------------------------------
/*{Protheus.doc} MonthlyConsumptionTReportsBusinessObject
description
@author  author
@since   date
@version version
*/
//-------------------------------------------------------------------
class MonthlyConsumptionTReportsBusinessObject from totvs.protheus.backoffice.est.smartView.integratedProvider.EstIntegratedProvider
	public method new() as object
	public method getDescription() as character
	public method getData() as object

	Protected Method oNGetSchema()

	protected data aFieldsSB1 as array
	protected data aFieldsSB3 as array
	protected data aColImp as array
	protected data cAlias as character
	protected data cWhere as character
	protected data jItens as json
	Protected data lExistPergunte as logical

endclass

/*/{Protheus.doc} New
Metodo de instancia da classe.
@type  Metodo
@author Squad Entradas
@since  Maio 04,2023
/*/
method new() class MonthlyConsumptionTReportsBusinessObject
	_Super:new()

	//Define a Área
	self:appendArea(STR0001) // Estoque/Custos

	//Define o nome do Objeto de Negócio
	self:setDisplayName(STR0002) // Consumo mês a mês

	//Indica o pergunte que será utilizado no relatório
	self:lExistPergunte := self:SetPergunte(SX1GRUPO)
	If !self:lExistPergunte
		cMsgSX1 := OemToAnsi(I18N(STR0018,{SX1GRUPO})) //#Grupo de perguntas #1[SX1GRUPO]# nao encontrado. Verifique na tabela SX1, o grupo de perguntas informado
		self:setErrorStatus(400,STR0019,cMsgSX1)   	  //#Sem Pergunte
		FwLogMsg("WARN",, "SmartView ESTSV015",,,,cMsgSX1,,,)
	EndIf

	//Indica que o LookUp será do tipo padrão LookUp
	self:setIsLookUp(.T.)

	//Carrega os campos da SB3 que farão parte do ON
	self:aFieldsSB3 := FWSX3Util():GetAllFields("SB3",.F.)

return self

/*/{Protheus.doc} getDescription
Metodo que retorna a descrição do objeto de negócio.
@type  Metodo
@author Squad Entradas
@since  Maio 04,2023
/*/
method getDescription() as character class MonthlyConsumptionTReportsBusinessObject
return (STR0003) // Apresenta o consumo dos últimos 12 meses de cada material ou produto acabado.

/*/{Protheus.doc} getData
Metodo que retorna o Objeto de dados.
@type  Metodo
@author Squad Entradas
@since  Maio 04,2023
/*/
method getData(nPage as numeric, oFilter as object) as object class MonthlyConsumptionTReportsBusinessObject
	local oQuery as object
	local cQuery as character
	local cFields as character
	local cCurFil as character
	local cEmpExec as character
	local cFilExec as character
	local aMeses  := ARRAY(12) as array
	local nX as numeric
	local nFil	as numeric
	local jParams as json
	local cCustom	as Character
	local aCustom	as Array
    local cFiltro as character
    local cFilterParam as character

	If !self:lExistPergunte
		Return self:oData
	EndIf

	//Variáveis com o nome da Filial e Grupo de Empresa
	cEmpExec := AllTrim(FWEmpName(cEmpAnt))
	cFilExec := AllTrim(FWFilialName())

	//Cria um alias disponível para utilização
	self:cAlias := GetNextAlias()

	//Atualiza o array aMeses com o nome das colunas
	aMeses := {"MES01","MES02","MES03","MES04","MES05","MES06","MES07","MES08","MES09","MES10","MES11","MES12"}

	//Metodo para retorno do json dos parâmetros
	jParams := oFilter:getParameters()

    //Metodo para retorno do filtro em expressão SQL
    cFilterParam	:= oFilter:getSQLExpression()
	cFiltro			:= " AND "

    //Retorno da tela de multi filiais com as filiais selecionadas ou somente a filial corrente
    self:aFils := self:retFils(jParams['SV_MULTBRANCH'])

	//Se tiver custom
	cCustom := self:getSQLFields(.f.,nil,.t.)
	if !empty(cCustom)
		aCustom := StrTokArr(cCustom,",")
		For nX := 1 to len(aCustom)
			aadd(self:aFieldsSB1,aCustom[nX])
		Next
	EndIf

	//Campos que farão parte do select da query
	cFields := ArrTokStr(self:aFieldsSB1,",") + ","
	cFields += ArrTokStr(self:aFieldsSB3,",")

	//Retorna o tipo do campos da SB9 convertidos para o Smart View
	self:aFieldsSB3 := estGetCpo(self:aFieldsSB3)

	//Montagem do Select da Query
	cQuery := "SELECT ? "
	cQuery += "FROM " + RetSqlName("SB1") + " SB1 "
	cQuery += "INNER JOIN " + RetSqlName("SB3") + " SB3 ON "
	cQuery += "SB3.B3_FILIAL = ? AND "
	cQuery += "SB3.B3_COD = SB1.B1_COD AND "
	cQuery += "SB3.D_E_L_E_T_ = ? "
	cQuery += "WHERE SB1.B1_FILIAL = ? AND "
	cQuery += "SB1.B1_TIPO >= ? AND "
	cQuery += "SB1.B1_TIPO <= ? AND "
	cQuery += "SB1.B1_COD >= ? AND "
	cQuery += "SB1.B1_COD <= ? AND "
	cQuery += "SB1.B1_GRUPO >= ? AND "
	cQuery += "SB1.B1_GRUPO <= ? AND "
	cQuery += "SB1.B1_DESC >= ? AND "
	cQuery += "SB1.B1_DESC <= ? "

	cQuery += self:cWhere

	//Os filtros serão setados na interface do novo TReports
	cQuery += "?"

	cQuery += " AND SB1.D_E_L_E_T_ = ? "

    //Os filtros serão setados na interface do novo SmartView
	If !(oFilter:hasFilter())
		cFiltro := ""  
	Endif 

	cQuery := ChangeQuery(cQuery)

	oQuery := FwExecStatement():New(cQuery)

	//Colocar while ou for de filiais aqui
	For nFil :=1 to len(self:aFils)
		cCurFil := self:aFils[nFil]

		cFilExec := AllTrim(FwFilialName(cEmpAnt,cCurFil))

		oQuery:SetUnsafe(1, cFields)
		oQuery:SetString(2, FWxFilial('SB3', cCurFil))
		oQuery:SetString(3, " ")
		oQuery:SetString(4, FWxFilial('SB1', cCurFil))
		oQuery:SetString(5, jParams['MV_PAR03'][1])
		oQuery:SetString(6, jParams['MV_PAR04'][1])
		oQuery:SetString(7, jParams['MV_PAR01'][1])
		oQuery:SetString(8, jParams['MV_PAR02'][1])
		oQuery:SetString(9, jParams['MV_PAR05'][1])
		oQuery:SetString(10, jParams['MV_PAR06'][1])
		oQuery:SetString(11, jParams['MV_PAR07'][1])
		oQuery:SetString(12, jParams['MV_PAR08'][1])
		oQuery:SetUnsafe(13, cFiltro + cFilterParam)
		oQuery:SetString(14, " ")

		oQuery:OpenAlias(self:cAlias)

		(self:cAlias)->( DBGoTop() )
		Do While !(self:cAlias)->(Eof())

			self:jItens := JsonObject():New()

			For nX := 1 To Len(aMeses)
				self:jItens["MES" + StrZero(nX,2)] := self:aColImp[1][nX]
				self:jItens["B3_Q" + StrZero(nX,2)] := (self:cAlias)->&(self:aColImp[2][nX])
			Next nX

			For nX := 1 To Len(self:aFieldsSB1)
				self:jItens[self:aFieldsSB1[nX]] := (self:cAlias)->&(self:aFieldsSB1[nX])
			Next nX

			For nX := 1 To Len(self:aFieldsSB3)
				If self:aFieldsSB3[nX][2] == "date"
					If !Empty((self:cAlias)->&(self:aFieldsSB3[nX][1]))
						self:jItens[self:aFieldsSB3[nX][1]] := totvs.framework.treports.date.dateToTimeStamp(StoD((self:cAlias)->&(self:aFieldsSB3[nX][1])))	
					EndIf
				Else
					If !("B3_Q" $ self:aFieldsSB3[nX][1])
						self:jItens[self:aFieldsSB3[nX][1]] := (self:cAlias)->&(self:aFieldsSB3[nX][1])
					EndIf
				EndIf
			Next nX

			self:jItens["CODEMP"]  := cEmpAnt
			self:jItens["EMPNOME"] := cEmpExec
			self:jItens["FILNOME"] := cFilExec

			self:processData()
			self:oData:appendData(self:jItens)

			(self:cAlias)->( dbSkip() )
		EndDo
	Next

	(self:cAlias)->( DBCloseArea() )

	oQuery:Destroy()

return self:oData

/*/{Protheus.doc} getSchema
Metodo que retorna a Estrutura de dados.
@type  Metodo
@author Squad Entradas
@since  Maio 04,2023
/*/
method oNGetSchema() class MonthlyConsumptionTReportsBusinessObject

	self:aFieldsSB1 := {"B1_COD", "B1_DESC", "B1_TIPO", "B1_GRUPO", "B1_UM"}

	self:aliasToSchema("SB1",self:aFieldsSB1)
	self:aliasToSchema("SB3",self:aFieldsSB3)

	self:aColImp := impCabec()

	self:addProperty("CODEMP", STR0020, "string", STR0020, "CODEMP")
	self:addProperty("EMPNOME", STR0016, "string", STR0016, "EMPNOME")
	self:addProperty("FILNOME", STR0017, "string", STR0017, "FILNOME")
	self:addProperty("MES01", self:aColImp[1][1], "string", self:aColImp[1][1], "MES01")
	self:addProperty("MES02", self:aColImp[1][2], "string", self:aColImp[1][2], "MES02")
	self:addProperty("MES03", self:aColImp[1][3], "string", self:aColImp[1][3], "MES03")
	self:addProperty("MES04", self:aColImp[1][4], "string", self:aColImp[1][4], "MES04")
	self:addProperty("MES05", self:aColImp[1][5], "string", self:aColImp[1][5], "MES05")
	self:addProperty("MES06", self:aColImp[1][6], "string", self:aColImp[1][6], "MES06")
	self:addProperty("MES07", self:aColImp[1][7], "string", self:aColImp[1][7], "MES07")
	self:addProperty("MES08", self:aColImp[1][8], "string", self:aColImp[1][8], "MES08")
	self:addProperty("MES09", self:aColImp[1][9], "string", self:aColImp[1][9], "MES09")
	self:addProperty("MES10", self:aColImp[1][10], "string", self:aColImp[1][10], "MES10")
	self:addProperty("MES11", self:aColImp[1][11], "string", self:aColImp[1][11], "MES11")
	self:addProperty("MES12", self:aColImp[1][12], "string", self:aColImp[1][12], "MES12")

return

/*/{Protheus.doc} impCabec
Função responsável pela montagem do array com o nome e posicionamento das colunas
@type  Função
@author Squad Entradas
@since  Maio 04,2023
/*/
Static Function impCabec()
	local aRet := {ARRAY(12),ARRAY(12)} as array
	local aMeses as array
	local nAno as numeric
	local nMes as numeric
	local nX as numeric

	aMeses := {STR0004,STR0005,STR0006,STR0007,STR0008,STR0009,STR0010,STR0011,STR0012,STR0013,STR0014,STR0015}

	nAno := Year(Date())
	If month(Date()) < 12
		nAno--
	EndIf

	nMes := Month(Date())+1
	If nMes == 13
		nMes := 1
	EndIf

	For nX := 1 To 12
		If aMeses[nMes] == "JAN" .And. nX != 1	//"JAN"
			nAno++
		EndIf
		aRet[1][nX] := aMeses[nMes]+"/"+SubStr(cValToChar(nAno),3,4)
		aRet[2][nX] := "B3_Q" + StrZero(nMes,2)
		nMes++
		If nMes > 12
			nMes := 1
		EndIf
	Next nX
Return aRet

/*/{Protheus.doc} estGetStruct
Prepara a estrutura dos campos
@type  Função
@author Squad Entradas
@since  Maio 16,2023
/*/
Static Function estGetCpo(aFields as array)
	local aDeParaCpo as array
	local aCpoTmp := {} as array
	local cTipR as character
	local cTipo as character
	local nPos as numeric
	local nX as numeric

	aDeParaCpo := {{"C", "string"}, {"D", "date"}, {"N", "number"}, {"L", "boolean"}}

	For nX := 1 To Len(aFields)
		cTipo := FWSX3Util():GetFieldType( aFields[nX] )

		If (nPos := aScan( aDeParaCpo, {|c| c[01] = cTipo } ) ) > 0
			cTipR := aDeParaCpo[nPos, 02]
		Else
			cTipR := "string"
		EndIf

		AAdd( aCpoTmp,;
			{aFields[nX],;
			cTipR})
	Next nX

Return (aCpoTmp)
