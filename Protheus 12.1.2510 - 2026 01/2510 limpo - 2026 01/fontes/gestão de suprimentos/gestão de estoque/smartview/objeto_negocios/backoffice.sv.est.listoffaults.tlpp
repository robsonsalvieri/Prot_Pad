#include "msobject.ch"
#include "protheus.ch"
#include "backoffice.sv.est.listoffaults.ch"
#include "totvs.framework.treports.integratedprovider.th"

#DEFINE SX1GRUPO "ESTT035"

namespace totvs.protheus.backoffice.est.listoffaults.integratedprovider
using namespace totvs.protheus.backoffice.est.smartView.integratedProvider

@TotvsFrameworkTReportsIntegratedProvider(active=.T., team="SIGAEST", tables="SB1",name="Lista de Faltas", country="ALL")

//-------------------------------------------------------------------
/*{Protheus.doc} ListOfFaultsSmartViewBusinessObject
Classe para criação do Objeto de Negócio Lista de Faltas

@author Squad Entradas
@since 12/2023
@Review Breno Nogueira
@version 1.0
*/
//-------------------------------------------------------------------  
Class ListOfFaultsSmartViewBusinessObject From totvs.protheus.backoffice.est.smartView.integratedProvider.EstIntegratedProvider

	Public Method new() as object
	Public Method getData() as object

	Protected Method oNGetSchema()
	Protected Method atuVarPriv()
	Protected Method t350PROC()
	Protected Method r350Empenh()

	Protected data jItems as Json
	Protected data cWhere as Character
	Protected data cSubsDB as character
	Protected data cNumOP as character
	Protected data lExistPergunte as Logical
	Protected data aFields	as array
	Protected data aItemOP	as array
	Protected data aSeqOP	as array
	Protected data aItGrdOP as array

EndClass

//-------------------------------------------------------------------
 /*{Protheus.doc} new
Método de instância da classe

@return object: self
 
@author Squad Entradas
@since 12/2023
@version 1.0
*/
//-------------------------------------------------------------------   
Method new() Class ListOfFaultsSmartViewBusinessObject

	local cMsgSX1 as character

	_Super:new()

	//Define a Área
	self:appendArea( STR0001 ) //"Estoque/Custos"

	//Define o nome do Objeto de Negócio
	self:setDisplayName( STR0002 ) //"Lista de Faltas"

	//Define a descrição do Objeto de Negócio
	self:setDescription( STR0003 ) //"Exibe um resumo por produto ou OP de faltas no período."

	//Grupo de Perguntas
	self:lExistPergunte := self:SetPergunte(SX1GRUPO)
	If !self:lExistPergunte
   	cMsgSX1 := OemToAnsi(I18N(STR0012,{SX1GRUPO})) //#Grupo de perguntas #1[SX1GRUPO]# nao encontrado. Verifique na tabela SX1, o grupo de perguntas informado
	   self:setErrorStatus(400,STR0013,cMsgSX1)		//#Sem Pergunte
	   FwLogMsg("WARN",, "SmartView ESTSV042",,,,cMsgSX1,,,)
	EndIf 

	//Indica que o LookUp será do tipo padrão LookUp
    self:setIsLookUp(.T.)

Return self

//-------------------------------------------------------------------
/*{Protheus.doc} getData
Retorna os dados do objeto de negócio
 
@param nPage, numérico, indica a página atual do relatório
@param oFilter, objeto, contém o filtro do TReports
@return object: self:oData
 
@author Squad Entradas
@since 12/2023
@version 1.0

*/
//-------------------------------------------------------------------   
Method getData( nPage as Numeric, oFilter as object) as object Class ListOfFaultsSmartViewBusinessObject

	local nX         	as numeric
	local nFil			as numeric
	local cAliasTRB     := GetNextAlias()
	local cQuery        as character
	local cPrdAlias     as character
	local cFiltro       as character
	local cFilExec		as character
	local cEmpExec		as character
	local cBkpFil		as character
	local oTempTable	as Object
	local oQuery		as Object
	
	private  jParams	as json
	private xWhereTpOP  := Nil
	private oQueryProc	as Object
	private oQrySalAbe	as Object
	private oQrySC2Abe	as Object
	private oQrySD4		as Object

	If !self:lExistPergunte
	   Return Self:oData 
	EndIf

	//Verificação do banco de dados em execução para utilização da função SUBSTR
	self:cSubsDB := "SUBSTR"
    If Upper(TCGetDB()) $ "MSSQL"
        self:cSubsDB := "SUBSTRING"
    EndIf

	//Atualiza as variáveis private
	self:atuVarPriv()

	//Variável com o nome do Grupo de Empresa
	cEmpExec := AllTrim(FWEmpName(cEmpAnt))

	// Verifica as perguntas selecionadas                           
	// mv_par01     // Produto inicial                               
	// mv_par02     // Produto final                                 
	// mv_par03     // Considera saldo entradas em aberto            
	// mv_par04     // Lista somente registros com saldo neg         
	// mv_par05     // Almoxarifado de (para formacao do saldo Ini)  
	// mv_par06     // Almoxarifado Ate(para formacao do saldo Ini)  
	// mv_par07     // Considera OPs 1- Firmes 2- Previstas 3- Ambas 
	// mv_par08     // Apenas SCs com data limite de compra em atraso
	// mv_par09     // Da Ordem de Producao                          
	// mv_par10     // Ate a Ordem de Producao                       
	// mv_par11     // Listar as OPs 1.Atendidas/N Atendidas/Ambas   
	// mv_par12     // Qtd. Nossa Poder 3o.  1-Ignora / 2-Soma       
	// mv_par13     // Qtd. 3o. Nosso Poder  1-Ignora / 2-Subtrai    
	// mv_par14     // Utiliza Data                                  
	// mv_par15     // Data de referencia     

	jParams := oFilter:getParameters() //metodo para retorno do json dos parâmetros

    //Retorno da tela de multi filiais com as filiais selecionadas ou somente a filial corrente
    self:aFils := self:retFils(jParams['SV_MULTBRANCH'], oFilter)

	xWhereTpOP	:= qryAvalOP((jParams[ "MV_PAR07" ][1]), "SC2")
	cPrdAlias	:= "LSOFPROD"
	cFIltro		:= " AND "
	oTempTable	:= CreateTMP(cAliasTRB)
	dbSelectArea("SD4")

	cBkpFil := cFilAnt

	For nFil :=1 to len(self:aFils)
		cFilAnt := self:aFils[nFil]

		//Variável com o nome da Filial
		cFilExec := AllTrim(FWFilialName())

		self:t350PROC(cAliasTRB)
		
		dbSelectArea(cAliasTRB)
		dbSetOrder(1)
		dbGoTop()

		(cAliasTRB)->(dbGoTop())

		While (cAliasTRB)->(!Eof())
		
			cCodAnt := (cAliasTRB)->PRODUTO
			
			dbSelectArea("SB2")
			dbSetOrder(1)
			MsSeek(xFilial("SB2")+cCodAnt)
			nSaldo := 0
			nQemp  := 0
		
			While !Eof() .And. B2_FILIAL+B2_COD == xFilial("SB2")+cCodAnt
				If SB2->B2_LOCAL >= jParams[ "MV_PAR05" ][1] .And. SB2->B2_LOCAL <= jParams[ "MV_PAR06" ][1]
					nSaldo += SaldoSB2(.F.,.F.,dDataBase,(jParams[ "MV_PAR13" ][1])==2,(jParams[ "MV_PAR12" ][1])==1)
					nQemp  += If((jParams[ "MV_PAR07" ][1])==1,B2_QEMP,If((jParams[ "MV_PAR07" ][1])==2,B2_QEMPPRE,B2_QEMP+B2_QEMPPRE))
				EndIf
				dbSkip()
			EndDo

			nSaldoIni := nSaldo

			dbSelectArea(cAliasTRB)
			
			While !Eof() .And. PRODUTO == cCodAnt

				If (jParams[ "MV_PAR11" ][1]) == 2 .And. QUANTIDADE == 0
					dbSkip()
					Loop
				ElseIf (jParams[ "MV_PAR11" ][1]) == 1 .And. QUANTIDADE > 0
					dbSkip()
					Loop
				EndIf

				If TIPO == "E"
					nSaldo += QUANTIDADE
				Else
					nSaldo -= QUANTIDADE
				EndIf
			
				If ((jParams[ "MV_PAR04" ][1]) == 1 .And. nSaldoIni < nQemp) .Or. (((jParams[ "MV_PAR04" ][1]) == 1 .And. nSaldo < 0) .Or. (jParams[ "MV_PAR04" ][1]) == 2)

					If !Empty(SubStr(DOCUMENTO,7,5)) .And. TIPODOC != "OP"
						self:jItems := JsonObject():New()
						
						//Traz os dados do produto
						If oQuery == NIL
							cQuery := " SELECT B1_COD,B1_DESC,B1_TIPO,B1_GRUPO,B1_UM "
							cQuery += " FROM  "+RetSqlName("SB1")+" SB1 "
							cQuery += " WHERE SB1.B1_FILIAL = ? "
							cQuery += " AND SB1.B1_COD = ? "
							//Os filtros serão setados na interface do novo TReports
							cQuery += self:cWhereFiltroSV
							cQuery += self:cWhere
							cQuery += " AND SB1.D_E_L_E_T_ = ? "

							cQuery := changeQuery(cQuery)
							oQuery := FwExecStatement():New(cQuery)
						EndIf

						//Binding
						oQuery:setString(1,FWxFilial("SB1"))
						oQuery:setString(2,(cAliasTRB)->PRODUTO)
						oQuery:setString(3,' ')

						cPrdAlias := oQuery:OpenAlias()

						self:jItems["EMPNOME"] := cEmpExec
						self:jItems["FILIAL"] := cFilAnt
						self:jItems["FILNOME"] := cFilExec

						For nX := 1 To Len(self:aFields)
							self:jItems[self:aFields[nX]] := (cPrdAlias)->&(self:aFields[nX])
						Next nX

						self:jItems["TIPO"] := TIPO
						self:jItems["TIPODOC"] := TIPODOC
						self:jItems["DOCUMENTO"]  := DOCUMENTO
						self:jItems["EMISSAO"]  := totvs.framework.treports.date.dateToTimeStamp(EMISSAO)	
						self:jItems["DTEVENTO"]  := totvs.framework.treports.date.dateToTimeStamp(DTEVENTO)	
						self:jItems["QUANTIDADE"]  := QUANTIDADE
						self:jItems["SALDO"]  := nSaldo
						self:jItems["DTCOMPRA"]  := totvs.framework.treports.date.dateToTimeStamp(SomaPrazo(DTEVENTO, - CalcPrazo(PRODUTO, nSaldo)))
					
						self:processData()
						self:oData:appendData( self:jItems )

						(cPrdAlias)->( DBCloseArea() )
					EndIf
				EndIf
				dbSelectArea(cAliasTRB)
				dbSkip()
			EndDo
		EndDo

		//Limpa tabela temporaria
		oTempTable:Zap()
	Next

	(cAliasTRB)->( DBCloseArea() )

	cFilAnt := cBkpFil

	If oQuery <> Nil
		oQuery:Destroy()
	EndIf
	If oQueryProc <> Nil
		oQueryProc:Destroy()
	EndIf
	If oQrySalAbe <> Nil
		oQrySalAbe:Destroy()
	EndIf
	If oQrySC2Abe <> Nil
		oQrySC2Abe:Destroy()
	EndIf
	If oQrySD4 <> Nil
		oQrySD4:Destroy()
	EndIf
	oTempTable:Delete()

Return self:oData

//-------------------------------------------------------------------
/*{Protheus.doc} oNGetSchema
Retorna a estrutura dos campos
 
@return object: self:oSchema
@author Squad Entradas
@since 12/2023
@version 1.0
*/
//-------------------------------------------------------------------   
Method oNGetSchema() Class ListOfFaultsSmartViewBusinessObject

	self:addProperty( "EMPNOME"	, STR0014 , "string", STR0014 , "EMPNOME" ) //"Nome Empresa"
	self:addProperty( "FILIAL"  , STR0015 , "string", STR0015 , "FILIAL"  ) //"Filial"
	self:addProperty( "FILNOME"	, STR0016 , "string", STR0016 , "FILNOME" ) //"Nome Filial"

	self:aFields := {}
	aadd(self:aFields, 'B1_COD')
	aadd(self:aFields, 'B1_DESC')
	aadd(self:aFields, 'B1_TIPO')
	aadd(self:aFields, 'B1_GRUPO')
	aadd(self:aFields, "B1_UM")

	self:AliasToSchema("SB1", self:aFields)

	self:addProperty( 'TIPO'	   , STR0004 , "string", STR0004 , "TIPO"      ) //"TIPO"
	self:addProperty( 'TIPODOC'	   , STR0005 , "string", STR0005 , "TIPODOC"   ) //"TIPO DOCUMENTO"
	self:addProperty( 'DOCUMENTO'  , STR0006 , "string", STR0006 , "DOCUMENTO" ) //"DOCUMENTO"
	self:addProperty( 'EMISSAO'	   , STR0007 , "date"  , STR0007 , "EMISSAO"   ) //"EMISSAO"
	self:addProperty( 'DTEVENTO'   , STR0008 , "date"  , STR0008 , "DTEVENTO"  ) //"DATA EVENTO"
	self:addProperty( 'QUANTIDADE' , STR0009 , "number", STR0009 , "QUANTIDADE") //"QUANTIDADE"
	self:addProperty( 'SALDO'	   , STR0010 , "number", STR0010 , "SALDO"     ) //"SALDO DISPONÍVEL"
	self:addProperty( 'DTCOMPRA'   , STR0011 , "date"  , STR0011 , "DTCOMPRA"  ) //"DTCOMPRA"

Return

/*/{Protheus.doc} atuVarPriv
Função responsável por inicializar as variáveis private
@author Squad Entradas
@since 24/03/2022
/*/
Method atuVarPriv() Class ListOfFaultsSmartViewBusinessObject

	local nNumOP   := TamSX3("C2_NUM")[1]		as numeric
	local nItemOP  := TamSX3("C2_ITEM")[1]		as numeric
	local nSeqOP   := TamSX3("C2_SEQUEN")[1]	as numeric
	local nItGrdOP := TamSX3("C2_ITEMGRD")[1]	as numeric

	self:cNumOP   := cValToChar(nNumOP)
	self:aItemOP  := {cValToChar(nNumOP + 1), cValToChar(nItemOP)}
	self:aSeqOP   := {cValToChar(nNumOP + nItemOP + 1), cValToChar(nSeqOP)}
	self:aItGrdOP := {cValToChar(nNumOP + nItemOP + nSeqOP + 1), cValToChar(nItGrdOP)}

Return

/*/{Protheus.doc} CreateTMP
//TODO Cria a tabela temporaria para o processamento do relatorio, a qual sera lida para impressão
@author reynaldo
@since 21/12/2017
@version 1.0
@return objeto, Retorna o objeto criado pela FWTemporaryTable
@param cAliasTMP, characters, Alias da tabela do relatorio
@type function
/*/
Static Function CreateTMP(cAliasTMP)
	local aTrab
	local aKey
	local oTempTable

	//Define estrutura e gera o arquivo de trabalho
	aTrab := {	{"TIPO"      ,"C",01,0},;
				{"DOCUMENTO" ,"C",TamSX3("D3_OP")[1],0},;
				{"DTEVENTO"  ,"D",08,0},;
				{"PRODUTO"   ,"C",TamSX3("B1_COD")[1],0},;
				{"QUANTIDADE","N",TamSX3('B2_QATU')[1],TamSX3('B2_QATU')[2]},;
				{"EMISSAO"   ,"D",08,0},;
				{"OP"        ,"C",TamSX3("D3_OP")[1],0},;
				{"TIPODOC"   ,"C",02,0},;
				{"CHAVEIDX"     ,"C",TamSX3("D3_OP")[1],0} ; 
			}

	aKey := {"PRODUTO","DTEVENTO","TIPO"}

	oTempTable := FWTemporaryTable():New( cAliasTMP )
	oTempTable:SetFields( aTrab )
	oTempTable:AddIndex("01", aKey )
	oTempTable:AddIndex("02", {"TIPODOC","CHAVEIDX"} )
	oTempTable:Create()

Return oTempTable

/*/{Protheus.doc} t350PROC
//TODO Processa as informações para o relatorio.
@author reynaldo
@since 07/12/2017
@version 1.0
@return ${return}, ${return_description}
@param cAliasTRB, characters, descricao
@type function
/*/
Method t350PROC(cAliasTRB,lEnd) Class ListOfFaultsSmartViewBusinessObject
	local cQuery		as character
	local nBarra		as numeric
	local cAliasSel := GetNextAlias() as character
	
	default lEnd 	:= .F.

	// Verifica se deve considerar saldos em aberto das entradas    
	If jParams[ "MV_PAR03" ][1] == 1
		// Posiciona nos indices dos arquivos a serem pesquisados       
		dbSelectArea("SC1")
		dbSetOrder(2)
		dbSelectArea("SC2")
		dbSetOrder(2)
		dbSelectArea("SC7")
		dbSetOrder(1)
		dbSelectArea("SC8")
		dbSetOrder(3)
	EndIf
	
	If oQueryProc == NIL
		cQuery := " SELECT SD4.D4_COD, MIN(SD4.D4_DATA) DATAMIN, MAX(SD4.D4_DATA) DATAMAX "
		cQuery += " FROM " +retsqlname("SD4")+ " SD4 "
		cQuery += " INNER JOIN	" +retsqlname("SC2")+ " SC2 "
		cQuery += "	ON SC2.C2_FILIAL = ? "
		cQuery += "	AND SC2.C2_NUM = " + self:cSubsDB + "(D4_OP,1," + self:cNumOP + ") "
		cQuery += "	AND SC2.C2_ITEM = " + self:cSubsDB + "(D4_OP," + self:aItemOP[1] + "," + self:aItemOP[2] + ") "
		cQuery += "	AND SC2.C2_SEQUEN = " + self:cSubsDB + "(D4_OP,"+ self:aSeqOP[1] + "," + self:aSeqOP[2] + ") "
		cQuery += "	AND SC2.C2_ITEMGRD = " + self:cSubsDB + "(D4_OP," + self:aItGrdOP[1] + "," + self:aItGrdOP[2] + ") "
		If jParams['MV_PAR07'][1] == 2
			cQuery += "	AND SC2.C2_TPOP = ? "
		Else
			cQuery += "	AND SC2.C2_TPOP IN ( ? ) "
		EndIf
		cQuery += "	AND SC2.D_E_L_E_T_ = ? "
		cQuery += " WHERE  "
		cQuery += "	SD4.D4_FILIAL = ? "
		cQuery += "	AND SD4.D4_COD >= ?  "
		cQuery += " AND SD4.D4_COD <= ? "
		cQuery += "	AND SD4.D4_OP >= ?  "
		cQuery += " AND SD4.D4_OP <= ?  "
		cQuery += "	AND SD4.D4_QUANT > ? "
		cQuery += "	AND SD4.D_E_L_E_T_ = ? "
		cQuery += "	GROUP BY SD4.D4_COD "
		cQuery += "	ORDER BY SD4.D4_COD "

		cQuery 	   := changeQuery(cQuery)
		oQueryProc := FwExecStatement():New(cQuery)
	EndIf
	
	//Binding
	oQueryProc:setString(1,FWxFilial("SC2"))
	If jParams['MV_PAR07'][1] == 2
		oQueryProc:setString(2,xWhereTpOP)
	Else
		oQueryProc:SetIn(2,xWhereTpOP)
	EndIf
	oQueryProc:setString(3,' ')
	oQueryProc:setString(4,FWxFilial("SD4"))
	oQueryProc:setString(5,jParams[ "MV_PAR01" ][1])
	oQueryProc:setString(6,jParams[ "MV_PAR02" ][1])
	oQueryProc:setString(7,jParams[ "MV_PAR09" ][1])
	oQueryProc:setString(8,jParams[ "MV_PAR10" ][1])
	oQueryProc:setNumeric(9,0)
	oQueryProc:setString(10,' ')

	cAliasSel := oQueryProc:OpenAlias()
	nBarra := 0
	(cAliasSel)->(dbEval({|| nBarra++}))
	(cAliasSel)->(dbGoTop())

	While (cAliasSel)->(!Eof())
		If (jParams[ "MV_PAR14" ][1]) == 1 .Or. Empty(jParams[ "MV_PAR15" ][1])
			dData :=  stod((cAliasSel)->DATAMAX)
		Else
			dData := FwDateTimeToLocal(jParams["MV_PAR15"][1])[1]
		EndIF
		
		// Verifica se deve considerar saldos em aberto das entradas    
		If (jParams[ "MV_PAR03" ][1]) == 1
			r350SalAbe(cAliasTRB, (cAliasSel)->D4_COD, dData, (cAliasSel)->DATAMIN, (cAliasSel)->DATAMAX)
		EndIf

		// Seleciona os empenhos, como executa somente 1x por codigo e a query esta na ordem 
		// de produto e data decrescente. Assumo a data calculada
		self:r350Empenh(cAliasTRB, (cAliasSel)->D4_COD)

		dbSelectArea(cAliasSel)
		dbSkip()
	EndDo
	(cAliasSel)->(dbCloseArea())

	//Devolve as ordens principais dos arquivos
	dbSelectArea("SC1")
	dbSetOrder(1)

	dbSelectArea("SC2")
	dbSetOrder(1)

	dbSelectArea("SC7")
	dbSetOrder(1)

	dbSelectArea("SC8")
	dbSetOrder(1)

Return

//------------------
//qryAvalOP
//------------------
Static Function qryAvalOP(nSelecao,cAlias)

	Local xRet := Nil

	Default cAlias    := "SC2"

	If nSelecao == 1
		xRet := {' ','F'}
	ElseIf nSelecao == 3
		xRet := {'F','P',' '}
	Else
		xRet := 'P'
	EndIf

Return xRet

//------------------
//r350SalAbe
//------------------
Static Function r350SalAbe(cAliasTRB, cCodAnt, dData ,cDataMin, cDataMax)

	local aArea := GetArea() as array
	local aCampos			 as array
	local cFilialSC1		 as character
	local cAliasTMP := GetNextAlias() as character
	local cQuery 			 as character
	
	// Carrega array com Solicitacoes de Compra ou Cotacoes em aberto
	dbSelectArea("SC1")
	cFilialSC1 := xFilial("SC1") 
	MsSeek(cFilialSC1+cCodAnt)
	While !Eof() .And. C1_FILIAL+C1_PRODUTO == cFilialSC1+cCodAnt

		If C1_DATPRF <= dData .And. MtrAvalOP((jParams[ "MV_PAR07" ][1]),"SC1")
			If (jParams[ "MV_PAR08" ][1]) == 1 .And. (SomaPrazo(C1_DATPRF, - CalcPrazo(C1_PRODUTO, C1_QUANT)) >= dDataBase)
				dbSkip()
				Loop
			EndIf
			(cAliasTRB)->(dbSetOrder(2))
			If !(cAliasTRB)->(dbSeek("SC"+SC1->(C1_NUM+"/"+C1_ITEM))) 
				If C1_QUJE < C1_QUANT .And. Empty(C1_RESIDUO)
					If !Empty(C1_COTACAO)
						dbSelectArea("SC8")
						MsSeek(xFilial("SC8")+SC1->C1_COTACAO+SC1->C1_PRODUTO)
						If Found() .And. Empty(C8_NUMPED)
							(cAliasTRB)->(dbSetOrder(2))
							If !(cAliasTRB)->(dbSeek("CT"+sc8->(C8_NUM+"/"+C8_ITEM)))
								aCampos := { "E",C8_NUM,SC1->C1_DATPRF,C8_PRODUTO,C8_QUANT,C8_EMISSAO,"CT",SC1->C1_OP,C8_NUM+"/"+C8_ITEM}
								grvTmp(cAliasTRB, aCampos)
							EndIf
						Else
							dbSelectArea("SC1")
							aCampos := { "E",C1_NUM,C1_DATPRF,C1_PRODUTO,C1_QUANT-C1_QUJE,C1_EMISSAO,"SC",SC1->C1_OP,C1_NUM+"/"+C1_ITEM}
							grvTmp(cAliasTRB, aCampos)
						EndIf
					Else
						dbSelectArea("SC1")
						aCampos := { "E",C1_NUM,C1_DATPRF,C1_PRODUTO,C1_QUANT-C1_QUJE,C1_EMISSAO,"SC",SC1->C1_OP,C1_NUM+"/"+C1_ITEM}
						grvTmp(cAliasTRB, aCampos)
					EndIf
				EndIf
			EndIf
		EndIf
		dbSelectArea("SC1")
		dbSkip()
	EndDo

	// Carrega array com os Pedidos de Compas em aberto estando vinculado ou não a uma solicação de compra                   
	dbSelectArea("SC7")

	If oQrySalAbe == NIL
		cQuery := " SELECT C7_PRODUTO, C7_NUM, C7_DATPRF, C7_QUANT, C7_QUJE, C7_EMISSAO, C7_OP, C7_ITEM "
		cQuery += " FROM "+RetSqlName("SC7")+" SC7 "
		cQuery += " WHERE " 
		cQuery += " SC7.C7_FILIAL = ? "
		cQuery += " AND SC7.C7_PRODUTO = ? "
		cQuery += " AND SC7.C7_DATPRF <= ? "
		cQuery += " AND SC7.C7_QUJE < SC7.C7_QUANT " 
		cQuery += " AND C7_RESIDUO = ? "
		cQuery += " AND SC7.D_E_L_E_T_ = ? "

		cQuery		:= changeQuery(cQuery)
		oQrySalAbe	:= FwExecStatement():New(cQuery)
	EndIf
	
	//Binding
	oQrySalAbe:setString(1,FWxFilial("SC7"))
	oQrySalAbe:setString(2,cCodAnt)	
	oQrySalAbe:setString(3,dtos(dData))	
	oQrySalAbe:setString(4,CriaVar("C7_RESIDUO"))	
	oQrySalAbe:setString(5,' ')	

	cAliasTMP := oQrySalAbe:OpenAlias()	

	(cAliasTRB)->(dbSetOrder(2))
	dbSelectArea(cAliasTMP)
	While (cAliasTMP)->(!Eof())
		//Verifica se o usuario cancelou o processamento
		If !((jParams[ "MV_PAR08" ][1]) == 1 .And. (SomaPrazo(sToD(C7_DATPRF), - CalcPrazo(C7_PRODUTO, C7_QUANT)) >= dDataBase))
			If !(cAliasTRB)->(dbSeek("PC"+(cAliasTMP)->(C7_NUM+"/"+C7_ITEM)))
				aCampos := { "E",C7_NUM,C7_DATPRF,C7_PRODUTO,C7_QUANT-C7_QUJE,C7_EMISSAO,"PC",C7_OP+"/"+C7_ITEM,C7_NUM+"/"+C7_ITEM}
				grvTmp(cAliasTRB, aCampos)
			EndIf
		EndIf
		(cAliasTMP)->(dbSkip())
	EndDo
	(cAliasTMP)->(dbCloseArea())

	//Carrega array com Ordens de Producao em aberto
	dbSelectArea("SC2")

	If oQrySC2Abe == NIL
		cQuery := " SELECT C2_NUM, C2_ITEM, C2_SEQUEN, C2_ITEMGRD, C2_DATPRF, C2_PRODUTO, C2_QUANT, C2_QUJE, C2_PERDA, C2_EMISSAO "
		cQuery += " FROM "+RetSqlName("SC2")+" SC2 "
		cQuery += " WHERE " 
		cQuery += " SC2.C2_FILIAL = ? "
		cQuery += " AND SC2.C2_PRODUTO = ? "
		cQuery += " AND SC2.C2_DATPRF >= ? "
		cQuery += " AND SC2.C2_DATPRF <= ? "
		cQuery += " AND SC2.C2_DATRF = ? "
		If jParams['MV_PAR07'][1] == 2
			cQuery += "	AND SC2.C2_TPOP = ? "
		Else
			cQuery += "	AND SC2.C2_TPOP IN ( ? ) "
		EndIf
		cQuery += " AND ( SELECT (SC2B.C2_QUJE + SC2B.C2_PERDA) "
		cQuery += "	FROM "+RetSqlName("SC2")+" SC2B "
		cQuery += "	WHERE "
		cQuery += "		SC2B.C2_FILIAL = SC2.C2_FILIAL "
		cQuery += "		AND SC2B.C2_NUM = SC2.C2_NUM "
		cQuery += "		AND SC2B.C2_ITEM = SC2.C2_ITEM "
		cQuery += "		AND SC2B.C2_SEQUEN = SC2.C2_SEQUEN "
		cQuery += "		AND SC2B.C2_ITEMGRD = SC2.C2_ITEMGRD "
		cQuery += "		AND SC2B.D_E_L_E_T_ = ? ) < SC2.C2_QUANT "
		cQuery += " AND SC2.D_E_L_E_T_ = ? "

		cQuery := changeQuery(cQuery)
		oQrySC2Abe := FwExecStatement():New(cQuery)
	EndIf

	//Binding
	oQrySC2Abe:setString(1,FWxFilial("SC2"))
	oQrySC2Abe:setString(2,cCodAnt)	
	oQrySC2Abe:setString(3,cDataMin)	
	oQrySC2Abe:setString(4,cDataMax)
	oQrySC2Abe:setString(5,'          ')
	If jParams['MV_PAR07'][1] == 2
		oQrySC2Abe:setString(6,xWhereTpOP)
	Else
		oQrySC2Abe:SetIn(6,xWhereTpOP)
	EndIf
	oQrySC2Abe:setString(7,' ')	
	oQrySC2Abe:setString(8,' ')	

	cAliasTMP := oQrySC2Abe:OpenAlias()

	dbSelectArea(cAliasTMP)
	While (cAliasTMP)->(!Eof())	
		If !((jParams[ "MV_PAR08" ][1]) == 1 .And. (SomaPrazo(sToD(C2_DATPRF), - CalcPrazo(C2_PRODUTO, C2_QUANT)) >= dDataBase))
			aCampos := { "E",C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD,C2_DATPRF,C2_PRODUTO,C2_QUANT-C2_QUJE-C2_PERDA,C2_EMISSAO,"OP",C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD,C2_NUM+C2_ITEM+C2_SEQUEN+C2_ITEMGRD}
			grvTmp(cAliasTRB, aCampos)
		EndIf	
		dbSkip()
	EndDo
	(cAliasTMP)->(dbCloseArea())
	RestArea(aArea)
Return

//------------------
//r350Empenh
//------------------
Method r350Empenh(cAliasTRB, cCodAnt, dData) Class ListOfFaultsSmartViewBusinessObject
	local cAliasTMP := GetNextAlias() as character
	local aArea		:= GetArea() as array
	local aCampos	:= {}		 as array
	local cQuery as character

	If oQrySD4 == NIL
		cQuery := " SELECT D4_OP, D4_DATA, D4_COD, D4_QUANT "
		cQuery += " FROM "+RetSqlName("SD4")+" SD4 "
		cQuery += " INNER JOIN	"+RetSqlName("SC2")+" SC2 " 
		cQuery += " ON SC2.C2_FILIAL = ? "
		cQuery += "	AND SC2.C2_NUM = " + self:cSubsDB + "(D4_OP,1," + self:cNumOP + ") "
		cQuery += "	AND SC2.C2_ITEM = " + self:cSubsDB + "(D4_OP," + self:aItemOP[1] + "," + self:aItemOP[2] + ") "
		cQuery += "	AND SC2.C2_SEQUEN = " + self:cSubsDB + "(D4_OP,"+ self:aSeqOP[1] + "," + self:aSeqOP[2] + ") "
		cQuery += "	AND SC2.C2_ITEMGRD = " + self:cSubsDB + "(D4_OP," + self:aItGrdOP[1] + "," + self:aItGrdOP[2] + ") "
		If jParams['MV_PAR07'][1] == 2
			cQuery += "	AND SC2.C2_TPOP = ? "
		Else
			cQuery += "	AND SC2.C2_TPOP IN ( ? ) "
		EndIf
		cQuery += " AND SC2.D_E_L_E_T_ = ? "
		cQuery += " WHERE "
		cQuery += " SD4.D4_FILIAL = ? "
		cQuery += " AND SD4.D4_COD = ? "
		cQuery += " AND SD4.D4_OP >= ? "
		cQuery += " AND SD4.D4_OP <= ? "
		cQuery += " AND SD4.D_E_L_E_T_ = ? "

		cQuery := changeQuery(cQuery)
		oQrySD4 := FwExecStatement():New(cQuery)
	EndIf

	//Binding
	oQrySD4:setString(1,FWxFilial("SC2"))
	If jParams['MV_PAR07'][1] == 2
		oQrySD4:setString(2,xWhereTpOP)
	Else
		oQrySD4:SetIn(2,xWhereTpOP)
	EndIf
	oQrySD4:setString(3,' ')
	oQrySD4:setString(4,FWxFilial("SD4"))
	oQrySD4:setString(5,cCodAnt)
	oQrySD4:setString(6,jParams[ "MV_PAR09" ][1])
	oQrySD4:setString(7,jParams[ "MV_PAR10" ][1])
	oQrySD4:setString(8,' ')

	cAliasTMP := oQrySD4:OpenAlias()

	While (cAliasTMP)->(!Eof())

		If (jParams["MV_PAR08"][1]) == 1 .And. (SomaPrazo(STOD((cAliasTMP)->D4_DATA), - CalcPrazo((cAliasTMP)->D4_COD,(cAliasTMP)->D4_QUANT)) >= dDataBase)
			// Não faz nada
		Else
			aCampos := { "S",(cAliasTMP)->D4_OP,(cAliasTMP)->D4_DATA,(cAliasTMP)->D4_COD,(cAliasTMP)->D4_QUANT,(cAliasTMP)->D4_DATA,"EM",(cAliasTMP)->D4_OP,""}	
			grvTmp(cAliasTRB, aCampos)
		EndIf
		dbSelectArea(cAliasTMP)
		dbSkip()

	EndDo
	(cAliasTMP)->(dbCloseArea())

	RestArea(aArea)
Return

//------------------
//GrvTmp
//------------------
Static Function grvTmp(cAliasTRB, aCampos)
	Local cAliasOld := Alias()
	Local dEmissao as date
	Local dEvento as date

	If ValType(aCampos[03]) == "D"
		dEvento := aCampos[03]
	Else
		dEvento := STOD(aCampos[03])
	EndIf

	If ValType(aCampos[06]) == "D"
		dEmissao := aCampos[06]
	Else
		dEmissao := STOD(aCampos[06])
	EndIf

	RecLock(cAliasTRB, .T.)
	Replace	TIPO       With aCampos[01],;
			DOCUMENTO  With aCampos[02],;
			DTEVENTO   With dEvento,;
			PRODUTO    With aCampos[04],;
			QUANTIDADE With aCampos[05],;
			EMISSAO    With dEmissao,;
			TIPODOC    With aCampos[07],;
			OP         With aCampos[08],;
			CHAVEIDX   With aCampos[09] 
	MsUnlock()

	dbSelectArea(cAliasOld)

Return
