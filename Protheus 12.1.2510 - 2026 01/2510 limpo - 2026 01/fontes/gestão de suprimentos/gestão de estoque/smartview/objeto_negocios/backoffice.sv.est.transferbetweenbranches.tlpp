#include "msobject.ch"
#include "protheus.ch"
#include "backoffice.sv.est.transferbetweenbranches.ch"
#include "totvs.framework.treports.integratedprovider.th"

#DEFINE SX1GRUPO "ESTT025"

namespace totvs.protheus.backoffice.est.TransferBetweenBranches.integratedprovider
using namespace totvs.protheus.backoffice.est.smartView.integratedProvider

@totvsFrameworkTReportsIntegratedProvider(active=.T., team="SIGAEST", tables="SD1,SB1,SF4",name="Transferência entre filiais", country="ALL")

//-------------------------------------------------------------------
/*{Protheus.doc} TransferenciaEntreFiliaisSmartViewBusinessObject
Classe para criação do Objeto de Negócio de Prodotos 
 
@author Michel Sander
@since  11/2023
@version 1.0
*/
//-------------------------------------------------------------------  

Class TransferBetweenBranchesSmartViewBusinessObject From totvs.protheus.backoffice.est.smartView.integratedProvider.EstIntegratedProvider

	Public Method new() as object
	Public Method getData() as object

	Protected Method oNGetSchema()

	Protected data aFields as array
	Protected data jItems  as json
	Protected data cWhere  as Character
	Protected data lExistPergunte as Logical

EndClass

//-------------------------------------------------------------------
/*{Protheus.doc} new
Método de instância da classe
 
@return object: self
 
@author Michel Sander
@since  11/2023
@version 1.0
*/
//-------------------------------------------------------------------   

Method new() Class TransferBetweenBranchesSmartViewBusinessObject

	LOCAL cMsgSX1 as Character

	_Super:new()

	//Define a Área
	self:appendArea( STR0001 ) // Estoque/Custos

	//Define o nome do Objeto de Negócio
	self:setDisplayName( STR0002 ) // Transferencia entre Filiais

	//Define a descrição do Objeto de Negócio
	self:setDescription( STR0003 ) // Essa visão de dados demonstra os dados de notas fiscais de transferências realizadas entre filiais do sistema

	//Grupo de Perguntas
	self:lExistPergunte := self:SetPergunte(SX1GRUPO)
	If !self:lExistPergunte
		cMsgSX1 := OemToAnsi(I18N(STR0006,{SX1GRUPO}))  // #Grupo de perguntas #1[SX1GRUPO]# nao encontrado. Verifique na tabela SX1, o grupo de perguntas informado
		self:setErrorStatus(400,STR0007,cMsgSX1)		// #Sem Pergunte
		FwLogMsg("WARN",, "SmartView ESTSV029",,,,cMsgSX1,,,)
	EndIf

	//Indica que o LookUp será do tipo padrão LookUp
	self:setIsLookUp(.T.)

Return self

//-------------------------------------------------------------------
/*{Protheus.doc} getData
Retorna os dados do objeto de negócio 
 
@param nPage, numérico, indica a página atual do relatório
@param oFilter, objeto, contém o filtro do TReports
 
@return object: self:oData
 
@author  Michel Sander
@since   11/2023
@version 1.0
*/
//-------------------------------------------------------------------   

Method getData( nPage as Numeric, oFilter as object) as object Class TransferBetweenBranchesSmartViewBusinessObject

	local oQuery	 as Object
	local cQuery	 as Character
	local cAlias	 as Character
	local nX		 as Numeric
	local dDataIni   as Date
	local dDataFin   as Date
	local jParams	 as Json
	local cEmpNome	 as Character
	local cSituac	 as Character
	local nTipDoc	 as Numeric
	local nQualSit	 as Numeric
	local cFilBkp	 as Character
	local cChave	 as Character
	local cRealName  as Character
	local cFieldsSD1 as Character
	local cFieldsSD2 as Character
	local nFil		 as Numeric

	If !self:lExistPergunte
		Return self:oData
	EndIf

	jParams    := oFilter:getParameters() //metodo para retorno do json dos parâmetros

    //Retorno da tela de multi filiais com as filiais selecionadas ou somente a filial corrente
    self:aFils := self:retFils(jParams['SV_MULTBRANCH'], oFilter)

	dDataIni   := FwDateTimeToLocal( jParams['MV_PAR03'][1] )[1]
	dDataFin   := FwDateTimeToLocal( jParams['MV_PAR04'][1] )[1]
	nTipDoc    := jParams['MV_PAR09'][1]
	nQualSit   := jParams['MV_PAR10'][1]
	cFilBkp    := cFilAnt
	cFieldsSD1 := "D1_FILIAL, D1_DOC, D1_SERIE, D1_FORNECE, D1_LOJA, D1_EMISSAO, D1_DTDIGIT, D1_COD, B1_DESC, B1_GRUPO, D1_QUANT, D1_TES,"
	cFieldsSD1 += "D1_UM, D1_CF, D1_VUNIT, D1_TOTAL, D1_VALIPI, D1_VALICM, D1_VALFRE, D1_SEGURO, D1_DESPESA, D1_VALDESC,"
	cFieldsSD1 += "D1_CUSTO, D1_ITEM, D1_TIPO, '2' TABELA, '' FILDEST "

	cFieldsSD2 := "D2_FILIAL D1_FILIAL, D2_DOC D1_DOC, D2_SERIE D1_SERIE, D2_CLIENTE D1_FORNECE, D2_LOJA D1_LOJA,"
	cFieldsSD2 += "D2_EMISSAO D1_EMISSAO, D2_EMISSAO D1_DTDIGIT, D2_COD D1_COD, B1_DESC, B1_GRUPO, D2_QUANT D1_QUANT, D2_TES D1_TES,"
	cFieldsSD2 += "D2_UM D1_UM, D2_CF D1_CF, D2_PRCVEN D1_VUNIT, D2_TOTAL D1_TOTAL, D2_VALIPI D1_VALIPI, D2_VALICM D1_VALICM,"
	cFieldsSD2 += "D2_VALFRE D1_VALFRE, D2_SEGURO D1_SEGURO, D2_DESPESA D1_DESPESA, D2_DESCON D1_VALDESC,"
	cFieldsSD2 += "D2_CUSTO1 D1_CUSTO, D2_ITEM D1_ITEM, D2_TIPO D1_TIPO, '1' TABELA, F2_FILDEST FILDEST "

	cQuery := "SELECT ? "
	cQuery += "FROM "+RetSQLName("SD1")+" SD1 "
	cQuery += "INNER JOIN "+RetSQLName("SF1")+" SF1 ON "
	cQuery += "D1_FILIAL = F1_FILIAL AND "
	cQuery += "D1_DOC = F1_DOC AND "
	cQuery += "D1_SERIE = F1_SERIE AND "
	cQuery += "D1_FORNECE = F1_FORNECE AND "
	cQuery += "D1_LOJA = F1_LOJA "
	cQuery += "INNER JOIN " + RetSqlName("SB1") + " SB1 ON "
    cQuery += "SB1.B1_FILIAL = ? AND "
    cQuery += "SB1.B1_COD = SD1.D1_COD AND "
    cQuery += "SB1.D_E_L_E_T_ = ? "
	cQuery += "WHERE D1_COD >= ? "
	cQuery += "AND D1_COD <= ? "
	cQuery += "AND D1_DOC >= ? "
	cQuery += "AND D1_DOC <= ? "
	cQuery += "AND D1_TES >= ? "
	cQuery += "AND D1_TES <= ? "
	cQuery += "AND D1_EMISSAO >= ? "
	cQuery += "AND D1_EMISSAO <= ? "
	cQuery += "AND SD1.D_E_L_E_T_ = ? "
	cQuery += "AND SF1.D_E_L_E_T_ = ? "

	//Os filtros serão setados na interface do novo TReports
	cQuery += self:cWhere
	cQuery += self:cWhereFiltroSV

	cQuery += "UNION "

	cQuery += "SELECT ? "
	cQuery += "FROM "+RetSQLName("SD2")+" SD2 "
	cQuery += "INNER JOIN "+RetSQLName("SF2")+" SF2 ON "
	cQuery += "D2_FILIAL = F2_FILIAL AND "
	cQuery += "D2_DOC = F2_DOC AND "
	cQuery += "D2_SERIE = F2_SERIE AND "
	cQuery += "D2_CLIENTE = F2_CLIENTE AND "
	cQuery += "D2_LOJA = F2_LOJA "
	cQuery += "INNER JOIN " + RetSqlName("SB1") + " SB1 ON "
    cQuery += "SB1.B1_FILIAL = ? AND "
    cQuery += "SB1.B1_COD = SD2.D2_COD AND "
    cQuery += "SB1.D_E_L_E_T_ = ? "
	cQuery += "WHERE D2_DOC >= ? "
	cQuery += "AND D2_DOC <= ? "
	cQuery += "AND D2_EMISSAO >= ? "
	cQuery += "AND D2_EMISSAO <= ? "
	cQuery += "AND D2_COD >= ? "
	cQuery += "AND D2_COD <= ? "
	cQuery += "AND D2_TES >= ? "
	cQuery += "AND D2_TES <= ? "
	cQuery += "AND SD2.D_E_L_E_T_ = ? "
	cQuery += "AND SF2.D_E_L_E_T_ = ? "
	
	cQuery += "ORDER BY D1_FILIAL, TABELA, D1_DOC, D1_SERIE, D1_FORNECE, D1_LOJA, D1_ITEM"

	cQuery := ChangeQuery(cQuery)

    //Montagem da query para execução
    oQuery := FwExecStatement():New(cQuery)

	//Colocar while ou for de filiais aqui
	For nFil :=1 to len(self:aFils)
		cFilAnt	:= self:aFils[nFil]

		//Binding
		oQuery:SetUnsafe(1, cFieldsSD1)
		oQuery:SetString(2, FWxFilial("SB1"))
		oQuery:setString(3, ' ')
		oQuery:SetString(4, jParams['MV_PAR05'][1])
		oQuery:SetString(5, jParams['MV_PAR06'][1])
		oQuery:SetString(6, jParams['MV_PAR01'][1])
		oQuery:SetString(7, jParams['MV_PAR02'][1])
		oQuery:SetString(8, jParams['MV_PAR07'][1])
		oQuery:SetString(9, jParams['MV_PAR08'][1])
		oQuery:SetString(10, Dtos(dDataIni))
		oQuery:SetString(11, Dtos(dDataFin))
		oQuery:setString(12, ' ')
		oQuery:setString(13, ' ')
		oQuery:SetUnsafe(14, cFieldsSD2)
		oQuery:SetString(15, FWxFilial("SB1"))
		oQuery:setString(16, ' ')
		oQuery:SetString(17, jParams['MV_PAR01'][1])
		oQuery:SetString(18, jParams['MV_PAR02'][1])
		oQuery:SetString(19, Dtos(dDataIni))
		oQuery:SetString(20, Dtos(dDataFin))
		oQuery:SetString(21, jParams['MV_PAR05'][1])
		oQuery:SetString(22, jParams['MV_PAR06'][1])
		oQuery:SetString(23, jParams['MV_PAR07'][1])
		oQuery:SetString(24, jParams['MV_PAR08'][1])
		oQuery:setString(25, ' ')
		oQuery:setString(26, ' ')

		cAlias := oQuery:OpenAlias()

		(cAlias)->(dbGoTop())

		SF4->(dbSetOrder(1))
		While !(cAlias)->(Eof())
			// Saidas 
			If (cAlias)->TABELA == "1" .And. ( nTipDoc == 1 .Or. nTipDoc == 3 )
				If (cAlias)->D1_TIPO $ "DB"
					// Posiciona no fornecedor 
					dbSelectArea("SA2")
					dbSetOrder(1)
					MsSeek(xFilial("SA2")+(cAlias)->D1_FORNECE+(cAlias)->D1_LOJA)
					cEmpNome := SA2->A2_NOME
				Else
					// Posiciona no cliente
					dbSelectArea("SA1")
					dbSetOrder(1)
					MsSeek(xFilial("SA1")+(cAlias)->D1_FORNECE+(cAlias)->D1_LOJA)
					cEmpNome := SA1->A1_NOME
				EndIf

				cChave := (cAlias)->(D1_FILIAL+D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA)
				While (cAlias)->(!Eof()) .And. (cAlias)->(D1_FILIAL+D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA) == cChave
					If SF4->(dbSeek(xFilial()+(cAlias)->D1_TES)) .And. SF4->F4_TRANFIL != "1"
						(cAlias)->(dbSkip())
						Loop
					EndIf

					cSituac := fNfTransito((cAlias)->FILDEST, (cAlias)->D1_COD, (cAlias)->D1_DOC, (cAlias)->D1_SERIE)
					If nQualSit != 3
						If ( cSituac == "T" .And. nQualSit == 2 ) .Or. ( cSituac == "R" .And. nQualSit == 1 )
							(cAlias)->(dbSkip())
							Loop
						EndIf
					EndIf

					self:jItems := JsonObject():New()

					self:jItems["TABELA"] := STR0009    //#Saída 

					For nX := 1 To Len(self:aFields)

						cRealName := self:aFields[nX]:getRealName()

						If self:aFields[nX]:getType() == "date" //Campo tipo data tem um tratamento diferente para envio
							If !Empty( (cAlias)->&(cRealName) )
								self:jItems[cRealName] := totvs.framework.treports.date.stringToTimeStamp((cAlias)->&(cRealName))
							EndIf
						Else							
							self:jItems[cRealName] := (cAlias)->&((cRealName))
						EndIf
					Next nX

					If cSituac == "T"
						self:jItems["SITUAC"] := STR0010 //#"Em Transito"
					Else
						self:jItems["SITUAC"] := STR0011 //#"Recebida"
					EndIf
					self:jItems["EMPNOME"] 	  := cEmpNome

					self:processData()
					self:oData:appendData(self:jItems)
					(cAlias)->(dbSkip())
				EndDo
			// Entradas
			ElseIf (cAlias)->TABELA == "2" .And. ( nTipDoc == 2 .Or. nTipDoc == 3 )
				If (cAlias)->D1_TIPO $ "DB"
					// Posiciona no cliente
					dbSelectArea("SA1")
					dbSetOrder(1)
					SA1->(dbSeek(xFilial()+(cAlias)->D1_FORNECE+(cAlias)->D1_LOJA))
					cEmpNome := SA1->A1_NOME
				Else
					// Posiciona no fornecedor
					dbSelectArea("SA2")
					dbSetOrder(1)
					SA2->(dbSeek(xFilial()+(cAlias)->D1_FORNECE+(cAlias)->D1_LOJA))
					cEmpNome := SA2->A2_NOME
				EndIf

				cChave := (cAlias)->(D1_FILIAL+D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA)
				While (cAlias)->(!Eof()) .And. (cAlias)->(D1_FILIAL+D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA) == cChave
					If !Empty((cAlias)->D1_TES)
						If SF4->(MsSeek(xFilial()+(cAlias)->D1_TES)) .And. SF4->F4_TRANFIL != "1"
							(cAlias)->(dbSkip())
							Loop
						EndIf
					EndIf

					If nQualSit != 3
						If ( Empty((cAlias)->D1_TES) .And. nQualSit == 2 ) .Or. ( Empty((cAlias)->D1_TES) .And. nQualSit == 1 )
							(cAlias)->(dbSkip())
							Loop
						EndIf
					EndIf

					self:jItems := JsonObject():New()

					self:jItems["TABELA"] := STR0008 //#Entrada 

					For nX := 1 To Len(self:aFields)

						cRealName := self:aFields[nX]:getRealName()

						If self:aFields[nX]:getType() == "date" //Campo tipo data tem um tratamento diferente para envio
							If !Empty( (cAlias)->&(cRealName) )
								self:jItems[cRealName] := totvs.framework.treports.date.stringToTimeStamp((cAlias)->&(cRealName))
							EndIf
						Else							
							self:jItems[cRealName] := (cAlias)->&((cRealName))
						EndIf
					Next nX

					If Empty((cAlias)->D1_TES)
						self:jItems["SITUAC"] := STR0010 //#"Em Transito"
					Else
						self:jItems["SITUAC"] := STR0011 //#"Recebida"
					EndIf
					self:jItems["EMPNOME"] := cEmpNome

					self:processData()
					self:oData:appendData(self:jItems)
					(cAlias)->(dbSkip())
				EndDo
			Else 
				(cAlias)->(dbSkip())
				Loop
			EndIf
		EndDo
		(cAlias)->(DBCloseArea())
	Next

	cFilAnt := cFilBkp

	oQuery:Destroy()

Return self:oData

//-------------------------------------------------------------------
/*{Protheus.doc} oNGetSchema
Retorna a estrutura dos campos
 
@return object: self:oSchema
 
@author  Michel Sander
@since   11/2023
@version 1.0
*/
//-------------------------------------------------------------------   

Method oNGetSchema() Class TransferBetweenBranchesSmartViewBusinessObject

	Local aFieldsSB1 as Array
	Local aFieldsSD1 as Array

	aFieldsSB1 := {"B1_DESC","B1_GRUPO"}
	aFieldsSD1 := {"D1_FILIAL","D1_DOC","D1_SERIE","D1_FORNECE","D1_LOJA","D1_EMISSAO","D1_DTDIGIT","D1_COD",;
				   "D1_QUANT","D1_TES","D1_UM","D1_CF","D1_VUNIT","D1_TOTAL","D1_VALIPI","D1_VALICM","D1_VALFRE",;
				   "D1_SEGURO","D1_DESPESA","D1_VALDESC","D1_CUSTO"}

	self:AliasToSchema("SD1",aFieldsSD1)
	self:AliasToSchema("SB1",aFieldsSB1)

	self:aFields := self:getStructFields()

	self:addProperty("EMPNOME" , STR0004, "string", STR0004, "EMPNOME") // Nome Cliente/Fornecedor
	self:addProperty("TABELA"  , STR0005, "string", STR0005, "TABELA")  // Tipo de NF
	self:addProperty("SITUAC"  , STR0012, "string", STR0012, "SITUAC")	// Situação

Return

//-------------------------------------------------------------------
/*{Protheus.doc} fNfTransito
Retorna se um documento de entrada está em transito
 
@return  cTransito
@author  Michel Sander
@since   11/2023
@version 1.0
*/
//-------------------------------------------------------------------   

Static Function fNfTransito(xFilDest as character, xCodigo as character, xNota as character, xSerie as character)

	local aAreaD1   := SD1->(getArea()) as array
	local cTransito := "T" as character

	dbSelectArea("SD1")
	dbSetOrder(2)
	dbSeek(xFilDest+xCodigo+xNota+xSerie)

	While !Eof() .And. D1_FILIAL+D1_COD+D1_DOC+D1_SERIE == xFilDest+xCodigo+xNota+xSerie

		// Checa TES
		If Empty(SD1->D1_TES)
			cTransito := "T"
		Else
			cTransito := "R"
		EndIf

		dbSkip()

	End

	SD1->(RestArea(aAreaD1))

Return ( cTransito )
