#include 'protheus.ch'
#include 'fw-tlpp-core.th'

/*/{Protheus.doc} LjControlaEstoque
Valida se o produto esta dentro de alguma regra de não controle de estoque
@type  Function
@author joao.marcos
@since 22/09/2025
@version V1.0   
@param cProduto, character, Codigo do produto
@return lRet, logical, .T. se o produto controla estoque, .F. caso contrário
/*/
Function LjControlaEstoque(cProduto)
Local lRet := .T.   as Logical

If ExisteSX2("MI3")
    cProduto := PadR(cProduto,TamSx3("B1_COD")[1])
    lRet := !ValidaRegra(cProduto)
EndIf

Return lRet

/*/{Protheus.doc} ValidaRegra
Valida se o produto esta dentro de alguma regra de não controle de estoque
@type  Static Function
@author joao.marcos
@since 22/09/2025
@version V1.0   
@param cProduto, character, Codigo do produto
@return lRet, logical, .T. se o produto não controla estoque, .F. caso contrário
/*/
Static Function ValidaRegra(cProduto)
Local lRet              := .F.                      as  Logical
Local nRegraProduto     := RegraProduto(cProduto)   as Numeric
Local nRegragrupo       := RegraGrupo(cProduto)     as Numeric
Local nRegraCategoria   := RegraCategoria(cProduto) as Numeric
Local cMvRegEstGrCat    := Upper( AllTrim( SuperGetMv("MV_RESTGCT",,"G",FWCodFil()) ) ) as Character

// 1 - Não controla estoque
// 2 - Controla estoque 
// 0 - Sem regra definida

Do Case
    Case nRegraProduto == 1
        // Se o produto tem regra de não controle de estoque esta configuração que vai prevalecer
        lRet := .T.
    Case nRegraProduto == 2
        // Se o produto tem regra de controle de estoque esta configuração que vai prevalecer
        lRet := .F.
    Case (nRegragrupo == 1 .AND. nRegraCategoria == 0) .OR. (nRegragrupo == 0 .AND. nRegraCategoria == 1)
        // Se apenas um dos dois (grupo ou categoria) tem regra de não controle de estoque, então o produto NÃO CONTROLA estoque
        lRet := .T.
    Case (nRegragrupo == 2 .AND. nRegraCategoria == 0) .OR. (nRegragrupo == 0 .AND. nRegraCategoria == 2)
        // Se apenas um dos dois (grupo ou categoria) tem regra de controle de estoque, então o produto CONTROLA estoque
        lRet := .F.
    Case nRegragrupo == 1 .AND. nRegraCategoria == 1
        // Se ambos (grupo e categoria) tem regra de não controle de estoque, então o produto NÃO CONTROLA estoque
        lRet := .T.
    Case nRegragrupo == 2 .AND. nRegraCategoria == 1 .AND. cMvRegEstGrCat == "G"
        // Se o grupo controla estoque e a categoria não controla estoque e a configuração esta como G (Grupo), então o produto CONTROLA estoque
        lRet := .F.
    Case nRegragrupo == 1 .AND. nRegraCategoria == 2 .AND. cMvRegEstGrCat == "G"
        // Se o grupo não controla estoque e a categoria controla estoque e a configuração esta como G (Grupo), então o produto NÃO CONTROLA estoque
        lRet := .T.
    Case nRegraCategoria == 1 .AND. nRegragrupo == 2 .AND. cMvRegEstGrCat == "C"
        // Se a categoria não controla estoque e o grupo controla estoque e a configuração esta como C (Categoria), então o produto NÃO CONTROLA estoque
        lRet := .T.
    Case nRegraCategoria == 2 .AND. nRegragrupo == 1 .AND. cMvRegEstGrCat == "C"
        // Se a categoria controla estoque e o grupo não controla estoque e a configuração esta como C (Categoria), então o produto CONTROLA estoque
        lRet := .F.        
EndCase

Return lRet

/*/{Protheus.doc} RegraProduto
Retorna se o produto tem regra de estoque flexível
@type  Static Function
@author joao.marcos
@since 10/11/2025
@version V1.0
@param cProduto, character, Codigo do produto
@return nRet, Numeric, 1 se o produto tem regra de estoque flexível, 2 se não tem regra de estoque flexível, 0 caso não tenha regra definida
/*/
Static Function RegraProduto(cProduto)
Local nRet          := 0                as Numeric
Local cQuery        := ""               as  Character
Local cAliasRegProd := GetNextAlias()   as  Character

cQuery += " SELECT MI3_COD, MI3_CODPRO, MI3_DTINI, MI3_DTFIM, MI3_REGRA " + CRLF
cQuery += " FROM " + RetSqlName("MI3")                          + CRLF
cQuery += " WHERE MI3_FILIAL = '" + xFilial("MI3") + "' "       + CRLF
cQuery += " AND MI3_CODPRO = '" + cProduto + "' "               + CRLF
cQuery += " AND ((MI3_DTINI <= '" + DtoS(Date()) + "'"          + CRLF
cQuery += "       AND MI3_DTFIM >= '" + DtoS(Date()) + "' )"    + CRLF
cQuery += " 	   OR MI3_DTFIM = '') "                         + CRLF
cQuery += " AND D_E_L_E_T_ = '' "                               + CRLF

cQuery := ChangeQuery(cQuery)
MPSysOpenQuery(cQuery,cAliasRegProd)

While (cAliasRegProd)->(!EoF())

    If Upper( AllTrim((cAliasRegProd)->MI3_REGRA) ) == "1"
        nRet := 1
    ElseIf Upper( AllTrim((cAliasRegProd)->MI3_REGRA) ) == "2"
        nRet := 2
        Exit
    EndIf

    (cAliasRegProd)->(dbSkip())

EndDo

(cAliasRegProd)->(DbCloseArea())

return nRet 

/*/{Protheus.doc} RegraGrupo
Retorna se o grupo do produto tem regra de estoque flexível
@type  Static Function
@author joao.marcos
@since 10/11/2025
@version V1.0
@param cProduto, character, Codigo do produto
@return nRet, Numeric, 1 se o grupo do produto tem regra de estoque flexível, 2 se não tem regra de estoque flexível, 0 caso não tenha regra definida
/*/
Static Function RegraGrupo(cProduto)
Local nRet           := 0                as Numeric
Local cQuery         := ""               as  Character
Local cAliasRegGrupo := GetNextAlias()   as  Character
Local cGrupo         := GetAdvFVal("SB1","B1_GRUPO",xFilial('SB1') + cProduto,1) as Character

cQuery += " SELECT MI3_COD, MI3_CODPRO, MI3_GRUPO, MI3_DTINI, MI3_DTFIM, MI3_REGRA " + CRLF
cQuery += " FROM " + RetSqlName("MI3")                          + CRLF
cQuery += " WHERE MI3_FILIAL = '" + xFilial("MI3") + "' "       + CRLF
cQuery += " AND MI3_GRUPO = '"+ cGrupo +"' "                    + CRLF
cQuery += " AND ((MI3_DTINI <= '" + DtoS(Date()) + "'"          + CRLF
cQuery += "       AND MI3_DTFIM >= '" + DtoS(Date()) + "' )"    + CRLF
cQuery += " 	   OR MI3_DTFIM = '') "                        + CRLF
cQuery += " AND D_E_L_E_T_ = '' "                               + CRLF

cQuery := ChangeQuery(cQuery)
MPSysOpenQuery(cQuery,cAliasRegGrupo)

While (cAliasRegGrupo)->(!EoF())

    If Upper( AllTrim((cAliasRegGrupo)->MI3_REGRA) ) == "1"
        nRet := 1
    ElseIf Upper( AllTrim((cAliasRegGrupo)->MI3_REGRA) ) == "2"
        nRet := 2
        Exit
    EndIf

    (cAliasRegGrupo)->(dbSkip())

EndDo

(cAliasRegGrupo)->(DbCloseArea())

Return nRet

/*/{Protheus.doc} RegraCategoria
Retorna se a estrutura categoria do produto tem regra de estoque flexível
@type  Static Function
@author joao.marcos
@since 10/11/2025
@version V1.0
@param cProduto, character, Codigo do produto
@return nRet, Numeric, 1 se a categoria do produto tem regra de estoque flexível, 2 se não tem regra de estoque flexível, 0 caso não tenha regra definida
/*/
Static Function RegraCategoria(cProduto)
Local nRet           := 0                as Numeric
Local cCategoria     := BuscaCategoria(cProduto) as  Character
Local cCategoriaPai  := ""               as  Character

If !Empty(cCategoria)
    nRet := BuscaRegraCategoria(cCategoria)

    If nRet == 0 
        // Verifica categorias pai
        cCategoriaPai := BuscaCategoriaPai(cCategoria)     
        While nRet == 0 .AND. !Empty(cCategoriaPai)        
            If !Empty(cCategoriaPai)
                nRet :=  BuscaRegraCategoria(cCategoriaPai)
            EndIf
            If nRet == 0 .AND. !Empty(cCategoriaPai)
                cCategoriaPai := BuscaCategoriaPai(cCategoriaPai)
            ElseIf nRet == 1 .OR. nRet == 2
                Exit
            EndIf
        EndDo

    EndIF
EndIf

Return nRet

/*/{Protheus.doc} BuscaRegraCategoria
Retorna se categoria do produto tem regra de estoque flexível
@type  Static Function
@author joao.marcos
@since 13/11/2025
@version V1.0
@param cProduto, character, Codigo do produto
@return nRet, Numeric, 1 se a categoria do produto tem regra de estoque flexível, 2 se não tem regra de estoque flexível, 0 caso não tenha regra definida
/*/
Static Function BuscaRegraCategoria(cCategoria)
Local nRet           := 0                as Numeric
Local cQuery         := ""               as  Character
Local cAliasRegCateg := GetNextAlias()   as  Character

If !Empty(cCategoria)   

    cQuery += " SELECT MI3_COD, MI3_CODPRO, MI3_CATEGO, MI3_DTINI, MI3_DTFIM, MI3_REGRA " + CRLF
    cQuery += " FROM " + RetSqlName("MI3")                          + CRLF
    cQuery += " WHERE MI3_FILIAL = '" + xFilial("MI3") + "' "       + CRLF
    cQuery += " AND MI3_CATEGO = '" + cCategoria + "' "      + CRLF
    cQuery += " AND ((MI3_DTINI <= '" + DtoS(Date()) + "'"          + CRLF
    cQuery += "       AND MI3_DTFIM >= '" + DtoS(Date()) + "' )"    + CRLF
    cQuery += " 	   OR MI3_DTFIM = '') "                         + CRLF
    cQuery += " AND D_E_L_E_T_ = '' "                               + CRLF

    cQuery := ChangeQuery(cQuery)
    MPSysOpenQuery(cQuery,cAliasRegCateg)

    While (cAliasRegCateg)->(!EoF())

        If Upper( AllTrim((cAliasRegCateg)->MI3_REGRA) ) == "1"
            nRet := 1
        ElseIf Upper( AllTrim((cAliasRegCateg)->MI3_REGRA) ) == "2"
            nRet := 2
            Exit
        EndIf

        (cAliasRegCateg)->(dbSkip())

    EndDo

    (cAliasRegCateg)->(DbCloseArea())
EndIf

Return nRet

/*/{Protheus.doc} BuscaCategoriaPai
Retorna a categoria pai
@type  Static Function
@author joao.marcos
@since 13/11/2025
@version V1.0
@param cCategoria, character, Codigo da categoria
@return cCategoriaPai, character, codigo da categoria pai
/*/
Static Function BuscaCategoriaPai(cCategoria)
Local cAliasACU             := GetNextAlias()   as Character                                     
Local cCategoriaPai         := ""               as Character                                                                                     
Local cQuery                := ""               as Character 

cQuery += " SELECT ACU_COD, ACU_CODPAI "                    + CRLF
cQuery += " FROM " + RetSqlName("ACU")                      + CRLF
cQuery += " WHERE ACU_FILIAL = '" + xFilial("ACU") + "' "   + CRLF
cQuery += " AND ACU_COD = '" + cCategoria + "' "            + CRLF

If ACU->(FieldPos("ACU_MSBLQL")) > 0
    cQuery += " AND ACU_MSBLQL <> '1' "                     + CRLF
EndIf

cQuery += " AND D_E_L_E_T_ = '' "                           + CRLF

cQuery := ChangeQuery(cQuery)
MPSysOpenQuery(cQuery,cAliasACU)

If (cAliasACU)->(!EoF()) .AND. !Empty( (cAliasACU)->ACU_CODPAI )
    cCategoriaPai := (cAliasACU)->ACU_CODPAI    
EndIf

(cAliasACU)->(DbCloseArea())

Return cCategoriaPai

/*/{Protheus.doc} BuscaCategoria
Retorna a categoria do produto
@type  Static Function
@author joao.marcos
@since 22/09/2025
@version V1.0
@param cProduto, character, Codigo do produto
@return cCategoria, character, Codigo da categoria do produto
/*/
Static Function BuscaCategoria(cProduto)
Local cCategoria    := ""               as  Character
Local cQuery        := ""               as  Character
Local cAliasACV     := GetNextAlias()   as  Character

cQuery += " SELECT ACV_CATEGO "                             + CRLF
cQuery += " FROM " + RetSqlName("ACV") + " ACV "            + CRLF    
cQuery += " INNER JOIN " + RetSqlName("ACU") + " ACU "      + CRLF
cQuery += " ON ACV_FILIAL = ACU_FILIAL "                    + CRLF
cQuery += " AND ACV_CATEGO = ACU_COD "                      + CRLF
cQuery += " WHERE  ACV_FILIAL = '" + xFilial("ACV") + "'"   + CRLF
cQuery += " AND ACV_CODPRO = '" + cProduto + "' "           + CRLF
cQuery += " AND ACU_MSBLQL <> '1' "                         + CRLF
cQuery += " AND ACU.D_E_L_E_T_ = ' ' "                      + CRLF
cQuery += " AND ACV.D_E_L_E_T_ = ' ' "                      + CRLF

cQuery := ChangeQuery(cQuery)
MPSysOpenQuery(cQuery,cAliasACV)

If (cAliasACV)->(!EoF())
    cCategoria := (cAliasACV)->ACV_CATEGO
EndIf

(cAliasACV)->(DbCloseArea())

Return cCategoria
