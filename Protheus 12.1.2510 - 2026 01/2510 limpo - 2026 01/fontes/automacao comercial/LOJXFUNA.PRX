#INCLUDE "PROTHEUS.CH"
#INCLUDE "LOJXFUNA.CH"
#INCLUDE "TBICONN.CH"
#INCLUDE "PARMTYPE.CH"	// (Para controle dos parâmetros  utilizando o comando PARAMTYPE)
#INCLUDE "AP5MAIL.CH"	// (Para utilizar o comando CONNECT SMTP SERVER na função LjEnvEmLP)
#INCLUDE "FILEIO.CH"
               
#DEFINE CONFIRMA	1
#DEFINE REDIGITA	2
#DEFINE ABANDONA	3
#DEFINE BOLETO 	    1
#DEFINE PAGAR		2
#DEFINE RECEB		3
#DEFINE VENDA		4
#DEFINE IMPRIME	    5
#DEFINE _FORMATEF	"CC;CD"     	// Formas de pagamento que utilizam operação TEF para validação

//Defines relacionados a Gravação de LOGs
#DEFINE LOGPATH	 	"AUTOCOM" 			// Caminho principal (Diretorio Pai) onde os LOGs serão gravados
#DEFINE LOGSUBPATH 	"LOGS" 				// Sub-Caminho (Diretorio Filho) onde os LOGs serão gravados
#DEFINE LOGSECTION	"LOGLOJA"			// Nome da Seção de Configuração do LOGLOJA no arquivo AppServer.INI
#DEFINE CRLF      	Chr(13)+Chr(10)  	// Pula linha

//Variaveis relacionadas a Gravação de LOGs
Static lEnableLog 	:= Nil				// Variavel para controle se LOGs esta ativo.
Static lHeadInfo 	:= .T. 				// Variavel para controlar a gravaçao das informações de Cabeçalho do LOG
Static cFile_Log 	:= Nil				// Variavel para armazenar o nome do arquivo de LOG
Static dDate_Log	:= Date()			// Variavel para armazenar a data do arquivo de LOG
Static lCStack 		:= .F.				// Variavel para controlar a geracao da pilha de chamada (CallStack) em todas as gravações de LOG
Static cAuxEstacao             	// Variavel auxiliar para recuperar cEstacao
Static cMov := ""               // Variavel para obter o numero do ultimo movimento
Static nDec						// Numero de decimais na captura do peso da balanca
Static nMaxTimeOut
Static cSenha		:= "******"					//Variavel apagada pelo Framework
Static lGetLjUp104	:= Nil						// Retorna resultado da validacao da Garantia Estendida
Static lVDVer12		:= Nil
Static nModAnt 		:= 0		//Ultimo modulo acessado
Static lFiscAnt		:= NIL		//Usuario fiscal do Loja
Static nOpcUser		:= 0		//Varaivel para controle de nopc (Inclusão/Alteração)
Static lLogCliCfg	:= Nil		//Variavel do controle de log centralizado
Static lLinux		:= IIF(!IsBlind(),"LINUX" $ UPPER(GetRmtInfo()[2]),.F.)

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Fun‡„o    ³ LojaxFun ³ Autor ³ Vendas Clientes		³ Data ³           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Contem fun‡”es especificas do SigaLoja I e II.              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SigaLoja                                                    ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³ Fun‡„o    ³Lj030Verif³ Autor ³ Vendas Clientes       ³ Data ³ 24/01/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡„o ³ Verifica se o caixa esta cadastrado na tabela 23 (Caixas)  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Sintaxe   ³Ljc030Verif(Numero do Caixa)                                ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function LJ030Verif(lFrontCx)
Local cAlias := Alias()							// Alias da area utilizada
Local lExist := .F.								// Retorna se achou no SX5

Default lFrontCx := .F.

If !(lFrontCx)
	DbSelectArea("SX5")
	If DbSeek(xFilial()+"23")
		While SX5->X5_TABELA == "23" .AND. xFilial() == X5_FILIAL
			If Alltrim(cCaixa) == Alltrim(SX5->X5_CHAVE)
				lExist := .T.
			EndIf
			DbSkip()
		End
	Else
		DbSelectArea(cAlias)
		Help(" ",1,"NOBANCO")
		Return .F.
	EndIf
	
	If lExist
		DbSelectArea(cAlias)
		Return .T.
	Else
		DbSelectArea(cAlias)
		Help(" ",1,"NOBANCO")
		Return .F.
	EndIf
Else
	If Empty(xNumCaixa())
		DbSelectArea(cAlias)
		Help(" ",1,"NOBANCO")
		Return .F.
	Else
		DbSelectArea(cAlias)
		Return .T.	
	EndIf
EndIf

Return (NIL)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡„o    ³MsStrZero ³ Autor ³ Vendas Clientes		 ³ Data ³ 24/01/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡„o ³Converte para string completandoa com zeros.                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Sintaxe   ³MsStrZero(nValor, nByter)                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function MsStrZero( nValor, nBytes )
// nValor - Valor a ser convertido
// nBytes - Quantidade de bytes que devem ser utilizados
Local cZeros := ""											// Zeros para retorno
Local cRetorno												// Retorno da funcao

cRetorno := AllTrim( Str( nValor ) )

If Len( cRetorno ) < nBytes
	cZeros	:= Repl( "0", nBytes - Len(cRetorno) )
	cRetorno := cZeros + cRetorno
EndIf

Return ( cRetorno )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡„o    ³ljCxAberto³ Autor ³ Vendas Clientes		 ³ Data ³ 27/02/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡„o ³ Retorna se o Caixa esta aberto ou nao                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Sintaxe   ³ ljCxAberto(Mostra ou n„o o Help , Numero Caixa)            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Parametros³ 1 - Mostra ou n„o o Help                                   ³±±
±±³           ³ 2 - Numero Caixa (Caso queira verificar ou caixa)          ³±±    
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LjCxAberto(lHelp,cCaixa)
Local cHoraAbr                                    		// Hora de aberturea do Caixa
Local dDataAbr                                    		// Data de abertura do Caixa
Local aArea       	:= GetArea()                   		// Area corrente
Local lRet        	:= .T.                         		// Retorno da funcao
Local lMv_LjAbrCx	:= SuperGetMV("MV_LJABRCX")   		// Controla se abertura do Caixa pode ser feito pela venda
Local lPerm                                      		// Variavel verifica se é permitido abrir/reabrir caixa
Local aPermissao                                 		// Verifica se permissao 16 foi criada na lj120permi
Local cRetorno	  	:= ""								// Retorno da hora
Local lAbrCxImp   	:= .T.								// Verifica se abre o caixa.
Local lFechaConf  	:= SuperGetMV("MV_LJCONFF",.F.,.F.) // Verifica se utiliza conferencia de caixa
Local lEmitNfce	  	:= LjEmitNFCe()						// Sinaliza se utiliza NFC-e
Local lFtvdVer12	:= LjFTVD() 						//Verifica se é Release 11.7 e o FunName é FATA701 - Compatibilização Venda Direta x Venda Assisitida
Local aDtHoraECF	:= iif(lEmitNfce .or. IsBlind(), LjDtHrECF(.t.), {GetRmtDate(), GetRmtTime()}) 

Default lHelp   		:= .T.
Default cCaixa  		:= xNumCaixa()

DbSelectArea("SA6")
SA6->( DbSetOrder(1) )	//A6_FILIAL+A6_COD+A6_AGENCIA+A6_NUMCON
If SA6->( DbSeek(xFilial("SA6")+AllTrim(cCaixa)) )
   cHoraAbr := SA6->A6_HORAABR
   dDataAbr := SA6->A6_DATAABR
Endif   

If __cUserID <> "000000"

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Atualiza a database³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lFiscal .AND. !Empty(dDataAbr)  .AND. nModulo <> 23 .AND. !lEmitNfce // não fará essa verificação para o Front e NFC-e
		nRet := IFStatus( nHdlECF, '19', @cRetorno )
		If nRet == 0
			If CtoD(cRetorno) == dDataAbr
				lAbrCxImp := .F.		    
			EndIf
		ElseIf nRet == 2
	 		If dDataBase == dDataAbr
				lAbrCxImp := .F.
	        EndIf
		EndIf
	EndIf	

	If Empty(dDataAbr) .OR. (SubtHoras(dDataAbr,cHoraAbr,aDtHoraECF[1],Substr(aDtHoraECF[2],1,5)) < 0) .OR.;
		dDataAbr <> dDataBase .AND. lAbrCxImp
		If lHelp
			If dDataAbr <> dDataBase .AND. !Empty(dDataAbr)
			
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Se ultiliza conferencia de caixa nao permite abertura/fechamento ³
				//³automatico na tela de vendas. somente pelo menu.                 ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lFechaConf  .AND. ( nModulo == 12 .OR. nModulo == 05 )
					Help(" ",1,"LJCXSEMFE")
					Return .F.
				EndIf
				
				//Para o Front não sugere fechamento, apenas avisa que necessita fechar
				If lMv_LjAbrCx .AND. If (nModulo <> 23 ,MsgNoYes(STR0066),.F.)  // Caixa anterior esta sem fechamento. Deseja abri-lo ?
					If (! LJProFile(4)) .AND. (nModulo <> 5)
						// Usuário / sem permissão para Abrir/Fechar o Caixa. / Atenção
						MsgStop(STR0079 + AllTrim(cUserName) + STR0080, STR0001)
						lRet := .F.
					Else
						Cx_Abre_Fecha(cCaixa, "F")
						Cx_Abre_Fecha(cCaixa, "A")
					EndIf
				Else
					Help(" ",1,"LJCXSEMFE")
					lRet := .F.
				EndIf
			ElseIf SubtHoras(dDataAbr,cHoraAbr,aDtHoraECF[1],Substr(aDtHoraECF[2],1,5)) < 0
				Help(" ",1,"LJHORAABR")
				lRet := .F.
			Else
			
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Se ultiliza conferencia de caixa nao permite abertura/fechamento ³
				//³automatico na tela de vendas. somente pelo menu.                 ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If (lFechaConf  .AND. nModulo == 12) .OR. (lFechaConf  .AND. lFtvdVer12)
					If nModulo == 05
						DbSelectArea("SLW")
						SLW->( DbSetOrder(6))
						If SLW->(DBSeek(xFilial("SLW")+ cCaixa + "")) .AND. Empty(SLW->LW_DTFECHA) .AND. Cx_Abre_Fecha(cCaixa, "A")
							Return (.T.)
						Else
							MsgInfo(STR0184 + CHR(13)+CHR(10)+; //#"O caixa esta fechado!"
									STR0185, STR0001) //#"Favor efetuar a sua abertura atraves da rotina de abertura de caixa em um PDV." ##Atenção
							Return (.F.)
						EndIF
					Else
						Help(" ",1,"LJCXSEMFE")
						Return (.F.)
					Endif
				EndIf			
										// Para o Front,não sugere abertura de caixa, apenas avisa que precisa abrir
				If lMv_LjAbrCx .AND. If (nModulo <> 23,MsgNoYes(STR0067), .F.) // O Caixa esta fechado. Deseja abri-lo ?
					If Empty(SA6->A6_DATAABR) .AND. SA6->A6_DATAFCH == dDataBase
       					aPermissao:= Lj120Permi()
     					If aScan(aPermissao, {|x| x[1] == 16}) > 0 
	     					lPerm := LJProFile(16) //Permissao de Reabertura de Caixa
     					Else
	     					lPerm := LJProFile(4)   
	 					Endif
                    Else
                       lPerm := LJProFile(4)
                    Endif

				
					If !lPerm
						// Usuário / sem permissão para Abrir/Reabrir/Fechar o Caixa. / Atenção
						MsgStop(STR0079 + AllTrim(cUserName) + STR0099, STR0001)
						lRet := .F.
					Else
						Cx_Abre_Fecha(cCaixa, "A")
					Endif
				Else
					Help(" ",1,"LJCXFECHA")
					lRet := .F.
				EndIf
			EndIf
		EndIf
	EndIf
EndIf

RestArea(aArea)

Return (lRet)
**************************************************************************
*																		 *
*		  CRIA REGISTRO PADRAO CASO NAO EXISTA NO SA1,SA3,SF4,SE4		 *
*																		 *
**************************************************************************

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³CriaClipad³ Autor ³Vendas Clientes        ³ Data ³ 04/04/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Cria Cliente Padr„o para SIGALOJA                           ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function CriaCliPad()
Local cAlias     := Alias()         							// Alias corrente
Local cCliPad                       							// Conteudo do parametro "MV_CLIPAD"
Local cLojPad                       							// Conteudo do parametro "MV_LOJAPAD"
Local cNomeClie  := ""

Do Case
	Case cPaisLoc == "SAL"
		cNomeClie := STR0088 //"CLIENTE EFETIVO"
	Case cPaisLoc == "GUA"
		cNomeClie := STR0090 //"CONSUMIDOR FINAL"
	Case cPaisLoc == "BOL"
		cNomeClie := STR0126 //"CLIENTE GENERICO"
	Otherwise
		cNomeClie := STR0002 //"CLIENTE PADRAO"
EndCase

If Empty(SuperGetMV("MV_CLIPAD"))
	PutMv("MV_CLIPAD","000001")
EndIf

If Empty(SuperGetMV("MV_LOJAPAD"))
	PutMv("MV_LOJAPAD","01")
EndIf

cCliPad := SuperGetMV("MV_CLIPAD")
cLojPad := SuperGetMV("MV_LOJAPAD")

DbSelectArea("SA1")
DbSetOrder(1)
If !DbSeek(xFilial("SA1")+cCliPad+cLojPad)
	RecLock("SA1",.T.)
	REPLACE SA1->A1_FILIAL	WITH  xFilial("SA1")
	REPLACE SA1->A1_COD 	WITH cCliPad
	REPLACE SA1->A1_LOJA	WITH cLojPad
	REPLACE SA1->A1_NOME	WITH cNomeClie
	REPLACE SA1->A1_NREDUZ 	WITH cNomeClie
	If cPaisLoc $ "CHI|PAR"
		REPLACE SA1->A1_TIPO WITH "A"
	ElseIf cPaisLoc $ "MEX|POR|EUA|DOM|COS|COL|GUA"	  //Inclui Mexico - Localizacoes - Jose Aurelio - 28/05/02
		REPLACE SA1->A1_TIPO WITH "1"
	ElseIf cPaisLoc $ "URU|SAL"	   
		REPLACE SA1->A1_TIPO WITH "2"		   		
	Else
		REPLACE SA1->A1_TIPO WITH "F"
	EndIf
	REPLACE SA1->A1_END WITH "R..."
	REPLACE SA1->A1_MUN WITH If(!Empty(SM0->M0_CIDCOB),SM0->M0_CIDCOB,If(cPaisLoc=="BRA","SAO PAULO","."))
	REPLACE SA1->A1_EST WITH SuperGetMV("MV_ESTADO")	
	If cPaisLoc <> "BRA"
	    SA1->A1_END := "."	
		If cPaisLoc=="DOM"
			REPLACE SA1->A1_PERCIVA WITH "S"
		Else
			REPLACE SA1->A1_PERCIVA WITH "N"		
		EndIf			
	Endif		
	MsUnLock()
EndIf

DbSelectArea( cAlias )

Return (NIL)
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³CriaVenPad³ Autor ³ Vendas Clientes       ³ Data ³ 04/04/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Cria Vendedor Padr„o para SIGALOJA                          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function CriaVenPad()
Local cAlias := Alias()              // Alias corrente

DbSelectArea("SA3")
DbSetOrder(1)
RecLock("SA3",.T.)
REPLACE SA3->A3_FILIAL WITH xFilial("SA3")
If Empty(SuperGetMV("MV_VENDPAD"))
	PutMv("MV_VENDPAD","000001")
EndIf
REPLACE SA3->A3_COD    WITH SuperGetMV("MV_VENDPAD")
REPLACE SA3->A3_NOME   WITH STR0003				// VENDEDOR PADRAO
REPLACE SA3->A3_NREDUZ WITH STR0003
MsUnLock()
DbSelectArea( cAlias )

Return (NIL)
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³CriaCondPa³ Autor ³ Vendas Clientes       ³ Data ³ 04/04/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Cria Condi‡„o de Pagamento Padr„o para SIGALOJA             ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function CriaCondPad()
Local cAlias := Alias()               // Alias corrente

DbSelectArea("SE4")
DbSetOrder(1)
If !DbSeek(xFilial("SE4")+"001")
	Reclock( "SE4" , .T. )
	REPLACE SE4->E4_FILIAL WITH xFilial("SE4")
	REPLACE SE4->E4_CODIGO WITH "001"
	REPLACE SE4->E4_TIPO   WITH "1"
	REPLACE SE4->E4_COND   WITH "00"
	REPLACE SE4->E4_DESCRI WITH STR0004				// "A VISTA"
	REPLACE SE4->E4_FORMA  WITH SuperGetMV("MV_SIMB1")
	MsUnLock()
EndIf
If cPaisLoc $ "EUA|POR"
	If !DbSeek(xFilial("SE4")+"LAY")
		Reclock( "SE4" , .T. )
		REPLACE SE4->E4_FILIAL WITH xFilial("SE4")
		REPLACE SE4->E4_CODIGO WITH "LAY"
		REPLACE SE4->E4_TIPO   WITH "1"
		REPLACE SE4->E4_COND   WITH "00"
		REPLACE SE4->E4_DESCRI WITH STR0089	    //"Lay-Away" 			
		MsUnLock()
	EndIf
EndIf
DbSelectArea( cAlias )

Return (NIL)
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³CriaTESEnt³ Autor ³ Vendas Clientes       ³ Data ³ 04/04/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Cria TES Padr„o - Entrada para SIGALOJA                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function CriaTESEnt()
Local cAlias := Alias()               // Alias corrente

DbSelectArea("SF4")
DbSetOrder(1)
If !DbSeek(xFilial("SF4")+"001")
	Reclock( "SF4" , .T. )
	REPLACE SF4->F4_FILIAL 	WITH xFilial("SF4")
	REPLACE SF4->F4_CODIGO 	WITH "001"
	REPLACE SF4->F4_TIPO   	WITH "E"
	REPLACE SF4->F4_ICM    	WITH "S"
	REPLACE SF4->F4_IPI    	WITH "N"
	REPLACE SF4->F4_CREDICM	WITH "S"
	REPLACE SF4->F4_CREDIPI	WITH "N"
	REPLACE SF4->F4_ESTOQUE	WITH "S"
	REPLACE SF4->F4_CF	   	WITH "112"
	REPLACE SF4->F4_DUPLIC 	WITH "S"
	REPLACE SF4->F4_TEXTO  	WITH STR0005				// ENTRADA MERCADORIAS
	REPLACE SF4->F4_BASEICM	WITH 0
	REPLACE SF4->F4_BASEIPI	WITH 0
	REPLACE SF4->F4_INCIDE 	WITH "N"
	REPLACE SF4->F4_LFICM  	WITH "T"
	REPLACE SF4->F4_LFISS  	WITH "N"
	REPLACE SF4->F4_LFIPI  	WITH "N"
	REPLACE SF4->F4_ISS    	WITH "N"
	REPLACE SF4->F4_DESTACA	WITH "N"
	REPLACE SF4->F4_COMPL  	WITH "N"
	REPLACE SF4->F4_PODER3 	WITH "N"
	If cPaisLoc <> "BRA"
	   REPLACE SF4->F4_GERALF WITH "1"	   
	EndIf	
	MsUnLock()
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Grava Tes de Entrada Padrao ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Empty(SuperGetMV("MV_TESENT"))
	PutMV("MV_TESENT","001")
EndIf

DbSelectArea( cAlias )

Return (NIL)
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³CriaTESSai³ Autor ³ Vendas Clientes       ³ Data ³ 04/04/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Cria TES Padr„o - Saida para SIGALOJA                       ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function CriaTESSai()
Local cAlias := Alias()               // Alias corrente

DbSelectArea("SF4")
DbSetOrder(1)
If !DbSeek(xFilial("SF4")+"501")
	Reclock( "SF4" , .T. )
	REPLACE SF4->F4_FILIAL 	WITH xFilial("SF4")
	REPLACE SF4->F4_CODIGO 	WITH "501"
	REPLACE SF4->F4_TIPO	WITH "S"
	REPLACE SF4->F4_ICM 	WITH "S"
	REPLACE SF4->F4_IPI 	WITH "N"
	REPLACE SF4->F4_CREDICM	WITH "S"
	REPLACE SF4->F4_CREDIPI	WITH "N"
	REPLACE SF4->F4_ESTOQUE	WITH "S"
	REPLACE SF4->F4_CF	   	WITH "512"
	REPLACE SF4->F4_DUPLIC 	WITH "S"
	REPLACE SF4->F4_TEXTO	WITH STR0006				// SAIDA DE MERCADORIAS
	REPLACE SF4->F4_BASEICM	WITH 0
	REPLACE SF4->F4_BASEIPI	WITH 0
	REPLACE SF4->F4_INCIDE 	WITH "N"
	REPLACE SF4->F4_LFICM	WITH "T"
	REPLACE SF4->F4_LFISS	WITH "N"
	REPLACE SF4->F4_LFIPI	WITH "N"
	REPLACE SF4->F4_ISS 	WITH "N"
	REPLACE SF4->F4_DESTACA	WITH "N"
	REPLACE SF4->F4_COMPL	WITH "N"
	REPLACE SF4->F4_PODER3 	WITH "N"
	If cPaisLoc <> "BRA"
	   SF4->F4_GERALF := "1"	   
	EndIf
	MsUnLock()
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Grava Tes de Saida Padrao ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Empty(SuperGetMV("MV_TESSAI"))
	PutMV("MV_TESSAI","501")
EndIf

DbSelectArea( cAlias )

Return (NIL)
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³LJ010ESTOQ³ Autor ³ Vendas Clientes       ³ Data ³ 10/04/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Verifica se o estoque esta positivo e avisa no Browse de   ³±±
±±³          ³ vendas (aCols) / Verifica TES e ESTNEG                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parƒmetros³ Sem parametros                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Sigaloja                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LJ010ESTOQ(cRetorno,lEstPosit, lComRes)
Local cCodigo := ""
Local nQuant  := 0
Local cTes	  := ""
Local cLocal  := ""
Local ny 	  := 1
Local cAlias  := Alias()
Local nReg	  := Recno()
Local xRetorno
Local nl      := 0
Local nTQuant := 0
Local nPProd  := Ascan( aHeader,{ |x| Alltrim(x[2]) == "L2_PRODUTO" } )
Local nPQuant := Ascan( aHeader,{ |x| Alltrim(x[2]) == "L2_QUANT" } ) 
Local nQtdRes := 0
Local cRpcServer := ""
Local nRPCPort 	 := 0
Local cRPCEnv 	 := ""
Local cRPCEmp 	 := ""
Local cRPCFilial := ""
Local cNomeLoja   := ""
Local cCodigoLoja := ""
Local oServer
Local cMVEstNeg		:= SuperGetMV("MV_ESTNEG")		// Permite ou nao o estoque negativo

Default lEstPosit	:= .T.                         
Default lComRes  	:= .T.  //Variavel que deseja validar se deseja substrair a Reserva

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se esta' chamando da rotina de trocas ou da rotinda da Venda³
//³ Balcao, durante o processo de saida da troca. Se for da Venda Balcao ³
//³ deixa o parametro como esta, senao, forca para ficar sempre negativo ³
//³ porque nao eh necessario consultar o estoque durante a entrada.      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Alltrim( Upper( FunName() ) ) == "LOJA020"
	nY    := 0
	cProc := AllTrim( Upper( ProcName( nY ) ) )
	While ! ( cProc == "" ) .AND. ! ( "LJ010ATE" $ cProc )
		nY ++
		cProc := AllTrim( Upper( ProcName( nY ) ) )
	End
	If !( "LJ010ATE" $ cProc )
		cMvEstNeg := "S"
	Endif
Endif

If cMVEstNeg == "N"
	For ny := 1 to Len(aHeader)
		If Trim(aHeader[ny][2]) == "L2_PRODUTO"
			cCodigo := aCols[n][ny]
			For nl:= 1 to Len(aCols)
				If cCodigo == aCols[nl][nPProd] .AND. acols[nl][len(acols[n])] == .F.
					nTQuant+=aCols[nl][nPQuant]
				EndIf
			Next nl
		EndIf
		If Trim(aHeader[ny][2]) == "L2_QUANT"
			nQuant := aCols[n][ny]
		EndIf
		If Trim(aHeader[ny][2]) == "L2_TES"
			cTes := aCols[n][ny]
		EndIf
		If Trim(aHeader[ny][2]) == "L2_LOCAL"
			cLocal := aCols[n][ny]
		EndIf
		If nTQuant > 0 .AND. !Empty(cCodigo) .AND. !Empty(cTes) .AND. !Empty(cLocal)
			
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Caso exista reserva e tenha recebido parametro para desconsiderar a      ³
			//³reserva, faco a pesquisa da reserva e somo sua quantidade no SaldoSB2    ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !lComRes
				If !Empty( GDFieldGet("L2_RESERVA",N) )
				
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Caso o campo L2_LOJARES tenha conteudo, significa que houve uma reserva  ³
					//³para outra filial/empresa, caso contrario, faco pesquisa na base local.  ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ				
					If Empty(GDFieldGet("L2_LOJARES",N))
						SC0->( DbSetOrder( 1 ))
						If SC0->( DbSeek( xFilial("SC0") + GDFieldGet("L2_RESERVA",N) ))
							nQtdRes := SC0->C0_QUANT
						EndIf
					Else
						SLJ->( DbSetOrder( 1 ) )
						If !SLJ->( DbSeek( xFilial( "SLJ" )+GDFieldGet("L2_LOJARES",N)) )
							MsgStop(STR0091+GDFieldGet("L2_LOJARES",N)+STR0092,STR0001)//"Problema ao procurar a loja "+" no cadastro de identificação de lojas, contate o administrador!"
							lEstPosit := .F.
							Return Nil
						EndIf
						
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Realizando pesquisa da reserva via RPC Connect                           ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If SLJ->LJ_RESERVA == "1"
							cRpcServer 	:= Alltrim(SLJ->LJ_RPCSRV)
							nRPCPort 	:= Val(Alltrim(SLJ->LJ_RPCPORT))
							cRPCEnv 	:= Alltrim(SLJ->LJ_RPCENV)
							cRPCEmp 	:= SLJ->LJ_RPCEMP
							cRPCFilial	:= SLJ->LJ_RPCFIL			
							cNomeLoja 	:= Alltrim(SLJ->LJ_NOME) 
							cCodigoLoja := SLJ->LJ_CODIGO
							
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³Criando uma conexao com o outro servidor                                 ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							CREATE RPCCONN oServer ON SERVER cRpcServer PORT nRPCPort ENVIRONMENT cRPCEnv EMPRESA cRPCEmp;
							FILIAL cRPCFilial TABLES 'SC0' MODULO "LOJA"
				
							If ValType(oServer) == "O"
								//  / 
								LjMsgRun(STR0093+cNomeLoja+".",,{|| nQtdRes := oServer:CallProc("LjRpcQtdRes",GDFieldGet("L2_RESERVA",N))} )//"Aguarde ... Consutando loja "
								If ValType(nQtdRes) <> "N"
									nQtdRes := 0
								Endif
								RESET ENVIRONMENT IN SERVER oServer
								CLOSE RPCCONN oServer
							Else
								MsgStop(STR0094+cNomeLoja+". "+STR0095,STR0001)//"Houve problemas na conexão com a Loja "//"Contate o Administrador do Sistema"
								lEstPosit := .F.
								Return Nil
							EndIf
								
						Endif
					EndIf
				EndIf
			EndIf

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Possiona no Tes do produto ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			DbSelectArea("SF4")
			DbSeek(xFilial("SF4")+cTes)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Possiona no Saldo do produto no estoque ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			DbSelectArea( "SB1" )
			DbSeek( xFilial("SB1") + cCodigo )
			DbSelectArea( "SB2" )
			If ( DbSeek( xFilial("SB2") + cCodigo + cLocal ) ) .AND. ( SF4->F4_ESTOQUE == "S" )
				If SldBlqSB2(cCodigo,cLocal) .AND. (SaldoSB2()+nQtdRes < nTQuant) 
					Help(" ",1,"SALDOINSUL")
				   	MsgInfo(STR0087 + chr(13) + chr(10) + chr(13) + chr(10) + AllTrim(cCodigo) + " - " + AllTrim(SB1->B1_DESC) ,"Atenção") 
					lEstPosit := .F.
				EndIf
			ElseIf !( DbSeek( xFilial("SB2") + cCodigo + cLocal ) ) .AND. ( SF4->F4_ESTOQUE == "S" )
				Help(" ",1,"SALDOINSUL")
				MsgInfo(STR0087 + chr(13) + chr(10) + chr(13) + chr(10) + AllTrim(cCodigo) + " - " + AllTrim(SB1->B1_DESC) ,"Atenção")
				lEstPosit := .F.
			EndIf
			Exit
		EndIf
	Next ny
Else
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Caso Possa Vender com estoque negativo retorna o Campo ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For ny := 1 to Len(aHeader)
		If Trim(aHeader[ny][2]) == "L2_PRODUTO"
			cCodigo := aCols[n][ny]
		EndIf
		If Trim(aHeader[ny][2]) == "L2_QUANT"
			nQuant := aCols[n][ny]
		EndIf
		If Trim(aHeader[ny][2]) == "L2_TES"
			cTes := aCols[n][ny]
		EndIf
		If Trim(aHeader[ny][2]) == "L2_LOCAL"
			cLocal := aCols[n][ny]
		EndIf
		
		If !Empty(cCodigo) .AND. !Empty(cTes) .AND. !Empty(cLocal)
			DbSelectArea("SF4")
			DbSeek(xFilial("SF4")+cTes)
			
			If ( SF4->F4_ESTOQUE == "S" ) .AND. !( SldBlqSB2(cCodigo,cLocal) )
				Exit
			EndIf
		EndIf

	Next ny
EndIf

DbSelectArea(cAlias)
dbGoto(nReg)

If cRetorno == "P"
	xRetorno := cCodigo
ElseIf cRetorno == "Q"
	xRetorno := nQuant
ElseIf cRetorno == "L"
	xRetorno := cLocal
ElseIf cRetorno == "T"
	xRetorno := cTes
EndIf
     

Return (xRetorno)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³LJSenha   ³ Autor ³ Vendas Clientes       ³ Data ³ 28.01.97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Autorizacao para desconto na venda                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parƒmetros³ ExpC1 = Origem da chamada da funcao Lj010Autor             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ExpL1 := Lj010Autor( ExpC1 )                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ SIGALOJA                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LjSenha(cChamada)
Local lRet		 := .T.					// Retorno da funcao, se encontrou ou nao a senha digitada
Local aReg		 := {}					// Array com o retorno da funcao PswRet()
Local cAcessAnt	 := cAcesso				// Variavel com o acesso do usuario logado no sistema
Local nTent		 := 0					// Valida a quantidade de tentativas
Local cSenhaLoja := ""					// Senha digitada na caixa de dialogo
Local cNome      := ""					// Retorno do nome do usuario, da senha digitada
Local lPswSeek   := .F.					// Verifica se a senha foi encontrada

cSenhaAnt		 := cSenha

While .T.
	nTent++
	If ljGetsenha(cChamada, @cSenhaLoja)
		PswOrder(3)
		lPswSeek := PswSeek(cSenhaLoja)
		If __cUserID == "000000" .OR. lPswSeek

			aReg  := PswRet()
			cNome := If( lPswSeek, aReg[01,02], "" )

			If __cUserID <> "000000"
				If lPswSeek
					cAcesso := aReg[3]
					lRet := .T.
				Else
					MsgStop(STR0007,STR0001)				// Senha Inv lida / Aten‡„o
				Endif
			EndIf

			cSenha	  := aReg[1][3]	// Senha do Usuario
			cNome 	  := aReg[1][2]	// Nome do Usuario
			cNivel	  := cNivelSup := cNivelSup2 := Val(Substr(aReg[3][12],3,1))	// Niveis
			If lRet
				cAcesso := cAcessAnt
				Exit
			EndIf
		Else
			// Senha Inv lida / Aten‡„o
			MsgStop(STR0007,STR0001)
			If nTent == 3
				lRet := .F.
				Exit
			EndIf
		EndIF
	Else
		lRet := .F.
		Exit
	EndIf
End
cAcesso := cAcessAnt

Return (lRet)
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³lj010InitP³ Autor ³ Vendas Clientes       ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Inicializa impressora paralela                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³lj010InitPrint()                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³LOJA010                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Lj010InitPrint(cSaida)
Local cPorta							//Porta corrente
Local nErroPrt		:= 0				//Retorna o erro, caso a impressora nao esteja conectada
Local lRetImp		:= .T.				//Variavel que verifica se a impressora conectou

Private nLastKey	:= 0
Private aReturn		:= { "", 1, "" , 2, 3, cPorta , "",IndexOrd() }

If cSaida == "N"
	cPorta	:=SuperGetMV("MV_PORTNOT")
ElseIf cSaida == "O"
	cPorta	:=SuperGetMV("MV_PORTORC")
ElseIf cSaida == "C"
	cPorta	:=LjGetStation("PORTICP")
Endif

If !left(cPorta,3) == "LPT"
	Return (lRetImp)
Endif

SetPrint(Alias(),"","","",,,,.F.,,,,,,,'EPSON.DRV',.T.,.F.,cPorta)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica se teve exito nas configuracoes do SetPrint e se existe impressora conectada|
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nLastKey <> 27 .AND. IsPrinter()
	If cPaisLoc == "BRA"
		SetDEFAULT(aReturn,Alias())
	Else 
		SetDEFAULT(aReturn,Alias(),,.T.)
	EndIf   

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se teve exito nas configuracoes do SetDEFAULT			   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nLastKey <> 27
		@ PRow(), PCol() PSay Chr(27) + Chr(64)
		SetPrc(0,0)
	Endif
Else
    MsgAlert( "Impressora nao conectada" + Alltrim(Str(nErroPrt) ) )
    lRetImp	:= .F.
Endif

Return (lRetImp)
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³lj010EndPr³ Autor ³ Vendas Clientes       ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Encerra impressora paralela                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³lj010EndPrint()                                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³LOJA010                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Lj010EndPrint(cSaida)

Do case
	Case cSaida == "N"
		cTipoImp := SuperGetMV("MV_IMPNOTA")
	Case cSaida == "C"
		cTipoImp := LJGetStation("IMPCUP")
	Case cSaida == "O"
		cTipoImp := SuperGetMV("MV_IMPORC")
Endcase
If SubStr(cTipoImp,1,10) == "EPSON/COMP"
	@ 1,0 PSay Chr(18)+""
Endif
SetPgEject(.F.)
MS_FLUSH()

Return (NIL)
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³FechaSf2  ³ Autor ³ Vendas Clientes       ³ Data ³ 06.06.94 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Fecha uma determinada Nota Fiscal                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SigaLoja                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function FechaSF2(	lFirst,			nICMF2,			nBsICMF2,		nIPIF2,;
					nBSIPIF2,		nVlMF2,			nBsISSF2,		nISSF2,;
					nDESCF2,		cFirst,			lFim,			lEntrou,;
					nVlIcmRetF2,	nBsIcmRetF2,	lImpCupFis,		nImpFat,;
					nMoedaCor,		nSmIcmRetF2,	aNotas,			nNotaAtu,;
					nVlrIcmFre,		cTipoDocCF,		cNumDocCF,		cClienteCF,;
					cEnderCF,		nVlrFreNota,	nVlrSegNota,	nVlrDesNota,;
					nItens,			cDocSerie, 		nBasePS2,		nValPS2,;
					nBaseCF2, 		nValCF2,		nIcmsDifer	)

Local nRegSf2		:= 0						// Recno do SF2
Local nRndFat      	:= MsDecimais(nMoedaCor)	// Nr. de decimais para arredondamento
Local cCampo       	:= ""						// Guarda o nome do campo
Local nCount      	:= 0						// Usada em lacos For...Next
Local nCmp         	:= 0						// Usada em lacos For...Next
Local nC 			:= 0						// Usada em lacos For...Next
Local nCA    		:= 0						// Usada em lacos For...Next
Local nPosSign     	:= 0						// Posicao do sinal dentro da string
Local nValImp      	:= 0 						// Valor do Imposto
Local nValBas      	:= 0						// Base do Imposto
Local nDecs        	:= MsDecimais(nMoedaCor)	// Nr. padrao de casas decimais a usar
Local nTotImpsNF   	:= 0  						// Total dos impostos por NF, prevendo multiplas faturas
Local nE          	:= 0						// Retorno da posicao no array de Impostos
Local cAliasNF	   	:= ""						// Alias do arq. de Nota Fiscal
Local cNumAnt      	:= Space(TamSx3("L1_DOC")[1])				// Nr. anterior da NF
Local cTiposDoc    	:= ALLTRIM( SuperGetMv( 'MV_ESPECIE' ) )	// Tipos de Documento
Local cEspecie     	:= Space(5)									// Especie da NF
Local lNoArredImp  	:= .F.										// Indica se arredonda ou nao o valor dos impostos
Local nArredImp    	:= 2										// Nr. de casas a arredondar nos impostos
Local lSeqEspecie  	:= .F.										// Indica se utiliza a sequencia de especie
Local cMV_TPNRNFS	:= LjTpNrNFS()								// Retorno do parametro MV_TPNRNFS, utilizado pela Sx5NumNota() de onde serah controlado o numero da NF  1=SX5  2=SXE/SXF  3=SD9
Local aRelImp      	:= MaFisRelImp("MT100",{ "SF2" })      		// Array com os impostos calculados
Local lLockSF2      := !(AllTrim(Upper(FunName()))$"LOJA010/LOJA220/LOJA020/LOJA016/LOJA021")   //Determina se inclui ou modifica SF2
Local nTamF2_DOC	:= TamSx3("F2_DOC")[1]

Default nVlrFreNota	:= 0		//Valor de Frete da NF
Default nVlrSegNota	:= 0		//Valor de Seguro da NF
Default nVlrDesNota	:= 0		//Valor de Despesa da NF
Default nVlrIcmFre 	:= 0		//Valor de ICMS do Frete 
Default nItens     	:= 1        //Item corrente
Default nBasePS2 		:= 0   		//Base de calculo do PIS
Default nValPS2 		:= 0       	//Valor do PIS
Default nBaseCF2		:= 0      	//Base de calculo do COFINS
Default nValCF2		:= 0    	//Valor do COFINS
Default lFim        	:= .F.		//Indica se eh finalizacao
Default nIcmsDifer	:= 0		//Totalizador do ICMS Diferido

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Checa o valor do ICMS antes da gravacao do SF2 para nao dar ³
//³ falha de integridade ao chamar a funcao LJ010ICMS           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Upper(AllTrim(FunName())) $ "LOJA010|LOJA020"
	nVlrIcmFre  := If(nVlrFreNota>0,LjxDIcms(nItens,,nIPIF2+If(lVlrFSD,nVlrFreNota+nVlrSegNota+nVlrDesNota,0)),0)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Faz a gravacao do SF2 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lEntrou := .T.
Reclock( "SF2", lLockSF2 )
REPLACE SF2->F2_FILIAL	WITH xFilial("SF2")
REPLACE SF2->F2_DOC 	WITH cNumNota
REPLACE SF2->F2_SERIE	WITH SL1->L1_SERIE
REPLACE SF2->F2_CLIENTE	WITH SL1->L1_CLIENTE
REPLACE SF2->F2_LOJA	WITH SL1->L1_LOJA
REPLACE SF2->F2_PDV 	WITH SL1->L1_PDV
REPLACE SF2->F2_ECF 	WITH If( lImpCupFis, "S", "" )

If lImpCupFis
	cEspecie := "CF"
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se for o estado de Piaui, grava ECF³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If LjAnalisaLeg(18)[1]
		cEspecie := "ECF"
	Endif
Else
	If cPaisLoc == "BRA"
		If cTiposDoc <> NIL
			cTiposDoc := StrTran( cTiposDoc, ";", CHR(13)+CHR(10))
			For nCount := 1 TO MLCount( cTiposDoc )
				cEspecie := ALLTRIM( StrTran( MemoLine( cTiposDoc,, nCount ), CHR(13), CHR(10) ) )
				nPosSign := Rat( "=", cEspecie)
				If nPosSign > 0 .AND. ALLTRIM( cSerie ) == ALLTRIM( SUBSTR( cEspecie, 1, nPosSign - 1 ) )
					If SX5->( DbSeek( xFilial("SX5") + "42" + SUBSTR( cEspecie, nPosSign + 1 ) ) )
						cEspecie := SUBSTR( cEspecie, nPosSign + 1 )
					Else
						cEspecie := SPACE(5)
					Endif
					Exit
				Else
					cEspecie := SPACE(5)
				Endif
			Next nCount
		Endif
		
	Else
		cEspecie := MVNOTAFIS
	EndIf
EndIf

REPLACE SF2->F2_ESPECIE	WITH cEspecie
REPLACE SF2->F2_EST 	WITH SA1->A1_EST
REPLACE SF2->F2_COND	WITH SL1->L1_CONDPG
REPLACE SF2->F2_DUPL	WITH cFirst
REPLACE SF2->F2_EMISSAO	WITH dDataBase
REPLACE SF2->F2_VALICM 	WITH nICMF2
REPLACE SF2->F2_BASEICM	WITH nBsICMF2
REPLACE SF2->F2_VALIPI 	WITH nIPIF2
REPLACE SF2->F2_BASEIPI	WITH nBsIPIF2 + If( lVlrFSD, (nVlrFreNota + nVlrSegNota + nVlrDesNota) - SL1->L1_DESCNF, 0)
REPLACE SF2->F2_VALMERC	WITH Round(nVlmF2,nRndFat)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza o campo de ICMS Diferido ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If SF2->(FieldPos("F2_ICMSDIF")) > 0 .AND. ( nIcmsDifer > 0 )
	REPLACE SF2->F2_ICMSDIF WITH nIcmsDifer
EndIf

If cPaisLoc == "BRA"
	REPLACE SF2->F2_VALBRUT WITH nIPIF2 + nVlmF2 + If(SA1->A1_TIPO $ SuperGetMV("MV_TPSOLCF"),nSmIcmRetF2,0) + If( lVlrFSD, nVlrFreNota + nVlrSegNota + nVlrDesNota, 0 )
	REPLACE SF2->F2_VALFAT  WITH nVlmF2 + nIPIF2 + If(SA1->A1_TIPO $ SuperGetMV("MV_TPSOLCF"),nSmIcmRetF2,0) + If( lVlrFSD, nVlrFreNota + nVlrSegNota + nVlrDesNota, 0 )
EndIf
REPLACE SF2->F2_TIPO	WITH "N"
If !Empty(SL1->L1_TIPOCLI)
	REPLACE SF2->F2_TIPOCLI	WITH SL1->L1_TIPOCLI
Else
	REPLACE SF2->F2_TIPOCLI	WITH SA1->A1_TIPO
EndIf
REPLACE SF2->F2_VEND1	WITH SL1->L1_VEND
REPLACE SF2->F2_BASEISS	WITH nBsISSF2
REPLACE SF2->F2_VALISS 	WITH nISSF2
REPLACE SF2->F2_ICMSRET	WITH nVlIcmRetF2
REPLACE SF2->F2_BRICMS 	WITH nBsIcmRetF2
REPLACE SF2->F2_DESCONT	WITH nDescF2
If !(cEspecie == "CF" .OR. cEspecie == "SATCE" .OR. cEspecie == "NFCE") 
	REPLACE SF2->F2_HORA	WITH SubStr(Time(),1,5)
Else
	REPLACE SF2->F2_HORA	WITH  SL1->L1_HORA
EndIf
REPLACE SF2->F2_PREFIXO	WITH &(SuperGetMV("MV_LJPREF"))   

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³  Grava o valor de acrescimo financeiro se existir o campo ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Type( "nVlrAcrs" ) # "U"
	REPLACE SF2->F2_VALACRS WITH nVlrAcrs
EndIf	

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Grava dados do frete, ja esta posicionado. ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
REPLACE SF2->F2_FRETE 	WITH nVlrFreNota
REPLACE SF2->F2_SEGURO 	WITH nVlrSegNota
REPLACE SF2->F2_PLIQUI 	WITH SL1->L1_PLIQUI
REPLACE SF2->F2_PBRUTO 	WITH SL1->L1_PBRUTO
REPLACE SF2->F2_VOLUME1	WITH SL1->L1_VOLUME
REPLACE SF2->F2_TRANSP 	WITH SL1->L1_TRANSP
REPLACE SF2->F2_ESPECI1	WITH SL1->L1_ESPECI1
REPLACE SF2->F2_DESPESA	WITH nVlrDesNota
REPLACE SF2->F2_ICMFRET	WITH nVlrIcmFre

If SL1->(ColumnPos('L1_ESPECI1')) > 0 .And. !Empty(SL1->L1_ESPECI1)
	REPLACE SF2->F2_ESPECI1	WITH SL1->L1_ESPECI1
EndIf 

If SL1->(ColumnPos('L1_VEICUL1')) > 0 .And. !Empty(SL1->L1_VEICUL1)
	REPLACE SF2->F2_VEICUL1	WITH SL1->L1_VEICUL1
EndIf	 

If cPaisLoc == "BRA"
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Gravação da Base do PIS de apuração    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
   	If (nScanPis := AScan(aRelImp,{|x| x[1]=="SF2" .AND. x[3]=="NF_BASEPS2"})) > 0
    	If SF2->(FieldPos(aRelImp[nScanPis,2])) > 0
        	REPLACE SF2->&(aRelImp[nScanPis,2]) WITH nBasePS2
      	EndIf                                                               
   	EndIf  
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Gravação do Valor do PIS de apuração  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
   	If (nScanPis := AScan(aRelImp,{|x| x[1]=="SF2" .AND. x[3]=="NF_VALPS2"})) > 0
    	If SF2->(FieldPos(aRelImp[nScanPis,2])) > 0
        	REPLACE SF2->&(aRelImp[nScanPis,2]) WITH nValPS2
      	EndIf                                                               
   	EndIf  
   	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Gravação da Base do Cofins de apuração ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
   	If (nScanPis := AScan(aRelImp,{|x| x[1]=="SF2" .AND. x[3]=="NF_BASECF2"})) > 0
    	If SF2->(FieldPos(aRelImp[nScanPis,2])) > 0
        	REPLACE SF2->&(aRelImp[nScanPis,2]) WITH nBaseCF2
      	EndIf                                                               
   	EndIf  
   	 
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Gravação do Valor do Cofins de apuração³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 	If (nScanPis := AScan(aRelImp,{|x| x[1]=="SF2" .AND. x[3]=="NF_VALCF2"})) > 0
    	If SF2->(FieldPos(aRelImp[nScanPis,2])) > 0
        	SF2->&(aRelImp[nScanPis,2]) := nValCF2
      	EndIf                                                               
   	EndIf  
   
Else
	If Upper(AllTrim(FunName())) $ "LOJA010|LOJA021"
		For nC := 1 To Len( aImpVarSF2 )
			nPosCpo := SF2->(FieldPos("F2_"+Alltrim(Substr(aImpVarSF2[nC,1],4))))
			SF2->(FieldPut(nPosCpo, Round(aImpVarSF2[nC,2],nDecimais)))
		Next nC
		nTotImpsNF  := nImpFat		
	Else
        lNoArredImp  := cPaisLoc == "CHI" .AND. nMoedaCor == 1                                           	
        nArredImp    := TamSX3("L2_VALIMP1")[2]
        aImpVarSF2   := {}
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Gravacao dos impostos no arquivo de cabecalho da NF(SF2), tratando multi-fatura ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		For nCmp := 1 To Len(aImpsSF2)
			For nCA := 1 To Len( aImpsSF2[nCmp,6] )
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Armazena no array aImpVarSF2 a base e valor dos impostos da NF ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		        If (nE := aScan( aImpVarSF2,{|x| x[1] == aImpsSF2[nCmp,6,nCA,8]   } )) == 0
					AAdd( aImpVarSF2, { aImpsSF2[nCmp,6,nCA,8], 0.00 , aImpsSF2[nCmp,6,nCA,2]  } )
					nE := Len( aImpVarSF2 )
				EndIf
                
				If lNoArredImp
				   aImpVarSF2[ nE,2 ] += Round(NoRound(aImpsSF2[nCmp,6,nCA,4],nArredImp+1),nArredImp)				
				Else
				   aImpVarSF2[ nE,2 ] += Round(NoRound(aImpsSF2[nCmp,6,nCA,4],nDecs+1),nDecs)
				EndIf   
                
				If (nE := aScan( aImpVarSF2,{|x| x[1] == aImpsSF2[nCmp,6,nCA,9]  } )) == 0
					AAdd( aImpVarSF2, { aImpsSF2[nCmp,6,nCA,9], 0.00 , aImpsSF2[nCmp,6,nCA,2]  } )
					nE := Len( aImpVarSF2 )
				EndIf

				If lNoArredImp
				   aImpVarSF2[ nE,2 ] += Round(NoRound(aImpsSF2[nCmp,6,nCA,3],nArredImp+1),nArredImp)								
				Else   
				   aImpVarSF2[ nE,2 ] += Round(NoRound(aImpsSF2[nCmp,6,nCA,3],nDecs+1),nDecs)
				EndIf   

				If Subs(aImpsSF2[nCmp,6,nCA,9],3,7) == "_BASIMP"
					cCampo := "F2"+Subs(aImpsSF2[nCmp,6,nCA,9],3,8)
					nValBas:= FieldGet(FieldPos(cCampo))
					If FieldPos( cCampo ) > 0
					   If lNoArredImp                                                                          
						  SF2->( FieldPut( FieldPos( cCampo ),nValBas+aImpsSF2[nCmp,6,nCA,3] ) )					   
					   Else                                                                                    					   
						  SF2->( FieldPut( FieldPos( cCampo ),Round(nValBas+aImpsSF2[nCmp,6,nCA,3],nDecs) ) )
					   EndIf
					Endif
				EndIf
				If Subs(aImpsSF2[nCmp,6,nCA,8],3,7) == "_VALIMP"
					cCampo := "F2"+Subs(aImpsSF2[nCmp,6,nCA,8],3,8)
					nValImp:= FieldGet(FieldPos(cCampo))
					If Substr(aImpsSF2[nCmp,6,nCA,5],2,1) == "1"  
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ O imposto soma na NF(FC_INCNOTA) ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					   If lNoArredImp                                                                          					
					      nTotImpsNF  += aImpsSF2[nCmp,6,nCA,4]
					   Else 
					      nTotImpsNF  += Round(aImpsSF2[nCmp,6,nCA,4],nDecs)					   
					   EndIf   
					EndIf
					If FieldPos( cCampo ) > 0
					   If lNoArredImp                                                                          					
						  SF2->( FieldPut( FieldPos( cCampo ), nValImp+aImpsSF2[nCmp,6,nCA,4] ) )					   
					   Else
						  SF2->( FieldPut( FieldPos( cCampo ), Round(nValImp+aImpsSF2[nCmp,6,nCA,4],nDecs) ) )
					   EndIf
					Endif
				EndIf
			Next nCA
		Next nCmp
        If Len(aImpVarSF2) > 0 .AND. lNoArredImp
           
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Arredonda os valores totais de base e valor de imposto de acordo com o moeda³
			//³Gravacao dos valores e bases dos impostos considerando o arredondamento	    ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
           	For nE := 1 to Len(aImpVarSF2)   
            	aImpVarSF2[nE][2]	:=	Round(NoRound(aImpVarSF2[nE][2],nDecs+1),nDecs)   
			  	nPosCpo := SF2->(FieldPos("F2_"+Alltrim(Substr(aImpVarSF2[nE,1],4))))
			  	If nPosCpo > 0
			    	SF2->(FieldPut(nPosCpo, aImpVarSF2[nE,2]))              
			  	EndIf   
           	Next nE		
        EndIf   
	EndIf
	If lNoArredImp
		nTotImpsNF  := Round(nTotImpsNF,nDecs)
	EndIf
	REPLACE SF2->F2_VALBRUT	WITH Round(nVlmF2 + nTotImpsNF,nRndFat)
	REPLACE SF2->F2_VALFAT 	WITH SF2->F2_VALBRUT
	REPLACE SF2->F2_TIPODOC	WITH "01" 					
	REPLACE SF2->F2_MOEDA  	WITH SL1->L1_MOEDA
	REPLACE SF2->F2_TXMOEDA	WITH SL1->L1_TXMOEDA
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Realiza a gravacao do registro fiscal, para que o mesmo seja utilizado³
	//³futuramente na geracao do livro fiscal.	                              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If (cPaisLoc == "SAL") .AND. lCredFisc .AND. ;
	   (SF2->F2_CLIENTE == SuperGetMV("MV_CLIPAD")) .AND. (SF2->F2_LOJA == SuperGetMV("MV_LOJAPAD"))
		REPLACE SF2->F2_REGFISC WITH cRegFisc	   
	EndIf	
	If cPaisLoc == "GUA" .AND. SF2->(FieldPos("F2_MANUAL")) > 0
	   REPLACE SF2->F2_MANUAL  WITH If(lNFManual,"S","N")
	EndIf		
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Nao grava o F2_NEXTDOC quando o MV_TPNRNSF for igual a "3" porque o  ³
//³ numero da nota so existe no meio da transacao, isto e, so quando o   ³
//³ proximo SF2 for gravado.                                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lFim .AND. cMV_TPNRNFS <> "3"
	nRegSf2  := RecNo()
	cNumNota := aNotas[nNotaAtu+1][2]
	cNumNota := PadR( cNumNota , nTamF2_DOC )
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Tratamento da numeracao da NF usando MayIUseCode ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If cPaisLoc <> "BRA"
	   cNumAnt  := cNumNota
       cAliasNF		:="SF2"
	   While !aNumNaoExiste(cAliasNF,cSerie,cNumNota,SF2->F2_CLIENTE,SF2->F2_LOJA,SF2->F2_ESPECIE,"LOJ")
	   	  cNumNota := PadR( StrZero(Val(cNumNota)+1,Len(AllTrim(cNumNota))) , nTamF2_DOC )	      
	   End	          	
	   If cNumAnt <> cNumNota
	      aNotas[nNotaAtu+1][2] := cNumNota
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atualizar SX5 caso o numero seja alterado ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
       EndIf
       lSeqEspecie  := SuperGetMV("MV_SEQESPE",,.F.)	
       LjLocAtuSX5(lSeqEspecie,cDocSerie)	                    
	EndIf   	
	DbSelectArea("SF2")
	dbGoTo(nRegSf2)
	REPLACE SF2->F2_NEXTDOC WITH cNumNota
EndIf
MsUnlock()

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³RetDescri ³ Autor ³ Vendas Clientes       ³ Data ³ 13/03/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Retorna a Descricao da forma de pagamento cadastrada no SX5³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ExpC1 := RetDescri( <ExpC1> )                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parƒmetros³ ExpC1 - "Chave no SX5 para a Forma.                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Sigaloja                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function RetDescri( cChave )
Local cDescricao	:= STR0053				// Dinheiro
Local aArea 		:= GetArea()

Default cChave 		:= SuperGetMV("MV_SIMB1")

*ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
*³ Descricao da forma de acordo com o SX5 ³
*ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DbSelectArea( "SX5" )
DbSeek( xFilial("SX5") + "24" )
While !Eof() .AND. SX5->X5_FILIAL == xFilial("SX5") .AND. SX5->X5_TABELA = "24"
	If AllTrim(SX5->X5_CHAVE) == Alltrim(cChave)
		cDescricao := Capital(Substr(Alltrim(X5Descri()),1,22))
		Exit
	EndIf
	DbSkip()
End

RestArea( aArea )

Return Alltrim(cDescricao)
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³GetValDev ³ Autor ³ Vendas Clientes       ³ Data ³ 06/04/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Obtem a forma de pagamento para a devolu‡„o para o cliente ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parƒmetros³ ExpN1 - Valor Total da Troca                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ ExpL1 - .T. ou .F.                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ LojA020                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GetValDev(	nVlrTroca, cNumAnt, cSerAnt, cForma )
Local oFormaDev
Local oDlgDev
Local oValorDev
Local oButton
Local oButton2

Local nValorDev 	:= 0							// Valor da troca, sera utilizado no PE LJGRVDEV()
Local nFound	 	:= 0							// Checa o valor original da venda, para gerar NCC ou trata os titulos
Local nValorOri		:= 0							// Somatoria do SE1->E1_VALOR

Local lRet		 	:= .F.							// Retorno da funcao
Local lConfNcc    	:= .F.							// Valida se gera NCC
Local lDinheiro   	:= .T.							// Valida se a forma de devolucao eh em dinheiro
Local lLjTrNcc 		:= ExistBlock("LJTRNCC")		// Valida se existe execblock LJTRNCC()
Local lFTVDTRNCC 		:= ExistBlock("FTVDTRNCC")		// Valida se existe execblock FTVDTRNCC()

Local cParcela		:= SuperGetMv("MV_1DUP")		// Parcela caso exista valor de devolucao
Local cPrefDev		:= ""							// Prefixo da devolucao

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Localizacao  - Tratamento da devolucao nas 5 moedas³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local oMoeda
Local nI			:= 0							// Auxiliar do For
Local nValorDev1 	:= 0							// Valor a devolver na moeda 1
Local nValorDev2 	:= 0							// Valor a devolver na moeda 2
Local nValorDev3 	:= 0							// Valor a devolver na moeda 3
Local nValorDev4 	:= 0							// Valor a devolver na moeda 4
Local nValorDev5 	:= 0							// Valor a devolver na moeda 5
Local nDecs			:= MsDecimais(1)				// Quantidade de casas decimais
Local cMoeda1 		:= SuperGetMV( "MV_MOEDA1" )	// Titulo da moeda 1
Local cMoeda2 		:= SuperGetMV( "MV_MOEDA2" )	// Titulo da moeda 2
Local cMoeda3 		:= SuperGetMV( "MV_MOEDA3" )	// Titulo da moeda 3
Local cMoeda4 		:= SuperGetMV( "MV_MOEDA4" )	// Titulo da moeda 4
Local cMoeda5 		:= SuperGetMV( "MV_MOEDA5" )	// Titulo da moeda 5
Local cPrefixo      := LJPREFIXO()					// Prefixo
Local cE1Num 		:= ""							// Numero do Titulo
Local cMvLjPref		:= SuperGetMv( "MV_LJPREF" )	// Regra para gravacao do SF2->F2_PREFIXO
Local cMvSimb1		:= SuperGetMv( "MV_SIMB1") 		// Simbolo da moeda 1
Local cMvDevNCC		:= SuperGetMv( "MV_DEVNCC")		// Indica se gera Nota de credito
Local lQtdDif       := .F.							// Valida se houve diferenca na quantidade
Local cMV_TPNRNFS	:= LjTpNrNFS()					// Retorno do parametro MV_TPNRNFS, utilizado pela Sx5NumNota() de onde serah controlado o numero da NF  1=SX5  2=SXE/SXF  3=SD9
Local nTamE1Parc    := TamSX3("E1_PARCELA")[1]		//Tamanho do campo
Local lFtvdVer12	:= LjFTVD() //Verifica se é Release 11.7 e o FunName é FATA701 - Compatibilização Venda Direta x Venda Assisitida
Local aDadosBanc 		:= {}							//array com dados de ag e conta CADASTRADOS Na SA6
Local cCaixa		:= xNumCaixa()

cNumAnt := PadR(cNumAnt,TamSX3("E1_NUM")[1])

Private cFormaDev := If( lTrocLoja,If( Empty( SL1->L1_FORMPG ),cMvSimb1,Trim( SL1->L1_FORMPG ) ),cMvSimb1 )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Abaixo segue a mesma regra utilizada para a gravacao do campo E1_PREFIXO quando L1_TIPO == "P"³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If SL1->L1_TIPO=="P"

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se o parametro foi alterado, pois qdo eh gerado um pedido nao  ³
	//³eh feita a gravacao do SF2, sendo impossivel gravar o SF2->F2_SERIE     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Alltrim( Upper( cMvLjPref ) ) == "SF2->F2_SERIE"
		cPrefixo	:= If( Empty( SL1->L1_SERIE ), SL1->L1_SERPED, SL1->L1_SERIE )
	Else
		cPrefixo	:= &(cMvLjPref)
	Endif
Endif

cE1Num := LJ7NumTit()

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Pesquisa titulo no SE1                           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DbSelectArea("SE1")
DbSetOrder(1)				// Filial + Prefixo + Num + Parcela + Tipo

If lTrocLoja .AND. DbSeek( xFilial( "SE1" ) + cPrefixo + cE1Num )
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se o titulo foi processado pela rotina "Faturas a Receber". Se    ³
	//³ afirmativo nao faz a busca no titulo pois essa rotina tem a possibilidade  ³
	//³ de aglutinar varios titulos em um unico                                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SE1->E1_FILIAL  == xFilial("SE1") 	.AND.;
			SE1->E1_PREFIXO == cPrefixo  	.AND.;
			SE1->E1_NUM == cE1Num 			.AND.;
			Empty(SE1->E1_FATURA) 			.AND.;
			Empty(SE1->E1_DTFATUR)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se j  foi pago ao menos 1 parcela		 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		While !Eof() .AND. SE1->E1_FILIAL  == xFilial( "SE1" ) .AND.;
			SE1->E1_PREFIXO	== cPrefixo  .AND.;
			SE1->E1_NUM		== cE1Num
		
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Checando valor original da venda, para ver se gera nota de credito ou trata os titulos³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nValorOri := nValorOri + SE1->E1_VALOR
			DbSelectArea( "SE5" )
			DbSetOrder( 2 )
			If DbSeek(xFilial( "SE5" ) + "LJ" + SE1->E1_PREFIXO + SE1->E1_NUM + SE1->E1_PARCELA + SE1->E1_TIPO) .OR.;
			   DbSeek(xFilial( "SE5" ) + "VL" + SE1->E1_PREFIXO + SE1->E1_NUM + SE1->E1_PARCELA + SE1->E1_TIPO) .OR.;
			   DbSeek(xFilial( "SE5" ) + "CP" + SE1->E1_PREFIXO + SE1->E1_NUM + SE1->E1_PARCELA + SE1->E1_TIPO)
				nFound := nFound + 1
			EndIf
		
			DbSelectArea("SE1")
		
			DbSkip()
		End
	
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ\¿
		//³Localizacoes - Compara a Qtde Atual dos produtos com a qtde anterior a devolucao³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ\Ù
		For nI := 1 to Len( aCols )
			If !aCols[nI][Len(aCols[nI])]
				If aQtde[nI] <> aCols[nI][nPosQuant]
					lQtdDif := .T.
					Exit
				EndIf
			Else   
				lQtdDif := .T.
				Exit
			Endif
		Next nI 

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Ponto de entrada para alterar o valor total da troca. Para os casos³
		//³de customizacao no ato da venda da alteracao no valor do titulo,   ³
		//³assim qdo devolvido, faz o acerto do financeiro com o valor vendido³
		//³ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
		//³Parametros:[1] - Prefixo do titulo                                 ³
		//³           [2] - Numero do titulo                                  ³
		//³           [3] - Somatoria  do valor dos titulos                   ³
		//³           [4] - Valor que esta sendo trocado                      ³
		//³Retorno: Valor que esta sendo trocado                              ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ExistBlock("GETVALDV") .AND. !lFtvdVer12
			nVlrTroca := ExecBlock("GETVALDV",.F.,.F.,{ cPrefixo, cE1Num, nValorOri, nVlrTroca } )
		Endif
		
		If ExistBlock("ftvdVALDV") .AND. lFtvdVer12
			nVlrTroca := ExecBlock("ftvdVALDV",.F.,.F.,{ cPrefixo, cE1Num, nValorOri, nVlrTroca } )
		Endif
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Se o valor eh diferente, entao significa que eh Troca Parcial.³
		//³Gerar nota de credito, caso contrario trata os titulos        ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If nValorOri <> nVlrTroca .AND. lQtdDif
			nFound := -1
		Else
			lRet := .T.
			nFound := 1
		Endif
	Else
		nFound := 1
	Endif
Else
	nFound := 1
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica qual a forma de pagamento que ira gerar um t¡tulo a pagar para a devolucao  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If (lLjTrNcc .AND. !lFtvdVer12) .OR. (lFTVDTRNCC .AND. lFtvdVer12)
	If !lFtvdVer12 
		lRet := ExecBlock("LJTRNCC",.F.,.F.)
	ElseIf lFtvdVer12
		lRet := ExecBlock("FTVDTRNCC",.F.,.F.)
	EndIf	
Else

	If nFound <> 0 .OR. SuperGetMV("MV_DEVNCC") == "4"
		If cPaisLoc == "BRA"
			lRet		:= .F.
			nValorDev	:= nVlrTroca            
			If (ExistBlock("LJGRVDEV") .AND. !lFtvdVer12) .OR. (ExistBlock("FTVDGRVDEV") .AND. lFtvdVer12)
				If !lFtvdVer12
					lRet := ExecBlock("LJGRVDEV",.F.,.F.,{nValorDev } )
				ElseIf lFtvdVer12
					lRet := ExecBlock("FTVDGRVDEV",.F.,.F.,{nValorDev } )
				EndIf	
			Else

				DEFINE MSDIALOG oDlgDev TITLE STR0054 From 10,30 To 15,64 OF GetWndDEFAULT()	// Devolu‡„o (Forma de pagamento)
			
				@ 0,1 TO 22,130 OF oDlgDev PIXEL
			
				@ 8.5,  3 Say STR0055 of oDlgDev PIXEL SIZE 25,8  // Forma
				@ 8.5, 46 Say STR0056 of oDlgDev PIXEL SIZE 50,8 // Valor a devolver
			
				@ 6, 22 MSGET oFormaDev VAR cFormaDev F3 "24" PICT "!!";
				SIZE 10,6 OF oDlgDev  PIXEL  RIGHT ;
				VALID ( ExistCpo("SX5","24"+cFormaDev))

				@ 6, 90 MSGET oValorDev VAR nValorDev PICT "@E 9,999,999.99";
				SIZE 35,6 OF oDlgDev  PIXEL  RIGHT WHEN .F.
			
				DEFINE SBUTTON oButton FROM 24,70 TYPE 1 ACTION (lRet:=If(SuperGetMV("MV_LJVLDEV",.F.),;
				LjVSaldo(nValorDev,cFormaDev),.T.),;
				oDlgDev:End()) ENABLE OF oDlgDev
				DEFINE SBUTTON oButton2 FROM 24,100 TYPE 2 ACTION (lRet:= .F.,;
				oDlgDev:End()) ENABLE OF oDlgDev
				ACTIVATE MSDIALOG oDlgDev CENTERED
			EndIf
		Else
			lRet		:= .F.
			nValorDev	:= Round(nVlrTroca,MsDecimais(nMoedaTr))
			lDinheiro	:= IsMoney(cFormaDev)
			cFormaDev	:= Padr(cFormaDev,3)

			DEFINE MSDIALOG oDlgDev TITLE STR0054 From 10,30 To 27,64 OF GetWndDEFAULT()	//Devolu‡„o (Forma de pagamento)
			
			@ 0,1 TO 22,130 OF oDlgDev PIXEL
			
			@ 8.5,  3 Say STR0055 of oDlgDev PIXEL SIZE 25,8  // Forma
			@ 8.5, 46 Say STR0056 of oDlgDev PIXEL SIZE 50,8 // Valor a devolver
			
			@ 6, 22 MSGET oFormaDev VAR cFormaDev F3 "24" PICT "@!";
			SIZE 10,6 OF oDlgDev  PIXEL  RIGHT ;
			VALID (ExistCpo("SX5","24" + Trim( cFormaDev )),lDinheiro := IsMoney(cFormaDev),;
			       oValorDev:Refresh(),oMoeda:Refresh())
			@ 6, 90 MSGET oValorDev VAR nValorDev PICT "@E 9,999,999.99";
			SIZE 35,6 OF oDlgDev  PIXEL  RIGHT WHEN .F.
			
			@ 34, 22 MSGET oMoeda 		VAR cMoeda1 SIZE 50,6 OF oDlgDev PIXEL WHEN .F.
			@ 34, 75 MSGET oValorDev 	VAR nValorDev1 PICT "@E 9,999,999.99" SIZE 50,6 OF oDlgDev  PIXEL  RIGHT WHEN lDinheiro .AND. !Empty(cMoeda1)
			
			@ 46, 22 MSGET oMoeda		VAR cMoeda2 SIZE 50,6 OF oDlgDev PIXEL WHEN .F.
			@ 46, 75 MSGET oValorDev 	VAR nValorDev2 PICT "@E 9,999,999.99" SIZE 50,6 OF oDlgDev  PIXEL  RIGHT WHEN lDinheiro  .AND. !Empty(cMoeda2)
			
			@ 58, 22 MSGET oMoeda		VAR cMoeda3 SIZE 50,6 OF oDlgDev PIXEL WHEN .F.
			@ 58, 75 MSGET oValorDev 	VAR nValorDev3 PICT "@E 9,999,999.99" SIZE 50,6 OF oDlgDev  PIXEL  RIGHT WHEN lDinheiro .AND. !Empty(cMoeda3)
			
			@ 70, 22 MSGET oMoeda		VAR cMoeda4 SIZE 50,6 OF oDlgDev PIXEL WHEN .F.
			@ 70, 75 MSGET oValorDev 	VAR nValorDev4 PICT "@E 9,999,999.99" SIZE 50,6 OF oDlgDev  PIXEL  RIGHT WHEN lDinheiro .AND. !Empty(cMoeda4)
			
			@ 82, 22 MSGET oMoeda		VAR cMoeda5 SIZE 50,6 OF oDlgDev PIXEL  WHEN .F.
			@ 82, 75 MSGET oValorDev	VAR nValorDev5 PICT "@E 9,999,999.99" SIZE 50,6 OF oDlgDev  PIXEL  RIGHT WHEN lDinheiro .AND. !Empty(cMoeda5)
			
			DEFINE SBUTTON oButton FROM 100,70 TYPE 1 ACTION (lRet:=If(SuperGetMV("MV_LJVLDEV",.F.),	LjVSaldo(nValorDev,Trim(cFormaDev)),;
			lRet:= .T.),If(lRet,lRet:= ( !lDinheiro .OR. CalcMoedOk(nValorDev,@nValorDev1, nValorDev2,nValorDev3,;
			nValorDev4, nValorDev5 )) ,oDlgDev:End()),IF(lRet, oDlgDev:End(), NIL )) ENABLE OF oDlgDev
			DEFINE SBUTTON oButton2 FROM 100,100 TYPE 2 ACTION (lRet:= .F.,;
			oDlgDev:End()) ENABLE OF oDlgDev
			ACTIVATE MSDIALOG oDlgDev CENTERED
		Endif
	EndIf
EndIf

cForma := cFormaDev

If lRet .AND. cFormPro == "S" 
   //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
   //³ Faz um tratamento diferenciado para o controle de NF pelo SD9 quando ³
   //³ o parametro MV_TPNRNFS for igual a "3"                               ³
   //ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
   If cMV_TPNRNFS == "3"
      cSerieDev := Padr(SuperGetMV("MV_LJNFTRO"),3)
	  cNumTroc  := MA461NumNf( .T., cSerieDev )
   EndIf					

   If Empty( cNumTroc ) .AND. Empty( cSerieDev )
	  lRet := LjxANota( Padr( SuperGetMv( "MV_LJNFTRO" ),3 ) )
   EndIf	 
EndIf

If lRet
	
	If (nValorDev > 0 .AND. !lLjTrNcc .AND. !lFtvdVer12) .OR. ( nValorDev > 0 .AND. !lFTVDTRNCC .AND. lFtvdVer12)
		If cMvDevNCC == "4"
			lConfNcc := .T.
		ElseIf Trim( cFormaDev ) = cMvSimb1 .OR. SuperGetMv( "MV_DEVNCC" ) == "1"
			lConfNcc := .F.
		ElseIf cMvDevNCC == "2"
			lConfNcc := .T.
		ElseIf cMvDevNCC == "3"
			lConfNcc := MsgYesNo(STR0081,STR0085)  //"Deseja Gerar NCC(Nota de Credito ao Cliente) para o Financeiro"  "Gera NCC"
		EndIf
	EndIf
			
	BEGIN TRANSACTION
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Gera um t¡tulo baixado no SE5 ³
	//³	 e NCC para o financeiro      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nValorDev > 0
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Criando e Baixando NCC por devolu‡Æo para nÆo mexer com Saldo Bancario³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cPrefDev	:= cSerieDev
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Ponto de Entrada para gravacao do prefixo no SE1 e SE5, havia duplicidade na chave quando SX6 exclusivo e SE1 compartilhado ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ExistBlock("LJPRFDEV") .AND. !lFtvdVer12
			cPrefDev	:= ExecBlock("LJPRFDEV",.F.,.F.)
			If ValType( cPrefDev ) <> "C"
				cPrefDev	:= cSerieDev
			Endif
		Endif
			
		If ExistBlock("FTVDPRFDEV") .AND. lFtvdVer12
			cPrefDev	:= ExecBlock("FTVDPRFDEV",.F.,.F.)
			If ValType( cPrefDev ) <> "C"
				cPrefDev	:= cSerieDev
			Endif
		Endif
		
		aDadosBanc := GetAdvFVal( "SA6", { "A6_AGENCIA", "A6_NUMCON" },xFilial("SA6")+cCaixa, 1, { ".", "."} )		//³ Busca AG e conta cadastrados na SA6
			
		If lConfNcc
			While SE1->(DbSeek(cFilial + cSerAnt + cNumAnt + PadR(cParcela, nTamE1Parc) + "NCC"))
				cParcela := CHR(ASC(cParcela)+1) 
			End
			RecLock("SE1",.T.)
			REPLACE E1_FILIAL	WITH cFilial
			REPLACE E1_PREFIXO	WITH cPrefDev
			REPLACE E1_NUM		WITH cNumTroc
			REPLACE E1_PARCELA	WITH cParcela
			REPLACE E1_NATUREZ	WITH &(SuperGetMv( "MV_NATNCC" ))		// NOTA DE CREDITO
			REPLACE E1_PORTADO	WITH cCaixa
			REPLACE E1_AGEDEP	WITH aDadosBanc[1]
			REPLACE E1_CONTA	WITH aDadosBanc[2]
			REPLACE E1_TIPO		WITH MV_CRNEG
			REPLACE E1_EMISSAO	WITH dDataBase
			REPLACE E1_EMIS1	WITH dDataBase
			REPLACE E1_VALOR	WITH nValorDev
			REPLACE E1_VENCREA	WITH dDataBase
			REPLACE E1_SALDO	WITH nValorDev
			REPLACE E1_VENCTO	WITH dDataBase
			REPLACE E1_VENCORI	WITH ddataBase
			REPLACE E1_CLIENTE	WITH cCliente
			REPLACE E1_LOJA		WITH cLoja
			REPLACE E1_NOMCLI	WITH Posicione( "SA1",1,xFilial( "SA1" ) + cCliente + cLoja,"SA1->A1_NREDUZ" )
			REPLACE E1_MOEDA	WITH 1
			REPLACE E1_VLCRUZ	WITH xMoeda( SE1->E1_VALOR,1,1,SE1->E1_EMISSAO )
			REPLACE E1_STATUS	WITH If( SE1->E1_SALDO > 0.01,"A","B" )
			REPLACE E1_SITUACA	WITH "0"
			REPLACE E1_ORIGEM	WITH "LOJA020"
			REPLACE E1_SERIE	WITH cSerieDev
			REPLACE E1_FILORIG	WITH cFilAnt
			REPLACE E1_MULTNAT	WITH "2"
			REPLACE E1_FLUXO	WITH "N"
			dbCommit()
			MsUnlock()

		Endif
		
		If cPaisLoc == "BRA"
			If !lConfNcc
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Cria registro de movimentacao no E5 para acerto do numerario³  
				//³devolvido no pelo caixa somente quando nao for gerada NCC   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				RecLock("SE5",.T.)
				REPLACE SE5->E5_FILIAL	WITH xFilial("SE5")
				REPLACE SE5->E5_PREFIXO	WITH cSerieDev
				REPLACE SE5->E5_NUMERO	WITH cNumTroc
				REPLACE SE5->E5_PARCELA	WITH cParcela
				REPLACE SE5->E5_CLIFOR	WITH cCliente
				REPLACE SE5->E5_LOJA	WITH cLoja
				REPLACE SE5->E5_DOCUMEN	WITH cSerieDev + cNumTroc + cParcela + cFormaDev + cLoja
				REPLACE SE5->E5_DATA	WITH dDataBase
				REPLACE SE5->E5_AGENCIA	WITH aDadosBanc[1]
				REPLACE SE5->E5_TIPODOC	WITH "LJ"
				REPLACE SE5->E5_TIPO	WITH cFormaDev
				REPLACE SE5->E5_HISTOR	WITH STR0068						//"BAIXA REF. DEVOL. TROCA"
				REPLACE SE5->E5_VALOR	WITH nValorDev
				REPLACE SE5->E5_DTDIGIT	WITH dDataBase
				REPLACE SE5->E5_NATUREZ	WITH &(SuperGetMv( "MV_NATDEV" ))	// DEV./TROCA
				REPLACE SE5->E5_DTDISPO	WITH SE5->E5_DATA
				REPLACE SE5->E5_BANCO	WITH cCaixa
				REPLACE SE5->E5_CONTA	WITH aDadosBanc[2]
				REPLACE SE5->E5_VENCTO	WITH dDataBase
				REPLACE SE5->E5_RECPAG	WITH "P"
				REPLACE SE5->E5_MOTBX	WITH "NOR"
				REPLACE SE5->E5_BENEF	WITH cUserName
				dbCommit()
				MsUnLock()
			Endif
		Else
			For nI := 1 to MoedFin()
				nValorDev := Eval( MemVarBlock( 'nValorDev' + Str( nI, 1 ) ) )
				If nValorDev > 0
					RecLock("SE5",.T.)
					REPLACE SE5->E5_FILIAL	WITH xFilial("SE5")
					REPLACE SE5->E5_PREFIXO	WITH cSerieDev
					REPLACE SE5->E5_NUMERO	WITH cNumTroc
					REPLACE SE5->E5_PARCELA	WITH cParcela
					REPLACE SE5->E5_CLIFOR	WITH cCliente
					REPLACE SE5->E5_LOJA    WITH cLoja
					REPLACE SE5->E5_DOCUMEN WITH cSerieDev + cNumTroc + cParcela + cFormaDev + cLoja
					REPLACE SE5->E5_DATA    WITH dDataBase
					REPLACE SE5->E5_AGENCIA WITH If (nI == 1, aDadosBanc[1],SuperGetMV( "MV_SIMB" + Str( nI, 1 ) ))
					REPLACE SE5->E5_TIPODOC WITH "LJ"
					REPLACE SE5->E5_TIPO    WITH cFormaDev
					REPLACE SE5->E5_HISTOR  WITH STR0068  					//"BAIXA REF. DEVOL. TROCA"
					REPLACE SE5->E5_VALOR   WITH nValorDev
					REPLACE SE5->E5_DTDIGIT WITH dDataBase
					REPLACE SE5->E5_NATUREZ WITH &(SuperGetMV( "MV_NATDEV" ))	// DEV./TROCA
					REPLACE SE5->E5_DTDISPO WITH SE5->E5_DATA
					REPLACE SE5->E5_BANCO	WITH cCaixa
					REPLACE SE5->E5_CONTA	WITH aDadosBanc[2]
					REPLACE SE5->E5_VENCTO 	WITH dDataBase
					REPLACE SE5->E5_RECPAG 	WITH "P"
					REPLACE SE5->E5_MOTBX	WITH "NOR"
					REPLACE SE5->E5_BENEF	WITH cUserName
					REPLACE SE5->E5_MOEDA 	WITH StrZero( nI, 2 )
					REPLACE SE5->E5_VLMOED2	WITH Round(xMoeda(nValorDev, nI, 1, dDatabase,nDecs+1),nDecs)
					DbCommit()
					MsUnLock()
				EndIf
			Next nI
		EndIf
	EndIf
	
	END TRANSACTION
EndIf

Return (lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³LjSetAliq ³ Autor ³ Vendas Clientes       ³ Data ³ 08/08/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Carrega aliquotas da impressora fiscal para aIcms          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³                                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Sigaloja                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LjSetAliq(cTipo)
Local nRet := -1				// Retorno das funcoes da impressora
Local cAliquotas := Space(100)	// Armazena as aliquotas
Local aAliq := {}				// Retorno da funcao
Local nPos := 0					// Tamanho da string da aliquota

If PCount() = 0
	cTipo = 'ICMS'
Endif

If cTipo == 'ICMS'
	nRet := IFLeAliq( nHdlECF, @cAliquotas )
Else
	nRet := IFLeAliIss( nHdlECF, @cAliquotas )
Endif

If 'SCHALTER' $ LjGetStation( 'IMPFISC' ) 
	nRet := IFLeAliq( nHdlECF, @cAliquotas ) 
	While .T.
		nPos := At('|',cAliquotas)
		If nPos > 0
			aAdd( aAliq, { SubStr(cAliquotas,1,nPos-1) } )
			cAliquotas := SubStr(cAliquotas,nPos+1,Len(cAliquotas))
		Else
			If !Empty( cAliquotas )
				aAdd( aAliq, { Val(cAliquotas) } )
			Endif
			exit
		Endif
    End
Else
	If cTipo == 'ICMS'
		nRet := IFLeAliq( nHdlECF, @cAliquotas )
	Else
		nRet := IFLeAliIss( nHdlECF, @cAliquotas )
	Endif
	
	While .T.
		nPos := At('|',cAliquotas)
		If nPos > 0
			aAdd( aAliq, { Val(SubStr(cAliquotas,1,nPos-1)) } )
			cAliquotas := SubStr(cAliquotas,nPos+1,Len(cAliquotas))
		Else
			If !Empty( cAliquotas )
				aAdd( aAliq, { Val(cAliquotas) } )
			Endif
			exit
		Endif
	End
End

Return(aAliq)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ A010QtdGra³ Autor ³ Vendas Clientes       ³ Data ³ 04.09.98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Efetua a entrada de dados da quantidade quando a grade      ³±±
±±³          ³ esta ativa                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Loja010                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function A010QTDGRA()
Local lRet		:= .T.
Local aTam		:= {}
Local cProdGrd 	:= ""
Local cGrade
Local lSoma     := .T.
Local nOpca     := 3
Local oDlg
Local oGetGra
Local cTitle
Local cDescGrd
Local aRots

// Desabilitando getdados de tras
oGet:oBrowse:lDisablePaint:= .T.

//Armazena o codigo do produto...
If (nX := aScan(aHeader,{|x| Trim(x[2])== "L2_PRODUTO"})) > 0
	cProdGrd:= aCols[n][nX]
EndIf 

//Armazena se o produto pertence a grade ou nao...
If (nX := aScan(aHeader,{|x| Trim(x[2])== "L2_GRADE"})) > 0
	cGrade := aCols[n][nX]
EndIf
                                                  
//Armazena a descricao do produto...
If (nX := aScan(aHeader,{|x| Trim(x[2])== "L2_DESCRI"})) > 0
	cDescGrd := Alltrim(aCols[n][nX])
EndIf

//N„o e produto de grade
If cGrade <> "S" .OR. lVendaRapida
	oGet:oBrowse:lDisablePaint:= .F.
	Return .T.
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Arrays auxiliares para armazenar a getdados principal³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aHeadAux:=Aclone(aHeader)
aColsAux:=Aclone(aCols)
nAux	  :=n

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³  Verifica qual o tamanho do campo							³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aTam		:= TamSX3("L2_QUANT")
cProdRef := Substr(cProdGrd,1,nTamRef)  + Space(nTamLin+nTamCol)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se a grade esta ativa								³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lGrade
	lRet:=a010Mont(n,cProdGrd,cGrade)
	If lRet
		cTitle:="Grade do Produto ("+Alltrim(cProdGrd)+" - "+cDescGrd+" )"
		DEFINE MSDIALOG oDlg TITLE cTitle FROM 10,10 TO 25,68	 OF oMainWnd
		aHeader:=Aclone(aHeadGrade[n])
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Monta o acols conforme dados dos SC6						³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aCols  :=a010Acols()
		If Type("aRotina") =="A"
			aRots := aClone(aRotina)
		Endif
		aRotina := MenuDef()
		oGetGra:=MSGetDados():New(20,12,103,223,1,"AllwaysTrue","AllwaysTrue",,.T.,aAltGr)
		SetKey(VK_F4, {|| A010Saldo(oGetGra)})
		ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||nopca:=1,oDlg:End()},{||nOpca:=3,oDlg:End()})
		If aRots<>Nil
			aRotina :=aClone(aRots)
		Endif
		SetKey(VK_F4, NIL)
		
		If Inclui .OR. Altera
			If nOpcA == 1
				aHeadGrade[nAux]:=Aclone(aHeader)
				lMonta	:=.F.
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Monta o acols conforme dados dos SL2						³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				a010Acols()
				lMonta	:=.T.
				aHeader	:={}
				aCols 	:={}
				aHeader	:=aClone(aHeadAux)
				aCols 	:=aClone(aColsAux)
				n			:=nAux
				
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³  Soma as quantidades digitadas na getdados da grade	³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				a010Soma(nAux,cProdGrd)
				lSoma := .F.
			ElseIf nOpca == 3
				lAlterou := .F.
				a010Mont(nAux,cProdGrd,cGrade)
				aHeader	:={}
				aCols 	:={}
				aHeader	:=aClone(aHeadAux)
				aCols 	:=aClone(aColsAux)
				n			:=nAux
				
			Endif
		Endif
	Else
		lRet:=.T.
	Endif
Endif

// Habilitando getdados de tras
oGet:oBrowse:lDisablePaint:= .F.

Return (lRet)            
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    |MenuDef	³ Autor ³ Vendas Clientes       ³ Data ³13/12/06  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Funcao de definição do aRotina                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ aRotina   retorna a array com lista de aRotina             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ SIGALOJA                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function MenuDef() 
Local aRotina:= {		{"","",0,6 , , .T.}}
							
							
Return(ARotina)
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ A010Mont  ³ Autor ³ Vendas Clientes       ³ Data ³ 04.09.98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Monta o aHeadGrade e o AcolsGrade                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ Numero da Linha do acols                                    ³±±
±±³Descri‡„o ³ Codigo do Produto                                           ³±±
±±³Descri‡„o ³ Se e' um item de grade ou nao(c6_grade)                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Loja010A                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function a010Mont( nCnt, cProdGrd, cGrade )
Local nJaExiste := 0
Local i
Local nX
Local lRet		:= .T.
Local nColunas  := 1
Local nLinhas   := 0
Local cAlias	:= Alias()
Local aTam		:= TamSX3("L2_QUANT")        // Tamanho do campo L2_QUANT

nCnt	:= If(nCnt == Nil,n,nCnt)
DbSelectArea("SB4")
DbSetOrder(1)
DbSeek(xFilial("SB4")+cProdGrd)

DbSelectArea("SX5")
DbSetOrder(1)
DbSeek(xFilial()+SB4->B4_LINHA)
While !Eof() .AND. (X5_TABELA == SB4->B4_LINHA)
	Aadd(aDescLin,Substr(X5_CHAVE,1,nTamLin))
	DbSkip()
End

DbSelectArea("SB4")
DbSetOrder(1)
DbSeek(xFilial()+cProdGrd)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se ja existe array para	³
//³ este item									³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nJaExiste := 0
For nx:=1 to Len(aHeadGrade)
	If nx == nCnt
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Quando existe, verifica se o array era de um produto 	 ³
		//³ referencia, se ja era ok, se nao deve criar o array de	 ³
		//³ novo 																	 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nJaExiste := nx
		If lAlterou
			aListaProd[nCnt]:=cProdGrd
			aDel(aHeadGrade,nCnt)
			aDel(aColsGrade,nCnt)
			aIns(aHeadGrade,nCnt)
			aIns(aColsGrade,nCnt)
			DbSelectArea("SX5")
			DbSeek(xFilial()+SB4->B4_COLUNA)
			aHeadGrade[nCnt]:={}
			AADD(aHeadGrade[nCnt],{})
			aHeadGrade[nCnt][1]:={Replicate("_",aTam[1]),"R","@!",aTam[1],0," ","û", "C"," "," " }
			
			While !EOF() .AND. (x5_tabela == SB4->B4_COLUNA)
				nColunas++
				AADD(aHeadGrade[nCnt],{})
				aHeadGrade[nCnt][nColunas]:= {Alltrim(X5Descri()),"_"+Substr(X5_CHAVE,1,nTamCol),PesqPictQt("L2_QUANT",14),;
				aTam[1],aTam[2],"A010GValid(cProdRef)","û", "C"," "," " }
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Alimenta este array apenas nas ro- ³
				//³ tinas de inclusao e alteracao com	³
				//³ as colunas passiveis de alteracao	³
				//³ no caso de exclusao e visualizacao ³
				//³ nenhum campo da grade pode ser al- ³
				//³ rado,entao este array deve ser sem-³
				//³ pre vazio. 								³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If Inclui .OR. Altera
					AADD(aAltGr,"_"+Substr(X5_CHAVE,1,ntamCol))
				Else
					aAltGr:={}
				Endif
				DbSkip()
			End
			DbSelectArea("SX5")
			DbSeek(xFilial()+SB4->B4_LINHA)
			nCont:=0
			While !Eof() .AND. (x5_tabela == SB4->B4_LINHA)
				nCont++
				DbSkip()
			End
			DbSelectArea("SX5")
			DbSeek(xFilial()+SB4->B4_LINHA)
			nLinhas:=0
			nCont:=0
			aColsGrade[nCnt]:={}
			While !EOF() .AND. (x5_tabela == SB4->B4_LINHA)
				nCont++
				For i:=1 to nColunas
					If i == 1
						AADD(aColsGrade[nCnt],{})
						AADD(aColsGrade[nCnt][nCont],Alltrim(X5Descri()))
					Else
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ C6_QTDVEN,C6_QTDLIB,(C6_QTDEMP+C6_QTDENT)		  ³
						//³ o penultimo array usado apenas para digitacao da ³
						//³ quantidade liberada na alteracao do pedido		  ³
						//³ o ultimo elemento C6_item 							  ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						AADD(aColsGrade[nCnt][nCont],{0,0,0,"T","0"})
					Endif
				Next i
				nLinhas:=0
				AADD(aColsGrade[nCnt][nCont],.F.)
				DbSkip()
			End
		Endif
		Exit
	Endif
Next nx

If nJaExiste <= 0
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Ajuste de posicionamento do array aHeadGrade com o aCols³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	
	While Len(aHeadGrade) < nCnt
		AADD(aHeadGrade,{})
	end
	AADD(aHeadGrade[nCnt],{Replicate("_",aTam[1]),"R","@!",aTam[1],0," ","û", "C"," "," " })
	DbSelectArea("SX5")
	DbSeek(xFilial()+SB4->B4_COLUNA)
	While !EOF() .AND. (x5_tabela == SB4->B4_COLUNA)
		nColunas++
		AADD(aHeadGrade[nCnt],{ Alltrim(X5Descri()),"_"+Substr(X5_CHAVE,1,nTamCol),PesqPictQt("L2_QUANT",14),;
		aTam[1],aTam[2],"A010GValid(cProdRef)","û", "C"," "," "} )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Alimenta este array apenas nas ro- ³
		//³ tinas de inclusao e alteracao com	³
		//³ as colunas passiveis de alteracao	³
		//³ no caso de exclusao e visualizacao ³
		//³ nenhum campo da grade pode ser al- ³
		//³ rado,entao este array deve ser sem-³
		//³ pre vazio. 								³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Inclui .OR. Altera
			AADD(aAltGr,"_"+Substr(X5_CHAVE,1,ntamCol))
		Else
			aAltGr:={}
		Endif
		DbSkip()
	End
	DbSelectArea("SX5")
	DbSeek(xFilial()+SB4->B4_LINHA)
	nCont:=0
	While !Eof() .AND. (x5_tabela == SB4->B4_LINHA)
		nCont++
		DbSkip()
	End
	DbSelectArea("SX5")
	DbSeek(xFilial()+SB4->B4_LINHA)
	nLinhas:=0
	nCont:=0
	AADD(aColsGrade,{})
	While !EOF() .AND. (x5_tabela == SB4->B4_LINHA)
		nCont++
		For i:=1 to nColunas
			If i == 1
				AADD(aColsGrade[nCnt],{})
				AADD(aColsGrade[nCnt][nCont],Alltrim(X5Descri()))
			Else
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ C6_QTDVEN,C6_QTDLIB,(C6_QTDEMP+C6_QTDENT)		  ³
				//³ o penult.array usado apenas para digitacao da	  ³
				//³ quantidade liberada na alteracao do pedido		  ³
				//³ o ultimo elemento C6_item 							  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				AADD(aColsGrade[nCnt][nCont],{0,0,0,"T","0"})
			Endif
		Next i
		AADD(aColsGrade[nCnt][nCont],.F.)
		DbSkip()
	End
Endif
lAlterou := .F.

DbSelectArea(cAlias)

Return (lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ A010GValid³ Autor ³ Vendas Clientes       ³ Data ³ 04.09.98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Verifica se o produto da grade existe                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Loja010                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function a010GValid(cProdRef)
Local lRet	  :=.T.
Local cProdGrd:=""
Local cAlias  :=Alias()
Local i		  := 0
Local nQtdGra :=&(ReadVar())
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Posiciona na Coluna Correta ³
//³ para verificar conteudo	  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For i :=1 to Len(aHeader)
	If Alltrim(aHeader[i][2]) == Alltrim(Substr(Readvar(),4) )
		Exit
	Endif
Next i

cProdGrd := Substr(cProdRef,1,nTamRef) + aDescLin[n]+SubStr( aHeader[i][2],2 )
cProdGrd := cProdGrd+Space(15-Len(cProdGrd) )

DbSelectArea("SB1")
DbSetOrder(1)
DbSeek(xFilial()+cProdGrd)
If !Found()
	HELP(" ",1,"NAOEXISTE")
	lRet:=.F.
	aCols[n][i]:=0
	&cVar:=0
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se havia valor e   ³
//³ foi zerado 					  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If (nQtdGra == 0 .AND. aColsGrade[nAux][n][i][1] > 0)
	aColsGrade[nAux][n][i][4]:= "F"
ElseIf (nQtdGra == 0 .AND. aColsGrade[nAux][n][i][1] == 0)
	aColsGrade[nAux][n][i][4]:="T"
ElseIf nQtdGra > 0 .AND. aColsGrade[nAux][n][i][1] == 0
	If Altera
		aColsGrade[nAux][n][i][4]:="N"
	Else
		aColsGrade[nAux][n][i][4]:="F"
	Endif
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se ha saldo em esto³
//³ que caso MV_EstNeg          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

If SuperGetMV("MV_ESTNEG") == "N"
	DbSelectArea( "SB1" )
	DbSeek( xFilial("SB1") + cProdGrd )
	DbSelectArea( "SB2" )
	DbSeek( xFilial("SB2") + cProdGrd )
	If SldBlqSB2()
		If (Eof() .OR. SB2->B2_QATU < nQtdGra)
			Help(" ",1,"SALDOINSUL")
			MsgInfo( AllTrim(cProdGrd ) + " - " + AllTrim(SB1->B1_DESC) ,STR0087)
			lRet	:=.F.
		Endif
	Else             
		lRet	:=.F.
	EndIf
EndIf

DbSelectArea(cAlias)

Return (lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ A010ACols ³ Autor ³ Vendas Clientes       ³ Data ³ 04.09.98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Monta o ACols so com a quantidade de venda                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Loja010                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function a010Acols()
Local aRet     := {}
Local nColunas := 0
Local nLinhas  := 0
Local xRet                     // Retorno da funcao

If lMonta
	AADD(aRet,{})
	For nLinhas := 1 to Len(aColsGrade[n])
		For nColunas := 1 to len(aHeadGrade[n])
			If nColunas == 1
				AADD(aRet[1],{})
				AADD(aRet[1][nLinhas],aColsGrade[n][nLinhas][nColunas])
			Else
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Monta array apenas com a Quantidade de Venda (L2_QUANT) 	  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				AADD(aRet[1][nLinhas],aColsGrade[n][nLinhas][nColunas][1])
			Endif
		Next nColunas
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Acols que controla se o item esta deletado ou nao 			  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		AADD(aRet[1][nLinhas],aColsGrade[n][nLinhas][nColunas])
	Next nLinhas
	xRet  := aRet[1]
Else
	For nLinhas := 1 to Len(aCols)
		For nColunas := 1 to len(aHeader)
			If nColunas == 1
				aColsGrade[nAux][nLinhas][nColunas]:=aCols[nLinhas][nColunas]
			Else
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Monta array apenas com a Quantidade de Venda (L2_QUANT) 	  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				aColsGrade[nAux][nLinhas][nColunas][1]:=aCols[nLinhas][nColunas]				
			Endif
		Next nColunas
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Acols que controla se o item esta deletado ou nao 			  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aColsGrade[nAux][nLinhas][nColunas]:=aCols[nLinhas][nColunas]
	Next nLinhas
	xRet  := .T.
Endif

Return xRet

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Fun‡„o    ³ A010Soma  ³ Autor ³ Vendas Clientes       ³ Data ³ 11.08.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Efetua a Soma das quantidades digitadas na grade            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ numero do elemento do acols principal                       ³±±
±±³          ³ quantidade total digitada na getdados principal             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Loja010                                                     ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function A010Soma(nAux,cProdGrd)
Local nColunas  := 0
Local nLinhas   := 0
Local nSoma     := 0
Local cProduto
Local nPosUnit  := ASCAN(aCampos,"L2_VRUNIT")
Local nPosQuant := ASCAN(aCampos,"L2_QUANT")
Local nPosProd  := ASCAN(aCampos,"L2_PRODUTO")
Local nPosTab   := ASCAN(aCampos,"L2_PRCTAB")
Local nPosDesc  := ASCAN(aCampos,"L2_DESC")
Local nPosTes   := ASCAN(aCampos,"L2_TES")
Local nNovo
Local nPreco	:= 0
Local nQuant
Local nUnit
Local cTes
Local nZ        := 0
Local nX
Local nY

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se deve-se somar a quantidade venda    ³
//³ ou a quantidade liberada                        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nQtd:=1

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Soma todas as quantidades digitadas na Getdados ³
//³ da Grade que nao estiverem deletadas			³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For nColunas:=2 to Len(aHeadGrade[nAux])
	For nLinhas:=1 to Len(aColsGrade[nAux])
		If !Empty(aColsGrade[nAux][nLinhas][nColunas][nQtd]) .AND.;
			! (aColsGrade[nAux][nLinhas][Len(aColsGrade[nAux][nLinhas])])
			
			//Antes de Somar, verificar se o unitario e o mesmo da grade
			cProduto := Substr(cProdGrd,1,nTamRef) + aDescLin[nLinhas] + Substr(aHeadGrade[nAux][nColunas][2],2)
			cProduto := cProduto + Space(15 - Len(cProduto) )
			DbSelectArea("SB0")
			DbSetOrder(1)
			DbSeek(xFilial("SB0")+cProduto)
			cTabela := Str(nTabela,1)
       		
			LjxeValPre(@nPreco, cProduto, /*cCliente*/, /*cLoja*/)
            
			If aCols[n][nPosUnit] == nPreco
				nSoma+=aColsGrade[nAux][nLinhas][nColunas][nQtd]
			Else
				//Criando uma linha para este produto, que tem preco diferenciado
				//na Getdados e disparando todos os gatilhos associados
				AADD(aCols,{})
				nNovo:=Len(aCols)
				DbSelectArea("SB1")
				DbSetOrder(1)
				DbSeek(xFilial("SB1")+cProduto)
				For nz:=1 to Len(aHeader)
					If Trim(aHeader[nz][2]) == "L2_PRODUTO"
						AADD(aCols[nNovo],cProduto)
					ElseIf Trim(aHeader[nz][2]) == "L2_UM"
						AADD(aCols[nNovo],SB1->B1_UM)
					ElseIf Trim(aHeader[nz][2]) == "L2_DESCRI"
						AADD(aCols[nNovo],SB1->B1_DESC)
					ElseIf Trim(aHeader[nz][2]) == "L2_TES"
						AADD(aCols[nNovo],RetFldProd(SB1->B1_COD,"B1_TS"))
						cTes:=RetFldProd(SB1->B1_COD,"B1_TS")
					ElseIf Trim(aHeader[nz][2]) == "L2_CF"
						DbSelectArea("SF4")
						DbSetOrder(1)
						DbSeek(xFilial("SF4")+cTes)
						AADD(aCols[nNovo],SF4->F4_CF)
					ElseIf Trim(aHeader[nz][2]) == "L2_LOCAL"
						AADD(aCols[nNovo],RetFldProd(SB1->B1_COD,"B1_LOCPAD"))
					ElseIf Trim(aHeader[nz][2]) == "L2_QUANT"
						AADD(aCols[nNovo],aColsGrade[nAux][nLinhas][nColunas][nQtd])
						nQuant:=aColsGrade[nAux][nLinhas][nColunas][nQtd]
					ElseIf Trim(aHeader[nz][2]) == "L2_VRUNIT"
						AADD(aCols[nNovo],nPreco)
						nUnit:=nPreco
					ElseIf Trim(aHeader[nz][2]) == "L2_PRCTAB"
						AADD(aCols[nNovo],nPreco)
					ElseIf Trim(aHeader[nz][2]) == "L2_VLRITEM"
						AADD(aCols[nNovo],NoRound(nQuant*nUnit,2))
					ElseIf Trim(aHeader[nz][2]) == "L2_GRADE"
						AADD(aCols[nNovo],"N")
					Else
						AADD(aCols[nNovo],aColsAux[n][nz])
					Endif
				Next nz
				AADD(aCols[nNovo],.F.)
				
				For ny:=1 to Len(aHeader)
					If Trim(aHeader[ny][2]) == "L2_VALICM"
						aCols[nNovo][ny]:=LjxDIcms(Len(aCols))
					ElseIf Trim(aHeader[ny][2]) == "L2_VALIPI"
						aCols[nNovo][ny]:=LjxDIpi(aCols[nNovo][nPosTab],aCols[nNovo][nPosQuant],aCols[nNovo][nPosDesc],,aCols[nNovo][nPosTes],nNovo,aCols[nNovo][nPosProd],,gdFieldGet("L2_VALFRE",nNovo),gdFieldGet("L2_SEGURO",nNovo),gdFieldGet("L2_DESPESA",nNovo))
					ElseIf Trim(aHeader[ny][2]) == "L2_VALISS"
						aCols[nNovo][ny]:=LjxDIss()
					Endif
				Next ny
				aColsGrade[nAux][nLinhas][nColunas][nQtd]:=0
				a010Mont(nNovo,cProduto,"N")
			Endif
		Endif
	Next nLinhas
Next nColunas

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Atualiza a quantidade do item do pedido de venda³
//³ com a soma da grade                             ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For nX := 1 to Len(aHeader)
	If Trim(aHeader[nX][2])== "L2_QUANT" .AND. nSoma > 0
		aCols[nAux][nX] := nSoma
		M->L2_QUANT     := nSoma
		Exit
	Endif
Next nX

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Se ha produtos na grade com valor diferente no  ³
//³ B0, entao montar item a parte no acols          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

Return .T.

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Fun‡„o    ³ A010ProdRf³ Autor ³ Vendas Clientes	     ³ Data ³ 04.09.98³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Verifica se o produto digitado e' referencia               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametro ³ Codigo do Produto digitado                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Loja010                                                    ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function a010ProdRf(cProdRef)
Local nRet := 1 

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se o espaco definido para linha esta preenchido	  ³
//³ se estiver significa que nao esta sendo digitado a referencia³
//³ e sim um produto 														  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

If Substr(cProdRef,nTamRef+1,nTamLin) <> Space(nTamLin) .AND. !Empty(cProdRef)
	nRet := 0
	DbSelectArea("SB1")
	DbSetOrder(1)
	If !(DbSeek(xFilial("SB1")+cProdRef))
		nRet := 2
	Endif
Else
	DbSelectArea("SB4")
	DbSetOrder(1)
	If !DbSeek(xFilial("SB4")+cProdRef)
		nRet := 0
		DbSelectArea("SB1")
		DbSetOrder(1)
		If !(DbSeek(xFilial("SB1")+cProdRef))
			nRet := 2
		Endif
	Endif
Endif

Return nRet

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Fun‡„o    ³ A010GraGrd³ Autor ³ Vendas Clientes       ³ Data ³ 14.09.98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Grava aCols baseado no acolsgrade, assim sendo, a venda se  ³±±
±±³          ³ torna normal, como se o usuario tivesse digitado todos      ³±±
±±³          ³ os itens normalmente.                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Loja010A                                                    ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function a010GraGrd()
Local aColsAux  :={}
Local nItem     := LEN(aCols)
Local nCont     := 0
Local nQtdVen   := 0
Local nVlUnit   := 0
Local nItemGrade:= 0
Local cProdGrd  := ""
Local nTamGrd
Local cGrade    := "N"
Local nDesconto := 0
Local nyDesc    := 0
Local nI,nX,ny  := 0
Local nPosTab   := ASCAN(aCampos,"L2_PRCTAB")
Local nPosQuant := ASCAN(aCampos,"L2_QUANT")
Local nPosDesc  := ASCAN(aCampos,"L2_DESC")
Local nPosTes   := ASCAN(aCampos,"L2_TES")
Local nPosProd  := ASCAN(aCampos,"L2_PRODUTO")
Local nLin
Local nCol

nTamGrd  := TamSx3("L2_ITEM")[1]
aColsAux := Aclone(aCols)
aCols    := {}
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Controla o numero de itens do aCols da Getdados Principal	  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For ni:=1 to nItem
	nItemGrade:=0
	cGrade	 :="N"
	For nx := 1 To Len(aHeader)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Armazena o conteudo do codigo do produto e do preco de venda ³
		//³ do Acols da Getdados principal										  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Trim(aHeader[nx][2]) == "L2_PRODUTO"
			cProdRef := aColsAux[ni][nx]
		ElseIf Trim(aHeader[nx][2]) == "L2_VRUNIT"
			nVlUnit := aColsAux[ni][nx]
		ElseIf Trim(aHeader[nx][2]) == "L2_GRADE"
			cGrade  := aColsAux[ni][nx]
		Endif
	Next nx
	
	If !Empty(cProdRef)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se o item do aCols ‚ grade e se nao esta dele ³
		//³ tado.																  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		
		If cGrade == "S" .AND. If(Valtype(aColsAux[ni,Len(aColsAux[ni])]) == "L" .AND. Inclui,!(aColsAux[ni,Len(aColsAux[ni])]),.T.)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Monta item no acols Principal, pegando o codigo do	  ³
			//³ produto e a quantidade digitada no acols da grade,	  ³
			//³ as outras informacoes sao copiadas do Acols da getdados³
			//³ principal															  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			For nCol:= 2 to Len(aHeadGrade[ni])
				For nLin:=1 to Len(aColsGrade[ni])
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³ Verifica se o item nao esta deletado,e se ele e' um    ³
					//³ item novo. 														  ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If aColsGrade[ni][nLin][nCol][4] $ "FN"
						nCont++
						nItemGrade++
						cProdGrd :=""
						cProdGrd := Alltrim(cProdRef) + Space(nTamRef-Len(Alltrim(cProdRef) ) )
						cProdGrd := cProdGrd+aDescLin[nLin]+SubStr( aHeadGrade[ni][nCol][2],2 )
						cProdGrd := cProdGrd+Space(15-Len(cProdGrd) )
						
						For ny:=1 to Len(aHeader)
							If Trim(aHeader[ny][2]) == "L2_PRODUTO"
								//Checar antes a quantidade vendida
								nQtdVen:=aColsGrade[ni][nLin][nCol][1]
								If nQtdVen > 0
									AADD(aCols,{})
									n:=Len(aCols)
									AADD(aCols[nCont],cProdGrd)
								Else
									nCont--
									Exit
								Endif
							ElseIf Trim(aHeader[ny][2]) == "L2_QUANT"
								AADD(aCols[nCont],aColsGrade[ni][nLin][nCol][1])
							ElseIf Trim(aHeader[ny][2]) == "L2_DESCRI"
								DbSelectArea("SB1")
								DbSetOrder(1)
								DbSeek(xFilial("SB1")+cProdGrd)
								AADD(aCols[nCont],SB1->B1_DESC)
							ElseIf Trim(aHeader[ny][2]) == "L2_VLRITEM"
								AADD(aCols[nCont],NoRound(nQtdVen * nVLUnit,2))
							ElseIf Trim(aHeader[ny][2]) == "L2_GRADE"
								AADD(aCols[nCont],"S")
							Else
								AADD(aCols[nCont],aColsAux[ni][ny])
							Endif
						Next ny
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³ So existe este array que controla se o item esta dele -³
						//³ tado ou nao no mata410,no mata440 este array nao existe³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If nQtdVen > 0
							If aColsGrade[ni][nLin][nCol][1] > 0 .AND. !(aColsGrade[ni][nLin][Len(aColsGrade[ni][nLin])])
								AADD(aCols[nCont],aColsAux[ni][ny])
							Else
								AADD(aCols[nCont],.T.)
							Endif
						Endif
					Endif
					nDesconto:=0
					If nCont > 0
						n:=nCont
						For ny:=1 to Len(aHeader)
							If Trim(aHeader[ny][2]) == "L2_VALICM"
								aCols[nCont][ny]:=LjxDIcms(Len(aCols))
							ElseIf Trim(aHeader[ny][2]) == "L2_VALIPI"
								aCols[nCont][ny]:=LjxDIpi(aCols[nCont][nPosTab],aCols[nCont][nPosQuant],aCols[nCont][nPosDesc],,aCols[nCont][nPosTes],nCont,aCols[nCont][nPosProd],,gdFieldGet("L2_VALFRE",nNovo),gdFieldGet("L2_SEGURO",nNovo),gdFieldGet("L2_DESPESA",nNovo))
							ElseIf Trim(aHeader[ny][2]) == "L2_VALISS"
								aCols[nCont][ny]:=LjxDIss()
							ElseIf Trim(aHeader[ny][2]) == "L2_DESC"
								nDesconto:=aCols[nCont][ny]
							ElseIf Trim(aHeader[ny][2]) == "L2_VALDESC"
								nyDesc:=nY
							ElseIf Trim(aHeader[ny][2]) == "L2_PRCTAB"
								aCols[nCont][nyDesc]:=Round((aCols[nCont][ny]*nQtdVen)*nDesconto / 100 ,2)
							Endif
						Next ny
					Endif
				Next nLin
			Next nCol
		Else
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ No caso do item nao ser uma referencia e' mantido      ³
			//³ todas as informacoes digitadas na Getdados principal   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			nCont++
			nItemGrade++
			AADD(aCols,{})
			aCols[nCont]:=Aclone(aColsAux[ni])
		Endif
	Endif
Next ni
aColsGrade:={}
aHeadGrade:={}
aListaProd:={}

Return .T.

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Fun‡„o    ³ljGetSenha³ Autor ³ Vendas Clientes       ³ Data ³          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Aceita a senha do usuario                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe e ³ GetSenha(Expl1)                                            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpL1 = True	Troca de Senha 	ExpL1 == False Get Senha 	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function ljGetSenha( cChamada,  cSenha )
Local cCaption := Space(20)
Local oDlgSenha
Local nOpc := 0
Local lRet := .F.

Default cChamada 	:= ""

//-- Desenha a Tela e Get Senha --
If cChamada == "TEF-EXC"
	cCaption := STR0008						// Autoriza‡„o para exclus„o TEF
ElseIf cChamada == "TEF-FORC"
	cCaption := STR0009						// Autoriza‡„o para venda for‡ada
Else
	cCaption := STR0010						// Autoriza‡„o
EndIf

cSenha := Space(6)
// Autoriza‡„o
DEFINE DIALOG oDlgSenha Of GetWndDEFAULT() TITLE ;
STR0010 FROM 12, 20 TO 18,45
@ .5,1 SAY STR0011							// Digite a Senha:
@ .5,7 MSGET oGetSenha VAR cSenha PASSWORD
DEFINE SBUTTON FROM 25,35 TYPE 1 ACTION (If(LojaSenha(cSenha),(nOpc:=1,oDlgSenha:End()),));
ENABLE OF oDlgSenha
DEFINE SBUTTON FROM 25,65 TYPE 2 ACTION oDlgSenha:End() ENABLE OF oDlgSenha
ACTIVATE MSDIALOG oDlgSenha CENTERED
If nOpc == 1
	cSenha:=cSenha+Space(6-Len(cSenha))
	lRet := .T.
EndIf

Return lRet

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºPrograma  ³LojaSenha ºAutor  ³Vendas Clientes     º Data ³  04/07/06   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Verifica se senha cadastrada 								  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ExpC1 - senha 											  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³ExpL2 - senha cadastrada 								      º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function LojaSenha(cSenha)
Local lRet  := .T.       // Verifica se senha cadastrada

PswOrder(3)
lRet  := (PswSeek(cSenha) .OR. !Empty(cSenha))

Return lRet

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºPrograma  ³MonFormPagºAutor  ³Vendas Clientes     º Data ³  31/07/00   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Monta array com as formas de pagamento cadastradas na       º±±
±±º          ³tabela 24.                                                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³array passado por referencia.                               º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function MonFormPag(aItens)
//-- Release 11.5 - Cartao Fidelidade--
Local lLjcFid	:= SuperGetMv("MV_LJCFID",,.F.) .AND. CrdxInt() 	//Indica se a recarga de cartao fidelidade esta ativa
Local lGrupo	:= .F.
Local lSemGrupo	:= .F.

aItens := {}

DbSelectArea("SAE")
DbSeek(xFilial())
While !Eof() .AND. xFilial("SAE") == SAE->AE_FILIAL                                     
	SX5->(DbSeek(xFilial("SX5")+"24"+AllTrim(SAE->AE_TIPO)))
	aAdd(aItens, {Alltrim(AE_DESC),AllTrim(AE_TIPO),Alltrim(X5Descri()) })
	AAdd(aItens[Len(aItens)], AE_GRPFRT)

	If !Empty(AE_GRPFRT)
		lGrupo := .T.
	Else
		lSemGrupo := .T.
	EndIf

	DbSkip()
End
DbSelectArea( "SX5" )
If DbSeek(xFilial()+"24CR")
	AAdd(aItens, {AllTrim(X5Descri()), "CR", AllTrim(X5Descri()) })
	AAdd(aItens[Len(aItens)], "   ")
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Release 11.5 - Cartao Fidelidade³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lLjcFid .AND. !Fa271aGrcf ()
	If DbSeek(xFilial()+"24FID")
		AAdd(aItens, {AllTrim(X5Descri()), "FID", AllTrim(X5Descri()) })
		AAdd(aItens[Len(aItens)], "   ")
	EndIf
Endif

/*
 Ordenação para que ao definir as teclas de atalho do FrontLoja sejam priorizadas as
 adm. financeiras que não possuem grupo de teclas. O seguinte aSort ordena por:
	- Administradoras sem grupo
	- Administradoras com grupo Ordem crescente
Obs.: Ordenar apenas quando ha mistura de atalhos com grupo e sem grupo.
*/
If lSemGrupo .And. lGrupo
	aSort(aItens,,,{|x,y|x[4] < y[4]})
EndIf

If DbSeek(xFilial()+"24CH")
	AAdd(aItens, {AllTrim(X5Descri()), "CH", AllTrim(X5Descri()) })
	AAdd(aItens[Len(aItens)], "   ")
Endif
If DbSeek(xFilial()+"24"+SuperGetMV("MV_SIMB1"))
	AAdd(aItens, {AllTrim(X5Descri()), SuperGetMV("MV_SIMB1"), AllTrim(X5Descri()) })
	AAdd(aItens[Len(aItens)], "   ")
ElseIf cPaisLoc <> "BRA"	
	AAdd(aItens, {STR0053, "$", STR0053 })	//"Dinheiro"
	AAdd(aItens[Len(aItens)], "   ")	
Endif

Return NIL

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Fun‡…o    ³ LJXRpl   ³ Autor ³ Vendas Clientes       ³ Data ³31/07/2000³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Replica as configuracoes de caixa e estacao                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ LJXRpl                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGALOJA/FRONTLOJA (LOJA121.PRW/LOJA120.PRW)               ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function LJXRpl( cAlias, nReg, nOpc )
Local oDlgEst
Local oList1
Local oList2
Local aItems1       := {}
Local aItems2       := {}
Local cNome
Local nList1		:= 1
Local nList2		:= 1
Local cTipo
Local cFilSLF       := ""

Private cCodigo


If EOF()
	Return NIL
Endif
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Estacao                            			                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cAlias == "SLG"
	cNome     := SLG->LG_NOME
	cCodigo   := SLG->LG_CODIGO
	bItems    := {|| If(SLG->LG_CODIGO<>cCodigo,AADD(aItems1,LG_CODIGO+" "+LG_NOME ),.T.)}
	cTipo     := STR0071
Endif
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Caixa                               			                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cAlias == "SLF"                                              
	// Soliciatado para ambiente "Mexico" o filtro dos caixas somente da mesma filial
	cFilSLF   := SLF->LF_FILIAL
	cCodigo   := SLF->LF_COD	
	cNome     := Lj120inibr()  
	bItems    := {|| If(SLF->LF_FILIAL+SLF->LF_COD<>cFilSLF+cCodigo .And. SLF->LF_FILIAL== xFilial(cAlias) ,AADD(aItems1,LF_COD+" "+Posicione( "SA6",1,xFilial("SA6")+SLF->LF_COD,"A6_NOME") ),.T.)}
	cTipo     := STR0072
Endif

DbSelectArea(cAlias)
DbSetOrder(1)
DbSeek(xFilial(cAlias))
dbEval(bItems)
dbGoto(nReg)

DEFINE MSDIALOG oDlgEst TITLE STR0069 FROM 0,0 TO 370,435 PIXEL // Replicar
@05,05 TO 45,215 PROMPT STR0070 PIXEL 				//"Cadastro"
@15,15 SAY cTipo PIXEL SIZE 20,9 					            //'Estacao'/Caixa
@14,55 MSGET cCodigo PIXEL SIZE 30,9 WHEN .F.

@30,15 SAY STR0073 PIXEL SIZE 20,9 					//'Nome'
@29,55 MSGET cNome PIXEL SIZE 75,9 WHEN .F.

@ 50,05 SAY cTipo PIXEL SIZE 50,9                          //'Estacao'/Caixa
@ 60,05  LISTBOX oList1 VAR nList1 ITEMS aItems1 SIZE 75,100 PIXEL

@ 50,140 SAY STR0074 PIXEL SIZE 50,9 // "Replicar para"
@ 60,140 LISTBOX oList2 VAR nList2 ITEMS aItems2 SIZE 75,100 PIXEL

@70,85 BUTTON oBtn4 PROMPT STR0075 SIZE 50,11 WHEN LEN(aItems1)>0 PIXEL ACTION LJ121RPLI1(nList1,@aItems1,oList1,@aItems2,oList2)  //"Adicionar >"
@85,85 BUTTON oBtn4 PROMPT STR0076 SIZE 50,11 PIXEL WHEN LEN(aItems2)>0   ACTION LJ121RPLI1(nList2,@aItems2,oList2,@aItems1,oList1)       // "< Remover"

@123,85 BUTTON oBtn4 PROMPT STR0077 SIZE 50,11 PIXEL WHEN LEN(aItems1)>0 ACTION LJ121RPLI1(nList1,aItems1,oList1,aItems2,oList2,"T")  //"Adicionar todos >>"
@138,85 BUTTON oBtn4 PROMPT STR0078 SIZE 50,11 PIXEL WHEN LEN(aItems2)>0 ACTION LJ121RPLI1(nList2,aItems2,oList2,aItems1,oList1,"T")  // "<< Remover todos"

DEFINE SBUTTON FROM	170,157 TYPE 1 ENABLE OF oDlgEst WHEN LEN(aItems2)>0 ACTION ( LJ121RPLIOK(aItems2,nReg,cAlias),oDlgEst:End())
DEFINE SBUTTON FROM  170,187 TYPE 2 ENABLE OF oDlgEst ACTION oDlgEst:End()

ACTIVATE DIALOG oDlgEst CENTER

Return NIL

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³LJ121RPLI1³ Autor ³ Vendas Clientes       ³ Data ³31/07/2000³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Selecao de caixa/estacoes para replicar                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ LJ121RPLI1(nL1,aIt1,oL1,aIt2,oL2,cTipo)                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ nL1  - Item do array das estacao/caixa selecionado.        ³±±
±±³          ³ aIt1 - Array com todas os estacoes/caixa disponiveis       ³±±
±±³          ³ oL1  - Objeto do array das estacoes/caixa disponiveis      ³±±
±±³          ³ aIt2 - Array com todas com as estacoes/caixa selecionadas  ³±±
±±³          ³ oL2  - Objeto do array das estacoes/caixa selecionadas     ³±±
±±³          ³ cTipo  - Tipo da operacao de selecao, sendo :              ³±±
±±³          ³         "T" - Tudo                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGALOJA/FRONTLOJA (LOJA121.PRW/LOJA120.PRW)               ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function LJ121RPLI1( nL1  ,aIt1  ,oL1  ,aIt2  ,;
                     oL2  ,cTipo )

If nL1 == 0
   nL1  := 1
Endif
If cTipo == "T"
	AEval(aIt1,{|x| aadd(aIt2,x)})
	aIt1  := {}
Else
	AADD(aIt2,aIt1[nL1])
	ADel(aIt1,nL1)
	ASize(aIt1,len(aIt1)-1)
Endif
ASort(aIt1)
ASort(aIt2)
oL1:SetItems(aIt1)
oL2:SetItems(aIt2)
oL1:Select(1)

Return (NIL)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³LJ121RPLIOK³ Autor ³ Vendas Clientes      ³ Data ³31/07/2000³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Gravacao das configuracoes nas estacao/caixa selecionada   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ LJ121RPLIOK(aItems2,nReg   )                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ aItems2- array com as estacoes/caixa selecionada.          ³±±
±±³          ³ nReg   - Registro no SLG/SLF da estacao/caixa a ser copiada³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGALOJA/FRONTLOJA (LOJA121.PRW/LOJA120.PRW)               ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function LJ121RPLIOK(aItems2,nReg,cAlias)
Local nI     	:= 0 				// contador dos campos
Local nA     	:= 0 				// contador do array q armazena os caixas
Local nInic  	:= 0
Local nX     	:= 0 				// contador da tabela MGW
Local aForms	:= STDFormsPay()	// Todas as formas de pagamento da tabela 24 da SX5
Local aColsMGW  :={}     			// Armazena dados da MGW
Local lLimSang	:= SuperGetMV( "MV_LJLISAN",, .F.) // Utiliza controle para limite de sangria 

If cAlias == "SLF"
   nInic  := 3
ElseIf cAlias == "SLG"
   nInic  := 4
Else
   nInic  := 0      
Endif   
DbSelectArea(cAlias)
DbGoto(nReg)
For nI := 1 TO FCount()
	M->&(Field(nI)):= FieldGet(nI)
Next nI

For nA := 1 to Len(aItems2)
	If DbSeek(xFilial(cAlias)+subs(aItems2[nA],1,3))
		Reclock( cAlias, .F. )
		For nI := nInic TO FCount()
			If !M->(Field(nI)) $ "LF_MSFIL"
				fieldPut(nI,M->&(Field(nI)))
			EndIf 	
		Next nI
		msUnlock( )
	Endif
Next nA

DbGoto(nReg)

If AliasIndic("MGW") .AND. cAlias == "SLF" .AND. lLimSang

    DbSelectArea("MGW")
    MGW->( DbSetOrder(1) )//MGW_FILIAL+MGW_CAIXA    
	
	If MGW->( DbSeek(xFilial("MGW") + SLF->LF_COD) )
        While !EOF() .AND. xFilial("MGW") + SLF->LF_COD == MGW->MGW_FILIAL + MGW->MGW_CAIXA
            aAdd(aColsMGW, {MGW->MGW_FILIAL, MGW->MGW_CAIXA, MGW->MGW_FPAGTO, MGW->MGW_LIM1, MGW->MGW_LIM2 } )
            MGW->( DbSkip() )
        End
     EndIf

     For nA := 1 to Len(aItems2)
     
         For nX := 1 To Len(aColsMGW)
            If MGW->( DbSeek(xFilial("MGW")+subs(aItems2[nA],1,3)+aColsMGW[nX][3]) )
               Reclock( "MGW", .F. )
               Replace MGW->MGW_LIM1 WITH aColsMGW[nX][4]
               Replace MGW->MGW_LIM2 WITH aColsMGW[nX][5]
            Else 
               Reclock( "MGW", .T. )
               Replace MGW->MGW_FILIAL WITH aColsMGW[nX][1]
               Replace MGW->MGW_CAIXA WITH subs(aItems2[nA],1,3)
               Replace MGW->MGW_FPAGTO WITH aColsMGW[nX][3]
               Replace MGW->MGW_LIM1 WITH aColsMGW[nX][4]
               Replace MGW->MGW_LIM2 WITH aColsMGW[nX][5]
            EndIf                        
         Next nX

         MGW->( MsUnlock() )

     Next nA

EndIf

Return (NIL)

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³LJGetStation³ Autor ³ Vendas Clientes     ³ Data ³22/07/2000³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna o conteudo dos campos da tabela de estacao (SLG)   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ LJGetStation(aCampos)                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ aCampos - Array contendo os campos  a serem retornados     ³±±
±±³          ³ caso seja recebido uma string com o nome do campo ou se for³±±
±±³          ³ passado apenas um campo no array sera retornado apenas o   ³±±
±±³          ³ conteudo do campo em forma de string, caso o a array conte-³±±
±±³          ³ mais de 1 elemento retornara um array com os valores dos   ³±±
±±³          ³ campos.                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGALOJA/FRONTLOJA                                         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function LJGetStation(uCampos, lUpperChar)
Local aArea	:= GetArea()
Local uRet
Local xRet
Local nI
Local cNewPar

Default lUpperChar		:= .T.

If cAuxEstacao == NIL .AND. !Empty(cEstacao)
   cAuxEstacao  := cEstacao
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Valida se a Estacao informada esta cadastrada  ³
//³       *****     IMPORTANTE     *****          ³
//³***** NAO ALTERAR ESTE DbSeek PARA DbSeek *****³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DbSelectArea("SLG")
DbSetOrder(1)
If !DbSeek(xFilial("SLG")+cEstacao)
	If Empty(cEstacao) .AND. ValType(cAuxEstacao) == "C" .AND. !Empty(cAuxEstacao)
	   cEstacao  := cAuxEstacao
	Endif
	If Empty(cEstacao)
	   //"O cadastro de estacao desse operador não foi localizado, por favor, saia do sistema e entre novamente."
	   //"Atenção"
   	   MsgStop(STR0121, STR0001)
   	   DbSeek(xFilial("SLG"),.T.)
   	Endif   
Endif

If ValType(uCampos) == "A"
	uRet := {}
	For nI := 1 to len(uCampos)
		xRet := FieldGet( FieldPos( If(! Left(uCampos[nI],3) == "LG_","LG_","")+uCampos[nI]))
		If ValType(xRet) == "C"
			If lUpperChar
				xRet := Upper(AllTrim(xRet))
			Else
				xRet := AllTrim(xRet)
			EndIf
		EndIf	
		If Upper(uCampos[nI]) == "SERIE"  .OR. Upper(uCampos[nI]) == "LG_SERIE"
			cNewPar := SuperGetMV("MV_LJSERIE")
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Este parametro permite que seja criada uma regra para o preenchimento   ³
			//³ do Numero de Serie do cupom:                                            ³
			//³ Por exemplo:                                                            ³
			//³ MV_LJSERIE = "Chr(64+Val(cFilAnt))+StrZero(Val(LJGetStation("PDV")),2)" ³
			//³ Ira gerar o numero "A01", onde "A" e a Filial e "01" e o numero do ECF. ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !Empty(cNewPar)
				xRet := &(cNewPar)
			EndIf
			// formata a variavel de retorno conforme o tamanho do campo
			Padr(xRet, TamSX3("LG_SERIE")[1] )
			
			xRet := SerieNfId("SL1",4,"L1_SERIE",dDataBase,LjEspecieNF(),xRet)
		EndIf
		AAdd(uRet,xRet)
	Next nI
Else
	uRet := FieldGet( FieldPos( If(! Left(uCampos,3) == "LG_","LG_","")+uCampos))
	If Valtype(uRet) == "C"
		If lUpperChar
			uRet := Upper(AllTrim(uRet))
		Else	
			uRet := AllTrim(uRet)
		EndIf	
	EndIf	
	If Upper(uCampos) == "SERIE" .OR. Upper(uCampos) == "LG_SERIE" 
		cNewPar := SuperGetMV("MV_LJSERIE")
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Este parametro permite que seja criada uma regra para o preenchimento   ³
		//³ do Numero de Serie do cupom:                                            ³
		//³ Por exemplo:                                                            ³
		//³ MV_LJSERIE = "Chr(64+Val(cFilAnt))+StrZero(Val(LJGetStation("PDV")),2)" ³
		//³ Ira gerar o numero "A01", onde "A" e a Filial e "01" e o numero do ECF. ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !Empty(cNewPar)
			uRet := &(cNewPar)
		EndIf
		// formata a variavel de retorno conforme o tamanho do campo
		Padr(uRet, TamSX3("LG_SERIE")[1] )
		uRet := SerieNfId("SL1",4,"L1_SERIE",dDataBase,LjEspecieNF(),uRet)
	EndIf
	If Upper(uCampos) == "GAVETA" .AND. lLinux //Para linux nao preciso ter o campo gaveta preenchido, porem como em diversas partes ele só permite a utiluzação quando esse campo tiver algum valor retornamos um ponto 
		uRet :='.'
	EndIf
EndIf

RestArea(aArea)

Return (uRet)


/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³LJGetProfile³ Autor ³ Vendas Clientes     ³ Data ³22/07/2000³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Retorna o conteudo dos campos da tabela de Perfil/Acesso   ³±±
±±³          ³ caixa (SLF)                                                ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ LJGetProFile(uCampos)                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ aCampos - Array contendo os campos  a serem retornados     ³±±
±±³          ³ caso seja recebido uma string com o nome do campo ou se for³±±
±±³          ³ passado apenas um campo no array sera retornado apenas o   ³±±
±±³          ³ conteudo do campo em forma de string, caso o a array conte-³±±
±±³          ³ mais de 1 elemento retornara um array com os valores dos   ³±±
±±³          ³ campos.                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGALOJA/FRONTLOJA                                         ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function LJGetProfile(uCampos, cCaixa)
Local cArea    := Alias()
Local uRet
Local xRet
Local nI

Default cCaixa := xNumCaixa()

DbSelectArea("SLF")
DbSetOrder(1)
DbSeek(xFilial("SLF")+ cCaixa )
If ValType(uCampos) == "A"
	uRet := {}
	For nI := 1 to len(uCampos)
		xRet := FieldGet( FieldPos( If(! Left(uCampos[nI],3) == "LF_","LF_","")+uCampos[nI]))
		If Valtype(xRet) == "C"
			xRet := Upper(AllTrim(xRet))
		Endif
		Aadd(uRet,xRet)
	Next nI
Else
	uRet := FieldGet( FieldPos( If(! Left(uCampos,3) == "LF_","LF_","")+uCampos))
	If Valtype(uRet) == "C"
		uRet := Upper(AllTrim(uRet))
	Endif
Endif

If !Empty(cArea)
	DbSelectArea(cArea)
EndIf

Return (uRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ljCriaCli ³ Autor ³ Vendas Clientes       ³ Data ³ 11/03/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Verifica se o cliente padrao existe e o cria.              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Sigaloja                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function ljCriaCli(cTipo)
Local cAlias := Alias()
Local nOrder := IndexOrd()
Local nReg	 := Recno()
//"CLIENTE EFETIVO"###"CONSUMIDOR FINAL"###"CLIENTE PADRAO"						
Local cNomeClie  := If(cPaisLoc == "SAL",STR0088,If(cPaisLoc == "GUA",STR0090,STR0002))

cTipo := If(cTipo == NIL,"",cTipo)

If cTipo == "clie"
	RecLock("SA1",.T.)
	REPLACE SA1->A1_FILIAL 	WITH xFilial("SA1")
	REPLACE SA1->A1_COD 	WITH "000001"
	REPLACE SA1->A1_LOJA	WITH "01"
	REPLACE SA1->A1_NOME	WITH cNomeClie
	REPLACE SA1->A1_NREDUZ 	WITH cNomeClie
	If cPaisLoc $ "CHI|PAR"	   
	   REPLACE SA1->A1_TIPO	WITH "A"	
	ElseIf cPaisLoc $ "MEX|POR|EUA|DOM|COS|COL|GUA"	   
	   REPLACE SA1->A1_TIPO	WITH "1"		   
	ElseIf cPaisLoc == "URU|SAL"	   
	   REPLACE SA1->A1_TIPO	WITH "2"		   
	Else   
	   REPLACE SA1->A1_TIPO	WITH "F"	
	EndIf
	REPLACE SA1->A1_END WITH "R..."
	REPLACE SA1->A1_MUN WITH If(!Empty(SM0->M0_CIDCOB),SM0->M0_CIDCOB,If(cPaisLoc=="BRA","SAO PAULO","."))
	If cPaisLoc == "BRA"
	   If !GetMv("MV_ESTADO",.T.)
		  REPLACE SA1->A1_EST WITH "SP"
	   Else
		  REPLACE SA1->A1_EST WITH SuperGetMV( "MV_ESTADO" )
	   EndIf	  
	Else
	   REPLACE SA1->A1_END WITH "."		
	   REPLACE SA1->A1_EST WITH SuperGetMV("MV_ESTADO")
	EndIf
	MsUnLock()
	cCliente  := SA1->A1_COD
	cLoja 	 := SA1->A1_LOJA
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Grava cliente padrao ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	PutMv("MV_CLIPAD",SA1->A1_COD)
	PutMv("MV_LOJAPAD",SA1->A1_LOJA)
	
ElseIf cTipo == "vend"
	If !( DbSeek( xFilial("SA3")+SuperGetMV("MV_VENDPAD") ) )
		RecLock("SA3",.T.)
		REPLACE SA3->A3_COD 	WITH SuperGetMV("MV_VENDPAD")
		REPLACE SA3->A3_NOME	WITH STR0003				// VENDEDOR PADRAO
		REPLACE SA3->A3_NREDUZ	WITH STR0003
		MsUnLock()
		cVend := SA3->A3_COD
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Grava Vendedor padrao³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		PutMv("MV_VENDPAD",SA3->A3_COD)
	Endif
EndIf

DbSelectArea(cAlias)
DbSetOrder(nOrder)
dbGoto(nReg)

Return( Nil )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³ A010Saldo ³ Autor ³ Vendas Clientes      ³ Data ³ 04.09.98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Consulta Saldo em Estoque                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametro ³ Indica se foi chamado da getdados da grade ou nao          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Loja010                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function a010Saldo(o)
Local cProduto  := ""
Local cLocal	:= ""
Local nX 		:= 0
Local nColHead

nColHead  := Int(o:oBrowse:nColPos)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Se foi ativado atraves da Getdados da Grade 		 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For nX := 1 to Len(aHeadAux)
	If Trim(aHeadAux[nX][2]) == "L2_PRODUTO"
		cProduto := aColsAux[nAux][nX]
	ElseIf Trim(aHeadAux[nX][2]) == "L2_LOCAL"
		cLocal := aColsAux[nAux][nX]
	Endif
Next nX
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Posiciona na coluna correta (X) para pegar o titulo	 ³
//³ da coluna para montar o nome do produto grade		 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cProduto := Substr(cProduto,1,nTamRef) + aDescLin[n]+Substr(aHeader[nColHead][2],2)
cProduto := cProduto+Space(15-Len(cProduto) )
F4Saldo(cProduto,"01")

Return (NIL)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±º Programa  ³ CalcMoedOk º Autor ³Vendas Clientes  º Data ³  01/06/01   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±º Descricao ³ Calcula soma das moedas no valor da moeda 1               º±±
±±ÌÍÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±º Sintaxe   ³ CalcMoedOk( cTes, nLine, cAlias, cOperator )              º±±
±±ÌÍÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±º Parametro ³ nValorDev  - Valor Total da Devolucao na Moeda 1          º±±
±±º           ³ nValorDev1 - Valor Parcial da Devolucao na Moeda 1        º±±
±±º           ³ nValorDev2 - Valor Parcial da Devolucao na Moeda 2        º±±
±±º           ³ nValorDev3 - Valor Parcial da Devolucao na Moeda 3        º±±
±±º           ³ nValorDev4 - Valor Parcial da Devolucao na Moeda 4        º±±
±±º           ³ nValorDev5 - Valor Parcial da Devolucao na Moeda 5        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±º Retorno   ³ .T. se o Valor Total = Soma dos Valores Parciais          º±±
±±ÌÍÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±º Uso       ³ SigaLoja - Localizacoes                                   º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function CalcMoedOk( nValorDev , nValorDev1 , nValorDev2, nValorDev3, ;
                            nValorDev4, nValorDev5 )

Local nSoma     := 0
Local lReturn 	:= .T.
Local nDecs		:= MsDecimais(1)

nSoma := Round(xMoeda(nValorDev1, 1, 1, dDatabase,nDecs+1),nDecs)+;
		 Round(xMoeda(nValorDev2, 2, 1, dDatabase,nDecs+1),nDecs)+;
		 Round(xMoeda(nValorDev3, 3, 1, dDatabase,nDecs+1),nDecs)+;
		 Round(xMoeda(nValorDev4, 4, 1, dDatabase,nDecs+1),nDecs)+;
		 Round(xMoeda(nValorDev5, 5, 1, dDatabase,nDecs+1),nDecs)

nSoma := nValorDev - nSoma

If nSoma > 0
	If MsgNoYes(  '$ ' + Transform( nSoma, "@E 9,999,999.99" ) + CRLF + STR0083  ) //"A diferen‡a acima ser  acertada na Moeda 1. Deseja Continuar ? "
		nValorDev1 += nSoma
	Else
		lReturn := .F.
	Endif
ElseIf nSoma < 0
	MsgAlert(  '$ ' + Transform( nSoma, "@E 9,999,999.99" ) + CRLF + STR0084 ,  STR0001  )  //"Devoluca MAIOR que o valor original ! Favor corrigir valores !!"   "Aten‡„o"
	lReturn := .F.
Endif

Return lReturn

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Fun‡„o    ³ LJSB1SLK  ³ Autor ³ Vendas Clientes      ³ Data ³ 04.09.98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Faz a pesquisa do codigo de produto digitado               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ SIGALOJA/FRONTLOJA                                         ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function LJSB1SLK( cProduto , nQuant , lFrt , cCodBar )
Local lRet      := .T.		// Retorno da função
Local aRet      := {}		// Retorno do Ponto de Entrada
Local nOrder    := 1		// Auxiliar na obtencao dos indices
Local lFtvdVer12:= LjFTVD() //Verifica se é Release 11.7 e o FunName é FATA701 - Compatibilização Venda Direta x Venda Assisitida
Local cProdAux	:= cProduto     // Auxiliar para verificar se o codigo
Local cTabPad	:= AllTrim(SuperGetMv("MV_TABPAD"))	//Tabela de preco padrao
Local lCenVenda := SuperGetMv("MV_LJCNVDA",,.F.)
Local lPESLKINI := .F.
Local lAutomato := If(Type("lAutomatoX")<>"L",.F.,lAutomatoX)
Local nTamB1UM	:= TamSX3("B1_UM")[1]
Local cUnidMed 	:= PadR("G", nTamB1UM) + "|" + PadR("MG", nTamB1UM) + "|" + PadR("KG", nTamB1UM)
Local lMensBlq 	:= .T.		// Apresenta mensagem de Bloqueio de Produto

Private nTmpQtd := 0		// Quantidade Temporaria

DEFAULT lFrt    	:= .F.		// Flag q informa se a requisicao veio do Front
DEFAULT nQuant  	:= 1		// Quantidade padrao
DEFAULT cCodBar		:= ""		// Guarda o codigo de barras da consulta

If lFtvdVer12
	If ExistBlock("FTVDSLKINI")
		LjGrvLog( NIL, "Antes da execução do PE FTVDSLKINI")
		aRet := ExecBlock("FTVDSLKINI",.F.,.F.,{cProduto,nQuant} )
		LjGrvLog( NIL, "Depois da execução do PE FTVDSLKINI",aRet)
		lPESLKINI := .T.
	EndIf
Else
	If ExistBlock("LJSLKINI")
		LjGrvLog( NIL, "Antes da execução do PE LJSLKINI")
		aRet := ExecBlock("LJSLKINI",.F.,.F.,{cProduto,nQuant} )
		LjGrvLog( NIL, "Depois da execução do PE LJSLKINI",aRet)
		lPESLKINI := .T.
	EndIf
EndIf

If lPESLKINI
	// *** Para o SIGAACD, o tratamento consiste em utilizar apenas 1 vez a etiqueta scaneada ***
	If Empty( aRet )
		Return .F.
	EndIf         
	
	cProduto := aRet[1]
	nQuant   := aRet[2]
EndIf

If lFrt
	nOrder := SBI->(IndexOrd())
	SBI->(DbSetOrder( 1 ))
	//Só realiza a busca pelo código de barras se o cProduto estiver preenchido.
	If !SBI->(DbSeek( xFilial("SBI") + cProduto )) 
		If !Empty(cProduto) 
			SBI->(DbSetOrder( 5 ))
			If SBI->(DbSeek( xFilial("SBI") + cProduto ))
				cProduto := SBI->BI_COD
			Else
				SLK->(DbSetOrder(1))
				If SLK->(DbSeek( xFilial("SLK") + cProduto ))
					cProduto := SLK->LK_CODIGO
					SBI->(DbSetOrder( 1 ))
					If SBI->(DbSeek( xFilial("SBI") + cProduto ))
						If SLK->LK_QUANT > 0
							nQuant *= SLK->LK_QUANT
						EndIf
					Else
						lRet := .F.
					EndIf
				Else
					//Verifica entao, se nao e balanca
					cCodProBal := Substr(cProduto,2,6) // PRIVATE
					cInfProBal := SubStr(cProduto,8,5) // PRIVATE
					SBI->(DbSetOrder(1))
					If SBI->(DbSeek(xFilial("SBI")+ cCodProBal)) .AND. Alltrim(cCodProBal) == Alltrim(SBI->BI_COD) .AND. SBI->BI_BALANCA $ "123"
						cProduto := SBI->BI_COD
						nQuant   := 1
						Do Case
							Case SBI->BI_BALANCA == "1"	// Pre‡o -> Colocado no tratamento do SB0
								lPrecoBal	:= .T.
							Case SBI->BI_BALANCA == "2"	// Quantidade (Peso)
								If StatBalanca()[1] .Or. (lAutomato .And. LjHaEmuBal())
									If lAutomato
										nTmpQtd := LjxAEmuBal(nTmpQtd)
									Else
										LjMsgRun(STR0096,,{|| nTmpQtd := Lj010PegaPeso(.T.)  } )//"Aguarde, consultando balança..."
									EndIf
									
									If nTmpQtd == 0
										Return .F.
									EndIF
									nQuant := nTmpQtd
								Else
									nQuant := Val(cInfProBal) / 1000
								EndIf							
							Case SBI->BI_BALANCA == "3"	// Quantidade (Unidade)
								nQuant		:= Val(cInfProBal)
						EndCase
					Else
						lRet := .F.
					Endif
				EndIf
			EndIf
		else
		 	lRet := .F.
		EndIf
	EndIf
	
	
	

	If lRet .AND. SBI->BI_UM $ cUnidMed .AND. (StatBalanca()[1] .Or. (lAutomato .And. LjHaEmuBal())) .AND. SBI->BI_BALANCA == "2"
		If lAutomato
			nTmpQtd := LjxAEmuBal(nTmpQtd)
		Else
			LjMsgRun(STR0096,,{|| nTmpQtd := Lj010PegaPeso(.T.)  } )//"Aguarde, consultando balança..."
		EndIf
		
		If nTmpQtd == 0
			Return .F.
		EndIf
		nQuant := nTmpQtd
	EndIf

	SBI->(DbSetOrder(nOrder))
Else
	nOrder := SB1->(IndexOrd())
	SB1->(DbSetOrder( 1 ))
	If !SB1->(DbSeek( xFilial("SB1") + cProduto ))
		//Só realiza a busca pelo código de barras se o cProduto estiver preenchido.
		If !Empty(cProduto)
			SB1->(DbSetOrder( 5 ))
			If SB1->(DbSeek( xFilial("SB1") + cProduto ))
                
                //Se o produto estiver bloqueado e se não estive executando a msu de retailsales
	    		If SB1->B1_MSBLQL=="1" .And. !Lj701GtInD()
					Help(" ",1,"REGBLOQ")
		   			lRet:=.F.
				Else
		      		cProduto := SB1->B1_COD   
		   		Endif		    
			Else
				SLK->(DbSetOrder(1))
				If SLK->(DbSeek( xFilial("SLK") + cProduto ))
					cProduto := SLK->LK_CODIGO
					SB1->(DbSetOrder( 1 ))
					If SB1->(DbSeek( xFilial("SB1") + cProduto ))
                        
                        //Se o produto estiver bloqueado e se não estive executando a msu de retailsales
        	    		If SB1->B1_MSBLQL=="1" .And. !Lj701GtInD()

				   			Help(" ",1,"REGBLOQ")
			   				lRet:=.F.
						ElseIf SLK->LK_QUANT > 1
							nQuant *= SLK->LK_QUANT
						EndIf
					Else
						lRet := .F.
					EndIf
				Else
					//Verifica entao, se nao e balanca
					cCodProBal := Substr(cProduto,2,6)
					cInfProBal := SubStr(cProduto,8,5)
					SB1->(DbSetOrder(1))
					If SB1->(DbSeek(xFilial("SB1")+ cCodProBal)) .AND. Alltrim(cCodProBal) == Alltrim(SB1->B1_COD) .AND. SB1->B1_BALANCA $ "123"

                        //Se o produto estiver bloqueado e se não estive executando a msu de retailsales
                        If SB1->B1_MSBLQL=="1" .And. !Lj701GtInD()
				   			Help(" ",1,"REGBLOQ")
			   				lRet:=.F.
			   			Else
							cProduto := SB1->B1_COD
							nQuant   := 1
						EndIf
						Do Case
							Case SB1->B1_BALANCA == "1"	// Preco -> Colocado no tratamento do SB0
								If !lCenVenda	
									lPrecoBal	:= .T.
									DbSelectArea("SB0")
									SB0->(DbSetOrder(1))//B0_FILIAL+B0_COD                                                                                                                                                
									If SB0->(DbSeek(xFilial("SB0") + cCodProBal))
										nVlrProd := Iif(ColumnPos("B0_PRV"+cTabPad) > 0 ,&("SB0->B0_PRV"+cTabPad),0)
										nQuant	 :=  NoRound(Val(cInfProBal) / 100 / nVlrProd, 3)
									EndIf
								Else
									nVlrProd := 0
									If LjxeValPre(@nVlrProd,cProduto, M->LQ_CLIENTE, M->LQ_LOJA	,nMoedaCor,nQuant)
										nQuant	 :=  Round(Val(cInfProBal) / 100 / nVlrProd, 3)
									Endif
								EndIf
							Case SB1->B1_BALANCA == "2"	// Quantidade (Peso)
								If StatBalanca()[1] .Or. (lAutomato .And. LjHaEmuBal())
									
									If lAutomato
										nTmpQtd := LjxAEmuBal(nTmpQtd)
									Else
										LjMsgRun(STR0096,,{|| nTmpQtd := Lj010PegaPeso(.T.)  } )//"Aguarde, consultando balança..."
									EndIf
									
									If nTmpQtd == 0
										Return .F.
									EndIF
									nQuant := nTmpQtd
								Else
									nQuant := Val(cInfProBal) / 1000
								EndIf							
							Case SB1->B1_BALANCA == "3"	// Quantidade (Unidade)
								nQuant		:= Val(cInfProBal)
						EndCase
					Else
						lRet := .F.
					Endif
				EndIf
			EndIf
		else
			lRet := .F.
		EndIf		
	Else	

        //Se o produto estiver bloqueado e se não estive executando a msu de retailsales
        If (SB1->B1_MSBLQL=="1" .And. !Lj701GtInD()) .OR. Iif(ExistFunc("Lj7PrdBlq"), !Lj7PrdBlq(Nil, cProduto, @lMensBlq) .And. !Lj701GtInD(), .F.)
			If lMensBlq
	   			Help(" ",1,"REGBLOQ")
			EndIf	
		   	lRet:=.F.   
	    Endif
	EndIf


	If lRet .AND. SB1->B1_UM $ cUnidMed .AND. (StatBalanca()[1] .Or. (lAutomato .And. LjHaEmuBal())) .AND. SB1->B1_BALANCA == "2"
		If lAutomato
			nTmpQtd := LjxAEmuBal(nTmpQtd)
		Else
			LjMsgRun(STR0096,,{|| nTmpQtd := Lj010PegaPeso(.T.)  } )//"Aguarde, consultando balança..."
		EndIf
		
		If nTmpQtd == 0
			Return .F.
		EndIf
		nQuant := nTmpQtd
	EndIf
	SB1->(DbSetOrder(nOrder))
EndIf

If cProdAux <> cProduto
	cCodBar := cProdAux			//Quando cProduto informado eh modificado, considera que utilizou codigo de barras para pesquisa
ElseIf !Empty(SB1->B1_CODBAR)	
	cCodBar := SB1->B1_CODBAR 	//Quando item registrado utilizando o codigo do produto, verifica se possui codigo de barras no cadastro
Else
	//Pesquisa na SLK se o produto possui codigo de barras cadastrado
	SLK->(DbSetOrder(2))  //LK_FILIAL+LK_CODIGO+LK_CODBAR
	If SLK->(DbSeek( xFilial("SLK") + cProduto ))
		cCodBar := SLK->LK_CODBAR
	EndIf		
EndIf

Return lRet

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Fun‡„o    ³LjVSaldo  ³ Autor ³ Vendas Clientes       ³ Data ³ 07/08/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Verifica se existe saldo na forma de pagamento para devo   ³±±
±±³          ³ lu‡ao para o cliente.                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parƒmetros³ ExpN1 - Valor a Devolver para o cliente.                   ³±±
±±³          ³ ExpC1 - Forma de pagto escolhida                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ ExpL1 - .T. se tiver saldo, ou .F. caso contr rio          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Loja020                                                    ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function LjVSaldo( nValorDev , cFormaDev )
Local lRet		  	:= .T.      				// Retorno da funcao
Local aArea 	  	:= GetArea()   				// Salva a area atual
Local aCaixa   	  	:= {}  						// Contem os valores de debito e credito com base no resumo de caixa
Local cCaixa	  	:= xNumCaixa() 				// Retorna o codigo do caixa ativo
Local aSimb 	 	:= {}                   	// Simbolos utilizados para cada moeda do sistema    	
Local nI		 	:= 1						// Contador do For
Local cMensagem 	:= STR0059 + STR0060 		// O valor a ser devolvido nesta forma de pagamento para o cliente ## n„o est  dispon¡vel em caixa. Escolha outra forma ou informe o supervisor.
Local nDevDin		:= 0						// Contem o valor de devolucao ja devolvido em dinheiro
Local nPgtosDIN		:= 0						// Contem o valor em dinheiro que foi utilizado para efetuar pagamentos
Local nRecebDIN		:= 0						// Contem o valor de recebimentos efetuados em dinheiro

Private aDDown  	:= Array( 8 )				// Contem o 2o. nivel das opcoes: Cartao de Credito, Vales, Convenio, Financiado, Cartao de Debito e Recebimento

//*** Posiciona no Caixa ***
xNumCaixa()
aCaixa := MovimCaixa(cCaixa,dDataBase,Nil,@aDDown)
For nI:= 1 to MoedFin()
	aadd(aSimb,Alltrim(SuperGetMV("MV_SIMB"+alltrim(str(nI)))))	
Next nI

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica com base no valor total de devolucao o quanto foi devolvido (retirado do caixa) em dinheiro. ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If aCaixa[23] > 0 
	nDevDIN:= LjSaldoDIN(1,cCaixa,dDataBase)
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica o valor em dinheiro que foi utilizado para realizar os pagamentos³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If aCaixa[2] > 0 
	nPgtosDIN:= LjSaldoDIN(2,cCaixa,dDataBase)  
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica o valor em dinheiro que foi utilizado para realizar os pagamentos³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If aCaixa[3] > 0 
	nRecebDIN:= LjSaldoDIN(3,cCaixa,dDataBase)  
Endif

/* Estrutura do Array aCaixa com base no programa de Resumo de Caixa.
P_TROCO            1
P_PAGAMENTOS       2
P_RECEBIMENTOS     3
P_SANG_DINHEIRO    4
P_SANG_CHEQUE      5
P_SANG_CARTAO      6
P_SANG_VALE        7
P_SANG_CONVENIO    8
P_SANG_FINANCIADO  9
P_SANG_DEBAUTO    10
P_SANG_OUTROS     11
P_TRANSF_ORIGEM   12
P_TRANSF_DESTINO  13 
P_VEND_DINHEIRO   14
P_VEND_CHEQUE     15
P_VEND_CARTAO     16
P_VEND_VALE       17
P_VEND_CONVENIO   18
P_VEND_FINANCIADO 19
P_VEND_DEBAUTO    20
P_VEND_CREDITO    21
P_VEND_OUTROS     22
P_DEVOLUCAO       23
P_MAXDEFINE       23
*/
Do Case
	Case AllTrim(cFormaDev) == If(Ascan( aSimb,cFormaDev) > 0,aSimb[Ascan( aSimb,cFormaDev)]," ")
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Considerar o saldo em dinheiro existente no caixa:            														³
		//³(Dinheiro + Troco + Recebimento em Dinheiro ) -																		³
		//³(Sangrias - O dinheiro que jah foi devolvido - O dinheiro que foi utilizado para efetuar pagamentos)                 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ( aCaixa[14] + aCaixa[1] + nRecebDIN - aCaixa[4]  - nDevDin - nPgtosDIN) < nValorDev
			// Vocˆ escolheu:
			MsgInfo( cMensagem + " - " + STR0061 + cFormaDev )
			lRet := .F.
		EndIf
	Case cFormaDev == "FI"
		If (aCaixa[19]- aCaixa[9]) < nValorDev
			// Vocˆ escolheu:
			MsgInfo( cMensagem + " - " + STR0061 + cFormaDev )
			lRet := .F.
		EndIf
	Case cFormaDev == "CC"
		If (aCaixa[16]- aCaixa[6]) < nValorDev
			// Vocˆ escolheu:
			MsgInfo( cMensagem + " - " + STR0061 + cFormaDev )
			lRet := .F.
		EndIf
	Case cFormaDev == "CO"
		If (aCaixa[18]- aCaixa[8]) < nValorDev
			// Vocˆ escolheu:
			MsgInfo( cMensagem + " - " + STR0061 + cFormaDev )
			lRet := .F.
		EndIf
	Case cFormaDev == "VA"
		If (aCaixa[17]- aCaixa[7]) < nValorDev
			// Vocˆ escolheu:
			MsgInfo( cMensagem + " - " + STR0061 + cFormaDev )
			lRet := .F.
		EndIf
	Case cFormaDev == "CH"
		If (aCaixa[15]- aCaixa[5]) < nValorDev
			// Vocˆ escolheu:
			MsgInfo( cMensagem + " - " + STR0061 + cFormaDev )
			lRet := .F.
		EndIf
	Case cFormaDev == "CD"
		If (aCaixa[20]- aCaixa[10]) < nValorDev
			//Vocˆ escolheu:
			MsgInfo( cMensagem + " - " + STR0061 + cFormaDev )
			lRet := .F.
		EndIf
	Case cFormaDev == "CR" //Para forma de pagamento Credito, nao eh preciso existir saldo em caixa.
		lRet:= .T.
	OtherWise
		If (aCaixa[22]- aCaixa[11]) < nValorDev
			// Vocˆ escolheu:
			MsgInfo( cMensagem + " - " + STR0061 + cFormaDev )
			lRet := .F.
		EndIf
EndCase

RestArea(aArea)

Return (lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³LjCriaSimb³ Autor ³ Vendas Clientes       ³ Data ³ 26/10/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Cria os simbolos das moedas ativas no SX5 para permitir    ³±±
±±³          ³ venda em multi-moeda                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parƒmetros³ ExpN1 - moeda a ser criada                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ LOJA010, LOJA220 e FRTA010                                 ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LjCriaSimb(nX)
Local cSimbMoeda:= SuperGetMV("MV_SIMB"+Ltrim(Str(nX)))
Local nInd 		:= 0
Local aGetSX5	:= {}
Local aDadosSX5	:= {}

//				  Tabela  Chave      Desc.Portug.  Desc.Ingles 	Desc.Espanhol 
aAdd( aDadosSX5, { "24", cSimbMoeda, "DINHEIRO"	, 	"CASH"		, "DINERO" } )
aAdd( aDadosSX5, { "05", cSimbMoeda, "DINHEIRO"	,	"CASH"		, "DINERO" } )

For nInd := 1 To Len(aDadosSX5)
	//Faz a busca para verificar se já existe a informação na tabela SX5
	aGetSX5 := FWGetSX5( aDadosSX5[nInd][1], aDadosSX5[nInd][2], Nil)

	If Empty(aGetSX5)
		//Inclui, quando nao existir ainda a informação no SX5
		FwPutSX5(Nil, aDadosSX5[nInd][1], aDadosSX5[nInd][2], aDadosSX5[nInd][3], aDadosSX5[nInd][4], aDadosSX5[nInd][5], Nil)
	EndIf
Next nInd

Return ( Nil )
                     

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LjRateioFrºAutor  ³Vendas Clientes     º Data ³ 25/02/2004  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Funcao que faz o rateio do valor do frete nos itens        º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGALOJA                                                   º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LjRateioFret()
Local nVlrTotFrt  := 0
Local nCountFrt   := 0
Local nI          := 0
Local nPerTotal   := 0
Local nVlrFrete   := 0
Local nVlrSeguro  := 0
Local nVlrDespesa := 0
Local nFrete      := 0
Local nSeguro     := 0
Local nDespesa    := 0
Local nLenCols    := Len( aCols )
Local aDespFrete  := Array(nLenCols,3)
	
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Faz o rateio do frete, seguro e desp.acessórias pelos itens vendidos ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nVlrTotFrt 	:= 0
nCountFrt	:= 0
For nI := 1 to nLenCols
	If !(aCols[nI][Len(aCols[nI])])
		If Posicione("SF4",1,xFilial("SF4")+gdFieldGet("L2_TES    ",nI),"SF4->F4_ISS") <> "S"
			nVlrTotFrt += gdFieldGet("L2_VLRITEM",nI)
			nCountFrt ++
		Endif
	Endif
Next nI

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Faz o rateio ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For nI := 1 to Len(aDespFrete)
	aFill( aDespFrete[nI], 0 )
Next nI

For nI := 1 to nLenCols
	If !(aCols[nI][Len(aCols[nI])])
		If Posicione("SF4",1,xFilial("SF4")+gdFieldGet("L2_TES    ",nI),"SF4->F4_ISS") <> "S"
			nPerTotal := gdFieldGet("L2_VLRITEM",nI) / nVlrTotFrt
			If cPaisLoc == "BRA"
				aDespFrete[nI][1] := Round(NoRound(nPerTotal * M->L1_FRETE,3),2)
				aDespFrete[nI][2] := Round(NoRound(nPerTotal * M->L1_SEGURO,3),2)
				aDespFrete[nI][3] := Round(NoRound(nPerTotal * M->L1_DESPESA,3),2)
			Else                                                          
				aDespFrete[nI][1] := Round(nPerTotal * M->L1_FRETE,nDecimais)
				aDespFrete[nI][2] := Round(nPerTotal * M->L1_SEGURO,nDecimais)
				aDespFrete[nI][3] := Round(nPerTotal * M->L1_DESPESA,nDecimais)
			EndIf
		Endif
	Endif
Next nI
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica o arredondamento dos valores do frete, seguro e desp.acessorias ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nVlrFrete 	:= 0
nVlrSeguro	:= 0
nVlrDespesa	:= 0

aEval(aDespFrete, {|x| (nVlrFrete+=x[1], nVlrSeguro+=x[2], nVlrDespesa+=x[3]) })

If nCountFrt > 0
	nFrete 		:= Mod((M->L1_FRETE - nVlrFrete), nCountFrt)
	nSeguro 	:= Mod((M->L1_SEGURO - nVlrSeguro), nCountFrt)
	nDespesa 	:= Mod((M->L1_DESPESA - nVlrDespesa), nCountFrt)
	
	aDespFrete[Len(aDespFrete)][1] += nFrete
	aDespFrete[Len(aDespFrete)][2] += nSeguro
	aDespFrete[Len(aDespFrete)][3] += nDespesa
	
	If cPaisLoc == "BRA"
		For nI := 1 to nLenCols
			gdFieldPut("L2_VALFRE",aDespFrete[nI][1],nI)
			gdFieldPut("L2_SEGURO",aDespFrete[nI][2],nI)
			gdFieldPut("L2_DESPESA",aDespFrete[nI][3],nI)
		Next nI
	EndIf
EndIf

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³AnoBissexto³Autor ³Vendas Clientes        ³ Data ³ 31/08/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Determina se um ano eh bissexto                             ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function AnoBissexto( nAno )
Local lRet	:= .F.

If Mod( nAno, 4 ) == 0 .AND. Mod( nAno, 100 ) <> 0
	lRet := .T.
Endif

Return lRet

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºPrograma  ³Lj010PegaPºAutor  ³Vendas Clientes     º Data ³ 30/09/2004  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Solicita peso da balanca e retira os valores.              º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ ExpL1 -> .T. = Chamada pelo sistema (funcao LJ010Produto)  º±±
±±º          ³          .F. = Chamada pelo CTRL + Y                       º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³ Caso o parametro seja igual a .T., retornara o peso.       º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ LOJA010                                                    º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function Lj010PegaPeso(lAutom)
Local nPosQuant := 0					//Posicao de quantidade da Venda Balcao
Local nPosProd  := 0					//Posicao do codigo do produto
Local cPeso     := Space(6)				//Variavel que irá tirar o peso da balanca
Local aAreaSX3  := {} 					//Area do SX3
Local aArea     := GetArea()         	//Area atual do sistema
Local nTimeOut  := 0                 	//Controle de TimeOut
Local lLoja010  := ( FunName() == "LOJA010" )
Local nValPeso  := 0                 	// Valor do peso

Default lAutom 	:= .F.

If nMaxTimeOut == NIL
	nMaxTimeOut := IIf( SLG->(FieldPos("LG_TIMEBAL")) > 0,LjGetStation("TIMEBAL"),20)
EndIf

If nDec == NIL	
    aAreaSX3  := SX3->(GetArea())	
	DbSelectArea("SX3")
	DbSetOrder(2)
	If DbSeek("LR_QUANT")	
		nDec := SX3->X3_DECIMAL  
	Endif	
	SX3->(RestArea(aAreaSX3))
EndIf
	
If lLoja010
	nPosQuant := aPosicoes[11][2]
	nPosProd  := aPosicoes[09][2]
EndIf

If !lAutom .AND. lLoja010
	//Verifico se foi digitado o produto.
	If Empty( aCols[N][nPosProd] )
		MsgStop(STR0097 , STR0001 )//"Atenção"//"Primeiro é necessário selecionar um produto."
		Return 0
	EndIf
	     
	//Funcionará somente na folder 1
	If oFolder:nOption <> 1
		Return 0
	EndIf
EndIf
   
While .T.                           
	cPeso := Space(6)
	If BalancaPegaPeso(StatBalanca()[2],@cPeso) <> 0
		Return 0
	EndIf
	
	If NoRound(Val(cPeso),nDec ) <> 0
		Exit
	EndIf     
	nTimeOut += 1
	
	If nTimeOut > nMaxTimeOut
		LjMsgRun(STR0098,,{|| Inkey(3)} )//"Tempo excedido para consulta do peso."
		Return 0
	EndIf
End
     
If ! lAutom .AND. lLoja010
	M->L2_QUANT         := NoRound(Val(cPeso),nDecimais)
	aCols[N][nPosQuant] := NoRound(Val(cPeso),nDecimais)
	
	//Caso exista desconto dispara o gatilho para acertar os valores
	DbSelectArea( "SX3" )
	DbSetOrder(2)
	DbSeek("L2_QUANT")
	If ExistTrigger("L2_QUANT")
		RunTrigger(2,N)
	EndIf
EndIf

nValPeso  := NoRound(Val(cPeso),nDec )

RestArea( aArea )

Return (nValPeso)       

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LjSaldoDINºAutor  ³Vendas Clientes     º Data ³  28/07/05   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ 1) Totaliza o valor em dinheiro de todas as devolucoes     º±±
±±º          ³ existentes para o caixa na data especificada.              º±±
±±º          ³ 2) Totaliza o valor em dinheiro de todos os pagamentos     º±±
±±º          ³ efetuados.                                                 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGALOJA                                                   º±±
±±ºÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄº±±
±±ºParƒmetros³ ExpN1 - Evento para filtrar o valor em dinheiro utilizado  º±±
±±º          ³        [1]- Devolucao                                      º±±
±±º          ³        [2]- Pagamentos                                     º±±
±±º          ³        [3]- Recebimentos                                   º±±
±±º          ³ ExpC2 - Codigo do CAIXA                                    º±±
±±º          ³ ExpD3 - Data do Movimento                                  º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function LjSaldoDIN( nOpcao , cCaixa , dDataMovto )
Local nValorDIN	:= 0       						//Saldo em Dinheiro     
Local cTipo		:= CriaVar("E5_TIPO"	,.F.)	//Tipo da Movimentacao Bancaria
Local cTipoDOC	:= CriaVar("E5_TIPODOC"	,.F.)  	//Tipo do Documento da Movimentacao Bancaria
Local cMoedaSE5	:= CriaVar("E5_MOEDA"	,.F.)	//Moeda utilizada na Movimentacao Bancaria
Local cRecPag	:= CriaVar("E5_RECPAG"	,.F.)	//Tipo de Documento R(Recebimento) ou P(Pagamento)

#IFDEF TOP
	Local cSE5		:= "SE5TMP" 				//Alias do arquivo temporario
	Local cQuery	:= ""  		
#ENDIF

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Assume que sera calculado o saldo do dinheiro de devolucao³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DEFAULT nOpcao	:= 1 
Do Case
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se for calcular o saldo do valor em dinheiro ja devolvido, le somente os ³
	//³registros que estao com TIPODOC == "LJ" e Tipo == Simbolo da Moeda Padrao³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Case nOpcao == 1 //Devolucao
		cTipoDoc	:= 'LJ'
	    cTipo		:= Alltrim(SuperGetMV("MV_SIMB1"))
   		cRecPag		:= 'P'
	Case nOpcao == 2 //Pagamentos
		cMoedaSE5   := Alltrim(SuperGetMV("MV_SIMB1"))
   		cRecPag		:= 'P'
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se for calcular o saldo do valor de recebimento em dinheiro le somente os³
	//³registros que estao com TIPODOC == "VL" e Tipo == Simbolo da Moeda Padrao³
	//³e Tipo do Documento == R (Recebimento).                                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Case nOpcao == 3 //Recebimentos
		cTipoDoc	:= 'VL'		
		cMoedaSE5   := Alltrim(SuperGetMV("MV_SIMB1"))
		cRecPag		:= 'R'
EndCase
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Leitura do SE5 para identificar quanto em dinheiro foi devolvido ou feito pagamento³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
#IFDEF TOP
	cQuery := "SELECT SE5.E5_DATA, SE5.E5_VALOR, SE5.E5_PREFIXO, SE5.E5_NUMERO, SE5.E5_PARCELA,"
	cQuery +=        "SE5.E5_TIPO , SE5.E5_TIPODOC, SE5.E5_CLIFOR, SE5.E5_LOJA   ,"
	cQuery +=        "SE5.E5_SEQ  , SE5.E5_VENCTO , SE5.E5_MOEDA , SE5.E5_RECPAG  "
	cQuery += " FROM " + RetSQLName("SE5") + " SE5"
	cQuery += " WHERE SE5.E5_FILIAL	= '" + xFilial("SE5") 	+ "'"
	cQuery += " AND SE5.E5_DATA 	= '" + DToS(dDataMovto)	+ "'"
	cQuery += " AND SE5.E5_BANCO 	= '" + cCaixa 	+ "'  "
	cQuery += " AND (SE5.E5_SITUACA <> 'C') AND (SE5.E5_MOEDA <> 'ES')"
	cQuery += " AND SE5.E5_RECPAG 	= '" + cRecPag	+ "'"

	If nOpcao <> 3 	//Recebimentos
		cQuery += " AND SE5.E5_TIPO   	= '" + cTipo 	+ "' "
	Endif

	cQuery += " AND SE5.E5_TIPODOC 	= '" + cTipoDoc + "'  "
	cQuery += " AND SE5.E5_MOEDA 	= '" + cMoedaSE5+ "'  "
	cQuery += " AND SE5.D_E_L_E_T_ 	= ' '"
	cQuery := ChangeQuery(cQuery)
	dbUseArea( .T., "TOPCONN", TCGenQry(,,cQuery), cSE5, .F., .T.)
                           
	While !EOF()
		//Verifica se tem cancelamento para este titulo.
		If TemBxCanc((cSE5)->E5_PREFIXO+(cSE5)->E5_NUMERO+(cSE5)->E5_PARCELA+(cSE5)->E5_TIPO+(cSE5)->E5_CLIFOR+(cSE5)->E5_LOJA+(cSE5)->E5_SEQ)
			DbSkip()
			Loop
		EndIf

		If ( AllTrim((cSE5)->E5_TIPO) $ ( MV_CRNEG + "/PA" ) ) .OR. (cSE5)->E5_VENCTO > (cSE5)->E5_DATA
			DbSkip()
			Loop
		EndIf

		If (cSE5)->E5_TIPODOC $ "DC/JR/MT/CM/D2/J2/M2/C2/V2/CP/TL"  //Valores de Baixas
			DbSkip()
			Loop
		EndIf
		
		nValorDIN+= (cSE5)->E5_VALOR
		        
		DbSkip()
	End
		
DbSelectArea(cSE5)
DbCloseArea()

#ELSE
	DbSelectArea("SE5")
	DbSetOrder(1)
	If DbSeek(xFilial() + DTOS( dDataMovto ) + cCaixa )	// Filial + Data + Caixa
		While !EOF() .AND. ;
			SE5->E5_FILIAL >= xFilial("SE5") 	.AND.;
			SE5->E5_FILIAL <= xFilial("SE5") 	.AND.;
			( DTOS(SE5->E5_DATA)+ SE5->E5_BANCO ) == ( DTOS(dDataMovto)+cCaixa )
	
			// Verifica se tem Estorno ou cancelado
			If SE5->E5_SITUACA == "C" .OR. SE5->E5_MOEDA == "ES"
				DbSkip()
				Loop
			Endif
	
			//Verifica se tem cancelamento para este titulo.
			If TemBxCanc(SE5->E5_PREFIXO+SE5->E5_NUMERO+SE5->E5_PARCELA+SE5->E5_TIPO+SE5->E5_CLIFOR+SE5->E5_LOJA+SE5->E5_SEQ)
				DbSkip()
				Loop
			EndIf  
	
			If ( AllTrim(SE5->E5_TIPO) $ ( MV_CRNEG + "/PA" ) ) .OR. (SE5->E5_VENCTO > SE5->E5_DATA)
				DbSkip()
				Loop
			EndIf
	
			If SE5->E5_TIPODOC $ "DC/JR/MT/CM/D2/J2/M2/C2/V2/CP/TL"  //Valores de Baixas
				DbSkip()
				Loop
			EndIf
	
			If SE5->E5_RECPAG  <> cRecPag
				DbSkip()
				Loop
			Endif
			
			If  nOpcao <> 3 	//Recebimentos
				If SE5->E5_TIPO    <> cTipo
					DbSkip()
					Loop
				Endif
	        Endif
	        
			If SE5->E5_TIPODOC <> cTipoDOC		
				DbSkip()
				Loop
			Endif
	
			If SE5->E5_MOEDA   <> cMoedaSE5
				DbSkip()
				Loop
			Endif
			
			nValorDIN+=SE5->E5_VALOR
	        DbSelectArea("SE5")
			DbSkip()
	
		End
	Endif
#ENDIF

Return (nValorDIN)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³LojxDin   ³ Autor ³ Vendas Clientes       ³ Data ³ 26/05/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Tela de negociacao de formas de pagamentos                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Frta010A                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LojxDin( 	aItens      , nTotal    	, oFntFecha   	, nEntrada    	,;
				   	nFinanciado , oDlgFecha 	, lNegociada  	, nVlrTot     	,;
				   	lAltValor   , aDadosPag 	, nLinParc    	, lValidParc  	,;
				   	lConfirma	, oPgtos		, aPgtos		, oPgtosAna		,;
				   	nTxJuros	, aMoeda		, nMoedaCor		, lVendaRapida	,;
				   	cSimbCheq	, nValorBase	, nTaxaMoeda	, cCliente		,;
				   	cLojaCli	, nDecimais		, oDlgFrt		, aTefBKPCS		,;
				   	aTxJurAdm	)
Local nValAteP																					//Alteracao de parcela
Local nI																						//Linha corrente de array
Local nPosParc := 0																				//Posicao da parcela
Local nValAnt																					//Valor anterior
Local oDlgLojaPag																				//Objeto
Local oValor																					//Objeto
Local oComboAdm																					//Objeto
Local oComboPag																					//Objeto
Local oComboMoed																				//Objeto
Local oCheckPag																					//Objeto
Local cComboAdm																					//Combo Adm
Local cComboPag																					//Combo pagamento
Local cComboAnt																					//Combo anterior
Local lSintVisu	   := If(SL4->(FieldPos("L4_FORMAID"))>0,.T.,.F.) 								//Indica se a interface utilizará a forma de visualização sintetizada ou a antiga, evitando problemas com a metodologia anterior
Local nLinha	   := If(lSintVisu .AND. ValType(oPgtosAna)=="O",oPgtosAna:nAt,oPgtos:nAt) 		//Verifica a posição no aPgtos, pois provém de 2 objetos <>'s										
Local aMatriz	   := {}																		//Matriz
Local aAdm_Back    := {}																		//Administradora anterior
Local aAdm		   := {}																		//Administradora
Local aMultMoeda   := {}																		//Mult moeda
Local lCheckPag    := .F.																		//Valida a linha
Local dDataForm    := aPgtos[nLinha,1]															//Data
Local nValor	   := aPgtos[nLinha,2]															//Valor
Local nParcAtu     := nLinha																	//Parcela Atual
Local xRet		   := Nil																		//Retorno da funcao
Local nValAtu	   := nValor 																	//Guarda o valor atual da parcela
Local nTam1        := 0																			//Tamanho2
Local nTam2        := 0																			//Tamanho1
Local nCol		   := 0																			//Coluna
Local cMoedaTit    := ""																		//Titulo
Local aTmpPgtos    := {}																		//Array temporario com as parcelas
Local lAParc       := LjProfile(9) 																//Verifica permissao de acesso do caixa Alterar dados da parcela
Local lDinheiro    := .F.																		//Se utiliza dinheiro
Local nPosMoeda1   := 0																			//Moeda
Local lExpres      := (nTxJuros==0 .OR. cPaisLoc=="BRA" .OR. (nTxJuros>0 .AND. FunName(0)$"FRTA010|FRTA271"))
Local lParcelas    := .F. 																		//Var de confirmacao de alteracao das parcelas
Local cFormas      := ""																		//Formas
Local cTipoVenda   := If(FunName()=="LOJA220","2","1")										//Tipo de Venda
Local lTefMult 	   := GetNewPar("MV_TEFMULT",.F.)			   									//Identifica se o cliente utiliza múltiplas transações TEF
Local cDigCart 	   := "" , oDigCart																//Dígitos do Cartão
Local lHabDig	   := If(lTefMult .AND. FunName()$"FRTA010|FRTA271",.T.,.F.)						//Identifica se solicita digitos do cartao
Local nLinDig      := 0					   														//Linha onde se começa as mudanças de posição por parâmetros					
Local nJanDig      := 0					   														//Aumento o tamanho da Dialog se for utilizar o TEF
Local nFor		   := 0																			//Controle de laço	para atualização das datas de vecto
Local cCond		   := SE4->E4_CODIGO															//Codigo da condicao para recalculo
Local aDatas	   := {}                                                						//Array com próximas condições de pagamento
Local cFormAtu	   := ""																		//Guarda a forma de pagamento para recalculo das datas
Local cDigAtu	   := ""																		//Guarda o digito para recalculo das datas
Local lUsaTroco    := (GetNewPar("MV_LJTROCO",.F.) .AND.  SL1->(FieldPos("L1_TROCO1"))>0  .AND. cPaisLoc == "BRA" .AND. lVendaRapida .AND. cTipoVenda <> "2")  // Determina se usa troco para diversas formas de pagamento
Local nPosPagto    := 0																			//Posicao Pagtos
Local nParcAtual   := aPgtos[nLinha][2] 														//Valor da parcela atual para utilizacao na funcao Lj010Fill
Local dDataEmis    := aPgtos[nLinha][1]															//Data de emissão da parcela
Local nTmpValor    := 0                                             							//Valor da venda para calculo das parcelas
Local lVerEmpres   := Lj950Acres(SM0->M0_CGC)													//Verifica as filiais da trabalharam com acrescimento separado
Local nRatAcres	   := 0     																	//Soma dos acrescimos
Local aPosPgtos	   := {}																		//Posicao das parcelas para serem recalculadas
Local nMenParc	   := 0																			//Menor Parcela
Local nPosReal	   := 0																			//Posicao da menor parcela
Local nValRat	   := 0																			//Valor do rateio
Local lValTot	   := SuperGetMV("MV_VALTOTA",NIL,.F.)  										//Verifica se valida ou nao o total da fatura com o que foi pago
Local lTransTef	   := .F.																		//verifica se foi efetuada uma transacao de TEF anteriormente para nao permitir alteracao
Local nPosId	   := 0																			//variavel para controlar a posicao do arrya de pagamentos
Local lMvJurCc	   := SuperGetMV("MV_LJJURCC",NIL,.F.)											//Parametro para habilitar ou nao o juros por cartao de credito
Local nIntervalo   := SuperGetMV("MV_LJINTER",NIL,0)											//Intervalo de dias das parcelas
Local cForma	   := ""																		//Forma de pagamento CC;CD
Local nQtParc	   := 0																			//Qtd de parcelas
Local lFtvdVer12   := LjFTVD()								 									//Verifica se é Release 11.7 e o FunName é FATA701 - Compatibilização Venda Direta x Venda Assisitida
Local nCount	   := 0     																	//Contador de For                                                                     
Local nParcela     := 0                                                                         //Contador da parcela

Default lAltValor  	:= .T.
Default aDadosPag  	:= {}
Default nLinParc   	:= 0  
Default nMoedaCor		:= 1	                                                                    //Moeda Corrente
Default nDecimais		:= MsDecimais(nMoedaCor)													//Numero de Casa Decimais	
Default aTefBKPCS		:= {}																		//
Default aTxJurAdm		:= {0,0,0}

nLinha     := If(nLinParc > 0, nLinParc,nLinha)                   //Respeita a linha passada por parametro
dDataForm  := aPgtos[nLinha,1]
nValor	   := aPgtos[nLinha,2]
nParcAtu   := nLinha
nValAtu	   := nValor 											
dDataEmis  := aPgtos[nLinha][1]								
nParcAtual := aPgtos[nLinha][2] 								

If nModulo <> 23 
	nPosId := 8
Else
	nPosId := 12
EndIf         

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Valida se existe alguma transacao de TEF ja enviada,   ³
//³ e nao permite alteracao da mesma                       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For nI := 1 to Len( aTefBKPCS )
	If aTefBKPCS[nI]:CAUTORIZA <> "" .AND. AllTrim(aTefBKPCS[nI]:CIDCART) == AllTrim(aPgtos[nLinha][nPosId])
		lTransTef	:=	.T.
		Exit		
	EndIf
Next nI

If lTransTef
	MsgStop (STR0124)	//"Transação de TEF efetuada. Alteração não permitida."
Else
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Atualiza a administradoras para cada forma ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nI := 1 to Len( aPgtos )
		Aadd( aAdm_Back, aPgtos[nI][4] )
	Next nI
	
	If IsMoney(aPgtos[nLinha,3])
		lDinheiro := .T.
		//Posicao do simbolo da moeda 1 para ser usada de forma generica para todas as moedas
		nPosMoeda1 := Ascan(aItens,{|aVal|AllTrim(aVal[2]) == AllTrim(SuperGetMV("MV_SIMB1"))})
	EndIf
	
	nPosParc := Ascan(aItens,{|aVal|AllTrim(aVal[2]) == AllTrim(aPgtos[nLinha,3])})
	
	If !Empty(aPgtos)
		
		For nI := 1 To Len(aItens)
			Aadd(aMatriz,aItens[nI][1])
		Next nI
	
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Ponto de Entrada para filtrar o array das formas de pagto. (combobox)³
		//³de acordo com as regras e politicas comerciais da empresa            ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ExistBlock("LJ220FORMA") .AND. !lFtvdVer12
			aMatriz := ExecBlock("LJ220FORMA",.F.,.F.,{aMatriz}) 
		Endif
		
		If ExistBlock("FTVD220FORMA") .AND. lFtvdVer12
			aMatriz := ExecBlock("FTVD220FORMA",.F.,.F.,{aMatriz}) 
		Endif
		
		// Soma o Valor total at‚ a parcela inferiormente a clicada
		nValAteP := 0
		For nI := 1 To nLinha-1
			nValAteP := nValAteP + Round(xMoeda(aPgtos[nI][2],aPgtos[nI][11],nMoedaCor,dDatabase,nDecimais+1,,nTaxaMoeda),nDecimais)
		Next nI
		If lDinheiro .AND. nPosMoeda1 > 0
			cComboPag := aItens[nPosMoeda1,1]  //Para todas as moedas, mostra a descricao Dinheiro
		ElseIf nPosParc > 0
			cComboPag := aItens[nPosParc,1]
		Endif
		cMoedaTit := SuperGetMV("MV_MOEDA"+Ltrim(Str(aPgtos[nLinha,11])))
		nValAnt	  := aPgtos[nLinha,2]
		cComboAnt := aPgtos[nLinha,3]
		dDataAnt  := aPgtos[nLinha,1]
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Pr‚ carrega o array aAdm ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If ExistBlock ("LJ220ADM") .AND. !lFtvdVer12
			aAdm := ExecBlock("LJ220ADM",.F.,.F.,) 
		ElseIf !lFtvdVer12
			DbSelectArea("SAE")
			DbSetOrder(1)
			DbSeek( xFilial("SAE") )
			aAdm := {}
			While !Eof() .AND. xFilial("SAE") == SAE->AE_FILIAL
				If Alltrim(SAE->AE_TIPO) == Alltrim(aPgtos[nParcAtu][3])
					Aadd( aAdm, SAE->AE_COD + " - " + SAE->AE_DESC )
				EndIf
				DbSkip()
			End
		EndIf	
		
		If ExistBlock ("FTVD220ADM") .AND. lFtvdVer12
			aAdm := ExecBlock("FTVD220ADM",.F.,.F.,) 
		ElseIf lFtvdVer12
			DbSelectArea("SAE")
			DbSetOrder(1)
			DbSeek( xFilial("SAE") )
			aAdm := {}
			While !Eof() .AND. xFilial("SAE") == SAE->AE_FILIAL
				If Alltrim(SAE->AE_TIPO) == Alltrim(aPgtos[nParcAtu][3])
					Aadd( aAdm, SAE->AE_COD + " - " + SAE->AE_DESC )
				EndIf
				DbSkip()
			End
		EndIf	
			
		//Caso nao exista nenhuma administradora financeira para a forma escolhida nao permite
		//a edicao da parcela.
		If !(IsMoney(cComboAnt) .OR. cComboAnt==cSimbCheq) .AND. Empty(aAdm)
			MsgStop(STR0102, STR0104)  //"Nao existe nenhuma administradora financeira cadastrada para a forma de pagamento escolhida."###"Atencao"
			Return(Nil)
		EndIf
			
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Administradora da forma atual ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cComboAdm := aAdm_Back[nParcAtu]
		
		// Verifica se o CheckBox "Utiliza nas próximas parcelas" vira marcado ou desmarcado
		lCheckPag := (AllTrim(aPgtos[nParcAtu][3]) $ SuperGetMV("MV_PRXPARC"))
		
		If Len(aMoeda) > 0  //Modificacao na tela para mostrar combo de Moedas(Localizacoes)
			nTam1  := 70
			nTam2  := 15
		EndIf
		
		aTmpPgtos := aClone(aPgtos)
	
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Se o cliente utilizar multiplas transações TEF vou exibir os dígitos ou o ID Cartão³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lHabDig 
			If lSintVisu
			    cDigCart:= If(!Empty(aTmpPgtos[nParcAtu][12]),aTmpPgtos[nParcAtu][12],Space(TamSX3("L4_FORMAID")[1]))
			Else
			    cDigCart:= If(!Empty(aTmpPgtos[nParcAtu][12]),aTmpPgtos[nParcAtu][12],Space(04))
			EndIf			    
			nLinDig := 12
			nJanDig := 35
		EndIf
	
		DEFINE MSDIALOG oDlgLojaPag FROM  73,144 TO 293+nTam1+nJanDig,490 TITLE STR0110 OF oDlgFecha PIXEL // Parcelas
	
		@nCol,03 TO 95+nTam2+nLinDig,171 LABEL "" OF oDlgLojaPag PIXEL
	
		If cPaisLoc <> "BRA"
	
			dDataForm := aPgtos[nLinha,1]
			If Len(aPgtos[nLinha]) > 12
				If ValType(aPgtos[nLinha,13]) =="D"
			   		dDataEmis := aPgtos[nLinha,13]
			   	EndIf			   
	        EndIf
			cFormas := cComboPag		
	
			If ExistBlock("LJ220VAL") .AND. !lFtvdVer12
				cFormas := ExecBlock("LJ220VAL",.F.,.F.)
			EndIf		
			
			If ExistBlock("FTVD220VAL") .AND. lFtvdVer12
				cFormas := ExecBlock("FTVD220VAL",.F.,.F.)
			EndIf
			
	        //Conversao de valores
			@ 03,44 BUTTON STR0103 SIZE 60,12 ACTION (LjxDRetVConv( @cMoedaTit 	, @oComboMoed 	, @nValor 	, @oValor ,;
																	 aMoeda		, @aMultMoeda	,"FRONT"	,cTipoVenda,;
																	 NIL		, oDlgFrt	)) OF oDlgLojaPag PIXEL 
	
			//Vencimento
			@ nCol+=15,06 	SAY STR0101 SIZE 30, 7 OF oDlgLojaPag PIXEL //Data
			@ nCol	  ,46 	MSGET dDataForm RIGHT Picture "99/99/99" SIZE 45,08 PIXEL OF oDlgLojaPag;
								VALID LjxDDtVcto(dDataEmis,dDataForm,cComboPag,oPgtos,@aPgtos);
								WHEN If(Alltrim(Upper(cComboPag)) $ Alltrim(Upper(cFormas)),.T.,.F.) 
			//Emissao
			@ nCol+=12, 06 	SAY STR0100 SIZE 21, 07 OF oDlgLojaPag PIXEL //Data contribuicao 
			@ nCol, 46 		MSGET dDataEmis RIGHT Picture "99/99/99" SIZE 45,08 PIXEL OF oDlgLojaPag;
								VALID LjxDDtEmis(dDataEmis,dDataForm,cComboPag,oPgtos,@aPgtos);
								WHEN If(Alltrim(Upper(cComboPag)) $ Alltrim(Upper(cFormas)),.T.,.F.) 
		Else
			@ nCol+=12, 06 	SAY STR0111 SIZE 16, 7 OF oDlgLojaPag PIXEL //Data
			@ nCol, 46 	MSGET dDataForm RIGHT Picture "99/99/99" SIZE 45,08 PIXEL When lAParc OF oDlgLojaPag Valid dDataForm >= dDataBase
		EndIf
	
		@ nCol+=15, 06 	SAY STR0112 SIZE 17, 7 OF oDlgLojaPag PIXEL //Valor
		@ ncol, 46	MSGET oValor VAR nValor RIGHT SIZE 55,08 Picture PesqPict("SL1","L1_VLRTOT");
					VALID(LjMsgVal(nValor,.F.) .AND. If(cPaisLoc == "BRA",((nValor+nValAteP)<=nTotal) .OR. ;
					     (lUsaTroco .AND. !lDinheiro),If(lValTot,LjxDValP(nValor,nValAteP,nTotal,cMoedaTit),.T.))) ;
					PIXEL WHEN (lAParc .AND. lAltValor) OF oDlgLojaPag
		
		@ nCol+=15, 06 	SAY STR0113 SIZE 19, 7 OF oDlgLojaPag PIXEL // Forma
	
		If cPaisLoc == "BRA"
			@ nCol, 46 	MSCOMBOBOX oComboPag VAR cComboPag ITEMS aMatriz SIZE 61, 44 OF oDlgLojaPag PIXEL;
							WHEN lAParc;
							ON CHANGE (LjxDChoicAdm(@aAdm, aItens[oComboPag:nAt][2], oComboAdm, @cComboAdm , oCheckPag),;
							aAdm_Back[nParcAtu] := cComboAdm ,;
													LjxDCbFor(	oCheckPag	, @lCheckPag	, aMatriz	, cComboPag	,;
																aItens		, @aPgtos))
		Else
			@ nCol, 046 MSCOMBOBOX oComboPag VAR cComboPag ITEMS aMatriz ;
				  			ON CHANGE (LjxDChoicAdm(@aAdm,aItens[oComboPag:nAt][2],oComboAdm,@cComboAdm,oCheckPag),aAdm_Back[nParcAtu]:=cComboAdm);
							VALID LjxDCbFrm(cComboPag,oPgtos,@aPgtos,@dDataEmis,@dDataForm,aPgtos) ;
							OF oDlgLojaPag SIZE 61, 44 PIXEL
	
			@ nCol+=15,06 SAY STR0107 SIZE 22, 07 OF oDlgLojaPag PIXEL         //"Moeda"
			@ nCol,46 	MSCOMBOBOX oComboMoed VAR cMoedaTit ITEMS aMoeda SIZE 61, 44 OF oDlgLojaPag PIXEL
			nCol+=3		
		EndIf						
		
		@ nCol+=20, 06 	SAY STR0114 SIZE 38, 7 OF oDlgLojaPag PIXEL // Administradora
		@ nCol, 46 	MSCOMBOBOX oComboAdm VAR cComboAdm ITEMS aAdm SIZE 121, 44 OF oDlgLojaPag PIXEL;
						ON CHANGE aAdm_Back[nParcAtu] := cComboAdm
	
		If lHabDig
			If lSintVisu
				@ nCol+=20,06 SAY STR0106 PIXEL 							//"ID Cartão"
	  		    @ nCol	  ,46 MSGET oDigCart VAR cDigCart SIZE 10,10 RIGHT PICTURE PesqPict("SL4","L4_FORMAID") ;
	  		    				VALID LjxValIdC (cDigCart, aTefBKPCS) ;
	  		    				OF oDlgLojaPag PIXEL ;
	  		    				WHEN .T.
				oDigCart:cSx1Hlp:="L4_FORMAID"
			Else
				@ nCol+=20,06 SAY STR0105 PIXEL 							//"Dígitos Cartão"
			    @ nCol    ,46 MSGET oDigCart VAR cDigCart SIZE 10,10 RIGHT PICTURE "9999" OF oDlgLojaPag PIXEL
			EndIf
		EndIf
	
		//Utiliza nas pr¢ximas parcelas
		@ nCol+=20,06 CHECKBOX oCheckPag VAR lCheckPag PROMPT STR0115 SIZE 92,10 OF oDlgLojaPag PIXEL
		oCheckPag:oFont := oDlgLojaPag:oFont
				
		DEFINE SBUTTON FROM nCol+=16,75 TYPE 1 ACTION ;
		        (lConfirma  := .T.         ,;
				If(dDataForm >= dDataBase,;
					If(LjxDDtPag( 	cComboPag	, nLinha     , aItens	, dDataForm  ,;
					                lCheckPag	, lValidParc , cCliente , cLojaCli ) .AND.;
					    LjxDDinV( 	@nValor   	, .T.    	, oDlgLojaPag  , cComboPag  ,;
					               	dDataForm ) .AND. LjxAAtuId(nLinha,@cDigCart,@aPgtos,lHabDig,;
					               								cComboPag,aItens) ,;
						   		 (lParcelas := .T.)  ,;
						   		 (lParcelas := .F.) ) ,;
			    lParcelas := .F. ),;
			    cForma := aItens[oComboPag:nAt][2]) ;
			    ENABLE OF oDlgLojaPag
			    
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Cria o botao para visualizacao das parcelas ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	    If (lMvJurCc) .AND. (Len(aTmpPgtos)  > 0) .AND. (Len(aItens) > 0)
			oButton := tButton():New(nCol, 06, STR0171, oDlgLojaPag,;
									 {|| LjAParc(IIf(lCheckPag,Len(aTmpPgtos),1), aTmpPgtos, nValor, dDataForm,;
									  aItens[oComboPag:nAt][2], nLinha, cComboAdm, nIntervalo,;
									  lMvJurCc, IIf(lTefMult,cDigCart,0)) }, 33, 10.5,,,, .T.) //"Visualizar"
		EndIf
		
		//DINHEIRO
		ACTIVATE MSDIALOG oDlgLojaPag ON INIT (If(Len(aPgtos)>1,If(nParcAtu<>Len(aPgtos),If(Upper(cComboPag)==STR0116,oCheckPag:Disable(),),oCheckPag:Disable()),oCheckPag:Disable())) CENTERED;
		VALID LjxConfPar(	lConfirma, 	nLinha, 	aPgtos, 	cDigCart, ;
							aTefBKPCS	)
	
		//Chama novamente a validação do ID, caso o usuário não o informe
		If lHabDig .AND. lSintVisu 
			lParcelas := ( LojxWhenID( nLinha    ,cComboPag   ,cDigCart   ,aItens   ,;
			                             .T.     , cComboAdm, @aPgtos) .AND. ;
			                LojxValiID( cComboPag  ,cDigCart   ,aItens, @aPgtos ) )
		EndIf
	
		If lParcelas
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Ponto de entrada utilizado para nao aceitar a troca do tipo de uma    	 ³
			//³ determinada parcela seguindo as politicas e regras da empresa.			 |
			//³ Ex: 3x Financiado -> alterado 1a. parcela para dinheiro					 ³
			//³ 	Nao segue regra da empresa. 										 ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !lFtvdVer12 .AND. ExistBlock( "LJ220APARC" )
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Verificar antes de atualizar a variavel que contem a parcela selecionada se esta³
				//³no modo de visualizacao sintetizada ou normal.                                  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nParcela := If(lSintVisu .AND. ValType(oPgtosAna)=="O",oPgtosAna:nAt,oPgtos:nAt)

				xRet := ExecBlock( "LJ220APARC", .F., .F., { 	aPgtos,		;	//Array com todas as parcelas
																nParcela,	;	//Parcela atual
																dDataForm,	;	//Data da parcela
																nValor,		;	//Valor da parcela
																cComboPag,	;	//Tipo da parcela
																aMatriz,	;	//Array com todos os tipos de parcela
																cComboAdm,	;	//Administradora
																aAdm,		;	//Array com todas as administradoras
																lCheckPag })
				If ValType(xRet) = "L"
					If !xRet
						Return
					EndIf     
				ElseIf ValType(xRet) = "A"
					dDataForm := xRet[nParcela][1]
					If lCheckPag .AND. Len(xRet) > 0   
						For nCount := 1 to Len(xRet)
							aTmpPgtos[nCount][1] := xRet[nCount][1]
						Next nCount
					EndIf
				EndIf
			ElseIf	lFtvdVer12 .AND. ExistBlock( "FTVD220APARC" )
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Verificar antes de atualizar a variavel que contem a parcela selecionada se esta³
				//³no modo de visualizacao sintetizada ou normal.                                  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				nParcela := If(lSintVisu .AND. ValType(oPgtosAna)=="O",oPgtosAna:nAt,oPgtos:nAt)
				
				xRet := ExecBlock( "FTVD220APARC", .F., .F., ;
									{ 	aPgtos, ;			//Array com todas as parcelas
										nParcela, ;			//Parcela atual
										dDataForm, ;		//Data da parcela
										nValor, ;			//Valor da parcela
										cComboPag, ;		//Tipo da parcela
										aMatriz, ;			//Array com todos os tipos de parcela
										cComboAdm, ;		//Administradora
										aAdm, ;				//Array com todas as administradoras
										lCheckPag } )		//Variavel 'Utiliza nas proximas parcelas'
	
				If ValType(xRet) = "L"
					If !xRet
						Return
					EndIf     
				ElseIf ValType(xRet) = "A"
					dDataForm := xRet[nParcela][1]
					If lCheckPag .AND. Len(xRet) > 0   
						For nCount := 1 to Len(xRet)
							aTmpPgtos[nCount][1] := xRet[nCount][1]
						Next nCount
					EndIf				
				EndIf
			EndIf
			
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Se o cliente utilizar multiplas transações TEF gravar o ID Cartão		     ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lHabDig
				cFormAtu := aTmpPgtos[nParcAtu][3]
		   		For nFor := nParcAtu To Len(aPgtos)
					If cFormAtu == aTmpPgtos[nFor][3]
						aTmpPgtos[nFor][12]:=Alltrim(cDigCart)
					EndIf
				Next nFor
		   	EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Recalcular datas de Vencimento para as próximas parcelas se houve alteração   ³
			//|quando escolhida uma forma de pagamento pré-cadastrada						 |
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		   	If !Empty(cCond) .AND. Len(aPgtos)>0 .AND. aTmpPgtos[nParcAtu][3] $ _FORMATEF .AND. aTmpPgtos[nParcAtu][1] <> dDataForm
		   		aDatas   := Condicao(nTotal,cCond,NIL,dDataForm,NIL,NIL,NIL,NIL)
				cFormAtu := aTmpPgtos[nParcAtu][3]
				cDigAtu  := aTmpPgtos[nParcAtu][12]
		   		For nFor := nParcAtu To Len(aPgtos)
					If Alltrim(cFormAtu) == Alltrim(aTmpPgtos[nFor][3]) .AND. Alltrim(cDigAtu) == Alltrim(aTmpPgtos[nFor][12])
						aTmpPgtos[nFor][1] := aDatas[nFor][1]
					EndIf
		   		Next nFor
		   	EndIf
	
			If lExpres
			   nTmpValor  := nVlrTot
			Else   
			   nTmpValor  := nVlrTot-aDadosJur[6]+aDadosJur[4]+aDadosJur[1]
			Endif   
	
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Se o checkbox utiliza nas proximas parcelas estiver ³
			//³marcado, pega o tamanho do array aTmpPgtos          ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If (lMvJurCc) .AND. Len(aTmpPgtos) > 0
				nQtParc := IIf(lCheckPag,Len(aTmpPgtos),1) 			
			EndIf
	
			LjxDFill(	oComboPag		, cComboPag		, aItens		, dDataForm			,;
						lCheckPag		, nValor		, @nEntrada		, NIL          		,;
						@nFinanciado	, NIL    		, cMoedaTit		, aTmpPgtos			,;
						NIL         	, nTmpValor		, @nMoedaCor	, @oPgtosAna		,;
						@oPgtos			, @aPgtos		, @lVendaRapida	, @nTxJuros			,;
						@nValorBase 	, @nTaxaMoeda  	, nLinha 		, lMvJurCc			,;
						cForma			, cComboAdm		, nQtParc		, @aTxJurAdm		)					
			
			If(cPaisLoc<>"BRA",If(Len(aPgtos[nLinha])>12,aPgtos[nLinha,13]:=dDataEmis,Nil),Nil)
	
	        If Empty(aAdm_Back[nParcAtu])
	           aAdm_Back[nParcAtu] := cComboAdm
	        EndIf
	
			//Atualiza Administradora
			aPgtos[nParcAtu][4] := aAdm_Back[nParcAtu]
	
			//Atualiza identificação do Cartão
			If lHabDig
			   aPgtos[nParcAtu][12] := aTmpPgtos[nParcAtu][12]
			EndIf
			
			//Utiliza nas próximas parcelas, retirei a função LJ220ALL pois só era utilizada neste ponto do sistema
			If lCheckPag
				//Atualizando a forma de pagamento
				For nI := nParcAtu To Len( aAdm_Back )
					aAdm_Back[nI] := cComboAdm
				Next nI
				//Atualizando o aPgtos
				For nI := nParcAtu To Len(aPgtos)
					aPgtos[nI][4] := aAdm_Back[nI]
	 			    aPgtos[nI][1] := aTmpPgtos[nI][1]			
					If lHabDig
					   aPgtos[nI][12] := aTmpPgtos[nI][12]
					EndIf
				Next nI
			EndIf  
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ 
			//³Se trabalha com conceito de acrescimo separado ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If (lVerEmpres .OR. (SuperGetMV("MV_LJICMJR",,.F.) .AND. cPaisLoc == "BRA")) .AND. SL4->(FieldPos("L4_ACRSFIN") > 0)   
				If aScan(aPgtos, {|x| x[3] == "FI"}) > 0 			
					For nI := 1 To Len(aPgtos)
						If aPgtos[nI][2] < nMenParc
							nPosReal := nI
						ElseIf nI == 1
							nPosReal := nI											
						EndIf
						If aPgtos[nI][13] > 0
							If aPgtos[nI][3] <> "FI"
								nRatAcres += aPgtos[nI][13]
								aPgtos[nI][13] := 0
							Else
								nRatAcres += aPgtos[nI][13]
								aPgtos[nI][13] := 0						
								aAdd(aPosPgtos,nI)
							EndIf
						Else
							If aPgtos[nI][3] == "FI"
								aAdd(aPosPgtos,nI)
							EndIf
						EndIf
						nMenParc := aPgtos[nI][2]
					Next nI
					If nRatAcres > 0 .AND. Len(aPosPgtos) > 0
						nValRat := ( nRatAcres / Len(aPosPgtos) )
						For nI := 1 to Len(aPosPgtos)
							If nPosReal == nI
								aPgtos[aPosPgtos[nI]][13] := NoRound(nValRat)												
							Else
								aPgtos[aPosPgtos[nI]][13] := Round(nValRat,nDecimais)
							EndIf
						Next nI
					EndIf					
				EndIf
			EndIf
		EndIf
	Else
		Help(" ",1,"SemDados")
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se alterou o valor para considera como cond negociada ³
	//³ para efeito do recalculo no caso de desconto.                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nValAtu <> nValor
		lNegociada := .T.
	Else
		lNegociada := .F.
	EndIf
	
	nPosPagto  := Ascan(aItens,{|x| ALLTRIM(UPPER(x[1])) == ALLTRIM(UPPER(cComboPag))})
	
	AADD(aDadosPag, dDataForm)
	AADD(aDadosPag, nValor   )
	If nPosPagto > 0
	   AADD(aDadosPag, aItens[nPosPagto][2] )
	Else 
	   AADD(aDadosPag, SuperGetMV("MV_SIMB1") )
	EndIf   
	AADD(aDadosPag, cComboAdm)
	AADD(aDadosPag, cDigCart) 
EndIf

Return( Nil )
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LojxWhenIDºAutora ³Vendas Clientes     º Data ³  11/04/04   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Verifica se é necessária a digitacao do digito de controle º±±
±±º          ³ de cartões                                                 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ ExpL1 = L220WhenID(ExpN2, ExpC3, ExpC4, ExpA5, ExpL6)      º±±
±±º			 ³ ExpL1 - Define se pode habilitar o ID do cartao            º±±
±±º			 ³ ExpN2 - linha corrente do array aPgtos            		  º±±
±±º			 ³ ExpC3 - Descricao da opcao selecionada em forma de pagto	  º±±
±±º			 ³ ExpC4 - Digito do cartao					  				  º±±
±±º			 ³ ExpA5 - Array com as formas de pagto e administradoras	  º±±
±±º			 ³ ExpL6 - Controla se a chamada desta funcao eh no When do   º±±
±±º			 ³ ID ou na confirmacao da modificacao. Se for o segundo caso,º±±
±±º			 ³ deve atualizar o aPgtos quando nao for TEF pois pode ter   º±±
±±º			 ³ selecionado a administradora financeira para as formas de  º±±
±±º			 ³ pagamento FI, VA etc.									  º±±
±±º			 ³ ExpA7 - aPgtos       									  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGALOJA                                                   º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/                                                                           
Static Function LojxWhenID( nLinha     	,cComboPag   ,cDigCart   ,aItens   ,;
                            lAtuPagtos	, cComboAdm, aPgtos )
Local lRet 		:= .F.																		// Retorno da funcao
Local nPos 		:= Ascan(aItens,{|x| Alltrim(Upper(x[1]))==Alltrim(Upper(cComboPag))})	// Se tem condicao de pagamento
Local lTemId	:= .F.																		// Se o aPgtos tem ID

Default cComboAdm := ""

If nPos > 0
	If Alltrim(Upper(aItens[nPos][2]))$_FORMATEF
		If !Empty(aPgtos[nLinha][12])  	//Se o item já possui uma identificação não permitir alterar no oPgtos
		    cDigCart	:= aPgtos[nLinha][12]
			lTemId 		:= .T.
		Else
			lRet := .T.
		EndIf			    
	Else
		cDigCart := Space(TamSX3("L4_FORMAID")[1])
		lRet     := lAtuPagtos
	EndIf
	If !lRet
		If Alltrim(Upper(aItens[nPos][2]))$ "CC|CD|VA|CO|FI"
		    If UPPER(aPgtos[nLinha][4]) <> UPPER(cComboAdm)
		    	aPgtos[nLinha][4] := cComboAdm
		    EndIf
	    EndIf
		If lTemId
			lRet := .T.
		EndIf
	EndIf
EndIf

Return(lRet)
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LojxValiIDºAutora ³Vendas Clientes     º Data ³  11/04/04   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Valida se o dígito informado é correto para o controle de  º±±
±±º          ³ múltiplos cartões                                          º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGALOJA                                                   º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/                                                                           
Static Function LojxValiID( cComboPag , cDigCart , aItens, aPgtos )
Local lRet 	 := .T.
Local nPos 	 := Ascan(aItens,{|x| Alltrim(Upper(x[1]))==Alltrim(Upper(cComboPag))})
Local cCond                                       // Forma de pagamento 

If nPos > 0
   cCond  := Alltrim(Upper(aItens[nPos][2]))
Else   
   cCond  := Space(02)
Endif   

If cCond $ _FORMATEF
	If Empty(cDigCart)
		MsgAlert(STR0109,STR0104) //"Informe o ID do Cartão para a operação TEF.","Atenção"
		lRet := .F.
	EndIf
EndIf

Return (lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³LjMSSM0     ³ Autor ³ Vendas Clientes     ³ Data ³ 16.06.06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Verifica se e o CNPJ da Microsiga para habilitar determinada³±±
±±³          ³funcionalidade											  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = CNPJ da empresa                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ cExpL1 = Habilita ou nao a funcionalidade				  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Venda Assistida e Front Loja                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LjMSSM0(cCNPJ)
Local lRet	:= .F.         	// Habilita ou nao a funcionalidade

If cCNPJ == "53113791000122"
   lRet  := .T.
Endif
	
Return (lRet)
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³LjConfCaixa ³ Autor ³ Vendas Clientes     ³ Data ³ 04.07.06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Tratamento para configuracao do Caixa: inclusao, exclusao   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ LjConfCaixa( ExpC1, ExpN2, ExpC3)						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Nome do usuario da senha                           ³±±
±±³			 ³ ExpN2 = Opcao (1-Inclusao,2-Alteracao,3-Exclusao) 		  ³±±
±±³			 ³ ExpC3 = Nome do Caixa para buscar no SA6                   ³±±
±±³			 ³ ExpL4 = Exibe mensagem em tela			                  ³±±
±±³			 ³ ExpC5 = Chave para retornar por referencia                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Configuracao de Caixa, chamado do CFGX021	              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LjConfCaixa( cNome  ,nOpcao  ,cOldUser , lShowMsg , cChave )

Local cModImp                               // Modelo do ECF
local cModGav                               // Modelo da gaveta
Local cModCmc7                              // Modelo do CMC7
Local cUsaTef                               // Modalidade do TEF
Local cInLoja		:= ""					// Controle para criacao do codigo do Caixa - letra inicial
Local cDigito1		:= "C"					// Controle para criacao do codigo do Caixa - letra inicial
Local nPos     		:= 0					// Posicao do usuario no array aInLoja
Local nIndex								// Indice corrente do SA6
Local lLjUsrChv 	:= ExistBlock("LJUSRCHV")	// Verifica se existe o ponto de entrada LJUSRCHV
Local lFTVDUsrChv	:= ExistBlock("FTVDUSRCHV")	
Local lFtvdVer12	:= LjFTVD() //Verifica se é Release 11.7 e o FunName é FATA701 - Compatibilização Venda Direta x Venda Assisitida
Local lRet	  		:= .T.						// Retorno da funcao
Local aArea    		:= GetArea()
Local aAreaSX5		:= SX5->( GetArea() )
Local aAreaSA6 		:= SA6->( GetArea() )
Local aAreaSLF 		:= SLF->( GetArea() )
Local lIntegDef		:= FWHasEAI("LOJA120",.T.,,.T.)//Integração EAI ativa para envio
Local aRetInt 		:= {} //Retorno integração 
Local cMsgRet		:= "" //Mensagem retorno Integração

Default cOldUser 		:= ""
Default lShowMsg 		:= .T.
Default cChave			:= "01"					// Controle para criacao do codigo do Caixa - sequencial(01, 02, ...)

//Salvo o nOpc para uso na função LjCriaCaixa
nOpcUser := nOpcao

If nOpcao == 1	

	If (lLjUsrChv .AND. !lFtvdVer12) .OR. (lFTVDUsrChv .AND. lFtvdVer12)
		// Ponto de entrada utilizado para gerar c¢digo de acesso para este usu rio.
		If !lFtvdVer12
			cChave := ExecBlock("LJUSRCHV",.F.,.F.,{aInLoja, nOpcao, cNome})
		ElseIf lFtvdVer12
			cChave := ExecBlock("FTVDUSRCHV",.F.,.F.,{aInLoja})
		EndIf

	ElseIf nModulo <> 72
		If Len(aInLoja) > 0
			cInLoja  := aInLoja[Len(aInLoja)][6]
			cDigito1 := SubStr(cInLoja,1,1)
			cChave	 := SubStr(cInLoja,2,2)
	    Endif

		DbSelectArea("SX5")
		SX5->( DbSetOrder(1) ) //X5_FILIAL+X5_TABELA+X5_CHAVE
		
		DbSelectArea("SA6")
		SA6->( DbSetOrder(1) ) //A6_FILIAL+A6_COD+A6_AGENCIA+A6_NUMCON

		DbSelectArea("SLF")
		SLF->( DbSetOrder(1) ) //LF_FILIAL+LF_COD

		//Busca um código que não existe
		While SX5->( DbSeek(xFilial("SX5") + "23" + cDigito1 + cChave) ) .Or.;
			  SA6->( DbSeek(xFilial("SA6") + cDigito1 + cChave) )		 .Or.;
			  SLF->( DbSeek(xFilial("SLF") + cDigito1 + cChave) )

			If cChave == "ZZ"
				cDigito1 := Soma1(cDigito1)
				cChave 	 := "00"
			Else
				cChave   := Soma1(cChave)
			EndIf
		End
		
		cChave := cDigito1 + cChave

		RestArea(aAreaSLF) 
		RestArea(aAreaSA6)
		RestArea(aAreaSX5)
		RestArea(aArea)
	Endif
	
	If ( nPos := Ascan(aInLoja,{|x| Trim(x[1]) == Trim(cNome)})) == 0
		Aadd(aInLoja,{ cNome   ,cModImp  ,cModGav  ,cModCmc7  ,;
		               cUsaTef ,cChave    })
	Else
		aInLoja[nPos] := { cNome  ,cModImp  ,cModGav  ,cModCmc7  ,;
		                   cUsaTef ,cChave   }
	Endif
	
	If lShowMsg
	
		MsgAlert((STR0117 + ;                  	// "Foi criado um c¢digo de acesso para este usu rio. "
	    	      STR0118 + ;                   // "Este c¢digo ser  o n£mero deste caixa no sistema. "
	        	  STR0119 + ;                   // "Quando houver necessidade de acess -lo, basta inform -lo. "
	          	  STR0120 + cChave), STR0104)   // "C¢digo do Novo Usu rio: " ### "Aten‡„o"
	          	  
	EndIf          	  

ElseIf nOpcao == 2
	If lLjUsrChv
		// Ponto de entrada utilizado para gerar c¢digo de acesso para este usu rio.
		cChave := ExecBlock("LJUSRCHV",.F.,.F.,{aInLoja, nOpcao, cNome})
	EndIf	
	DbSelectArea( "SA6" )
	nIndex := IndexOrd()
	DbSetOrder(2)
	If DbSeek(cFilial+Upper(cOldUser))
		DbSelectArea("SX5")
		DbSeek(cFilial+"23"+SA6->A6_COD)
		If SX5->X5_TABELA <> "23"
			DbSkip(-1)                                       
		Else
			Aadd(aInLoja,{ cNome   ,cModImp     ,cModGav  ,cModCmc7  ,;
			               cUsaTef ,SA6->A6_COD })
		Endif
	Endif		
	DbSelectArea( "SA6" )	
	DbSetOrder(nIndex)

ElseIf nOpcao == 3
	If lLjUsrChv
		// Ponto de entrada utilizado para gerar c¢digo de acesso para este usu rio.
		cChave := ExecBlock("LJUSRCHV",.F.,.F.,{aInLoja, nOpcao, cNome})
	EndIf
	
	If FindFunction("LjxbGetCx")
		If LjxbGetCx( cNome ) 	// Verifica se caixa tem movimentacao (AnalisaMov)	
			// Exclui registro do Caixa na tabela de controle para limite de sangria 
			DbSelectArea("SA6")
			DbSetOrder(2)
			cNome := SubStr(Upper(cNome),1,40)
			DbSeek (xFilial("SA6") + cNome )
			cCaixa := SA6->A6_COD
			
			If AliasIndic("MGW")
				DbSelectArea("MGW")
				MGW->( DbSetOrder(1) )

				// Exclusão da tabela MGW 
				If MGW->( DbSeek(xFilial("MGW") + cCaixa) )
					While MGW->(!EOF()) .AND. xFilial("MGW") + cCaixa == MGW->MGW_FILIAL + MGW->MGW_CAIXA 
						Reclock("MGW",.F.,.T.)
						MGW->( dbDelete() )
						MGW->( MsUnlock() )
						MGW->( DbSkip() )
					End
				EndIf
			EndIf

			ExclTab( cNome )  	// Exclui o registro da tabela 23 no Sx5, SA6 e SLF		 
			LJDelCxOk() 		// Chamada Processo Off-Line
			
			If lIntegDef 
				aRetInt := FwIntegDef("LOJA120",,,, "LOJA120")
				If Valtype(aRetInt) == "A" .And. Len(aRetInt) >= 2 .And. !aRetInt[1]
					If !Empty(AllTrim(aRetInt[2]))
						cMsgRet := AllTrim(aRetInt[2]) +chr(13)+chr(13)
					EndIf
					cMsgRet += STR0200 //"Maiores detalhes no monitor EAI."
					Aviso(STR0201,cMsgRet,{"Ok"},3)//"EAI: Erro de integração"
				EndIf
			EndIf
			
		Else
			MsgInfo(STR0179) //"Caixa com Movimentações, não podera ser excluido"
			lRet := .F.
		EndIf
	Else
		ExclTab( cNome )  	// Exclui o registro da tabela 23 no Sx5, SA6 e SLF
	EndIf
Endif

Return lRet

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Fun‡„o    ³LjCriaCaixa ³ Autor ³ Vendas Clientes     ³ Data ³ 04.07.06  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Criacao e atualizacao do Caixa                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ LjCriaCaixa(ExpC1,ExpC2,ExpC3,ExpC4,ExpC5,ExpC6,ExpC7)      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Nome do usuario da senha                            ³±±
±±³          ³ ExpC2 = Nao utilizado                                       ³±±
±±³          ³ ExpC3 = Nao utilizado                                       ³±±
±±³          ³ ExpC4 = Nao utilizado                                       ³±±
±±³          ³ ExpC5 = Nao utilizado                                       ³±±
±±³          ³ ExpC6 = Codigo do Caixa                                     ³±±
±±³          ³ ExpC7 = Nao utilizado 								       ³±±
±±³          ³ ExpL10 = Mostra wizard para realizar configuração           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Nenhum                                     				   ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function LjCriaCaixa( cNome  ,cModImp  	 , cModGav , cModCmc7,;
                      cUsaTef,cChave   	 , cOldUser, cAgencia,;
                      cConta ,lShowWizard, cNomeRed )
                      
    Local aRet := {}

	aRet := LjAtuCaixa(	cNome  ,cModImp  	, cModGav , cModCmc7,;
    			cUsaTef,cChave		, cOldUser, cAgencia,;
               	cConta ,lShowWizard	, cNomeRed)			
               	
    IF !aRet[1]
    
    	Final()
    
    Endif		  

Return .T.

//-------------------------------------------------------------------------------------------------
/*/{Protheus.doc} LjAtuCaixa
Atualiza informações do Operador de caixa, nas tabela SX5, SA6 e SLF.
Esta função foi extraida da função LjCriaCaixa, porque foi necessario mudar o seu retorno.

@return aRet	   - {Logico	,;	- Definindo se conseguiu efetuar a operação
@return aRet	   	  Caractere}	- Descrição do erro
				
@version 1.0				
/*/	
//-------------------------------------------------------------------------------------------------
Function LjAtuCaixa(  cNome  ,cModImp  	 , cModGav , cModCmc7,;
                      cUsaTef,cChave   	 , cOldUser, cAgencia,;
                      cConta ,lShowWizard, cNomeRed )

Local aRet			:= {.T., ""}                      
Local lNew			:= .F.																//Controla se e um novo Caixa
Local cSeek			:= ""          														//Chave de busca no arquivo SA6
Local nTamA6Age		:= TamSX3("A6_AGENCIA")[1]											//Tamanho do Campo A6_AGENCIA
Local nTamA6Cta 	:= TamSX3("A6_NUMCON")[1]											//Tamanho do Campo A6_CONTA
Local oProcessOff	:= Nil																//Objeto do tipo LJCProcessoOffLine
Local lAmbOffLn 	:= SuperGetMv("MV_LJOFFLN", Nil, .F.)								//Identifica se o ambiente esta operando em offline
Local cTipo 		:= ""																//Como os dados serao integrados no processo offline    
Local cHorario		:= ""																//Indica o horario
Local lPDVMobile	:= IIF(ExistFunc("STFGetCfg"), STFGetCfg( "lMobile" , .F.), .F.)	//Mobile wizard difetente
Local aAreaSA6		:= SA6->( GetArea() )
Local lPOS			:= IIF(ExistFunc("STFIsPOS"), STFIsPOS(), .F.)						//Verifica se é TOTVS PDV

Default cAgencia	:= "."	//Agencia para gravacao no SA6
Default cConta		:= "."	//Conta para gravacao no SA6
Default lShowWizard	:= .T.	//Mostra wizard para realizar configuração
Default cNomeRed	:= ""

If ValType(lPDVMobile) = "U"
	lPDVMobile := .F. //Não Mobile
EndIf


If lPOS
	aRet[2] := STR0205  // "Importante! - É imprescindível cadastrar o mesmo usuário caixa e código no ambiente da retaguarda. Caso não seja cadastrado irá ocasionar sérias divergência de informações."			   
	MsgInfo(aRet[2])
EndIf


//Não é permitido criação de usuários com nomes semelhantes, diferenciados apenas por letras maiusculas e minusculas
//Valido se não é alteração de usuario
If nOpcUser <> 2
	SA6->( DbSetOrder(2) )	//A6_FILIAL+A6_NOME
	If SA6->( DbSeek(xFIlial("SA6") + Upper(cNome)) ) .Or. SA6->( DbSeek(xFIlial("SA6") + Lower(cNome)) ) .Or. SA6->( dbSeek(xFIlial("SA6") + cNome) )
		aRet[1] := .F.
		aRet[2] := STR0202 + cNome + "." + CRLF +; 	//"Já existe usuário com o nome, "
				   STR0203 + CRLF +; 				//"Não é permitido usuários tipo caixa com nomes semelhantes, mesmo que sejam diferenciados por letras maiúsculas e minúsculas."
				   STR0204							//"A criação deste usuário será abortada e o sistema finalizado." 
		MsgAlert(aRet[2])
	EndIf
EndIF
RestArea(aAreaSA6)

//Variavel de controle para nOpc.
nOpcUser := 0

If aRet[1]

	// Validação se a função existe para execução do Wizard.
	lShowWizard := lShowWizard .And. !lPDVMobile .And. FindFunction("LJ120VWIZ")

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Adicionado o comando para Controle de Transacao BEGIN TRANSACTION, pois caso alguma ³
	//³transacao der errado, aborta as demais transacoes.                                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	BEGIN TRANSACTION
		//Ajusta o nome para o padrão em maiúsculo
		cNome := Upper(cNome)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Gravacao do SX5³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !SX5->(DbSeek(xFilial("SX5") + "23" + cChave))
			Reclock( "SX5", .T. )
			REPLACE X5_FILIAL WITH xFilial("SX5")
			REPLACE X5_TABELA WITH "23"
			REPLACE X5_CHAVE  WITH cChave
			lNew := .T.
		Else
			Reclock( "SX5", .F. )
		Endif
		REPLACE X5_DESCRI  WITH cNome
		REPLACE X5_DESCSPA WITH cNome
		REPLACE X5_DESCENG WITH cNome
		MsUnlock( )     
		SX5->( FkCommit() )
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Gravacao do SA6³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		DbSelectArea( "SA6" )
		SA6->( DbSetOrder(1) )
		cSeek := xFilial("SA6") + cChave + cAgencia + Space(nTamA6Age - Len(cAgencia)) +;
				cConta + Space(nTamA6Cta - Len(cConta))
		
		If !SA6->( DbSeek(cSeek) )
			If isBlind()
				cHorario := Substr(Time(),1,5)
			Else
				cHorario := Substr(GetRmtTime(),1,5)
			EndIf

			Reclock("SA6",.T.)
			REPLACE A6_FILIAL  WITH xFilial("SA6")
			REPLACE A6_COD 	   WITH cChave
			REPLACE A6_AGENCIA WITH cAgencia
			REPLACE A6_NUMCON  WITH cConta
			REPLACE A6_DATAFCH WITH dDatabase
			REPLACE A6_HORAFCH WITH cHorario
			REPLACE A6_MOEDA   WITH 1	
			cTipo := "INSERT"
		Else
			Reclock("SA6",.F.)
			cTipo := "UPDATE"
		Endif
		REPLACE A6_NOME	   WITH cNome
		REPLACE A6_NREDUZ  WITH IIF(!Empty(cNomeRed), cNomeRed, cNome)
		MsUnlock()
		SA6->(FkCommit())
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Gravacao do SLF                    ³
		//³Se for um novo Usuario, cria o SLF.³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lNew
			DbSelectArea("SLF")
			Reclock("SLF",.T.)

			REPLACE LF_FILIAL WITH xFilial("SLF")
			REPLACE LF_COD 	  WITH cChave

			MsUnlock()
			SLF->(FkCommit()) 

			If lShowWizard  
				a120CFG(.T.,cChave) // Executa a função de wizard de configuração do caixa
			Endif

		Endif    
			
		DbSelectArea("SM0")

	END TRANSACTION

	//Verifica se o ambiente esta em off-line
	If lAmbOffLn
		//Instancia o objeto LJCProcessoOffLine
		oProcessOff := LJCProcessoOffLine():New("017")
		//Insere os dados do processo (registro da tabela)
		oProcessOff:Inserir("SA6", cSeek, 1, cTipo)	
		//Insere os dados do processo (registro da tabela)
		oProcessOff:Inserir("SLF", xFilial("SLF") + SLF->LF_COD, 1, "INSERT")	
		//Processa os dados
		oProcessOff:Processar()	
	EndIf	
	
EndIf

Return aRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LJxGerSft ºAutor  ³Vendas Clientes     º Data ³ 24/08/2006  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Gera o arquivo SFT apos ter gerado o SF3                   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºSintaxe e ³ LJxGerSft(void)											  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ ExpA1 - Campos a serem gravados							  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³ Nil                             							  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ LOJA300, LOJR130                                           º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LJxGerSft(aGravaFT)
Local nX 			:= 0											// Contador de For
Local cExpr			:= ""											// Expressao do Seek
Local cVarFT		:= ""											// Campo a ser gravado
Local nAuxFT		:= ""											// Posicao do array
Local nTamIt		:= 0 											// Tamanho do FT_ITEM
Local lBuscaFT		:= If(Upper(FunName()) <> "LOJR130",.T.,.F.) // Origem da chamada

If (cPaisLoc == "BRA" .AND. AliasInDic("SFT"))

	nTamIt := TamSx3("FT_ITEM")[1]
    
	DbSelectArea("SFT")
	DbSetOrder(1)
	
	For nX :=1 To Len(aGravaFT)
		
		If lBuscaFT
			cExpr := 	aGravaFT[nX][1][2] + aGravaFT[nX][13][2] + aGravaFT[nX][5][2] + aGravaFT[nX][4][2] + ;
						aGravaFT[nX][6][2] + aGravaFT[nX][7][2] + PadR(aGravaFT[nX][12][2],nTamIt) + ;
						aGravaFT[nX][11][2]
			
			If DbSeek(cExpr)
				RecLock("SFT",.F.)
				DbDelete()
				MsUnLock()
			EndIf
		EndIf
		
		RecLock("SFT",.T.)
		
		For nAuxFT  := 1 To Len(aGravaFT[nX])
			cVarFT  := Trim(aGravaFT[nX][nAuxFT][1])
			&cVarFT := aGravaFT[nX][nAuxFT][2]
	    Next nAuxFT
		MsUnLock()
	Next nX
EndIf

Return				

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LJxCpsSft ºAutor  ³Vendas Clientes     º Data ³ 24/08/2006  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Campos a serem gravados no SFT			                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºSintaxe 	 ³ LJxCpsSft()												  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ Nenhum													  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³ ExpA1 - Campos a serem gravados no SFT					  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ LOJA300, LOJR130                                           º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LJxCpsSft()
Local aFixFT 		:= {}						// Array com os campos a serem gravados
Local lExisteFT		:= AliasInDic("SFT")		// Se existe o indice do SFT
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³1 - Filial               ³
//³2 - Data Entrada         ³
//³3 - Data de emissao      ³
//³4 - Nota Fiscal          ³
//³5 - Serie                ³
//³6 - Cliente              ³
//³7 - Loja                 ³
//³8 - Estado               ³
//³9 - PDV                  ³
//³10 - Especie             ³
//³11 - Produto             ³
//³12 - Item                ³
//³13 - Tipo movimento      ³
//³14 - CFOP                ³
//³15 - Aliquota de ICMS    ³
//³16 - Valor contabil      ³
//³17 - Base ICMS           ³
//³18 - Valor ICMS          ³
//³19 - Isencao ICMS        ³
//³20 - Outro ICMS          ³
//³21 - Base IPI            ³
//³22 - Valor IPI           ³
//³23 - Isencao IPI         ³
//³24 - Outro IPI           ³
//³25 - Observacao          ³
//³26 - ICMS retido         ³
//³27 - TIPO                ³
//³28 - ICMS Com            ³
//³29 - Codigo ISS          ³
//³30 - Obs IPI             ³
//³31 - Numero Livro        ³
//³32 - Icms auto           ³
//³33 - Base retencao       ³
//³34 - Formula             ³
//³35 - Formula             ³
//³36 - Despesas            ³
//³37 - Diferenca Icms      ³
//³38 - Trf Icms            ³
//³39 - Observacao Icms     ³
//³40 - Observacao solidario³
//³41 - Sol. trib.          ³
//³42 - CFOExt              ³
//³43 - IssSt               ³
//³44 - Rec Iss             ³
//³45 - Iss Sub             ³
//³46 - Livro de ISS no ICMS³
//³47 - Credito estatual    ³
//³48 - CRDEst              ³
//³49 - Identificao SF3     ³
//³50 - Aliquota IPI        ³
//³51 - Base PS3            ³
//³52 - Aliq PS3            ³
//³53 - Val PS3             ³
//³54 - Base CF3            ³
//³55 - Aliq CF3            ³
//³56 - Val CF3             ³
//³57 - Desconto            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Campos do SFT se tiver na base³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
AADD(aFixFT,{"FT_FILIAL"	,	""})
AADD(aFixFT,{"FT_ENTRADA"	,	""})
AADD(aFixFT,{"FT_EMISSAO"	,	""})
AADD(aFixFT,{"FT_NFISCAL"	,	""})
AADD(aFixFT,{"FT_SERIE"		,	""})
AADD(aFixFT,{"FT_CLIEFOR"	,	""})
AADD(aFixFT,{"FT_LOJA"		,	""})
AADD(aFixFT,{"FT_ESTADO"	,	""})
AADD(aFixFT,{"FT_PDV"		,	""})
AADD(aFixFT,{"FT_ESPECIE"	,	""})
AADD(aFixFT,{"FT_PRODUTO"	,	""})
AADD(aFixFT,{"FT_ITEM"		,	""})
AADD(aFixFT,{"FT_TIPOMOV"	,	""})
AADD(aFixFT,{"FT_CFOP"		,	""})
AADD(aFixFT,{"FT_ALIQICM"	,	0})
AADD(aFixFT,{"FT_VALCONT"	,	0})
AADD(aFixFT,{"FT_BASEICM"	,	0})
AADD(aFixFT,{"FT_VALICM"	,	0})
AADD(aFixFT,{"FT_ISENICM"	,	0})
AADD(aFixFT,{"FT_OUTRICM"	,	0})
AADD(aFixFT,{"FT_BASEIPI"	,	0})
AADD(aFixFT,{"FT_VALIPI"	,	0})
AADD(aFixFT,{"FT_ISENIPI"	,	0})
AADD(aFixFT,{"FT_OUTRIPI"	,	0})
AADD(aFixFT,{"FT_OBSERV"	,	""})
AADD(aFixFT,{"FT_ICMSRET"	,	0})
AADD(aFixFT,{"FT_TIPO"		,	""})
AADD(aFixFT,{"FT_ICMSCOM"	,	0})
AADD(aFixFT,{"FT_CODISS"	,	""})
AADD(aFixFT,{"FT_IPIOBS"	,	0})
AADD(aFixFT,{"FT_NRLIVRO"	,	""})
AADD(aFixFT,{"FT_ICMAUTO"	,	0})
AADD(aFixFT,{"FT_BASERET"	,	0})
AADD(aFixFT,{"FT_FORMUL"	,	""})
AADD(aFixFT,{"FT_FORMULA"	,	""})
AADD(aFixFT,{"FT_DESPESA"	,	0})
AADD(aFixFT,{"FT_ICMSDIF"	,	0})     
AADD(aFixFT,{"FT_TRFICM"	,	0})
If lExisteFT
	If ( SFT->(FieldPos("FT_OBSICM"))>0 )
		AADD(aFixFT,{"FT_OBSICM",0})
	Else
		AADD(aFixFT,{"XXX",0})			
	EndIf		
	If ( SFT->(FieldPos("FT_OBSSOL"))>0 )
		AADD(aFixFT,{"FT_OBSSOL",0})
	Else
		AADD(aFixFT,{"XXX",0})
	EndIf
	If ( SFT->(FieldPos("FT_SOLTRIB"))>0 )
		AADD(aFixFT,{"FT_SOLTRIB",0})
	Else
		AADD(aFixFT,{"XXX",0})
	EndIf
	If ( SFT->(FieldPos("FT_CFOEXT"))>0 )
		AADD(aFixFT,{"FT_CFOEXT",""})
	Else
		AADD(aFixFT,{"XXX",0})
	EndIf
	AADD(aFixFT,{"FT_ISSST",""})
	
	If ( SFT->(FieldPos("FT_RECISS"))>0 )
		AADD(aFixFT,{"FT_RECISS",""})
	Else
		AADD(aFixFT,{"XXX",""})
	EndIf
	If ( SFT->(FieldPos("FT_ISSSUB"))>0 )
		AADD(aFixFT,{"FT_ISSSUB",0})
	Else
		AADD(aFixFT,{"XXX",0})
	EndIf
	AADD(aFixFT,{"XXX",0})//Livro de ISS no ICMS
	If ( SFT->(FieldPos("FT_CREDST"))>0 )
		AADD(aFixFT,{"FT_CREDST",""})
	Else
		AADD(aFixFT,{"XXX",""})
	EndIf		    
	If ( SFT->(FieldPos("FT_CRDEST"))>0 ) // Credito Estimulo Manaus
		AADD(aFixFT,{"FT_CRDEST",0})
	Else
		AADD(aFixFT,{"XXX",0})
	EndIf		
	If ( SFT->(FieldPos("FT_IDENTF3"))>0 ) // Link com o SFT
		AADD(aFixFT,{"FT_IDENTF3",""})
	Else
		AADD(aFixFT,{"XXX",""})
	EndIf		
	//
	//Aliquota de IPI
	If (SFT->(FieldPos("FT_ALIQIPI"))>0 )
		AADD(aFixFT,{"FT_ALIQIPI",0})
	Else
		AADD(aFixFT,{"XXX",0})
	EndIf
	//
	// Pis/Cofins Subst. Tributaria
	If (SFT->(FieldPos("FT_BASEPS3"))>0 )
		AADD(aFixFT,{"FT_BASEPS3",0})
	Else
		AADD(aFixFT,{"XXX",0})
	EndIf
	If (SFT->(FieldPos("FT_ALIQPS3"))>0 )
		AADD(aFixFT,{"FT_ALIQPS3",0})
	Else
		AADD(aFixFT,{"XXX",0})
	EndIf                   
	If (SFT->(FieldPos("FT_VALPS3"))>0 )
		AADD(aFixFT,{"FT_VALPS3",0})
	Else
		AADD(aFixFT,{"XXX",0})
	EndIf
	If (SFT->(FieldPos("FT_BASECF3"))>0 )
		AADD(aFixFT,{"FT_BASECF3",0})
	Else
		AADD(aFixFT,{"XXX",0})
	EndIf
	If (SFT->(FieldPos("FT_ALIQCF3"))>0 )
		AADD(aFixFT,{"FT_ALIQCF3",0})
	Else
		AADD(aFixFT,{"XXX",0})
	EndIf                   
	If (SFT->(FieldPos("FT_VALCF3"))>0 )
		AADD(aFixFT,{"FT_VALCF3",0})
	Else
		AADD(aFixFT,{"XXX",0})
	EndIf                              
Else
	AADD(aFixFT,{"XXX",0})			
	AADD(aFixFT,{"XXX",0})
	AADD(aFixFT,{"XXX",0})
	AADD(aFixFT,{"XXX",0})
	AADD(aFixFT,{"FT_ISSST",""})
	AADD(aFixFT,{"XXX",""})
	AADD(aFixFT,{"XXX",0})
	AADD(aFixFT,{"XXX",0})//Livro de ISS no ICMS
	AADD(aFixFT,{"XXX",""})
	AADD(aFixFT,{"XXX",0})
	AADD(aFixFT,{"XXX",""})
	AADD(aFixFT,{"XXX",0})
	AADD(aFixFT,{"XXX",0})
	AADD(aFixFT,{"XXX",0})
	AADD(aFixFT,{"XXX",0})
	AADD(aFixFT,{"XXX",0})
	AADD(aFixFT,{"XXX",0})
	AADD(aFixFT,{"XXX",0})
EndIf

AADD(aFixFT,{"FT_DESCONT"	,	0})

Return (aFixFT)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LjxValcBarºAutora ³Vendas Clientes     º Data ³  26/02/07   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Valida a digitacao do codigo de barras.              	  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ ExpC1 = Codigo do produto a ser incluido.                  º±±
±±º			 ³ ExpC2 = Codigo de barra                                    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³ ExpL1 = Valida o campo                                     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGALOJA e FRONTLOJA                                       º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/                                                                           
Function LjxValCBar( cCodProd , cCodBar )
Local lRet		:= .T.				// Retorno da funcao
Local aAreaSB1		:= SB1->(GetArea())		// Area corrente do SB1
Local aAreaSLK		:= SLK->(GetArea())		// Area corrente do SLK
Local lContinua	:= .T.				// Continua o While

Default cCodProd 		:= ""						// Default do Codigo do Produto
Default cCodBar	 	:= ""						// Default do Codigo de Barra

If !Empty(cCodBar) .AND. !Empty(cCodProd)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Realiza a busca no SB1 para verificar se o codigo de barras³
	//³digita esta amarrado a outro produto.                      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	DbSelectArea("SB1")
	DbSetOrder(5)
	If DbSeek( xFilial("SB1") + AllTrim(cCodBar) )
		While !EOF() .AND. ( xFilial("SB1") + cCodBar == SB1->B1_FILIAL + SB1->B1_CODBAR ) .AND. lContinua
			If cCodProd <> SB1->B1_COD
				lContinua := .F.
				lRet := .F.
				//"Código de barra digitado pertence ao produto: " + ". Por favor, digite outro código de barra válido." + "Atencao"
				MsgAlert(STR0122 + Alltrim(SB1->B1_COD) + STR0123,STR0001)
			EndIf
	    	DbSkip()
	    	Loop
	    End
    Else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Caso nao encontre no SB1, o proximo passo eh realizar a ³
		//³busca no SLK                                            ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		DbSelectArea("SLK")
		DbSetOrder(1)
		If DbSeek( xFilial("SLK") + AllTrim(cCodBar) )
			While !EOF() .AND. ( xFilial("SLK") + cCodBar == SLK->LK_FILIAL + SLK->LK_CODBAR ) .AND. lContinua
				If cCodProd <> SLK->LK_CODIGO
					lContinua := .F.
					lRet := .F.
					//"Código de barra digitado pertence ao produto: " + ". Por favor, digite outro código de barra válido." + "Atencao"
					MsgAlert(STR0122 + Alltrim(SLK->LK_CODIGO) + STR0123,STR0001)
				EndIf
		    	DbSkip()
		    	Loop
		    End
    	EndIf    
    EndIf

EndIf

RestArea( aAreaSB1 )
RestArea( aAreaSLK )

Return (lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o    ³LJNumMov  ³ Autor ³ Vendas Clientes       ³ Data ³ 10/10/06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³Retorna o Ultimo Numero de Movimento  (SLW)                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametro ³Exp01 [C][A] : Define qual(is) o(s) campo(s) que devem ser  ³±±
±±³          ³               retornados pela funcao. Como caracter deve-se³±±
±±³          ³               passar apenas um campo, como array ilimitado.³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Revisao   ³08/10/10 : Pablo Gollan Carreras                            ³±±
±±³          ³A rotina com a sua logica anterior em algumas combinacoes   ³±±
±±³          ³entrava em looping infinito e em tabelas bem povoadas o     ³±±
±±³          ³processamento podia tornar-se lento. Foram feitos dois novos³±±
±±³          ³metodos de pesquisa um para bancos relacionais e outro para ³±±
±±³          ³bancos locais.                                              ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LJNumMov(aCampos)

Local aID			:= LjInfoCxAt(1,.T.,.F.)	//[1]-CAIXA [2]-ESTACAO [3]-SERIE [4]-PDV
Local aArea  		:= GetArea()
Local ni			:= 0
Local lRetCmp		:= .F.
Local aLstCmp		:= {}
Local uRetorno		:= Nil
Local aLstCmpPad	:= {"LW_NUMMOV","LW_DTFECHA"}
#IFNDEF TOP
Local cArq			:= ""
Local cIndice		:= ""
Local cFiltro		:= ""
Local nInd			:= 0
#ELSE
Local cQry			:= ""
Local cAlias		:= GetNextAlias()
Local cSGBD			:= ""
Local nPos			:= 0
Local aEstru		:= {}
#ENDIF

Default aCampos	:= {}

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Caso existam, validar campos de retorno solicitados  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Do Case
	Case ValType(aCampos) == "C"
		If !Empty(aCampos)
			aAdd(aLstCmp,AllTrim(Upper(aCampos)))
		Endif	
	Case ValType(aCampos) == "A"
		If Len(aCampos) > 0
			For ni := 1 to Len(aCampos)
				If ValType(aCampos[ni]) == "C" .AND. !Empty(aCampos[ni])
					aAdd(aLstCmp,AllTrim(Upper(aCampos[ni])))
				Endif
			Next ni	
		Endif
EndCase
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verificar os campos solicitados  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Len(aLstCmp) > 0
	aCampos := {}
	dbSelectArea("SX3")
	SX3->(dbSetOrder(2))
	For ni := 1 to Len(aLstCmp)
		If Substr(aLstCmp[ni],1,3) # "LW_"
			aLstCmp[ni] := "LW_" + aLstCmp[ni]
		Endif
		//Caso o campo nao tenha sido utilizado ainda, adicionar a lista
		If aScan(aCampos,{|x| x == aLstCmp[ni]}) == 0
			If SX3->(dbSeek(aLstCmp[ni]))
				aAdd(aCampos,aLstCmp[ni])
			Endif
		Endif
	Next ni
	If Len(aCampos) > 0
		lRetCmp := .T.
	Endif
Endif
If (AllTrim(cMov) == "" .OR. lRetCmp) .AND. AliasInDic("SLW")
	#IFDEF TOP
		aEstru := SLW->(dbStruct())

		cSGBD := Upper(AllTrim(TcGetDB()))

		cQry := "SELECT DISTINCT LW_NUMMOV, LW_DTFECHA " 

		If lRetCmp
			For ni := 1 to Len(aCampos)
				If aScan(aLstCmpPad,{|x| x == aCampos[ni]}) == 0
					cQry += "," + aCampos[ni] + Space(1)
				Endif
			Next ni
		Endif

		cQry += "FROM " + RetSQLName("SLW") + " "
		cQry += "WHERE LW_FILIAL = '" + xFilial("SLW") + "' AND LW_PDV = '" + aID[4] + "' AND LW_OPERADO = '" + aID[1] + "' AND D_E_L_E_T_=' ' "

		Do Case
			Case cSGBD $ "MSSQL|SYBASE"
				cQry += "AND (LEN(LW_DTFECHA) = 0) "
			Case cSGBD $ "MYSQL|POSTGRES|INFORMIX|OPENEDGE"
				cQry += "AND (LENGTH(LW_DTFECHA) = 0) "
            Case cSGBD == "ORACLE"
                cQry += "AND LW_DTFECHA = '" + Space( TamSx3("LW_DTFECHA")[1] ) + "' "
			Case cSGBD $ "DB2|DB2/400|SQLITE"
				cQry += "AND (LENGTH(TRIM(LW_DTFECHA)) = 0) "
			OtherWise
				cQry += "AND (LEN(LW_DTFECHA) = 0) "
		EndCase

		cQry += "ORDER BY LW_DTFECHA DESC, LW_NUMMOV ASC"
		cQry := ChangeQuery(cQry)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Importante : por utilizar função build in de SGBD, nao aplicar o PARSER.  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbUseArea(.T.,__cRDD,TcGenQry(,,cQry),cAlias,.T.,.F.)
		If lRetCmp
			For ni := 1 to (cAlias)->(FCount())
				If (nPos := aScan(aEstru,{|x| AllTrim(x[1]) == AllTrim((cAlias)->(FieldName(ni)))})) > 0
					If aEstru[nPos][2] # "C"
						TcSetField(cAlias,aEstru[nPos][1],aEstru[nPos][2],aEstru[nPos][3],aEstru[nPos][4])
					Endif
				Endif
			Next ni
		Endif
		(cAlias)->(dbGoTop())
		If !(cAlias)->(Eof())
			cMov := (cAlias)->LW_NUMMOV
			If lRetCmp
				uRetorno := Array(Len(aCampos))
				For ni := 1 to Len(aCampos)
					uRetorno[ni] := (cAlias)->&(aCampos[ni])
				Next ni
			Else
				uRetorno := cMov
			Endif
		Endif
		FechaArqT(cAlias)
	#ELSE
		//Buscar o movimento em aberto
		dbSelectArea("SLW")
		cArq := CriaTrab(,.F.)
		cIndice := "DTOS(LW_DTABERT)"
		cFiltro := "Empty(LW_DTFECHA) .AND. LW_FILIAL = '" + xFilial("SLW") + "' .AND. LW_PDV = '" + aID[4] + "' .AND. LW_OPERADO = '" + aID[1] + "'"
		IndRegua("SLW",cArq,cIndice,"D",cFiltro,"",.F.)
		dbSelectArea("SLW")
		nInd := RetIndex("SLW")
		dbSetIndex(cArq + OrdBagExt())
		SLW->(dbSetOrder(nInd + 1))
		SLW->(dbGoTop())
		If !SLW->(Eof())
			cMov := SLW->LW_NUMMOV
			If lRetCmp
				uRetorno := Array(Len(aCampos))
				For ni := 1 to Len(aCampos)
					uRetorno[ni] := SLW->&(aCampos[ni])
				Next ni
			Else
				uRetorno := cMov
			Endif				
		Endif
		//Retornar ao estado anterior		
       	dbSelectArea("SLW")
       	dbClearFilter()
       	RetIndex("SLW")
       	If File(cArq + OrdBagExt())	
       		fErase(cArq + OrdBagExt())
       	Endif
	#ENDIF
	RestArea(aArea)
Else
	uRetorno := cMov
Endif

Return uRetorno

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³LJAlterMovºAutor  ³Vendas Clientes     º Data ³  11/10/06   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Funcao Para Alterar o Valor da Variavel nMov (Static) no    º±±
±±º          ³Momento da Abertura de Caixa                                º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³                                                            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LJAlterMov(cNumMov)
	cMov := cNumMov
Return

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LjxConfParºAutora ³Vendas Clientes     º Data ³  15/08/06   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Valida a digitacao das alteracoes da parcela corrente	  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ ExpL1 = Sendo .T. botao "Ok". Sendo .F. botao "Cancela".   º±±
±±º			 ³ ExpN2 = Linha corrente da selecao da parcela               º±±
±±º			 ³ ExpA3 - Array com as informacoes de todos os titulos       º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³ ExpL1 = Se sai da tela de parcela ou nao                   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGALOJA                                                   º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/                                                                           
Static Function LjxConfPar( lConfirma , nLinha , aPgtos, 	cDigCart, ;
							aTefBKPCS	)
							
Local lRet 		 	:= .T.								// Retorno da funcao
Local lLjxCnfVen 	:= ExistBlock("LJXCNFVEN")			// Ponto de Entrada
Local xRet												// Retorno do Ponto de Entrada
Local lFtvdVer12	:= LjFTVD() 	//Verifica se é Release 11.7 e o FunName é FATA701 - Compatibilização Venda Direta x Venda Assisitida

If lLjxCnfVen .AND. !lFtvdVer12
	xRet := U_LJXCNFVEN(lConfirma, nLinha, aPgtos)
	If ValType(xRet) == "L"
		lRet := xRet
	Endif
Endif    		

If lLjxCnfVen .AND. lFtvdVer12
	xRet := U_FTVDXCNFVEN(lConfirma, nLinha, aPgtos)
	If ValType(xRet) == "L"
		lRet := xRet
	Endif
Endif    

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Validacao do ID cartao para transacoes ja efetuadas    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRet
	lRet :=	LjxValIdC (cDigCart, aTefBKPCS)
EndIf

Return (lRet)
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LjxAAtuId ºAutora ³Vendas Clientes     º Data ³  04/08/06   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Inclui o digito no cartao no aPgtos                        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ ExpN1 = Linha do aPgtos                                    º±±
±±º			 ³ ExpC2 = Digito do cartao usado na tela                     º±±
±±º			 ³ ExpA3 - aPgtos                                             º±±
±±º			 ³ ExpL4 - Se esta trabalhando com L4_FORMAID                 º±±
±±º			 ³ ExpC5 - Codicao de pagamento da venda                      º±±
±±º			 ³ ExpA6 - Condicao de pagamento                              º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³ ExpL1 = Sempre retorna .T.                                 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGALOJA                                                   º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/                                                                           
Static Function LjxAAtuId(	nLinha		,	cDigCart	,	aPgtos	,	lHabDig,;
							cComboPag	,	aItens	)

Local nPos := 0					// Posicao do aItens

Default aItens		:= {}		// aItens
Default nLinha 		:= 0		// Linha atual do aPgtos
Default cDigCart 	:= ""		// Digito do cartao
Default aPgtos		:= {}		// aPgtos
Default lHabDig		:= .F.		// Se esta trabalhando com o L4_FORMAID

If Len(aItens) > 0
	nPos := Ascan(aItens,{|x| Alltrim(Upper(x[1]))==Alltrim(Upper(cComboPag))})
EndIf

If nPos > 0 .AND. nLinha > 0 .AND. !Empty(cDigCart) .AND. Len(aPgtos) > 0
	If Alltrim(Upper(aItens[nPos][2]))$_FORMATEF
		If lHabDig
			aPgtos[nLinha][12] := cDigCart
		EndIf
	EndIf
EndIf

Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LjxValIdC ºAutor  ³Vendas Clientes     º Data ³  30/09/06   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ valida as transacoes de tef efetuadas                      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ ExpC1 = ID do cartao digitado                              º±±
±±º			 ³ ExpA2 = Array com as transacoes de tef transmitidas        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³ ExpL1 = Ret. valor logico se encontrou a transacao efetuadaº±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGALOJA                                                   º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/                                                                           
Static Function LjxValIdC( cDigCart, aTefBKPCS ) 

Local lRet			:= .T.		//variaval de retorno
Local nI			:= 0		//varical para loop de transacoes
Default aTefBKPCS	:=	{}		//transacoes de TEF efetuadas

For nI := 1 to Len(aTefBKPCS)
	If AllTrim(aTefBKPCS[nI]:CIDCART) == AllTrim(cDigCart)
		MsgStop (STR0125) //"ID de cartão já utilizado em outra transação TEF efetuada."
		lRet := .F.
		Exit
	EndIf
Next nI

Return lRet
                                 
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³RetMoeda  ºAutor  ³Vendas Clientes       º Data ³  10/09/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Retorna o codigo da moeda associada a um simbolo ou nome.     º±±
±±º          ³                                                              º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³Exp01[C] : Simbolo ou nome da moeda a se obter o codigo       º±±
±±º          ³           correspondente                                     º±±
±±º          ³Exp02[N] : (Opcional) 1. Simbolo 2. Nome da moeda             º±±
±±º          ³Exp03[N] : (Opcional) 1. Retorno numérico 2. Retorno caracter º±±
±±º          ³Exp04[L] : (Opcional) A string de retorno deve ser fomrmatada?º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³uMoeda[U]: Codigo da moeda em formato numerico ou caracter    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³Generico                                                      º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function RetMoeda(cStr,nOpc,nTipoRet,lFrmtStr)

Local aAreaSM2			:= SM2->(GetArea())
Local ni				:= 1
Local uMoeda			:= 0
Local cAcentua			:= "ÁÉÍÓÚÂÊÎÔÛÀÈÌÒÙÄËÏÖÜÂÊÎÔÛÃÕ"	//Acentuacoes
Local cAcentuaCorr		:= "AEIOUAEIOUAEIOUAEIOUAEIOUAO"	//Correspondentes
Local cTMP				:= ""
Local cTMP02			:= ""
Local nx				:= 0
Local nPos				:= 0
Local nTamMoeda			:= TamSX3("L1_MOEDA")[1]

Default cStr			:= ""
Default nOpc			:= 1
Default nTipoRet		:= 1
Default lFrmtStr		:= .T.

If ValType(cStr) # "C" .OR. ValType(nOpc) # "N" .OR. Empty(cStr) .OR. ValType(nTipoRet) # "N"
	Return uMoeda
Else
	If (nOpc < 1 .OR. nOpc > 2) .OR. (nTipoRet < 1 .OR. nTipoRet > 2)
		Return uMoeda
	Endif
Endif
dbSelectArea("SM2")
Do While SM2->(FieldPos("M2_MOEDA" + cValToChar(ni))) > 0
	Do Case
		Case nOpc == 1
			//Igualar caixa e remover espacos
			cTMP := Upper(AllTrim(SuperGetMV("MV_SIMB" + cValToChar(ni),.F.,"")))
			cTMP02 := Upper(AllTrim(cStr))
		Case nOpc == 2
			//Igualar caixa e remover espacos
			cTMP := Upper(AllTrim(SuperGetMV("MV_MOEDA" + cValToChar(ni),.F.,"")))
			cTMP02 := Upper(AllTrim(cStr))
		Otherwise
			Return uMoeda			
	EndCase
	//Remover acentuacao do parametro e variavel, caso exista
	For nx := 1 to Len(IIf(Len(cTMP) >= Len(cTMP02),cTMP,cTMP02))
		If nx <= Len(cTMP)
			If (nPos := At(Substr(cTMP,nx,1),cAcentua)) > 0
				cTMP := IIf(nx > 1, Substr(cTMP,1,nx - 1),"") + Substr(cAcentuaCorr,nPos,1) + Right(cTMP,Len(cTMP) - nx)
			Endif
		Endif
		If nx <= Len(cTMP02)
			If (nPos := At(Substr(cTMP02,nx,1),cAcentua)) > 0
				cTMP02 := IIf(nx > 1, Substr(cTMP02,1,nx - 1),"") + Substr(cAcentuaCorr,nPos,1) + Right(cTMP02,Len(cTMP) - nx)
			Endif
		Endif
	Next ni
	If cTMP == cTMP02
		uMoeda := ni
		Exit
	Endif	
	ni++
EndDo
//Caso tenha que ser retornado como caracter
If nTipoRet == 2
	If lFrmtStr
		uMoeda := StrZero(uMoeda,nTamMoeda)
	Else
		uMoeda := cValToChar(uMoeda)
	Endif
Endif
RestArea(aAreaSM2)

Return uMoeda

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LjInfoCxAtºAutor  ³Vendas Clientes        º Data ³  24/09/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Retorna a referencia completa de um caixa                     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³Exp01[N] : (Opcional) 1. Retorna uma array com os dados.      º±±
±±º          ³                      2. Retorna uma string com dados.        º±±
±±º          ³Exp02[L] : (Opcional) Define se os dados vao retornar com o   º±±
±±º          ³                      tamanho padrao definido no dicionario   º±±
±±º          ³                      de dados.                               º±±
±±º          ³Exp03[L] : (Opcional) Define se no array de retorno sera      º±±
±±º          ³                      adicionado um segundo elemento com o    º±±
±±º          ³                      tamanho do campo correspondente.        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³aID[A]   : Array contendo :                                   º±±
±±º          ³          [1]-CAIXA                                           º±±
±±º          ³          [2]-ESTACAO                                         º±±
±±º          ³          [3]-SERIE                                           º±±
±±º          ³          [4]-PDV                                             º±±
±±º          ³          [5]-SERIE NAO FISCAL                                º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³SIGALOJA-SIGAFRT                                              º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function LjInfoCxAt(nOpc,lFormata,lRetTam)

Local aID			:= {}
Local aTMP			:= {}

Private uResp		:= ""

Default nOpc		:= 1
Default lFormata	:= .F.
Default lRetTam	:= .F.

If !AmIIn(12,23,72) .OR. ValType(lFormata) # "L" .OR. Empty(nOpc) .OR. ValType(nOpc) # "N" .AND. ValType(lRetTam) # "L"
	aID := {}
	Return uResp
Endif
aTMP := LjGetStation({"CODIGO","SERIE","PDV","SERNFIS"})
If Len(aTMP) == 0
	Return uResp
Endif
//Caso nao se utilize o retorno de tamanho de campos ou a opcao de retorno seja de string
If !lRetTam .OR. nOpc # 1
	aID := Array(5)
	If !lFormata
		aID[1] := AllTrim(xNumCaixa())
		aID[2] := AllTrim(aTMP[1])
		aID[3] := AllTrim(aTMP[2])
		aID[4] := AllTrim(aTMP[3])
		aID[5] := AllTrim(aTMP[4])
	Else
		aID[1] := PadR(AllTrim(xNumCaixa()),TamSX3("L1_OPERADO")[1])
		aID[2] := PadR(AllTrim(aTMP[1]),TamSX3("LG_CODIGO")[1])
		aID[3] := PadR(AllTrim(aTMP[2]),TamSX3("LG_SERIE")[1])
		aID[4] := PadR(AllTrim(aTMP[3]),TamSX3("LG_PDV")[1])
		aID[5] := PadR(AllTrim(aTMP[4]),TamSX3("LG_SERNFIS")[1])
	Endif
	If nOpc == 1
		uResp := aID
	Else
		aEval(aID,{|x| uResp += x})
	Endif	
Else
	aID := Array(5,2)
	If !lFormata
		aID[1][1] := AllTrim(xNumCaixa())
		aID[2][1] := AllTrim(aTMP[1])
		aID[3][1] := AllTrim(aTMP[2])
		aID[4][1] := AllTrim(aTMP[3])
		aID[5][1] := AllTrim(aTMP[4])
	Else
		aID[1][1] := PadR(AllTrim(xNumCaixa()),TamSX3("L1_OPERADO")[1])
		aID[2][1] := PadR(AllTrim(aTMP[1]),TamSX3("LG_CODIGO")[1])
		aID[3][1] := PadR(AllTrim(aTMP[2]),TamSX3("LG_SERIE")[1])
		aID[4][1] := PadR(AllTrim(aTMP[3]),TamSX3("LG_PDV")[1])
		aID[5][1] := PadR(AllTrim(aTMP[4]),TamSX3("LG_SERNFIS")[1])
	Endif
	aID[1][2] := TamSX3("L1_OPERADO")[1]
	aID[2][2] := TamSX3("LG_CODIGO")[1]
	aID[3][2] := TamSX3("LG_SERIE")[1]
	aID[4][2] := TamSX3("LG_PDV")[1]
	aID[5][2] := TamSX3("LG_SERNFIS")[1]
	If nOpc == 1
		uResp := aID
	Else
		aEval(aID,{|x| uResp += x[1]})
	Endif		
Endif

Return uResp

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³EnvWSOk   ºAutor  ³Vendas Clientes       º Data ³  27/09/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Retorna se o ambiente do WS esta ok ou se sera necessario rea-º±±
±±º          ³lizar uma conexao RPC na execucao do WS.                      º±±
±±º          ³Alem de realizar uma verificacao das variaveis de empresa e   º±±
±±º          ³filial, ele valida se o WS esta configurado no INI do server  º±±
±±º          ³e se estiver, verifica se o parametro PREPAREIN existe e esta º±±
±±º          ³preenchido. Permite conexao via RPC com empresa e filial.     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³Exp01[L] : Determina se a rotina deve configurar uma conexao  º±±
±±º          ³           RPC                                                º±±
±±º          ³Exp02[C] : Empresa para conexao                               º±±
±±º          ³Exp03[C] : Filial para conexao                                º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³lRPC[L]  : Retorno se a conexao esta OK                       º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³Generico                                                      º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function EnvWSOk(lConecta,cEmpC,cFilC,lVerSX)

Local aJobs 		:= StrTokArr(GetPvProfString("ONSTART","JOBS","",GetAdv97()),",")	//Levantar a lista de jobs disparados na chave ONSTART
Local lRPC			:= .F.		//Eh necessario uma conexao RPC?
Local lEnc			:= .F.		//Foi encontrado a chave de WS?
Local ni			:= 0
Local lAmbNOK		:= Type("cEmpAnt") == "U" .OR. Empty(cEmpAnt) .OR. Type("cFilAnt") == "U" .OR. Empty(cFilAnt)	//Ambiente Nao OK?
Local aErro			:= {}
Local cRotina		:= "[EnvWSOk]" + Space(1)

Default lConecta	:= .F.
Default cEmpC		:= ""
Default cFilC		:= ""
Default lVerSX		:= .F.

If ValType(lConecta) # "L" .OR. ValType(cEmpC) # "C" .OR. ValType(cFilC) # "C"
	lConecta := .F.	
Endif
If lConecta .AND. (Empty(cEmpC) .OR. Empty(cFilC))
	lConecta := !lConecta
Endif
ConOut(cRotina + "lConecta : " + cValToChar(lConecta) + " cEmpC : " + cEmpC + " cFilC : " + cFilC)
//Verificar se a conexao utiliza a clausula PREPAREIN no WEBSERVICE
If Len(aJobs) == 0
	ConOut(cRotina + STR0127)	//"Nao existe jobs declarados para execução [ONSTART]"
	lRPC := !lRPC
Else
	For ni := 1 to Len(aJobs)
		//Caso o job declarado em questao no parametro JOBS seja o do WS
		If AllTrim(GetPvProfString(AllTrim(aJobs[1]),"ONSTART","",GetAdv97())) == "__WSSTART"
			//Veriricar se o job utiliza o parametro de preparacao de ambiente (empresa / filial)
			If !Empty(GetPvProfString(AllTrim(aJobs[1]),"PREPAREIN","",GetAdv97()))
				lEnc := .T.
				Exit
			Endif
		Endif
	Next ni
	If !lEnc
		ConOut(cRotina + STR0128 + AllTrim(GetAdv97()))	//"Nenhum job eh de WS ou esta preparando ambiente no "
		lRPC := !lRPC
	Endif
Endif
//Caso o ambiente esteja declarado, validar se as variaveis de ambiente estao declaradas
If !lRPC .AND. !lAmbNOK
	ConOut(cRotina + STR0129)	//"Processar RPC apesar de haver ambiente declarado pois o mesmo nao esta preparado."
	lRPC := .T.
Endif
//Se for necessario conectar
If lConecta .AND. lRPC
	//Verificar se a empresa conectada eh a mesma da definida no parametro, caso nao seja forcar nova conexao RPC
	If !lAmbNOK .AND. (AllTrim(cEmpC) # AllTrim(cEmpAnt) .OR. AllTrim(cFilC) # AllTrim(cFilAnt))
		ConOut(cRotina + STR0130 + cEmpAnt + STR0131 + cFilAnt + STR0132)	//"Desconectando a empresa "###" filial "###" para conectar a definida em parametro"
		RpcClearEnv()
		lAmbNOK := .T.
	Endif	
	If lAmbNOK
		ConOut(cRotina + STR0133)	//"Conectar RPC"
		RpcSetType(3)
		RpcSetEnv(cEmpC,cFilC)
		//Verificar se os arquivo SX estao disponiveis, que comprovam o sucesso na conexao
		If lVerSX
			If !RpcChkSXs(cEmpC,@aErro)
				ConOut(cRotina + STR0134 + cEmpC + ") : " + CRLF + aErro[1][2])	//"ALERTA! Erro ao tentar abrir os arquivos SXs da empresa ("
				//Retornar falso
				Return !lRPC
			Endif
		Endif
		lRPC := .F.      
	Else
		ConOut(cRotina + STR0135)	//"Ambiente jah conectado"
		lRPC := .F.
	Endif
Endif
ConOut(cRotina + STR0136 + cValToChar(!lRPC))	//"RETORNO - "

Return !lRPC

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ExConfAbLWºAutor  ³Vendas Clientes       º Data ³  28/09/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Efetua uma pesquisa na SLW para retornar se existe algum movi-º±±
±±º          ³mento pendente de conferencia na SLW. A consulta eh feita na  º±±
±±º          ³retaguarda atraves de WS. Aplicavel a terminais PDV.          º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³Exp01[N] : 1 - Retorno logico ou 2 - Retorno de chave ind. 03 º±±
±±º          ³Exp02[N] : 1 - Pesquisa de pendencias de conferencia completa,º±±
±±º          ³               utilizando Caixa + PDV + Estacao + Movimento   º±±
±±º          ³           2 - Pesquisa de pendencias de conferencia simplifi-º±±
±±º          ³               cada, utilizando apenas Caixa (PADRAO)         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³uRet[U]  : 1 - [L] Indica se existe conf. pendente            º±±
±±º          ³           2 - [C] Caso exista conferencia pendente, retorna  º±±
±±º          ³                   a chave completa da SLW indice 03, com :   º±±
±±º          ³                   LW_FILIAL+LW_PDV+LW_OPERADO+               º±±
±±º          ³             		 DTOS(LW_DTABERT)+LW_ESTACAO+LW_NUMMOV      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³SIGAFRT                                                       º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function ExConfAbLW(nTpRet,nOpc)

Local oWS				:= Nil
Local cWSSRV			:= Nil
Local aID				:= LjInfoCxAt()	//Caixa + Estacao + Serie + PDV
Local uRet				:= .T.
Local cWSErro			:= ""
Local cSoapErrCod		:= ""
Local cSoapErrDesc		:= ""
Local aRet				:= Array(2)
Local lRet				:= .F.
Local cRotina			:= "[ExConfAbLW]" + Space(1)
Local lMvLjPdvPaf 		:= FindFunction("LjxBGetPaf") .AND. LjxBGetPaf()[2] //Indica se é pdv

Default nTpRet			:= 1
Default nOpc			:= 2

If !AmIIn(05,12,23,72) .OR. ValType(nOpc) # "N" .OR. ValType(nTpRet) # "N"
	Return !uRet
Endif
If (nModulo == 12 .AND. !lMvLjPdvPaf) .OR. nModulo == 5  //12=SIGALOJA ou 5=SIGAFAT
	Return !uRet
Endif
If !cValToChar(nOpc) $ "1|2" .OR. !cValToChar(nTpRet) $ "1|2"
	Return !uRet
Endif
oWS		:= WSWSFRT272B():New()
iIf(ExistFunc("LjWsGetAut"),LjWsGetAut(@oWS),Nil) //Monta o Header de Autenticação do Web Service
cWSSRV	:= AllTrim(LjGetStation("WSSRV"))
If !Empty(cWSSRV)                   
	oWS:_URL 	:= "http://" + cWSSRV + "/WSFRT272B.apw"
	oWS:nNOPC	:= nOpc
	oWS:cCOPER	:= aID[1]
	If nOpc == 1
		oWS:cCPDV		:= aID[4]
		oWS:cCESTACAO	:= aID[2]
		oWS:cCNUMMOV	:= AllTrim(LjNumMov())
	Else
		oWS:cCPDV		:= ""
		oWS:cCESTACAO	:= ""
		oWS:cCNUMMOV	:= ""
	Endif
	oWS:cCEmpC	:= cEmpAnt
	oWS:cCFilC	:= FWGETCODFILIAL
	lRet := oWS:ExConfAbLW()
	If ValType(lRet) == "L"
		If !lRet
			cWSErro := GetWSCError()
			If Substr(cWSErro,1,9)	 = "WSCERR048"
				cWSErro := GetWSCError(3)
				cSoapErrCod  := Alltrim(Substr(cWSErro,1,At(":",cWSErro)-1))
				cSoapErrDesc := Alltrim(Substr(cWSErro,At(":",cWSErro)+1,Len(cWSErro)))
				Conout(cRotina + STR0137 + cSoapErrCod + " -> " + cSoapErrDesc)		//"ERRO WS : "
			Else
				ConOut(cRotina + STR0138)	//"Erro de comunicação com o WebService!"
			Endif
			uRet := IIf(nTpRet == 1,.F.,"")
		Else
			aRet[1] := oWS:oWSEXCONFABLWRESULT:oWSRetSLW[1]:cCCHAVE
			aRet[2] := oWS:oWSEXCONFABLWRESULT:oWSRetSLW[1]:lLRET
			//Retornar
			uRet := IIf(nTpRet == 1,aRet[2],aRet[1])
		Endif
	Else
		uRet := IIf(nTpRet == 1,.F.,"")
	Endif
Else
    MsgInfo(STR0186,STR0187)//“O endereco do WS no cadastro de estacao nao esta configurado, configure para abertura do caixa","Conferencia de Caixa" 
    
    uRet := .F.
Endif

Return uRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LjDtHrECF ºAutor  ³Vendas Clientes       º Data ³  10/09/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Funcao de retorno de data e hora da ECF, caso exista ECF ins- º±±
±±º          ³talado. Caso nao exista, retorna data e hora do computador.   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³Exp01[L] : Em caso de erro de comunicacao com a ECF a array   º±±
±±º          ³           nao deve retornar vazia.                           º±±
±±º          ³Exp02[L] : Tamanho do campo Hora                              º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³aRet[A]  : Array contendo Data e Hora                         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³                                                              º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function LjDtHrECF(lNaoRetVaz, nTamTime)

Local aRet			:= {}
Local nRet			:= 0
Local cRet			:= ""
Local lErro			:= .F.
Local aDataHr		:= Array(2)
Local lEmitNfce	  	:= LjEmitNFCe()	// Sinaliza se utiliza NFC-e/SAT
Local lUseSAT 		:= LjUseSat()
Local lHVerao		:= SuperGetMv("MV_HVERAO",.F.,.F.)					// Verifica se o local fisico do servidor est?em Hor?io de Ver?  .F. N? / .T. Sim

Default lNaoRetVaz	:= .F.	//Determina que em caso de erro na obtencao de data e hora com a ECF a rotina nao deve retornar uma array vazia
Default nTamTime    := 5

If ValType(lNaoRetVaz) # "L"
	lNaoRetVaz := .F.
Endif
//Caso exista ECF e o caixa tenha permissao para usa-la
If cPaisLoc == "BRA" .AND. lFiscal .AND. LjProfile(3) .AND. !lUseSAT
	//Levantar data da ECF
	If !lEmitNfce
		lErro := ( nRet := IFStatus(nHdlECF,"2",@cRet) ) <> 0
		If !lErro
			aDataHr[1] := CtoD(cRet)
			//Levantar hora da ECF
			lErro := ( nRet :=  IFStatus(nHdlECF,"1",@cRet) ) <> 0
			If !lErro
				aDataHr[2] := Substr(AllTrim(cRet),1,nTamTime)
			Endif
		Endif
	Else
		aDataHr := FwTimeUF(IIf(!GetNewPar("MV_SPEDEND",.F.) , SM0->M0_ESTCOB, SM0->M0_ESTENT),,lHVerao)	
		aDataHr[1] := Stod(	aDataHr[1] )
		aDataHr[2] := Substr(aDataHr[2],1,nTamTime)
	EndIf

	//Em caso de erro, abortar a operacao
	If lErro
		If !lNaoRetVaz
			Return aRet
		Else
			If isBlind()
				aDataHr[1] := Date()
				aDataHr[2] := Substr(Time(),1,nTamTime)
			Else
				aDataHr[1] := GetRmtDate()
				aDataHr[2] := Substr(GetRmtTime(),1,nTamTime)
			EndIf
		Endif
	Endif
Else
	If isBlind()
		aDataHr[1] := Date()
		aDataHr[2] := Substr(Time(),1,nTamTime)
	Else
		aDataHr[1] := GetRmtDate()
		aDataHr[2] := Substr(GetRmtTime(),1,nTamTime)
	EndIf
	
Endif
aRet := aDataHr

Return aRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LjExOrc   ºAutor  ³Vendas Clientes       º Data ³  06/10/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Funcao que retorna se existem orcamentos feitos atraves da    º±±
±±º          ³combinacao DATA+OPERADOR+PDV+SERIE dentro de uma data e mov.  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³Exp01[A] : Array com informacoes do operador, estacao, serie  º±±
±±º          ³            e PDV                                             º±±
±±º          ³Exp02[D] : Data para pesquisa                                 º±±
±±º          ³Exp03[C] : Numero do movimento a ser pesquisado na SL1        º±±
±±º          ³Exp04[L] : Considerar orcamentos cancelados?                  º±±
±±º          ³Exp05[L] : Considerar orcamentos incompletos? (Sem SL4)       º±±
±±º          ³Exp06[A] : Retornar lista de orcamentos encontrados?          º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³uRet[L]  : Retorna se existe ou nao orcamentos no movimento   º±±
±±º          ³OU (se o parametro lRetLst estiver ativo)                     º±±
±±º          ³uRet[A]  : Retorna lista de orcamentos (chave 01 FIL+ORC)     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³                                                              º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LjExOrc(aID,dData,cNumMov,lConsCanc,lConsOrcIn,lRetLst)

Local uRet				:= .T.             		    //Retorno
Local aAreaSLW			:= SLW->(GetArea())
Local cChave			:= ""					    //Chave de pesquisa
Local lOk				:= .F.					    //Validador
Local aLstOrc			:= {}					    //Lista de orcamentos do movimento
Local lVerIntDoc		:= .F.					    //Verificar intervalo de documentos fiscais do movimento?
Local aIntDoc			:= Array(2)			        //Intervalo de cupons fiscais do movimento, para validacao de orcamentos do movimento
Local cSerNfSer			:= SubStr( SuperGetmv("MV_LJVFSER",,""),1,3 )	// Serie da NF de Simples Faturamento
Local lNFSimpfat		:= SuperGetmv("MV_LJVFNFS",,.F.) 				// Gera NF se Simples Faturamento
Local cSerNFisc			:= "" 											// Série não fiscal

Default aID				:= LjInfoCxAt(1,.T.,.F.)	//[1]-CAIXA [2]-ESTACAO [3]-SERIE [4]-PDV  [5]-SERIE NAO FISCAL
Default dData			:= LjDtHrECF(.T.)[1]
Default cNumMov			:= AllTrim(LjNumMov())
Default lConsCanc		:= .F.
Default lConsOrcIn		:= .F.
Default lRetLst			:= .F.

// Serie nao fiscal
If Len(aID) > 4 .AND. ValType(aID[5]) == "C"
	If Empty(aID[5])
		cSerNFisc := AllTrim(SuperGetmv("MV_LOJAPED",,""))
	Else
		cSerNFisc := AllTrim(aID[5])
	EndIf
ElseIf Len(aID) == 4
	//Caso não tenha sido passado a seria não fiscal, adiciona a serie da estação corrente
	//Mesmo tratamento da função LjInfoCxAt
	Aadd(aID, LjGetStation({"SERNFIS"}))	
EndIf

If ValType(dData) # "D" .OR. ValType(cNumMov) # "C" .OR. ValType(lConsCanc) # "L"
	Return IIf(!lRetLst,!uRet,Array(0))
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Levantar o intervalo de cupons fiscais do movimento  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cChave := xFilial("SLW") + aID[4] + aID[1] + DtoS(dData) + aID[2] + RTrim(cNumMov)
dbSelectArea("SLW")
SLW->(dbSetOrder(3))	//LW_FILIAL+LW_PDV+LW_OPERADO+DTOS(LW_DTABERT)+LW_ESTACAO+LW_NUMMOV
If SLW->(dbSeek(cChave))
	If !Empty(SLW->LW_NUMINI) .AND. !Empty(SLW->LW_NUMFIM) .And. SLW->LW_NUMINI <= SLW->LW_NUMFIM
		lVerIntDoc := !lVerIntDoc
		aIntDoc[1] := AllTrim(SLW->LW_NUMINI)
		aIntDoc[2] := AllTrim(SLW->LW_NUMFIM)
	Endif
Endif

//Se os cancelados devem ser considerados, os incompletos devem ser considerados, o retorno nao eh a lista de orcamentos e existir pelo mens um orçamento na data de movimento, entao pode abandonar a funcao.
If LjBuscaOrc( "EXIST", aID[1], dData ) .AND. lConsCanc .AND. lConsOrcIn .AND. !lRetLst
	RestArea(aAreaSLW)
	Return uRet
Endif

lOk :=  LjBuscaOrc( "LOAD"		, aID[1]	, dData		, cNumMov	,;
					aID[2]		, aID[4]	, aID[3]	, aIntDoc[1],;
					aIntDoc[2]	, lRetLst	, @aLstOrc	, lConsCanc	,;
					lConsOrcIn )

If !lRetLst
	If !lOk
		uRet := !uRet
	Endif
Else
	uRet := aLstOrc
Endif

RestArea(aAreaSLW)

Return uRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LjExMov   ºAutor  ³Vendas Clientes       º Data ³  20/08/13   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Funcao que retorna se existem moviemntos feitos no caixa		º±±
±±º          ³ dentro de uma data e mov. (SANGRIA / TROCO)					º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³lRet[L]  : Retorna se existe ou nao movimentos no caixa		º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ FRTA272B                                                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LjExMov(cCaixa, dDtMov, cNumMov,lListMov, cEstacao)
Local uRet			:= .F.
Local cChaveSE5		:= ""
Local aSaveOrd		:= GetArea()
Local aLstMov		:= {}
Local cNatTroc		:= LjMExeParam("MV_NATTROC")

Default cCaixa		:= LjInfoCxAt(1,.T.,.F.)[1]	//[1]-CAIXA [2]-ESTACAO [3]-SERIE [4]-PDV
Default dDtMov		:= LjDtHrECF(.T.)[1]
Default cNumMov		:= AllTrim(LjNumMov())
Default lListMov	:= .F.
Default cEstacao	:= LjInfoCxAt(1,.T.,.F.)[2]	//[1]-CAIXA [2]-ESTACAO [3]-SERIE [4]-PDV

DbSelectArea("SE5")
SE5->(DbSetOrder(1)) //E5_FILIAL+DTOS(E5_DATA)+E5_BANCO+E5_AGENCIA+E5_CONTA+E5_NUMCHEQ
cChaveSE5 := xFilial("SE5")+DtoS(dDtMov)+cCaixa
If SE5->( DbSeek( cChaveSE5 ) )

	While !SE5->(EOF()) .And. cChaveSE5 == SE5->(E5_FILIAL+DTOS(E5_DATA)+E5_BANCO)
		If SE5->(FieldPos("E5_MSFIL")) != 0 .and. SE5->E5_MSFIL != cFilAnt
				SE5->(DBSkip())
				Loop
		EndIf
				
		If AllTrim(SE5->E5_NUMMOV) == AllTrim(cNumMov)
			uRet := .F.
			If AllTrim(SE5->E5_TIPODOC) == "TR" .And.;
			   ( Upper(AllTrim(E5_MOEDA)) == "TC" .And. ("TROCO" $ Upper(AllTrim(SE5->E5_NATUREZ))  .or. cNatTroc $ Upper(AllTrim(SE5->E5_NATUREZ)) )  ) .Or.; //TROCO
			   ( "SANGRIA" $ Upper(AllTrim(SE5->E5_NATUREZ)) ) .And. Iif("/" $ SE5->E5_HISTOR, "/"+AllTrim(cEstacao) $ AllTrim(SE5->E5_HISTOR),.T.)  //SANGRIA			   
				uRet := .T.
				If !lListMov
					Exit
				EndIf

			ElseIf (AllTrim(SE5->E5_TIPODOC) == "VL" .Or. AllTrim(SE5->E5_TIPODOC) == "ES" .Or. AllTrim(SE5->E5_TIPODOC) == "BA" ) .AND.;
					 (Upper(Substr(E5_HISTOR,1,15)) == "LOJ-RECEBIMENTO" .OR. Upper(Substr(E5_HISTOR,1,25)) == "LOJ-CANCELAMENTO DE BAIXA";
					 .OR. Upper(Substr(E5_HISTOR,1,21)) == "BAIXA POR COMPENSACAO") 	//Recebimentos e Estorno de Recebimento		
				uRet := .T.
				If !lListMov
					Exit
				EndIf

			ElseIf Upper(AllTrim(SE5->E5_HISTOR)) == Upper(AllTrim("CORRESPONDENTE BANCARIO"))  .Or.; //Correspondente Bancario
				 (Upper(AllTrim(SE5->E5_NATUREZ)) == Upper(AllTrim(SuperGetMv("MV_NATCB",,""))) .Or. Upper(AllTrim(SE5->E5_NATUREZ)) == SuperGetMV("MV_NATTEF") )
				uRet := .T.
				If !lListMov
					Exit
				EndIf

			ElseIf Upper(AllTrim(SE5->E5_HISTOR)) == Upper(AllTrim("RECARGA DE CELULAR")) //RECARGA DE CELULAR
				uRet := .T.
				If !lListMov
					Exit
				EndIf
			EndIf
			
			If uRet
				aAdd(aLstMov,SE5->(RECNO()) )
			EndIf			
		EndIf
		SE5->(DBSkip())
	EndDo

EndIf

If lListMov
	uRet := aLstMov
EndIf

RestArea(aSaveOrd)
Return uRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LjLWPendT ºAutor  ³Vendas Clientes       º Data ³  07/10/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Funcao que retorna o proximo registro pendente de subida ao   º±±
±±º          ³servidor da SLW e/ou SLT. Utilizada em casos onde varios movi-º±±
±±º          ³mentos foram feitos no PDV e estes movimentos por alguma razaoº±±
±±º          ³nao subiram ao server.Como o controle de subida atraves da SLIº±±
±±º          ³permite o processamento de um movimento por vez, ao subir um  º±±
±±º          ³movimento esta funcao eh executada para atualizar a SLI com o º±±
±±º          ³proximo movimento pendente de subida.                         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³Exp01[C] : Tipo de operacao da SLI                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³cRet[C]  : String com operacao e chave da SLW a subir         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³SIGAFRT                                                       º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function LjLWPendSu(cTipo,aID)

Local cRet			:= ""
Local aAreaSLW		:= SLW->(GetArea())
Local cDtFecha      := Space( TamSx3("LW_DTFECHA")[1] )
#IFDEF TOP
Local cAlias		:= GetNextAlias()
Local cQry			:= ""
Local cSGBD			:= ""
#ELSE
Local cFiltro		:= ""
#ENDIF

Default cTipo		:= ""
Default aID			:= aID := LjInfoCxAt(1,.T.,.F.)	//[1]-CAIXA [2]-ESTACAO [3]-SERIE [4]-PDV

//Se o modulo nao for o FRT ou PAF, se o tipo de movimento nao estiver definido, se a SLW nao estiver no dicionario, sair
If !AmIIn(23,72) .OR. !AliasInDic("SLW") .OR. ValType(cTipo) # "C" .OR. Empty(cTipo)
	Return cRet
Endif
//Se o campo de situacao nao existir, sair
If SLW->(FieldPos("LW_SITUA")) == 0
	Return cRet
Endif
//Se o tipo for invalido, sair
cTipo := AllTrim(cTipo)
If !cTipo $ "ABR|FCH"
	Return cRet
Endif
#IFDEF TOP
	cSGBD := Upper(AllTrim(TcGetDB()))
	cQry := "SELECT DISTINCT LW_FILIAL, LW_PDV, LW_OPERADO, LW_DTABERT, LW_NUMMOV, LW_ESTACAO, LW_TIPFECH "
	cQry += "FROM " + RetSQLName("SLW") + " "
	cQry += "WHERE D_E_L_E_T_ <> '*' AND LW_SITUA = '00' "
	cQry += "AND LW_PDV = '" + AllTrim(aID[4]) + "' "
	If !Empty(aID[1])
		cQry += "AND LW_OPERADO = '" + AllTrim(aID[1]) + "' "
	Endif
	cQry += "AND LW_SERIE = '" + AllTrim(aID[3]) + "' "
	cQry += "AND LW_ESTACAO = '" + AllTrim(aID[2]) + "' "
	Do Case
		Case cTipo == "ABR"
			Do Case
				Case cSGBD $ "MSSQL|SYBASE"
					cQry += "AND (LEN(LW_DTFECHA) = 0) "
				Case cSGBD $ "MYSQL|POSTGRES|INFORMIX|OPENEDGE"
					cQry += "AND (LENGTH(LW_DTFECHA) = 0) "
                Case cSGBD == "ORACLE"
                    cQry += "AND LW_DTFECHA = '" + cDtFecha + "' "
				Case cSGBD $ "DB2|DB2/400"
					cQry += "AND (LENGTH(TRIM(LW_DTFECHA)) = 0) "					
				OtherWise
					cQry += "AND (LEN(LW_DTFECHA) = 0) "
			EndCase
		Case cTipo == "FCH"
			Do Case
				Case cSGBD $ "MSSQL|SYBASE"
					cQry += "AND (LEN(LW_DTFECHA) <> 0) "
				Case cSGBD $ "MYSQL|POSTGRES|INFORMIX|OPENEDGE"
					cQry += "AND (LENGTH(LW_DTFECHA) <> 0) "
                Case cSGBD == "ORACLE"
                    cQry += "AND LW_DTFECHA <> '" + cDtFecha + "' "
				Case cSGBD $ "DB2|DB2/400"
					cQry += "AND (LENGTH(TRIM(LW_DTFECHA)) <> 0) "
				OtherWise
					cQry += "AND (LEN(LW_DTFECHA) <> 0) "
			EndCase		
	EndCase
	cQry += "ORDER BY LW_NUMMOV ASC"
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Importante : por utilizar função build in de SGBD, nao aplicar o PARSER.  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ	
	dbUseArea(.T.,__cRDD,TcGenQry(,,cQry),cAlias,.T.,.F.)
	(cAlias)->(dbGoTop())
	If !(cAlias)->(Eof())
		TcSetField(cAlias,"LW_DTABERT","D",8,0)
		Do Case
			Case cTipo == "ABR"
				cRet := StrZero(3,2) + (cAlias)->(LW_FILIAL + LW_PDV + LW_OPERADO + DtoS(LW_DTABERT) + LW_ESTACAO + LW_NUMMOV)
			Case cTipo == "FCH"
				Do Case
					Case (cAlias)->LW_TIPFECH == "1"	//Subir SLW
						cRet := "1" + StrZero(3,2) + (cAlias)->(LW_FILIAL + LW_PDV + LW_OPERADO + DtoS(LW_DTABERT) + LW_ESTACAO + LW_NUMMOV)
					Case (cAlias)->LW_TIPFECH == "2"	//Subir SLW + SLT
						cRet := "2" + StrZero(3,2) + (cAlias)->(LW_FILIAL + LW_PDV + LW_OPERADO + DtoS(LW_DTABERT) + LW_ESTACAO + LW_NUMMOV)
					Otherwise
						cRet := "1" + StrZero(3,2) + (cAlias)->(LW_FILIAL + LW_PDV + LW_OPERADO + DtoS(LW_DTABERT) + LW_ESTACAO + LW_NUMMOV)
				EndCase
		EndCase
	Endif
	FechaArqT(cAlias)
#ELSE
	cFiltro := "LW_SITUA = '00' "
	cFiltro += ".AND. LW_PDV = '" + PadR(aID[4],TamSX3("LW_PDV")[1]) + "' "
	If !Empty(aID[1])
		cFiltro += ".AND. LW_OPERADO = '" + PadR(aID[1],TamSX3("LW_OPERADO")[1]) + "' "
	Endif
	cFiltro += ".AND. LW_SERIE = '" + PadR(aID[3],TamSX3("LW_SERIE")[1]) + "' "
	cFiltro += ".AND. LW_ESTACAO = '" + PadR(aID[2],TamSX3("LW_ESTACAO")[1]) + "' "
	Do Case
		Case cTipo == "ABR"
			cFiltro += ".AND. Empty(LW_DTFECHA) "	//Utilizar empty, pois o suporte a esta funcao ADVPL abrange um maior numero de BDs no TOP
		Case cTipo == "FCH"
			cFiltro += ".AND. !Empty(LW_DTFECHA) "
	EndCase
	dbSelectArea("SLW")
	SLW->(dbSetOrder(3))	//LW_FILIAL+LW_PDV+LW_OPERADO+DTOS(LW_DTABERT)+LW_ESTACAO+LW_NUMMOV
	SLW->(dbSetFilter({|| &cFiltro},cFiltro))
	SLW->(dbGoTop())
	If !SLW->(Eof())
		Do Case
			Case cTipo == "ABR"
				cRet := StrZero(SLW->(IndexOrd()),2) + SLW->(LW_FILIAL + LW_PDV + LW_OPERADO + DtoS(LW_DTABERT) + LW_ESTACAO + LW_NUMMOV)
			Case cTipo == "FCH"
				Do Case
					Case SLW->LW_TIPFECH == "1"	//Subir SLW
						cRet := "1" + StrZero(SLW->(IndexOrd()),2) + SLW->(LW_FILIAL + LW_PDV + LW_OPERADO + DtoS(LW_DTABERT) + LW_ESTACAO + LW_NUMMOV)
					Case SLW->LW_TIPFECH == "2"	//Subir SLW + SLT
						cRet := "2" + StrZero(SLW->(IndexOrd()),2) + SLW->(LW_FILIAL + LW_PDV + LW_OPERADO + DtoS(LW_DTABERT) + LW_ESTACAO + LW_NUMMOV)
					Otherwise
						cRet := "1" + StrZero(SLW->(IndexOrd()),2) + SLW->(LW_FILIAL + LW_PDV + LW_OPERADO + DtoS(LW_DTABERT) + LW_ESTACAO + LW_NUMMOV)
				EndCase
		EndCase		
	Endif
	dbClearFilter()
#ENDIF
RestArea(aAreaSLW)

Return cRet

/*                                                  	
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³FechaArqT ºAutor  ³Vendas Clientes       º Data ³  19/04/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Rotina para encerrar alias e arquivos temporarios criados a   º±±
±±º          ³partir de uma query.                                          º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³Generico                                                      º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function FechaArqT(cAlias)

If Empty(cAlias)
	Return Nil
Endif
If Select(cAlias) > 0
	dbSelectArea(cAlias)
	dbCloseArea()
	If File(cAlias + OrdBagExt())
		fErase(cAlias + OrdBagExt())
	Endif
	If File(cAlias + GetDbExtension())
		fErase(cAlias + GetDbExtension())
	Endif
Endif

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LjRetSitLWºAutor  ³Vendas Clientes       º Data ³  13/10/10       º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Funcao para pesquisar qual a situacao de um movimento em aberto   º±±
±±º          ³encontrado localmente, na retaguarda.                             º±±
±±º          ³Ordem de pesquisa : 03                                            º±±
±±º          ³LW_FILIAL+LW_PDV+LW_OPERADO+DTOS(LW_DTABERT)+LW_ESTACAO+LW_NUMMOV º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³Exp01[C] : Chave do titulo a ser pesquisado (Indice 03)           º±±
±±º          ³Exp02[L] : Determina se a SLW local deve ser atualizada quando a  º±±
±±º          ³           conferencia jah estiver sido feita na retaguarda.      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³cRet - 00 - Nao esta na retaguarda ou houve erro de comunicacao   º±±
±±º          ³       01 - Esta na retaguarda e a conferencia esta em aberto     º±±
±±º          ³       02 - Esta na retaguarda e a conferencia esta feita         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³SIGAFRT                                                           º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function LjRetSitLW(cChave,lAtua)

Local oWS				:= Nil
Local cWSSRV			:= Nil
Local cRet				:= "00"
Local cWSErro			:= ""
Local cSoapErrCod		:= ""
Local cSoapErrDesc		:= ""
Local lRet				:= .F.
Local aAreaSLW			:= SLW->(GetArea())
Local cRotina			:= "[LjRetSitLW]" + Space(1)
Local lMvLjPdvPaf 		:= FindFunction("LjxBGetPaf") .AND. LjxBGetPaf()[2] //Indica se é pdv

Default cChave			:= ""
Default lAtua			:= .F.

If !AmIIn(12,23,72) .OR. ValType(cChave) # "C" .OR. Empty(cChave) .OR. ValType(lAtua) # "L"
	Return cRet
Endif
If nModulo == 12  .AND. !lMvLjPDVPAF	//SIGALOJA ONLINE
	Return cRet
Endif
//Posicionar na SLW para verificar a situacao do movimento
dbSelectArea("SLW")
SLW->(dbSetOrder(3))	//LW_FILIAL+LW_PDV+LW_OPERADO+DTOS(LW_DTABERT)+LW_ESTACAO+LW_NUMMOV
If !SLW->(dbSeek(cChave))
	//Se o movimento nao foi encontrado, sair
	Return cRet	
Else
	//Se o movimento jah sofreu o fechamento completo localmente, sair
	If AllTrim(SLW->LW_TIPFECH) $ "2|3|4|5|6"
		Return cRet
	Endif
Endif
oWS		:= WSWSFRT272B():New()
iIf(ExistFunc("LjWsGetAut"),LjWsGetAut(@oWS),Nil) //Monta o Header de Autenticação do Web Service
cWSSRV	:= AllTrim(LjGetStation("WSSRV"))
If !Empty(cWSSRV)                   
	oWS:_URL 	:= "http://" + cWSSRV + "/WSFRT272B.apw"
	oWS:cCCHAVE	:= cChave
	oWS:cCEmpC	:= cEmpAnt
	oWS:cCFilC	:= FWGETCODFILIAL
	lRet := oWS:RetSitLW()
	If ValType(lRet) == "L"
		If !lRet
			cWSErro := GetWSCError()
			If Substr(cWSErro,1,9)	 = "WSCERR048"
				cWSErro := GetWSCError(3)
				cSoapErrCod  := Alltrim(Substr(cWSErro,1,At(":",cWSErro)-1))
				cSoapErrDesc := Alltrim(Substr(cWSErro,At(":",cWSErro)+1,Len(cWSErro)))
				Conout(cRotina + "ERRO WS : " + cSoapErrCod + " -> " + cSoapErrDesc)
			Else
				ConOut(cRotina + "Erro de comunicação com o WebService!")
			Endif
		Else
			//Se o retorno for 02 (conferencia feita), atualizar o movimento, indicando que a conferencia foi feita
			cRet := oWS:cRETSITLWRESULT
			If !Empty(cRet)
				If AllTrim(cRet) == "02" .AND. lAtua
					RecLock("SLW",.F.)
					SLW->LW_TIPFECH := "2"	//Fechamento completo
					MsUnlock()
				Endif
			Else
				cRet := "00"
			Endif
		Endif
	Endif
Endif
RestArea(aAreaSLW)

Return cRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LjPendConfºAutor  ³Vendas Clientes       º Data ³19/10/10         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Funcao para retornar se existe pendencia de conferencia de fecha- º±±
±±º          ³mento de caixa.                                                   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³Exp01[C] - Tipo de movimento : [A]bertura ou [F]echamento         º±±
±±º          ³Exp02[A] - Array de identificacao completo do operador            º±±
±±º          ³                                                                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³lRet [L] : Retorna se existe ou nao pendencia de conferencia      º±±
±±º          ³                                                                  º±±
±±º          ³                                                                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³SIGALOJA                                                          º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function LjPendConf(cTipo,aID)

Local lRet		:= .F.
Local aAreaSLW	:= SLW->(GetArea())
Local cChave	:= ""
Local lUsaFecha	:= SuperGetMV("MV_LJCONFF",.T.,.F.)
Local aUltMov	:= LJNumMov({ "LW_NUMMOV", "LW_DTABERT"})   //Ultimo movimento de caixa

Default cTipo	:= ""
Default aID		:= aID := LjInfoCxAt()		                //[1]-CAIXA [2]-ESTACAO [3]-SERIE [4]-PDV

//Se for fechamento e não encontrou nenhuma movimento aberto, retornar pendencia
If AllTrim(cTipo) == "F" .And. ValType(aUltMov) == "U"
	Return .T.
EndIf

If ValType(cTipo) # "C" .OR. ValType(aID) # "A" .OR. Empty(cTipo) .OR. Len(aID) # 4
	Return lRet
Endif

If (nModulo <> 12 .And. nModulo <> 5) .OR. !AllTrim(cTipo) $ "A|F" //12=SIGALOJA; //5=SIGAFAT 
	Return lRet
Endif

If !lUsaFecha
	Return lRet
Endif

//No fechamento atraves da rotina de abertura e fechamento de caixa (retaguarda), desconhece-se qual o PDV, estacao e movimento que esta em aberto
cChave := LjUltMovAb(2,aID[1],,,,.F.)
If Empty(cChave)
	Return lRet
Else
	dbSelectArea("SLW")
	SLW->(dbSetOrder(3))	//LW_FILIAL+LW_PDV+LW_OPERADO+DTOS(LW_DTABERT)+LW_ESTACAO+LW_NUMMOV	

	If !SLW->(dbSeek(cChave))
		RestArea(aAreaSLW)
		Return lRet
	Endif

	aID[2] := SLW->LW_ESTACAO
	aID[3] := SLW->LW_SERIE
	aID[4] := SLW->LW_PDV
Endif
If AllTrim(cTipo) == "F" 
	//Procurar orcamentos apenas se o movimento tiver sido encerrado
	If !Empty(SLW->LW_DTFECHA)
		//Caso nao exista orcamentos feitos na data, desconsiderar
		If !LjExOrc({aID[1],aID[2],aID[3],aID[4]})
			RestArea(aAreaSLW)
			Return lRet	
		Endif
	Endif

	//Se for validação de fechamento não pode ter movimento aberto anterior ao movimento atual
	If SLW->LW_NUMMOV <> aUltMov[01] .OR. aUltMov[02] <> SLW->LW_DTABERT
		lRet := !lRet
	EndIf
	RestArea(aAreaSLW)
	Return lRet		
Else
	lAtuSLW := .F.
	RestArea(aAreaSLW)
	Return !lRet
Endif
RestArea(aAreaSLW)

Return lRet

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºPrograma  ³LjUpd70Ok ºAutor  ³Vendas Clientes       º Data ³  15/10/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Funcao que verifica se todas as tabelas e campos criados pelo º±±
±±º          ³UPDLOJA70, necessarios para o funcionamento do controle de    º±±
±±º          ³fechamento de caixa estao disponiveis.                        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³                                                              º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function LjUpd70Ok()

Local lRet			:= .T.	//Retorno

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LjRetParSrvºAutor  ³Vendas Clientes       º Data ³19/10/10        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Funcao que retornar o conteudo de um parametro no servidor (reta- º±±
±±º          ³guarda).                                                          º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³Exp01[C] - Nome do parametro                                      º±±
±±º          ³                                                                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³uRet [C] : Conteudo do parametro                                  º±±
±±º          ³                                                                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³Generico                                                          º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function LjRetParSrv(cParam)

Local oWS				:= Nil
Local cWSSRV			:= Nil
Local uRet				:= ""
Local cWSErro			:= ""
Local cSoapErrCod		:= ""
Local cSoapErrDesc		:= ""
Local lRet				:= .F.
Local cRotina			:= "[LjRetParSrv]" + Space(1)
Local aAreaSX6			:= SX6->(GetArea())
Local cChave			:= ""
Local cTipo				:= ""
Local aSepDec			:= Array(2)

Default cParam			:= ""

If Empty(cParam) .OR. ValType(cParam) # "C"
	Return Nil
Else
	cParam := AllTrim(Upper(cParam))
	If Substr(cParam,1,3) # "MV_"
		Return Nil
	Endif
Endif

If FindFunction("WSFRT272B") 
	oWS		:= WSWSFRT272B():New()
    iIf(ExistFunc("LjWsGetAut"),LjWsGetAut(@oWS),Nil) //Monta o Header de Autenticação do Web Service
	cWSSRV	:= AllTrim(LjGetStation("WSSRV"))
EndIf 

If !Empty(cWSSRV)                   
	oWS:_URL 	:= "http://" + cWSSRV + "/WSFRT272B.apw"
	oWS:cCEmpC	:= cEmpAnt
	oWS:cCFilC	:= FWGETCODFILIAL
	oWS:cCCHAVE	:= cParam
	lRet := oWS:RetParSrv()
	If ValType(lRet) == "L"
		If !lRet
			cWSErro := GetWSCError()
			If Substr(cWSErro,1,9)	 = "WSCERR048"
				cWSErro := GetWSCError(3)
				cSoapErrCod  := Alltrim(Substr(cWSErro,1,At(":",cWSErro)-1))
				cSoapErrDesc := Alltrim(Substr(cWSErro,At(":",cWSErro)+1,Len(cWSErro)))
				Conout(cRotina + "ERRO WS : " + cSoapErrCod + " -> " + cSoapErrDesc)
			Else
				ConOut(cRotina + "Erro de comunicação com o WebService!")
			Endif
		Else
			uRet := oWS:cRETPARSRVRESULT
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Caso o retorno nao seja nulo, convertet o retorno de acordo ³
			//³com o tipo de dados definido no parametro, jah que o        ³
			//³retorno do WS eh tipado (STRING).                           ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If uRet # Nil
				//Pesquisa utilizando a filial atual
				cChave := FWGETCODFILIAL + cParam
				dbSelectArea("SX6")
				SX6->(dbSetOrder(1))
				
				If !SX6->(dbSeek(cChave))
					cChave := Space(Len(SX6->X6_FIL)) + cParam
					If SX6->(dbSeek(cChave))
						cTipo := AllTrim(SX6->X6_TIPO)
					Endif
				Else
					cTipo := AllTrim(SX6->X6_TIPO)
				Endif
				If cTipo $ "DNL"
					Do Case
						Case cTipo == "D"
							If At("/",uRet) == 0
								uRet := StoD(uRet)
							Else
								uRet := CtoD(uRet)
							Endif
						Case cTipo == "N"
							//Pesquisar qual separador eh o separador decimal, para depois remover os separadores de milhar
							aSepDec[1] := Rat(".",uRet)
							aSepDec[2] := Rat(",",uRet)
							If aSepDec[1] == 0 .AND. aSepDec[2] == 0
								//Nao ha separador decimal nem de milhar
								uRet := Val(uRet)
							ElseIf aSepDec[1] == 0 .OR. aSepDec[2] == 0
								//Somente ha separador decimal
								uRet := GetDToVal(uRet)
							Else
								//Determinar qual o separador decimal
								If aSepDec[1] > aSepDec[2]
									uRet := GetDToVal(StrTran(uResp,aSepDec[1],""))
								Else
									uRet := GetDToVal(StrTran(uResp,aSepDec[2],""))
								Endif
							Endif
						Case cTipo == "L"
							If At("T",Upper(uRet)) > 0
								uRet := NtoL(1)
							Else
								uRet := NtoL(0)
							Endif
					EndCase
				Endif
			Endif
		Endif
	Endif
oWS:Reset() 
Endif

RestArea(aAreaSX6)
Return uRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LjChkCfgCF ºAutor  ³Vendas Clientes       º Data ³12/11/10        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Funcao que verifica se a configuracao da conferencia de caixa     º±±
±±º          ³da estacao esta alinhado com a configuracao da retaguarda.        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³                                                                  º±±
±±º          ³                                                                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³lRet [L] : Retorna se a configuracao esta OK                      º±±
±±º          ³                                                                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³SIGAFRT                                                           º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function LjChkCfgCF(lWsOk)

Local lRet				:= .T.		//Retorno
Local lConfCx			:= SuperGetMV("MV_LJCONFF",.F.,.F.) //Conferencia de caixa esta habilitada
Local lTrans			:= lConfCx .AND. SuperGetMV("MV_LJTRANS",.F.,.F.)	//Transferencia
Local cTransNat			:= SuperGetMV("MV_LJTRNAT",.F.,"")					//Natureza da transferencia de portador
Local lConfCxRet		:= .F.		//Configuracao da conferencia de caixa na retaguarda
Local lTransRet			:= .F.		//Configuracao de transferencia na retaguarda
Local cTransNatRet		:= ""		//Configuracao da natureza de transferencia na retaguarda
Local lMens				:= .F.

DEFAULT lWsOk			:= .T.
 
//Aplicavel apenas para SIGAFRT e PAF
If !AmIIn(23,72)
	Return lRet
Endif
If  lConfCx .AND. FindFunction("LjRetParSrv") 
	lConfCxRet 		:= LjRetParSrv("MV_LJCONFF")

	lWsOk := IIF(ValType(lConfCxRet) == "L",.T.,.F.) //Para otimizar a abertura do sistema, quando primeira chamada do WebService falha (retorno "U"), não tenta demais chamadas

	If lWsOk 
		lTransRet		:= LjRetParSrv("MV_LJTRANS")
		cTransNatRet	:= LjRetParSrv("MV_LJTRNAT")
	EndIf
	
	If lWsOk .AND. !lConfCxRet == Nil .AND. ValType(lConfCxRet) == "L"
		If lConfCxRet
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Conferencia de caixa ATIVADA na retaguarda  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !lConfCx
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Conferencia de caixa DESATIVADA na estacao  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				//Caso a validacao nao tenha retornado falso, alinhar o valor do parametro com o da retaguarda
				If lRet
					PutMV("MV_LJCONFF",lConfCxRet)
					ApMsgInfo(STR0139)	//"O parâmetro MV_LJCONFF, que ativa a conferência de caixa, foi automaticamente ATIVADO, respeitando a definição da retaguarda."
				Else
					If lMens
						Alert(STR0141)	//"A conferência de caixa esta ATIVADA na retaguarda e o update do pacote (UPDLOJ70) ainda não foi aplicado nesta estação."
					Endif
				Endif
			Endif
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Alinhar a configuracao da transferencia  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lTrans # lTransRet
				PutMV("MV_LJTRANS",lTransRet)
			Endif
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Alinhar a configuracao da natureza da transferencia  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cTransNat # cTransNatRet
				PutMV("MV_LJTRNAT",cTransNatRet)
			Endif
		Else
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Conferencia de caixa DESATIVADA na retaguarda  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lConfCx
				//Alinhar o valor do parametro com o da retaguarda caso a conferencia esteja ativada na estacao (desativar)
				If lRet
					PutMV("MV_LJCONFF",lConfCxRet)
					ApMsgInfo(STR0140)	//"O parâmetro MV_LJCONFF, que ativa a conferência de caixa, foi automaticamente DESATIVADO, respeitando a definição da retaguarda."
				Endif
			Endif
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Se a transferencia estiver ativa, desativar pois somente funciona com a conf. de caixa ativada  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ			
			If lTrans
				PutMV("MV_LJTRANS",.F.)
			Endif
		Endif
	Endif	
Endif

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³X3NaoUsa   ºAutor  ³Vendas Clientes       º Data ³12/11/10        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Funcao que pesquisa por campos que nao estao em uso em uma tabela º±±
±±º          ³e/ou campos virtuais.                                             º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³Exp01[A] : Alvo da pesquisa, nome do campo ou alias de tabela     º±±
±±º          ³Exp02[L] : Considerar campos nao usados                           º±±
±±º          ³Exp03[L] : Considerar campos virtuais                             º±±
±±º          ³Exp04[L] : Alvo da pesquisa eh uma tabela e todos os seus campos  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³aRet[A] : Retorna array com a lista de campos nao usados caso o   º±±
±±º          ³          o alvo seja uma tabela.                                 º±±
±±º          ³aRet[L] : Retorna se o campo nao eh usado, caso o alvo seja um    º±±
±±º          ³          campo.                                                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³Generico                                                          º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function X3NaoUsa(cAlvo,lNaoUsa,lVirtual,lPesqTab)

Local aRet				:= {}
Local aAreaSX3			:= SX3->(GetArea())

Default cAlvo			:= ""
Default lNaoUsa		:= .T.
Default lVirtual		:= .T.
Default lPesqTab		:= .F.

If Empty(cAlvo) .OR. ValType(cAlvo) # "C" .OR. ValType(lNaoUsa) # "L" .OR. ValType(lVirtual) # "L" .OR. (!lNaoUsa .AND. !lVirtual)
	Return aRet
Endif
cAlvo := AllTrim(Upper(cAlvo))
dbSelectArea("SX3")
If lPesqTab
	SX3->(dbSetOrder(1))
Else
	SX3->(dbSetOrder(2))
Endif
SX3->(dbSeek(cAlvo))
Do While !SX3->(Eof()) .AND. AllTrim(Upper(SX3->X3_ARQUIVO)) == cAlvo
	If lNaoUsa
		If !X3Uso(SX3->X3_USADO)
			If aScan(aRet,{|x| AllTrim(x) == AllTrim(SX3->X3_CAMPO)}) == 0
				aAdd(aRet,AllTrim(SX3->X3_CAMPO))
			Endif
		Endif
	Endif
	If lVirtual
		If AllTrim(Upper(SX3->X3_CONTEXT)) == "V"
			If aScan(aRet,{|x| AllTrim(x) == AllTrim(SX3->X3_CAMPO)}) == 0
				aAdd(aRet,AllTrim(SX3->X3_CAMPO))
			Endif
		Endif
	Endif
	SX3->(dbSkip())
EndDo
RestArea(aAreaSX3)

Return IIf(!lPesqTab,IIf(Len(aRet) > 0,.T.,.F.),aRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LjCartTit  ºAutor  ³Vendas Clientes       º Data ³17/11/10        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Funcao para determinar qual a carteira deve ser gravado nos titu- º±±
±±º          ³los gerados pelo SIGALOJA. (E1_SITUACA)                           º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³Exp01[C] : Numero do orcamento que esta gerando o titulo bancario º±±
±±º          ³Exp02[C] : Tipo do titulo a ser gravado (E1_TIPO)                 º±±
±±º          ³Exp03[C] : Portador de destino (E1_PORTADO)                       º±±
±±º          ³Exp04[C] : Determina se eh necessario validar origem do movimento º±±
±±º          ³Exp05[C] : Formatar o retorno com o tamanho do campo E1_SITUACA   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³cCart : Retorna o codigo da carteira a ser gravado                º±±
±±º          ³                                                                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³SIGALOJA                                                          º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function LjCartTit(cNumOrc,cTipo,cPortado,lValidOrig,lFormata)

Local aAreaSL1			:= SL1->(GetArea())
Local aAreaSLW			:= SLW->(GetArea())
Local cCart				:= ""									//Retorno (carteira)
Local lConfCx			:= SuperGetMV("MV_LJCONFF",.F.,.F.) //Conferencia de caixa esta habilitada
Local cTransNat			:= SuperGetMV("MV_LJTRNAT",.F.,"")		//Natureza para a transferencia de portador
Local lTrans			:= SuperGetMV("MV_LJTRANS",.F.,.F.) .AND. !Empty(cTransNat)	//Transferencia
Local nTamCod			:= TamSX3("A6_COD")[1]
Local nTamAg			:= TamSX3("A6_AGENCIA")[1]
Local cCxGeral			:= Substr(SuperGetMV("MV_CXLOJA",.F.,""),1,nTamCod)			//Codigo caixa geral
Local cAgGeral			:= Substr(SuperGetMV("MV_CXLOJA",.F.,""),nTamCod + 2,nTamAg)	//Agencia caixa geral
Local cCartPad			:= "0"									//Carteira padrao
Local cCartCxLoc		:= "I"									//Carteira caixa local
Local cCartCxGer		:= "J"									//Carteira caixa geral
Local nTamCart			:= TamSX3("E1_SITUACA")[1]				//Tamanho do campo de carteira
Local cChave			:= ""									//Chave de pesquisa
Local aLstCmpOb			:= {"L1_PDV","L1_OPERADO","L1_EMISSAO","L1_ESTACAO","L1_NUMMOV"}
Local lOk				:= .T.									//Controle de validacao
Local bValid			:= {|| AllTrim(cTipo) == AllTrim(MV_CRNEG) .OR. AllTrim(cTipo) == AllTrim(MVRECANT) .OR. AllTrim(cTipo) == "CR"}	//Bloco de validacao
Local lBcoOk			:= .T.
Local cPdv				:= ""
Default cNumOrc		:= ""
Default cTipo			:= ""
Default cPortado		:= ""
Default lValidOrig		:= .T.
Default lFormata		:= .F.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Validar caixa geral  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lBcoOk := LjVldBco(cCxGeral,cAgGeral,,.T.,.F.)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Validar parametros  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Empty(cNumOrc) .OR. Empty(cTipo) .OR. Empty(cPortado) .OR. ValType(cTipo) # "C" .OR. ValType(cPortado) # "C" .OR. !lBcoOk
	cCart := cCartPad
	If lFormata
		cCart := PadR(cCart,nTamCart)
	Endif	
	Return cCart
Endif
cNumOrc := PadR(AllTrim(AllToChar(cNumOrc)),TamSX3("L1_NUM")[1])
If !lConfCx
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se a conferencia de caixa nao estiver ativa, usar carteira 0  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cCart := cCartPad
Else
	If !lTrans
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Se a transferencia de caixa nao estiver ativa, usar carteira 0  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cCart := cCartPad
	Else
		If lValidOrig
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Validar se os campos necessarios para pesquisa (SL1) estao disponiveis  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aEval(aLstCmpOb,{|x| IIf(SL1->(FieldPos(x)) == 0, lOk := .F., lOk := lOk)})
			If lOk
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Pesquisar se a origem do movimento ao qual percente a venda (SL1) eh do frontloja  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				dbSelectArea("SL1")
				SL1->(dbSetOrder(1))
				If SL1->(dbSeek(xFilial("SL1") + RTrim(cNumOrc)))
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Utilizar campo L1_EMISSAO, pois do frontloja os campos de data  ³
					//³L1_EMISSAO, L1_DTLIM e L1_EMISNF sao gravados com o mesmo valor.³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					cPdv := PadR(SL1->L1_PDV,TamSX3("LW_PDV")[1])
					If Empty(Alltrim(SL1->L1_PDV))
						SLG->(DbSetOrder(1))
						If SLG->(DbSeek(xFilial("SLG")+SL1->L1_ESTACAO))
							cPdv := SLG->LG_PDV
						EndIf
					EndIf					
					cChave := xFilial("SLW")
					cChave += cPdv
					cChave += PadR(SL1->L1_OPERADO,TamSX3("LW_OPERADO")[1])
					cChave += DtoS(SL1->L1_EMISSAO)
					cChave += PadR(SL1->L1_ESTACAO,TamSX3("LW_ESTACAO")[1])
					cChave += RTrim(SL1->L1_NUMMOV)
					dbSelectArea("SLW")
					SLW->(dbSetOrder(3))	//LW_FILIAL+LW_PDV+LW_OPERADO+DTOS(LW_DTABERT)+LW_ESTACAO+LW_NUMMOV
					If SLW->(dbSeek(cChave))
						If SLW->(FieldPos("LW_ORIGEM")) > 0
							If !AllTrim(SLW->LW_ORIGEM) $ "FRT|FAT|LOJ" 
								//Se a origem do movimento nao for do frontloja, sigaloja ou sigafat usar carteira simples
								lOk := .F.
							Endif
						Else
							//Campo de origem do movimento nao existe, impossivel validar origem, entao usar carteira simples
							lOk := .F.
						Endif
					Else
						//O movimento nao pode ser encontrado, usar carteira simples
						lOk := .F.
					Endif
				Else
					//O orcamento nao pode ser encontrado, usar carteira simples
					lOk := .F.
				Endif
			Endif
		Endif
		If lOk
			If Eval(bValid)
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Se a conferencia e a transferencia estiver ativa, mas for um titulo de credito ao cliente, usar carteira 0  ³
				//³Os titulos de credito sao compensados, por exemplo o CR eh compensado com NCCs do cliente.                  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				cCart := cCartPad
			Else
				If AllTrim(cPortado) == AllTrim(cCxGeral)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Se a conferencia e a transferencia estiver ativa, tendo o portador como caixa geral,  ³
					//³caracteriza a transferencia para carteira do caixa geral                              ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					cCart := cCartCxGer
				Else
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Se a conferencia e a transferencia estiver ativa, tendo o portador caixa local, ³
					//³caracteriza inclusao de titulo com a carteira de caixa local.                   ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					cCart := cCartCxLoc
				Endif
			Endif
		Else
			cCart := cCartPad		
		Endif
	Endif
Endif
If lFormata
	cCart := PadR(cCart,nTamCart)
Endif
RestArea(aAreaSL1)
RestArea(aAreaSLW)

Return cCart     

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LjExConf  ºAutor  ³Vendas Clientes       º Data ³  18/11/10   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Funcao que retorna se existem conferencias em um movimento ou º±±
±±º          ³a lista de registros destas conferencias.                     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³Exp01[A] : Array com informacoes do operador, estacao, serie  º±±
±±º          ³           e PDV                                              º±±
±±º          ³Exp02[D] : Data de abertura do movimento                      º±±
±±º          ³Exp03[D] : Data de fechamento do movimento                    º±±
±±º          ³Exp04[C] : Numero do movimento a ser pesquisado na SLT        º±±
±±º          ³Exp05[L] : Considerar apenas os nao conferidos?               º±±
±±º          ³Exp06[A] : Retornar lista de orcamentos encontrados?          º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³uRet[L]  : Retorna se existe ou nao conferencias no movimento º±±
±±º          ³OU (se o parametro lRetLst estiver ativo)                     º±±
±±º          ³uRet[A]  : Retorna lista de conferencia (numeros do registros)º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³                                                              º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function LjExConf(aID,dDtMov,dDtFMov,cNumMov,lNConf,lRetLst)

Local uRet				:= .T.             		//Retorno
Local aAreaSLT			:= SLT->(GetArea())	//Area SLT
Local cChave			:= ""					//Chave de pesquisa
Local aREG				:= {}					//Lista de registros para retorno
Local lOk				:= .F.					//Validador

Default aID			:= LjInfoCxAt(1,.T.,.F.)	//[1]-CAIXA [2]-ESTACAO [3]-SERIE [4]-PDV
Default dDtFMov		:= LjDtHrECF(.T.)[1]
Default cNumMov		:= AllTrim(LjNumMov())
Default lNConf			:= .F.
Default lRetLst		:= .F.

If ValType(dDtFMov) # "D" .OR. ValType(cNumMov) # "C" .OR. ValType(lRetLst) # "L"
	Return IIf(!lRetLst,!uRet,Array(0))
Endif
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Levantar registros do movimento + operador + estacao + PDV  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cChave := xFilial("SLT") 
cChave += DtoS(dDtFMov) 
cChave += PadR(AllTrim(cNumMov),TamSX3("LT_NUMMOV")[1])
cChave += PadR(AllTrim(aID[1]),TamSX3("LT_OPERADO")[1])
cChave += PadR(AllTrim(aID[2]),TamSX3("LT_ESTACAO")[1])
cChave += RTrim(aID[4])
dbSelectArea("SLT")
SLT->(dbSetOrder(5))	//LT_FILIAL+LT_DTFECHA+LT_NUMMOV+LT_OPERADO+LT_ESTACAO+LT_PDV

If SLT->(dbSeek(cChave))
	Do While !SLT->(Eof()) .AND. RTrim(SLT->LT_FILIAL + DtoS(SLT->LT_DTFECHA) + SLT->(LT_NUMMOV + LT_OPERADO + LT_ESTACAO + LT_PDV)) == cChave
		//Se a data de abertura do movimento nao eh a mesma ou a conferencia jah esta conferida, saltar
		If !( SLT->LT_DTMOV >= dDtMov .AND. SLT->LT_DTMOV <= dDtFMov )
			SLT->(dbSkip())
			Loop
		Endif
		//Se for para considerar apenas os NAO conferidos e o registro estiver conferido, saltar
		If lNConf .AND. SLT->LT_CONFERE == "1"
			SLT->(dbSkip())
			Loop
		Endif
		//Registro valido encontrado
		If !lRetLst
			lOk := .T.
			Exit
		Else
			aAdd(aREG,SLT->(Recno()))
			SLT->(dbSkip())
		Endif		
	EndDo
Endif
If !lRetLst
	If !lOk
		uRet := !uRet
	Endif
Else
	uRet := aREG
Endif
RestArea(aAreaSLT)

Return uRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LjVerTrans ºAutor  ³Vendas Clientes       º Data ³18/11/10        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Funcao que verifica movimentos que possuem titulos pendentes de   º±±
±±º          ³transferencia de carteira e portador.                             º±±
±±º          ³Importante! Apenas p/ movimentos originados no SIGAFRT e SIGALOJA.º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³                                                                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³Nulo                                                              º±±
±±º          ³                                                                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³SIGALOJA                                                          º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function LjVerTrans()

Local aArea           	:= GetArea()
Local lConfCx			:= SuperGetMV("MV_LJCONFF",.F.,.F.) //Conferencia de caixa esta habilitada
Local cTransNat			:= SuperGetMV("MV_LJTRNAT",.F.,"")
Local lTrans			:= SuperGetMV("MV_LJTRANS",.F.,.F.) .AND. !Empty(cTransNat)	//Transferencia
Local nTamCod			:= TamSX3("A6_COD")[1]					//Tamanho do codigo de banco
Local nTamAg			:= TamSX3("A6_AGENCIA")[1]				//Tamanho do codigo de agencia
Local nTamConta			:= TamSX3("A6_NUMCON")[1]				//Tamanho do codigo da conta
Local cCxGeral			:= Substr(SuperGetMV("MV_CXLOJA",.F.,""),1,nTamCod)						//Codigo caixa geral
Local cAgGeral			:= Substr(SuperGetMV("MV_CXLOJA",.F.,""),nTamCod + 2,nTamAg)				//Agencia caixa geral
Local cCCGeral			:= Substr(SuperGetMV("MV_CXLOJA",.F.,""),nTamCod + nTamAg + 3,nTamConta)	//Conta caixa geral
Local lHabTroco     	:= SL1->(FieldPos("L1_TROCO1")) > 0 .AND. SuperGetMV("MV_LJTROCO",,.F.)	//Habilita troco
Local lBcoOk			:= .T.									//Validador do caixa geral
Local lQry				:= .F.									//Utilizar query
Local cQry				:= ""									//Instrucao SQL
Local aID				:= Array(4)							//Identificao completa do caixa
Local cAlias			:= GetNextAlias()						//Tabela de movimentos de abertura e fechamento de caixa
Local cFiltro			:= ""									//Filtro de pesquisa
Local cTipoF			:= ""									//Tipo de fechamento
Local aLstOrc			:= {}									//Lista de orcamentos de um movimento
Local aLstConf			:= {}									//Lista de conferencias de um movimento
Local ni				:= 0									//Contador
Local aTotal			:= Array(2)							//Array dos totalizadores (1. Orcamentos, 2. Conferencias)
Local aLstSitua			:= {}									//Lista para armazenar a situacao dos orcamentos de um dado movimento
Local bValid			:= {}									//Bloco de validacao
Local cLock				:= ""									//Controle de semaforo
Local cTabSLW			:= ""									//Nome da tabela SLW no SGBD
Local cFilSLW			:= xFilial("SLW")						//Filial da tabela SLW
Local cRotina			:= Upper("[LjVerTrans] ")				//Nome da rotina
Local cCond				:= ""									//String para condicao da instrucao SQL
Local lOk				:= .T.									//Campo de controle de fluxo
Local cMens				:= ""									//Variavel para mensagem de erro de retorno da funcao LjExecTrans
Local lUsaMVD			:= SuperGetMV("MV_LJTRMVD",.F.,.F.)	//Utiliza detalhamento de movimento bancario da transferencia de caixas?
Local aLstMov			:= {}

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Validar caixa geral  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lBcoOk := LjVldBco(cCxGeral,cAgGeral,cCCGeral,.T.,.T.)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Validar parametros  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lConfCx .OR. !lTrans .OR. Empty(cCxGeral) .OR. !lBcoOk
	Return Nil
Endif
#IFDEF TOP
	lQry := .T.
	cTabSLW := RetSQLName("SLW")
#ENDIF
If lQry
	cQry := "SELECT DISTINCT LW_FILIAL, LW_NUMMOV, LW_OPERADO, LW_ESTACAO, LW_SERIE, LW_PDV, LW_DTABERT, LW_DTFECHA, LW_NUMINI, LW_NUMFIM, LW_TIPFECH "
	cQry += "FROM " + cTabSLW + " "
	cQry += "WHERE D_E_L_E_T_ <> '*' AND LW_FILIAL = '" + cFilSLW + "' "
	cQry += "AND LW_SITUA = 'RX' "
	cQry += "AND LW_ORIGEM IN ('FAT','LOJ','FRT') " 
	cQry += "AND LW_TIPFECH IN ('2','4','5','6') "	
	cQry += "ORDER BY LW_TIPFECH ASC, LW_DTABERT ASC, LW_NUMMOV ASC"
	dbUseArea(.T.,__cRDD,TcGenQry(,,ChangeQuery(cQry)),cAlias,.T.,.F.)
	TcSetField(cAlias,"LW_DTABERT","D",8,0)
	TcSetField(cAlias,"LW_DTFECHA","D",8,0)
Else
	cFiltro := "LW_FILIAL = '" + cFilSLW + "' "
	cFiltro += ".AND. LW_SITUA = 'RX' "
	cFiltro += ".AND. LW_ORIGEM $ 'FRT|FAT|LOJ' "
	cFiltro += ".AND. LW_TIPFECH $ '2|4|5|6' "
	//Clonar tabela com o novo alias e aplicar o filtro
	ChkFile("SLW",.F.,cAlias)
	dbSelectArea(cAlias)
	(cAlias)->(dbSetOrder(2))
	(cAlias)->(dbSetFilter({|| &cFiltro},cFiltro))
Endif
(cAlias)->(dbGoTop())
If (cAlias)->(Eof())
	FechaArqT(cAlias)
	RestArea(aArea)
	Return Nil
Endif
Do While !(cAlias)->(Eof())
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Controle de semaforo por movimento                       ³
	//³Necessario pois pode haver um processamento concomitante ³
	//³da rotina de transferencia manual.                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cLock := "SLW" + (cAlias)->(LW_FILIAL + LW_PDV + LW_OPERADO + LW_ESTACAO) + DtoS((cAlias)->LW_DTABERT) + (cAlias)->LW_NUMMOV		//Alias + Chave(05)
	If !MayIUseCode(cLock)
		//Saltar para processamento posterior, caso necessario
		(cAlias)->(dbSkip())
		Loop
	Endif
	ConOut(cRotina + "CHECK <" + cLock + ">")
	aTotal[1] 	:= 0
	aTotal[2] 	:= 0
	aLstSitua	:= {}
	lOk			:= .T.
	cTipoF 		:= AllTrim((cAlias)->LW_TIPFECH)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Identificacao completa do caixa  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aID[1] := (cAlias)->LW_OPERADO
	aID[2] := (cAlias)->LW_ESTACAO
	aID[3] := (cAlias)->LW_SERIE
	aID[4] := (cAlias)->LW_PDV
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Condicao para as querys que atualizarao a SLW  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lQry
		cCond := "WHERE D_E_L_E_T_ <> '*' "
		cCond += "AND LW_FILIAL = '" + cFilSLW + "' "
		If nModulo != 5
			cCond += "AND LW_PDV = '" + AllTrim(aID[4]) + "' "
		EndIf
		cCond += "AND LW_OPERADO = '" + AllTrim(aID[1]) + "' "
		cCond += "AND LW_ESTACAO = '" + AllTrim(aID[2]) + "' "
		cCond += "AND LW_DTABERT = '" + DtoS((cAlias)->LW_DTABERT) + "' "
		cCond += "AND LW_NUMMOV = '" + AllTrim((cAlias)->LW_NUMMOV) + "'"	
	Endif	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Trazer lista de orcamentos do movimento correspondente ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aLstOrc := LjExOrc(aID,(cAlias)->LW_DTABERT,(cAlias)->LW_NUMMOV,.F. /*nao cons. cancelados*/,.T./*cons. incompletos*/,.T./*retornar lista*/)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Trazer lista de conferencias do movimento correspondente ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aLstConf := LjExConf(aID,(cAlias)->LW_DTABERT,(cAlias)->LW_DTFECHA,(cAlias)->LW_NUMMOV,,.T. /*retornar lista*/)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Trazer lista de movimentos do movimento correspondente ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ	
	aLstMov := LjExMov(aID[1], (cAlias)->LW_DTABERT, (cAlias)->LW_NUMMOV, .T. /*retornar lista*/, aID[2])
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Totalizar apenas para :            ³
	//³1. Conferidos                      ³
	//³2. Pend. transf. subida incompleta ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ	
	If cTipoF $ "2|4"
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Totalizar orcamentos   ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ	
		If Len(aLstOrc) > 0
			dbSelectArea("SL1")
			SL1->(dbSetOrder(1))
			For ni := 1 to Len(aLstOrc)
				If SL1->(dbSeek(aLstOrc[ni][1] + RTrim(aLstOrc[ni][2])))
					//Valores
					If !lHabTroco
						aTotal[1] += SL1->L1_VLRLIQ 
					Else
						aTotal[1] += (SL1->L1_VLRLIQ - SL1->L1_TROCO1)
					Endif
					//Situacao
					aAdd(aLstSitua,AllTrim(SL1->L1_SITUA))
				Endif
			Next ni
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Totalizando Movimentos ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Len(aLstMov) > 0
			dbSelectArea("SE5")
			For ni := 1 to Len(aLstMov)
				SE5->(dbGoTo(aLstMov[ni]))
				aTotal[1] += SE5->E5_VALOR
			Next
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Totalizar conferencias ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Len(aLstConf) > 0
			dbSelectArea("SLT")
			SLT->(dbSetOrder(1))
			For ni := 1 to Len(aLstConf)
				SLT->(dbGoto(aLstConf[ni]))
				If SLT->(Recno()) == aLstConf[ni]
					aTotal[2] += SLT->LT_VLRAPU
				Endif
			Next ni
		Else
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Movimento sem conferencia, com o LW_TIPFECH = 2, indica    ³
			//³que o movimento foi fechado sem que orcamentos tenham sido ³
			//³realizados.                                                ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If cTipoF == "2"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Atualizar a SLW como conferida e transferida (status 3) ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				ConOut(cRotina + "CHANGE <" + cLock + "> STATUS 3 - NO BUY")
				If lQry
					cQry := "UPDATE " + cTabSLW + " "
					cQry += "SET LW_TIPFECH = '3' " + cCond
					If TcSQLExec(cQry) < 0
						ConOut(cRotina + " " + DtoC(Date()) + " " + Time() + " Line " + ProcLine(0) + CRLF + TcSQLError())
						lOk := !lOk
						//Desfazer transacao
						If InTransaction()
							DisarmTransaction()
						Endif
					Endif
				Else
					RecLock(cAlias,.F.)	
					(cAlias)->LW_TIPFECH := "3"	
					MsUnlock()
				Endif
				//Alterar o tipo de fechamento para que um novo processamento nao seja realizado
				cTipoF := "3"
				//Marcar lOk como falso para que nada mais seja gravado
				lOk := .F.
			Endif
		Endif
	Endif
	Conout("[LJVERTRANS] - Valores dos Orcamentos Retaguarda - aTotal[1]: " + cValToChar(aTotal[1]))
	Conout("[LJVERTRANS] - Valor da Tabela SLT na Retaguarda - aTotal[2]: " + cValToChar(aTotal[2]))
	Conout("[LJVERTRANS] - cTipoF: " + cTipoF)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Processar de acordo com o tipo de fechamento do movimento ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	bValid := {|| AllTrim(aLstSitua[ni]) == "OK" .OR. AllTrim(aLstSitua[ni]) == "FR"}
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³LW_TIPFECH - Status                ³
	//³1 - Pendente de conferencia        ³
	//³2 - Conferido                      ³
	//³3 - Transferido                    ³
	//³4 - Pend.transf.subida incompleta  ³
	//³5 - Pend.transf.explosao incompleta³
	//³6 - Pend.transf.problema na transf.³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Do Case
		Case cTipoF == "2"		//CONFERIDO
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Validar o saldo  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If aTotal[1] # aTotal[2]
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Subida incompleta - os totais nao batem ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				lOk := .F.
				ConOut(cRotina + "CHANGE <" + cLock + "> STATUS 4")
				If lQry
					cQry := "UPDATE " + cTabSLW + " "
					cQry += "SET LW_TIPFECH = '4' " + cCond
					If TcSQLExec(cQry) < 0
						ConOut(cRotina + " " + DtoC(Date()) + " " + Time() + " Line " + ProcLine(0) + CRLF + TcSQLError())
						//Saltar registro para um nova tentativa
						(cAlias)->(dbSkip())
						Loop
					Endif
				Else
					RecLock(cAlias,.F.)	
					(cAlias)->LW_TIPFECH := "4"	
					MsUnlock()
				Endif
			Else
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Validar a situacao dos orcamentos  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				For ni := 1 to Len(aLstSitua)
					If !Eval(bValid)
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Processo de explosao de vendas incompleto ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						lOk := .F.
						ConOut(cRotina + "CHANGE <" + cLock + "> STATUS 5")
						If lQry
							cQry := "UPDATE " + cTabSLW + " "
							cQry += "SET LW_TIPFECH = '5' " + cCond
							If TcSQLExec(cQry) < 0
								ConOut(cRotina + " " + DtoC(Date()) + " " + Time() + " Line " + ProcLine(0) + CRLF + TcSQLError())
								//Saltar registro para um nova tentativa
								(cAlias)->(dbSkip())
								Loop
							Endif
						Else
							RecLock(cAlias,.F.)	
							(cAlias)->LW_TIPFECH := "5"	
							MsUnlock()
						Endif						
					Endif
				Next ni
			Endif
		Case cTipoF == "4"		//PENDENTE DE SUBIDA
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Validar o saldo  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If aTotal[1] # aTotal[2]
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Subida incompleta - os totais nao batem ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				lOk := .F.
			Else
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Validar a situacao dos orcamentos  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				For ni := 1 to Len(aLstSitua)
					If !Eval(bValid)
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³Processo de explosao de vendas incompleto ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						lOk := .F.
						ConOut(cRotina + "CHANGE <" + cLock + "> STATUS 5")
						If lQry
							cQry := "UPDATE " + cTabSLW + " "
							cQry += "SET LW_TIPFECH = '5' " + cCond
							If TcSQLExec(cQry) < 0
								ConOut(cRotina + " " + DtoC(Date()) + " " + Time() + " Line " + ProcLine(0) + CRLF + TcSQLError())
								//Saltar registro para um nova tentativa
								(cAlias)->(dbSkip())
								Loop
							Endif
						Else
							RecLock(cAlias,.F.)	
							(cAlias)->LW_TIPFECH := "5"	
							MsUnlock()
						Endif
					Endif
				Next ni
			Endif		
		Case cTipoF == "5"		//PEND.TRANSF.EXPLOSAO INCOMPLETA
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Validar a situacao dos orcamentos  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			For ni := 1 to Len(aLstSitua)
				If !Eval(bValid)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Processo de explosao de vendas incompleto ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					lOk := .F.
					ConOut(cRotina + "CHANGE <" + cLock + "> STATUS 5")
				Endif
			Next ni	
		Case cTipoF == "6"		//PEND.TRANSF.PROBLEMA NA TRANSF.
			ConOut(cRotina + "CHANGE <" + cLock + "> STATUS 6 - RETRYING")
	EndCase
	If lOk
		Begin Transaction
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Atualizar SL1,SE1,SE5 e FRA³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		//Parametros : Carteira,Portador,Agencia,Conta,ID Caixa,Data Mov.,Mov.,Pesq.Orc?,Lista orc.,Mens Erro,Int.proc.orc.s/titulo?
		If LjExecTrans("J",cCxGeral,cAgGeral,cCCGeral,aID,(cAlias)->LW_DTABERT,(cAlias)->LW_NUMMOV,.F.,aLstOrc,@cMens,.F.,lUsaMVD, aLstMov)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Atualizar a SLW como conferida e transferida (status 3) ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			ConOut(cRotina + "CHANGE <" + cLock + "> STATUS 3")
			If lQry
				cQry := "UPDATE " + cTabSLW + " "
				cQry += "SET LW_TIPFECH = '3' " + cCond
				If TcSQLExec(cQry) < 0
					ConOut(cRotina + " " + DtoC(Date()) + " " + Time() + " Line " + ProcLine(0) + CRLF + TcSQLError())
					lOk := !lOk
					//Desfazer transacao
					If InTransaction()
						DisarmTransaction()
					Endif
				Endif
			Else
				RecLock(cAlias,.F.)	
				(cAlias)->LW_TIPFECH := "3"	
				MsUnlock()
			Endif
		Else
			lOk := !lOk
			If InTransaction()
				DisarmTransaction()
			Endif
		Endif
		End Transaction
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Houve um erro no processamento de transferencia, alterar ³
		//³a situacao do movimento.                                 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !lOk
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Pend.transf.problema na transf.         ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			ConOut(cRotina + "CHANGE <" + cLock + "> STATUS 6")
			If lQry
				cQry := "UPDATE " + cTabSLW + " "
				cQry += "SET LW_TIPFECH = '6' " + cCond
				If TcSQLExec(cQry) < 0
					ConOut(cRotina + " " + DtoC(Date()) + " " + Time() + " Line " + ProcLine(0) + CRLF + TcSQLError())
					Loop
				Endif
			Else
				RecLock(cAlias,.F.)	
				(cAlias)->LW_TIPFECH := "6"	
				MsUnlock()
				ConOut(cRotina + " " + cMens) 
			Endif
		Endif
	Endif
	Leave1Code(cLock)
	(cAlias)->(dbSkip())
EndDo
FechaArqT(cAlias)
RestArea(aArea)

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LjExecTransºAutor  ³Vendas Clientes       º Data ³23/11/10        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Funcao que transfere orcamentos para a carteira do caixa geral ou º±±
±±º          ³para a carteira simples do financeiro. Por movimento de caixa.    º±±
±±º          ³Importante! O controle de transacao deve ser feito pela rotina de º±±
±±º          ³chamada.                                                          º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³Exp01[C] : Carteira de destino (E1_SITUACA)                       º±±
±±º          ³Exp02[C] : Portador de destino (E1_PORTADO)                       º±±
±±º          ³Exp03[C] : Agencia de destino (E1_AGEDEP)                         º±±
±±º          ³Exp04[C] : Conta de destino (E1_CONTA)                            º±±
±±º          ³Exp05[A] : Array com a identificacao completa do operador, sendo: º±±
±±º          ³           1. Operador                                            º±±
±±º          ³           2. Estacao                                             º±±
±±º          ³           3. Serie                                               º±±
±±º          ³           4. PDV                                                 º±±
±±º          ³Exp06[D] : Data do movimento                                      º±±
±±º          ³Exp07[C] : Numero do movimento a ser transferido                  º±±
±±º          ³Exp08[L] : Determina se a rotina deve processar com a lista de    º±±
±±º          ³           orcamentos enviada                                     º±±
±±º          ³Exp09[A] : Lista de orcamentos                                    º±±
±±º          ³Exp10[C] : Variavel para retorno de erro                          º±±
±±º          ³Exp11[L] : Interromper processamento p/ orcamentos s/ titulos     º±±
±±º          ³Exp12[L] : Gravar a transf. de cx no SE5 det. por forma de pagto? º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³lRet[L] : Retorna se o processamento foi efetuado com sucesso     º±±
±±º          ³                                                                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³SIGALOJA                                                          º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function LjExecTrans(cCart,cPortado,cAgencia,cConta,aID,dMov,cMov,lPesqOrc,aLstOrc,cMens,lIntProcOST,lGrvTrFP,aLstMov)

Local lRet             := .T.						//Retorno
Local aArea				:= GetArea()				//Armazena area de trabalho
Local cChave			:= ""						//Chave de pesquisa
Local cLoteF			:= ""						//Lote financeiro que amarrara a TR da SE5 com a FRA
Local ni				:= 0						//Contador
Local nx				:= 0						//Contador
Local nz				:= 0						//Contador
Local aTitF				:= {}						//Array que recebe a chave do(s) titulo(s) gerados para o orcamento
Local lGrvLj			:= AmIIn(12,23,72) .OR. IsInCallStack("LjGrvBatch")	//Verifica se a gravacao da FRA deve contemplar campos do loja
Local aChvSE2			:= {"E1_FILIAL","E1_CLIENTE","E1_LOJA","E1_PREFIXO","E1_NUM","E1_PARCELA","E1_TIPO"}	//Campos utilizados da chave de pesquisa da SE2
Local aChvSE2Tam		:= Array(Len(aChvSE2))	//Tamanho dos campos da chave da SE2
Local lTransf			:= .T.						//Controle de transferencia titulo a titulo associado ao movimento
Local lUsaPortado		:= .F.						//Define se na transferencia, o portador tambem deve ser trocado
Local aBcoDes			:= Array(3)				//Array com os dados do banco de destino
Local aBcoOrig			:= Array(3)				//Array com os dados do banco de origem
Local nValTotTrans		:= 0						//Valor total da transferencia
Local cTransf			:= ""						//Codigo sequencial de transferencias
Local dFMov				:= Nil						//Data de fechamento do movimento
Local lAltSE5			:= .F.						//Determina se o SE5 precisa ter sua referencia bancaria alterada, alem do SE1
Local lContTrans		:= SL1->(FieldPos("L1_TRCXGER")) > 0 .AND. SL1->(FieldPos("L1_TREFETI")) > 0	//Campos obrigatorios para transferencia
Local cTransNat			:= AllTrim(SuperGetMV("MV_LJTRNAT",.F.,""))	//Natureza financeira para transferencia
Local lUsaTrans			:= SuperGetMV("MV_LJTRANS",.F.,.F.) .AND. !Empty(cTransNat)	//Transferencia
Local cMoedaC			:= AllTrim(SuperGetMV("MV_SIMB1",.F.,""))		//Simbolo da moeda corrente
Local aLstFP			:= {}						//Lista das formas de pagamentos encontradas nos titulos pertinentes ao movimento, p/ transf. cx. no SE5
Local cChvSLW			:= ""						//Variavel para armazenar a chave utilizada na SLW para gravacao no historico da transf. no SE5
Local cTipoDoc			:= "TR"						//Tipo do movimento bancario
Local dDataAt			:= Date()					//Data da transacao
Local nTamSeq			:= TamSX3("E5_SEQ")[1]		//Tamanho do campo de sequencia de movimentacao bancaria
Local cSeqBx   			:= Replicate("0",nTamSeq)	//Inicializador do controle de sequencia
Local lPortNovo			:= .F.						//Portador do titulo em questao eh novo (diferente)?
Local lHouveTP			:= .F.						//Indica que houve transferencia de portador na operacao

Default cCart			:= ""
Default cPortado		:= ""
Default cAgencia		:= ""
Default cConta			:= ""
Default aID			:= {}
Default dMov			:= Nil
Default cMov			:= ""
Default lPesqOrc		:= .T.
Default aLstOrc		:= {}
Default cMens			:= "[LjExecTrans] "
Default lIntProcOST	:= .F.
Default lGrvTrFP		:= .F.
Default aLstMov			:= {}

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Validacao de parametros  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Empty(cCart) .OR. Len(aID) == 0 .OR. Empty(dMov) .OR. Empty(cMov) .OR. (!lPesqOrc .AND. Len(aLstOrc) == 0 .And. Len(aLstMov) == 0) .OR. !lContTrans
	cMens += STR0180	//"Carteira / Dt. Mov. / Cod. Mov.inválido(s) , ou sem Orcamento!"
	Return !lRet
Endif
//Caso a rotina seja chamada fora de uma transacao ou a transferencia nao seja utilizada, sair
If !InTransaction() .OR. !lUsaTrans
	Return !lRet
Endif
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Validar carteira de destino ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cCart := AllTrim(Upper(cCart))
dbSelectArea("SX5")
SX5->(dbSetOrder(1))
If !SX5->(dbSeek(xFilial("SX5") + cCart))
	cMens += STR0142	//"Carteira de destino invalida!"
	RestArea(aArea)
	Return !lRet
Endif
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Validar codigo do portador de destino (se houver) ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty(cPortado) .AND. !Empty(cAgencia) .AND. !Empty(cConta)
	If !LjVldBco(cPortado,cAgencia,cConta)
		cMens += STR0143	//"Portador / Agencia / Conta inválido(s)!"
		RestArea(aArea)
		Return !lRet	
	Endif
	lUsaPortado := .T.
	//Armazenar os dados que serao gravados nos dados bancarios de destino
	aBcoDes[1] := cPortado
	aBcoDes[2] := cAgencia
	aBcoDes[3] := cConta
Endif
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Determinar referencia completa do portador de origem  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SA6")
SA6->(dbSetOrder(1))
If SA6->(dbSeek(xFilial("SA6") + RTrim(aID[1])))
	aBcoOrig[1] := SA6->A6_COD
	aBcoOrig[2] := SA6->A6_AGENCIA
	aBcoOrig[3] := SA6->A6_NUMCON
Else
	cMens += STR0151	//"O caixa de origem não pode ser encontrado!"
	RestArea(aArea)
	Return !lRet	
Endif
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Validar natureza financeira  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Empty(GetAdvfVal("SED","ED_CODIGO",xFilial("SED") + cTransNat,1))
	cMens += STR0150	//"Natureza financeira definida no parâmetro MV_LJTRNAT é inválida!"
	RestArea(aArea)
	Return !lRet
Endif
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Posicionar registro de movimento  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cChave := xFilial("SLW") 
cChave += PadR(AllTrim(aID[4]),TamSX3("LW_PDV")[1])
cChave += PadR(AllTrim(aID[1]),TamSX3("LW_OPERADO")[1])
cChave += PadR(AllTrim(aID[2]),TamSX3("LW_ESTACAO")[1])
cChave += DtoS(dMov)
cChave += RTrim(cMov)
dbSelectArea("SLW")
SLW->(dbSetOrder(5))	//LW_FILIAL+LW_PDV+LW_OPERADO+LW_ESTACAO+DTOS(LW_DTABERT)+LW_NUMMOV
If !SLW->(dbSeek(cChave))
	//Caso o movimento nao tenha sido encontrado, sair retornando erro pois o movimento deve ser encontrado
	cMens += STR0144 + "05 - " + cChave + STR0145	//"O movimento ("###") não pode ser encontrado!"
	RestArea(aArea)
	Return !lRet	
Endif
cChvSLW	:= cChave
dFMov 	:= SLW->LW_DTFECHA
If lPesqOrc
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Trazer lista de orcamentos do movimento correspondente ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ	
	aLstOrc := LjExOrc(aID,SLW->LW_DTABERT,SLW->LW_NUMMOV,.F. /*nao cons. cancelados*/,.T./*cons. incompletos*/,.T./*retornar lista*/)
	If Len(aLstOrc) == 0
		//Caso nenhum orcamento tenha sido encontrado, sair retornando ok
		cMens += STR0146 + " ([05] - " + cChave + ")"	//"A lista de orcamentos do movimento retornou vazia!"
		RestArea(aArea)
		Return lRet
	Endif	
Endif
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Levantar o sequencial do lote financeiro  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Empty(cLoteF := LjRetLote("R"))
	//Caso o lote nao tenha sido definido, sair retornando erro
	cMens += STR0147	//"Erro na definicao do lote financeiro!"
	RestArea(aArea)
	Return !lRet
Endif
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definir tamanho dos campos da chave da SE2  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For ni := 1 to Len(aChvSE2)
	aChvSE2Tam[ni] := TamSX3(aChvSE2[ni])[1]
Next ni
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Processar toda a lista de orcamentos  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For ni := 1 to Len(aLstOrc)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Validar existencia do orcamento e verificar se o mesmo jah ³
	//³nao foi transferido para o caixa geral.                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SL1")
	SL1->(dbSetOrder(1))
	If !SL1->(MsSeek(aLstOrc[ni][1] + aLstOrc[ni][2]))
		cMens += STR0149	//"Orçamento do movimento não encontrado!"
		RestArea(aArea)
		Return !lRet	
	Endif
	//Se havera transferencia de portador e a carteira de destino for J (cx. geral), validar se o orcamento jah nao foi transferido, se for saltar
	If lUsaPortado .AND. cCart == "J" .AND. SL1->L1_TREFETI
		Loop
	Endif
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Levantar os titulos associados ao orcamento                                                  ³
	//³Retorno : Chave 02 E1_FILIAL+E1_CLIENTE+E1_LOJA+E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO e RECNO ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aTitF := LjRetTitFin(aLstOrc[ni][1],aLstOrc[ni][2],aChvSE2,.T.,.F.,"LOJA010|FATA701|LOJA701")
	If Len(aTitF) > 0
		For nx := 1 to Len(aTitF)
			lTransf 	:= .T.
			lAltSE5 	:= .F.
			lPortNovo	:= .T.
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Posicionar registro  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cChave := ""
			For nz := 1 to Len(aChvSE2)
				cChave += PadR(AllTrim(aTitF[nx][nz]),aChvSE2Tam[nz])
			Next nz
			dbSelectArea("SE1")
			SE1->(dbSetOrder(2))			
			If !SE1->(dbSeek(cChave))
				//Caso o titulo nao tenha sido encontrado, sair retornando erro
				cMens += STR0148 + " ([02] - " + cChave + ")" 	//"Orcamento com titulo nao encontrado!"
				RestArea(aArea)
				Return !lRet
			Endif
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Estudar viabilidade de transferencia  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !IsMoney(SE1->E1_TIPO)
				//Se o titulo jah tiver sido baixado (total ou parcial) ou em bordero, nao transferir
				If SE1->E1_VALLIQ > 0 .OR. SE1->E1_SALDO = 0 .OR. (SE1->E1_SALDO # SE1->E1_VALOR) .OR. SE1->E1_STATUS == "B" .OR. !Empty(SE1->E1_NUMBOR)
					lTransf := .F.
				Endif
			Else
				If lUsaPortado
					//Alterar a SE5 apenas se as referencias bancarias forem alteradas
					lAltSE5 := .T.
				Endif
			Endif
			//Se for carteira, carteira caixa loja ou carteira caixa geral
			If !SE1->E1_SITUACA $ "0|I|J"
				lTransf := .F.
			Endif
			//Caso o portador nao tenha sido alterado, assumir o existente no titulo
			If !lUsaPortado .AND. lTransf
				aBcoDes[1] := SE1->E1_PORTADO
				aBcoDes[2] := SE1->E1_AGEDEP
				aBcoDes[3] := SE1->E1_CONTA
			Endif
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Armazenar a forma de pagamento, seu valor, banco de origem e destino na array.³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lGrvTrFP
				If (nPos := aScan(aLstFP,{|x| x[1] == AllTrim(Upper(SE1->E1_TIPO))})) == 0
					aAdd(aLstFP,{AllTrim(Upper(SE1->E1_TIPO)),SE1->E1_VALOR,{aBcoOrig[1],aBcoOrig[2],aBcoOrig[3]},{aBcoDes[1],aBcoDes[2],aBcoDes[3]}})
					nPos := Len(aLstFP)
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Para outros paises, verificar se a moeda nao eh a corrente, caso nao seja, ³
					//³verificar se os bancos de origem e de destino possuem cadastro no SA6.     ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					If cPaisLoc # "BRA"
						//Se a forma de pagamento for moeda e esta nao for a moeda corrente
						If IsMoney(SE1->E1_TIPO) .AND. AllTrim(SE1->E1_TIPO) # cMoedaC
							//Origem
							If !LjVldBco(aBcoOrig[1],SE1->E1_TIPO,aBcoOrig[3])
								//Caso o caixa nao exista na moeda utilizada, criar
								LjxDVerCx(RetMoeda(SE1->E1_TIPO,,1),aBcoOrig[1],SE1->E1_TIPO,aBcoOrig[3])
								//Gravar na forma de pagamento qual o banco que deve ser utilizado
								aLstFP[nPos][3] := {aBcoOrig[1],SE1->E1_TIPO,aBcoOrig[3]}
							Endif
							//Destino
							If !LjVldBco(aBcoDes[1],SE1->E1_TIPO,aBcoDes[3])
								//Caso o caixa nao exista na moeda utilizada, criar
								LjxDVerCx(RetMoeda(SE1->E1_TIPO,,1),aBcoDes[1],SE1->E1_TIPO,aBcoDes[3])
								//Gravar na forma de pagamento qual o banco que deve ser utilizado
								aLstFP[nPos][4] := {aBcoDes[1],SE1->E1_TIPO,aBcoDes[3]}
							Endif							
						Endif
					Endif					
				Else
					aLstFP[nPos][2] += SE1->E1_VALOR
				Endif
			Endif
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Verificar se a carteira e o portador de destino nao sao os mesmos, caso seja, saltar  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lUsaPortado
				//Se houver transf. de portador e carteira
				If lGrvTrFP
					//Se utiliza transf. SE5 por FP
					If AllTrim(SE1->E1_PORTADO) == AllTrim(aLstFP[nPos][4][1]) .AND. ;
						AllTrim(SE1->E1_AGEDEP) == AllTrim(aLstFP[nPos][4][2]) .AND. ;
						AllTrim(SE1->E1_CONTA) == AllTrim(aLstFP[nPos][4][3]) 
						
						//Mesmo portador
						lPortNovo := .F.
						//Mesmo portador e mesma carteira? Saltar
						If !lPortNovo .AND. AllTrim(SE1->E1_SITUACA) == cCart
							//Saltar para a proxima sequencia nx (titulo)
							Loop
						Endif
					Endif
				Else
					//Se utiliza transf. SE5 apenas em moeda corrente
					If AllTrim(SE1->E1_PORTADO) == AllTrim(aBcoDes[1]) .AND. ;
						AllTrim(SE1->E1_AGEDEP) == AllTrim(aBcoDes[2]) .AND. ;
						AllTrim(SE1->E1_CONTA) == AllTrim(aBcoDes[3]) 
						
						//Mesmo portador
						lPortNovo := .F.
						//Mesmo portador e mesma carteira? Saltar
						If !lPortNovo .AND. AllTrim(SE1->E1_SITUACA) == cCart
							//Saltar para a proxima sequencia nx (titulo)
							Loop
						Endif
					Endif
				Endif			
			Else
				lPortNovo := .F.
				//Se houver apenas transf. de carteira
				If AllTrim(SE1->E1_SITUACA) == cCart
					//Saltar para a proxima sequencia nx (titulo)
					Loop
				Endif
			Endif
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Determinar que houve uma transferencia de portador e que ³
			//³a transferencia de caixa no SE5 precisa ser registrado.  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lUsaPortado .AND. lPortNovo
				lHouveTP := .T.
			Endif
			nValTotTrans += SE1->E1_VALOR
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³FRA - Registrar a transferencia de titulo e portador  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lTransf
				cTransf := GetSXENum("FRA","FRA_NUM")
				ConfirmSX8()
				RecLock("FRA",.T.)
				FRA->FRA_FILIAL		:= xFilial("FRA")
				FRA->FRA_NUM		:= cTransf
				FRA->FRA_DATA		:= dDataAt
				FRA->FRA_LOTE		:= IIf(lHouveTP,cLoteF,"")	//Gravar lote apenas caso houver transf. de portador, que gera SE5, motivo de amarracao pelo lote
				FRA->FRA_ORIGEM		:= SE1->E1_ORIGEM
				FRA->FRA_PREFIX		:= SE1->E1_PREFIXO
				FRA->FRA_NUMTIT		:= SE1->E1_NUM
				FRA->FRA_PARC		:= SE1->E1_PARCELA
				FRA->FRA_TIPO		:= SE1->E1_TIPO
				FRA->FRA_CLIENT		:= SE1->E1_CLIENTE
				FRA->FRA_LOJA		:= SE1->E1_LOJA
				FRA->FRA_BCORIG		:= SE1->E1_PORTADO
				FRA->FRA_AGORIG		:= SE1->E1_AGEDEP
				FRA->FRA_CTORIG		:= SE1->E1_CONTA
				FRA->FRA_CRORIG		:= SE1->E1_SITUACA
				If lGrvTrFP
					FRA->FRA_BCDEST		:= aLstFP[nPos][4][1]
					FRA->FRA_AGDEST		:= aLstFP[nPos][4][2]
					FRA->FRA_CTDEST		:= aLstFP[nPos][4][3]
				Else
					FRA->FRA_BCDEST		:= aBcoDes[1]
					FRA->FRA_AGDEST		:= aBcoDes[2]
					FRA->FRA_CTDEST		:= aBcoDes[3]
				Endif
				FRA->FRA_CRDEST		:= cCart
				//Campos do LOJA
				If lGrvLj
					FRA->FRA_LJCXOR	:= aID[1]
					FRA->FRA_LJESTA	:= aID[2]
					FRA->FRA_LJPDV	:= aID[4]
					FRA->FRA_LJMOV	:= cMov
					FRA->FRA_LJDTFE	:= dFMov
				Endif
				MsUnlock()
				If lAltSE5 .AND. lPortNovo
					//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
					//³Alterar SE5 e SE8 - para movimentos de baixa de titulos que sao lancados jah baixados  ³
					//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
					cChave := xFilial("SE5") + SE1->(E1_PREFIXO + E1_NUM + E1_PARCELA + E1_TIPO + E1_CLIENTE + E1_LOJA)
					dbSelectArea("SE5")
					SE5->(dbSetOrder(7))	//E5_FILIAL+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ
					SE5->(dbSeek(cChave))
					Do While !SE5->(Eof()) .AND. SE5->(E5_FILIAL+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA) == cChave
						//Caso os dados bancarios sejam iguais e o tipo de baixa seja da loja
						If AllTrim(SE1->E1_PORTADO) == AllTrim(SE5->E5_BANCO) .AND. ;
							AllTrim(SE1->E1_AGEDEP) == AllTrim(SE5->E5_AGENCIA) .AND. ;
							AllTrim(SE1->E1_CONTA) == AllTrim(SE5->E5_CONTA) .AND. ;
							SE5->E5_TIPODOC == "LJ"

							RecLock("SE5",.F.)
							If lGrvTrFP
								SE5->E5_BANCO	:= aLstFP[nPos][4][1]
								SE5->E5_AGENCIA	:= aLstFP[nPos][4][2]
								SE5->E5_CONTA	:= aLstFP[nPos][4][3]
							Else
								SE5->E5_BANCO	:= aBcoDes[1]
								SE5->E5_AGENCIA	:= aBcoDes[2]
								SE5->E5_CONTA	:= aBcoDes[3]
							Endif
							SE5->(MsUnlock())
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³SE8 - Atualizar saldos bancarios  ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							dbSelectArea("SE8")
							SE8->(dbSetOrder(1))	//E8_FILIAL+E8_BANCO+E8_AGENCIA+E8_CONTA+DTOS(E8_DTSALAT)
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³Abater o valor do movimento do saldo do portador de origem  ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							If SE8->(dbSeek(xFilial("SE8") + SE1->(E1_PORTADO + E1_AGEDEP + E1_CONTA) + DtoS(SE5->E5_DATA)))
								RecLock("SE8",.F.)
								SE8->E8_SALATUA	-= SE5->E5_VALOR
								SE8->(MsUnlock())
							Endif
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//³Incrementar o valor do movimento no saldo do portador de destino  ³
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ							
							If !SE8->(dbSeek(xFilial("SE8") + SE5->(E5_BANCO + E5_AGENCIA + E5_CONTA) + DtoS(SE5->E5_DATA)))
								RecLock("SE8",.T.)
								SE8->E8_FILIAL	:= xFilial("SE8")
								SE8->E8_BANCO	:= SE5->E5_BANCO
								SE8->E8_AGENCIA	:= SE5->E5_AGENCIA
								SE8->E8_CONTA	:= SE5->E5_CONTA
								SE8->E8_DTSALAT	:= SE5->E5_DATA
							Else
								RecLock("SE8",.F.)
							Endif
							SE8->E8_SALATUA	+= SE5->E5_VALOR
							SE8->(MsUnlock())
						Endif
						SE5->(dbSkip())
					EndDo
				Endif
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Alterar SE1   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				RecLock("SE1",.F.)
				SE1->E1_SITUACA	:= cCart
				If lUsaPortado .AND. lPortNovo
					If lGrvTrFP
						SE1->E1_PORTADO	:= aLstFP[nPos][4][1]
						SE1->E1_AGEDEP	:= aLstFP[nPos][4][2]
						SE1->E1_CONTA 	:= aLstFP[nPos][4][3]
					Else
						SE1->E1_PORTADO	:= aBcoDes[1]
						SE1->E1_AGEDEP	:= aBcoDes[2]
						SE1->E1_CONTA 	:= aBcoDes[3]
					Endif
				Endif
				MsUnlock()
			Endif
		Next nx
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Alterar o orcamento, indicando que a transferencia foi efetivada, caso a transf. seja para o cx. geral  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If cCart == "J" .AND. SL1->(Found())
			RecLock("SL1",.F.)
			If !SL1->L1_TRCXGER
				SL1->L1_TRCXGER := .T.
			Endif
			SL1->L1_TREFETI := .T.
			MsUnlock()
		Endif
	Else
		//Se foi determinado que se deve interromper o processamento para quando um orcamento esta sem titulo
		If lIntProcOST
			//Caso nenhum titulo tenha sido encontrado, sair retornando erro
			cMens += STR0148 //"Orcamento com titulo nao encontrado!"
			RestArea(aArea)
			Return !lRet
		Endif
	Endif
Next ni
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³SE5 - Transferencia de caixa - apenas se houver alteracao de portador ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nValTotTrans > 0 .AND. lHouveTP
	//Se nao a gravacao da transf. de cx. nao for por forma de pagamento, criar um registro unico com a moeda corrente, valor total e banco de origem e destino
	If !lGrvTrFP
		aAdd(aLstFP,{RetMoeda(cMoedaC,,2,.T.),nValTotTrans,{aBcoOrig[1],aBcoOrig[2],aBcoOrig[3]},{aBcoDes[1],aBcoDes[2],aBcoDes[3]}})
	Endif
	cHistor := Substr("SLW[05] " + AllTrim(cChvSLW),1,TamSX3("E5_HISTOR")[1])
	//Varrer a lista de formas de pagamento e registrar a transferencia
	For ni := 1 to Len(aLstFP)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Para cada FP, processar operacao de Debito e Credito (P/R)  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		For nx := 1 to 2
			//Definir a proxima sequencia do movimento
			cSeqBx := Soma1(cSeqBx,nTamSeq)
			//Gravar o registro
			RecLock("SE5",.T.)
			SE5->E5_FILIAL	:= xFilial("SE5")
			SE5->E5_DATA	:= dDataAt
			SE5->E5_MOEDA	:= aLstFP[ni][1]
			SE5->E5_VALOR	:= aLstFP[ni][2]
			SE5->E5_NATUREZ	:= cTransNat
			If nx == 1
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ORIGEM - LP 560  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				SE5->E5_BANCO	:= aLstFP[ni][3][1]
				SE5->E5_AGENCIA	:= aLstFP[ni][3][2]
				SE5->E5_CONTA	:= aLstFP[ni][3][3]
				SE5->E5_RECPAG	:= "P"
			Else
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³DESTINO - LP 561  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				SE5->E5_BANCO	:= aLstFP[ni][4][1]
				SE5->E5_AGENCIA	:= aLstFP[ni][4][2]
				SE5->E5_CONTA	:= aLstFP[ni][4][3]
				SE5->E5_RECPAG	:= "R"
			Endif
			SE5->E5_LA		:= ""
			SE5->E5_SITUACA	:= ""
			SE5->E5_HISTOR	:= cHistor
			SE5->E5_TIPODOC	:= cTipoDoc
			If SE5->(FieldPos("E5_NUMMOV")) > 0
				SE5->E5_NUMMOV	:= cMov
			Endif
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³IMPORTANTE!                                                    ³
			//³O campo E5_NUMERO NAO devera ser preenchido!                   ³
			//³Isso faz com que o movimento bancario nao seja contabilizado!  ³
			//³ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
			//³Regras de contabilizacao dos movimentos do tipo TR :           ³
			//³SE5->E5_LA <> "S"                                              ³
			//³SE5->E5_SITUACA <> "C"                                         ³
			//³SE5->E5_NUMERO = VAZIO                                         ³
			//³SE5->E5_RECPAG == "P" ENTAO cPadrao := "560"                   ³
			//³SE5->E5_RECPAG == "R" ENTAO cPadrao := "561"                   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			SE5->E5_PREFIXO	:= ""
			SE5->E5_NUMERO	:= ""
			SE5->E5_PARCELA	:= ""
			SE5->E5_TIPO	:= ""
			SE5->E5_DTDIGIT	:= dDataAt
			SE5->E5_SEQ		:= cSeqBx
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³IMPORTANTE!                                                    ³
			//³O campo E5_LOTE DEVE ser preenchido com o lote gravado na      ³
			//³tabela de controle de transferencias FRA                       ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			SE5->E5_LOTE	:= cLoteF
			//A sequencia deve ser determinada por ordem de gravacao, jah que o tipo TR nao gera sequencia de baixa valida, apenas os tipos (CP,BA,VL,V2,LJ)
			MsUnlock()
		Next nx
	Next ni
Endif
RestArea(aArea)

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LjRetTitFinºAutor  ³Vendas Clientes       º Data ³19/11/10        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Funcao que retorna uma lista com os titulos associados com um     º±±
±±º          ³orcamento (SL1). Os campos contidos na lista por padrao sao os do º±±
±±º          ³indice 02 da SE1 e na ultima posicao o Recno do titulo. Porem     º±±
±±º          ³eh possivel determinar os campos de retorno e se o Recno deve     º±±
±±º          ³estar presente ou nao entre os campos de retorno.                 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³Exp01[C] : Filial do orcamento (SL1)                              º±±
±±º          ³Exp02[C] : Numero do orcamento (SL1)                              º±±
±±º          ³Exp03[A] : Lista de campos de retorno. Padrao :                   º±±
±±º          ³E1_FILIAL+E1_CLIENTE+E1_LOJA+E1_PREFIXO+E1_NUM+E1_PARCELA+E1_TIPO º±±
±±º          ³Exp04[L] : Det. se o num. dos registros deve constar no retorno   º±±
±±º          ³Exp05[L] : Det. se os titulos de credito devem ser considerados   º±±
±±º          ³Exp06[C] : Filtro por rotina de origem (padrao LOJA010)           º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³aRet[L] : Lista de registros + campos de titulos encontrados.     º±±
±±º          ³                                                                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³Generico                                                          º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function LjRetTitFin(cFilOrc,cNumOrc,aLstCmp,lRetReg,lConsCred,cOrigem)

Local aRet             	:= {}
Local aArea				:= GetArea()
Local lPedido			:= .F.
Local cChave			:= ""
Local aLstCred			:= {MV_CRNEG,MVRECANT,"CR"}			//Lista de tipos de titulos de credito ao cliente
Local aLstFP			:= {}								//Lista de formas de pagamento utilizadas no orcamento (1.FP 2.Vencto 3.Registro 4.Parcela)
Local ni				:= 0								//Contador
Local nx				:= 0								//Contador
Local aChaveSE1			:= Array(7)						//Chave de pesquisa do titulo
Local cPrefixo			:= SuperGetMV("MV_LJPREF",.F.,"")	//Prefixo do titulo
Local cNumE1			:= ""								//Numero do titulo
Local cPrefTit			:= ""
Local cParcela			:= SuperGetMV("MV_1DUP",.F.,"A")	//Forma de definicao de parcelas no financeiro
Local cParcAt			:= ""								//Parcela atual
Local nTamParc			:= TamSX3("E1_PARCELA")[1]			//Tamanho do campo parcela do SE1
Local aTMP				:= {}								//Array temporaria
Local cCodADM 			:= ""								//Codigo da administradora financeira / forma de pagamento
Local nTamCADM			:= TamSX3("AE_COD")[1]				//Tamanho do codigo da administradora financeira
Local aTMP02			:= {}								//Array temporaria 02
Local aTMP03			:= {}								//Array temporaria 03
Local nTamClient  		:= TamSX3("E1_CLIENTE")[1]			//Tamanho do campo "E1_CLIENTE" do SE1
Local nTamLoja 			:= TamSX3("E1_LOJA")[1] 			//Tamanho do campo "E1_LOJA" do SE1
Local nTamPrefixo		:= TamSX3("E1_PREFIXO")[1]			//Tamanho do campo "E1_PREFIXO" do SE1
Local cFilSE1			:= xFilial("SE1")
Local cFilSAE			:= xFilial("SAE")
Local lAdmProp			:= .F.								// Retorna se a administradora e' propria

Static POS_FP			:= 1								//Posicao array : Forma de pagamento
Static POS_VENC			:= 2								//Posicao array : Vencimento
Static POS_REG			:= 3								//Posicao array : Numero do registro
Static POS_PARC			:= 4								//Posicao array : Parcela
Static POS_ADMF			:= 5								//Posicao array : Adm. financeira

Default cFilOrc		:= xFilial("SL1")
Default cNumOrc		:= ""
Default aLstCmp 	:= {"E1_FILIAL","E1_CLIENTE","E1_FILIAL","E1_PREFIXO","E1_NUM","E1_PARCELA","E1_TIPO"}
Default lRetReg		:= .T.
Default lConsCred	:= .F.
Default cOrigem		:= "LOJA010|FATA701|LOJA701"

If Empty(cFilOrc) .OR. Empty(cNumOrc) .OR. Len(aLstCmp) == 0 .OR. ValType(lRetReg) # "L" .OR. ValType(lConsCred) # "L"
	Return aRet
Endif
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Consultar o orcamento alvo  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("SL1")
SL1->(dbSetOrder(1))
If !SL1->(dbSeek(cFilOrc + RTrim(cNumOrc)))
	RestArea(aArea)
	Return aRet
Else
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Validar se existem formas de pagamento atreladas ao orcamento            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cChave := xFilial("SL4") + SL1->L1_NUM
	dbSelectArea("SL4")
	SL4->(dbSetOrder(1))
	If !SL4->(dbSeek(cChave + Space(TamSX3("L4_ORIGEM")[1])))
		RestArea(aArea)
		Return aRet
	Endif

	dbSelectArea("SAE")
	SAE->(dbSetOrder(1)) //AE_FILIAL + AE_COD
	
	Do While !SL4->(Eof()) .AND. RTrim(SL4->(L4_FILIAL + L4_NUM)) == RTrim(cChave) .AND. Empty(SL4->L4_ORIGEM)
		If !Empty(SL4->L4_ADMINIS)
			//Verificar se a adm. financeira eh valida e deve ser colocada como o cliente (E1_CLIENTE)
			cCodADM := Substr(SL4->L4_ADMINIS,1,nTamCADM)
			If SAE->( MsSeek(cFilSAE+cCodADM) ) .And. !Empty(SAE->AE_COD)
				cCodADM := SAE->AE_COD
			Else
				cCodADM := Space(nTamCADM)
			Endif
		Else
			cCodADM := Space(nTamCADM)
		Endif
		aAdd(aLstFP,{AllTrim(SL4->L4_FORMA),SL4->L4_DATA,SL4->(Recno()),Space(nTamParc),cCodADM})
		SL4->(dbSkip())
	EndDo
Endif
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Classificar as formas de pagamento por ordem de registro      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aSort(aLstFP,,,{|x,y| x[POS_REG] < y[POS_REG]})
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Ordenar independentemente as formas de pagamento :³
//³1. ESPECIE                                        ³
//³2. OUTRAS FORMAS                                  ³
//³Possuem regras diferentes de gravacao na SE1.     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aTMP 	:= {}
aTMP02	:= {}
For ni := 1 to Len(aLstFP)
	If !IsMoney(aLstFP[ni][POS_FP])
		aAdd(aTMP02,aLstFP[ni])
	Else
		aAdd(aTMP,aLstFP[ni])
	Endif
Next ni
aLstFP := Array(0)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Classificar as formas de pagamento que nao sao em especie por : ³
//³FP + ADMF + VENCTO(como sao gravadas na SE1)                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Len(aTMP02) > 0
	For ni := 1 to Len(aTMP02)
		For nx := 1 to Len(aTMP02)
			cChave := aTMP02[ni][POS_FP] + aTMP02[ni][POS_ADMF] + DtoS(aTMP02[ni][POS_VENC])
			If cChave < aTMP02[nx][POS_FP] + aTMP02[nx][POS_ADMF] + DtoS(aTMP02[nx][POS_VENC])
				//Armazenar o conteudo do registro maior na area temporaria
				aTMP03 := aClone(aTMP02[ni])
				//Registrar o conteudo do registro menor dentro do maior (anterior)
				aTMP02[ni] := aTMP02[nx]
				//Registrar o conteudo do registro maior dentro do menor (posterior)
				aTMP02[nx] := aTMP03
			Endif
		Next nx
	Next ni
Endif
//Agregar a lista as FP em especie (aTMP), que sao gravadas primeiro no SE1
If Len(aTMP) > 0
	aLstFP := aClone(aTMP)
Endif
//Agregar a lista as FP em outras FPs (aTMP02), que sao gravadas posteriormente no SE1
If Len(aTMP02) > 0
	If Len(aTMP) == 0
		aLstFP := aClone(aTMP02)
	Else
		For ni := 1 to Len(aTMP02)
			aAdd(aLstFP,aTMP02[ni])
		Next ni
	Endif
Endif
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Definicao das parcelas  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
For ni := 1 to Len(aLstFP)
	If !IsMoney(aLstFP[ni][POS_FP])
		If ni > 1
			If aLstFP[ni - 1][POS_FP] == aLstFP[ni][POS_FP]
				cParcAt := Soma1(cParcAt,nTamParc)
			Else
				cParcAt := PadR(cParcela,nTamParc)
			Endif
		Else
			cParcAt := PadR(cParcela,nTamParc)
		Endif
		aLstFP[ni][POS_PARC] := cParcAt
	Endif
Next ni
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Determinar se o orcamento eh de entrega futura  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lPedido := AllTrim(SL1->L1_TIPO) == "P" .OR. !Empty(SL1->L1_DOCPED)
If lPedido
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Determinar o prefixo do titulo  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If AllTrim(cPrefixo) == "SF2->F2_SERIE"
		cPrefTit := IIf(Empty(SL1->L1_SERIE),SL1->L1_SERPED,SL1->L1_SERIE)
	Else
		cPrefTit := &(cPrefixo)
	Endif
	cPrefTit := PadR(AllTrim(cPrefTit),nTamPrefixo)
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Determina o numero do titulo    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cNumE1 := LJ7NumTit()
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Montar a chave de pesquisa dos titulos  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SE1")
	SE1->(dbSetOrder(2))

	aSort(aLstFP,,,{|x,y| x[POS_REG] < y[POS_REG]})

	For ni := 1 to Len(aLstFP)
		cCodADM := aLstFP[ni][POS_ADMF]
		
		If !Empty(cCodADM)
			SAE->(dbSetOrder(1)) //AE_FILIAL + AE_COD
			SAE->(DbSeek(xFilial("SAE")+cCodADM))
			lAdmProp := LjGrvTpFin(SAE->AE_FINPRO, If(SAE->(FieldPos("AE_AGLPARC")) > 0, SAE->AE_AGLPARC, 2))[2]
		EndIf
		
		aChaveSE1[1] := cFilSE1												//E1_FILIAL
		If !Empty(cCodADM) .And. !lAdmProp
			If SAE->( ColumnPos("AE_LOJCLI") ) > 0 .And. !Empty(SAE->AE_CODCLI) .And. !Empty(SAE->AE_LOJCLI)
				aChaveSE1[2] := SAE->AE_CODCLI								//E1_CLIENTE
                aChaveSE1[3] := SAE->AE_LOJCLI								//E1_LOJA
			Else		
				aChaveSE1[2] := PadR(AllTrim(cCodADM),nTamClient)			//E1_CLIENTE
				aChaveSE1[3] := PadR("01",nTamLoja)				  			//E1_LOJA		
			EndIf
		Else
			aChaveSE1[2] := PadR(AllTrim(SL1->L1_CLIENTE),nTamClient)		//E1_CLIENTE
			aChaveSE1[3] := PadR(AllTrim(SL1->L1_LOJA),nTamLoja)			//E1_LOJA
		Endif
		aChaveSE1[4] := cPrefTit											//E1_PREFIXO
		aChaveSE1[5] := cNumE1												//E1_NUM	
		aChaveSE1[6] := aLstFP[ni][POS_PARC]								//E1_PARCELA
		aChaveSE1[7] := RTrim(aLstFP[ni][POS_FP])							//E1_TIPO
		cChave := ""
		aTMP := {}
		For nx := 1 to Len(aChaveSE1)
			cChave += aChaveSE1[nx]
		Next nx	
		SE1->(dbSeek(cChave))
		Do While !SE1->(Eof()) .AND. RTrim(SE1->(E1_FILIAL + E1_CLIENTE + E1_LOJA + E1_PREFIXO + E1_NUM + E1_PARCELA + E1_TIPO)) == cChave
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Se a data de vencimento for diferente, saltar  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If SE1->E1_EMISSAO != SL1->L1_EMISNF
				SE1->(dbSkip())
				Loop
			Endif
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Caso o titulo seja de credito e a rotina esteja configurada ³
			//³para nao retornar titulos de credito, saltar.               ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !lConsCred .AND. aScan(aLstCred,{|x| AllTrim(Upper(x)) == AllTrim(Upper(SE1->E1_TIPO))}) > 0
				SE1->(dbSkip())
				Loop
			Endif
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Caso a origem do titulo tenha sido definido, ignorar titulos de ³
			//³origem diferente da definida.                                   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !Empty(cOrigem) .AND. !(AllTrim(Upper(SE1->E1_ORIGEM)) $ AllTrim(Upper(cOrigem)))
				SE1->(dbSkip())
				Loop
			Endif
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Alimentar array temporaria com os campos solicitados  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			For nx := 1 to Len(aLstCmp)
				aAdd(aTMP,SE1->&(aLstCmp[nx]))
			Next nx
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Se for para gravar o Recno, adicionar a array na ultima posicao  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lRetReg
				aAdd(aTMP,SE1->(Recno()))
			Endif
			Exit
		EndDo
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Caso algum registro tenha sido encontrado, adicionar a array de retorno ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Len(aTMP) > 0
			aAdd(aRet,aTMP)
		Endif
	Next ni
Else
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Procurar por documento de saida  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SL1->(FieldPos("L1_NUMCFIS")) > 0 .AND. nModulo != 5 .And. !Empty(Alltrim(SL1->L1_NUMCFIS))
		cChave := xFilial("SF2") + PadR(SL1->L1_NUMCFIS,TamSX3("F2_DOC")[1]) + PadR(SL1->L1_SERIE,TamSX3("F2_SERIE")[1])
	Else
		cChave := xFilial("SF2") + PadR(SL1->L1_DOC,TamSX3("F2_DOC")[1]) + PadR(SL1->L1_SERIE,TamSX3("F2_SERIE")[1])
	Endif
	cChave += PadR(SL1->L1_CLIENTE,TamSX3("F2_CLIENTE")[1]) + RTrim(SL1->L1_LOJA)	
	dbSelectArea("SF2")
	SF2->(dbSetOrder(1))	//F2_FILIAL+F2_DOC+F2_SERIE+F2_CLIENTE+F2_LOJA+F2_FORMUL	
	If SF2->(dbSeek(cChave))
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Montar a chave de pesquisa dos titulos  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSelectArea("SE1")
		SE1->(dbSetOrder(2))
		For ni := 1 to Len(aLstFP)

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Determinar o prefixo do titulo  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If AllTrim(cPrefixo) == "SF2->F2_SERIE"
				cPrefTit := SF2->F2_SERIE
			Else
				cPrefTit := &(cPrefixo)
			Endif
			cPrefTit := PadR(AllTrim(cPrefTit),nTamPrefixo)
			
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Determinar o numero do titulo   ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			cNumE1 := LJ7NumTit()

			cCodADM := aLstFP[ni][POS_ADMF]
			If !Empty(cCodADM)
				SAE->(dbSetOrder(1)) //AE_FILIAL + AE_COD
				SAE->(DbSeek(xFilial("SAE")+cCodADM))
				lAdmProp := LjGrvTpFin(SAE->AE_FINPRO, If(SAE->(FieldPos("AE_AGLPARC")) > 0, SAE->AE_AGLPARC, 2))[2]
			EndIf
			
			aChaveSE1[1] := cFilSE1												//E1_FILIAL
			If !Empty(cCodADM) .And. !lAdmProp
				If SAE->( ColumnPos("AE_LOJCLI") ) > 0 .And. !Empty(SAE->AE_CODCLI) .And. !Empty(SAE->AE_LOJCLI)
					aChaveSE1[2] := SAE->AE_CODCLI								//E1_CLIENTE
                    aChaveSE1[3] := SAE->AE_LOJCLI								//E1_LOJA
				Else
					aChaveSE1[2] := PadR(AllTrim(cCodADM),nTamClient)			//E1_CLIENTE
					aChaveSE1[3] := PadR(AllTrim("01"),nTamLoja)				//E1_LOJA
				EndIf
			Else
				aChaveSE1[2] := PadR(AllTrim(SF2->F2_CLIENTE),nTamClient)		//E1_CLIENTE
				aChaveSE1[3] := PadR(AllTrim(SF2->F2_LOJA),nTamLoja)			//E1_LOJA
			Endif
			aChaveSE1[4] := cPrefTit											//E1_PREFIXO
			aChaveSE1[5] := cNumE1												//E1_NUM		
			aChaveSE1[6] := aLstFP[ni][POS_PARC]								//E1_PARCELA
			aChaveSE1[7] := RTrim(aLstFP[ni][POS_FP])							//E1_TIPO
			cChave := ""
			aTMP := {}
			For nx := 1 to Len(aChaveSE1)
				cChave += aChaveSE1[nx]
			Next nx	
			SE1->(dbSeek(cChave))
			Do While !SE1->(Eof()) .AND. RTrim(SE1->(E1_FILIAL + E1_CLIENTE + E1_LOJA + E1_PREFIXO + E1_NUM + E1_PARCELA + E1_TIPO)) == cChave
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Se a data de vencimento for diferente, saltar  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If SE1->E1_EMISSAO  != SL1->L1_EMISNF
					SE1->(dbSkip())
					Loop
				Endif
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Caso o titulo seja de credito e a rotina esteja configurada ³
				//³para nao retornar titulos de credito, saltar.               ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If !lConsCred .AND. aScan(aLstCred,{|x| AllTrim(Upper(x)) == AllTrim(Upper(SE1->E1_TIPO))}) > 0
					SE1->(dbSkip())
					Loop
				Endif
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Caso a origem do titulo tenha sido definido, ignorar titulos de ³
				//³origem diferente da definida.                                   ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If !Empty(cOrigem) .AND. !(AllTrim(Upper(SE1->E1_ORIGEM)) $ AllTrim(Upper(cOrigem)))
					SE1->(dbSkip())
					Loop
				Endif
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Alimentar array temporaria com os campos solicitados  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				For nx := 1 to Len(aLstCmp)
					aAdd(aTMP,SE1->&(aLstCmp[nx]))
				Next nx
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Se for para gravar o Recno, adicionar a array na ultima posicao  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lRetReg
					aAdd(aTMP,SE1->(Recno()))
				Endif
				Exit
			EndDo
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Caso algum registro tenha sido encontrado, adicionar a array de retorno ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If Len(aTMP) > 0
				aAdd(aRet,aTMP)
			Endif
		Next ni		
	Endif
Endif
RestArea(aArea)

Return aRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LjRetLote  ºAutor  ³Vendas Clientes       º Data ³22/11/10        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Funcao que retorna a proxima sequencia numerica disponivel de loteº±±
±±º          ³para movimentacoes bancarias (SE5).                               º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³Exp01[C] : (Opcional) Carteira a ser pesquisada (R/P)             º±±
±±º          ³Exp02[L] : (Opcional) Determina que a pesquisa nao deve ser feita º±±
±±º          ³           atraves de uma query.                                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³cLote[C] : Retorna o proximo sequencial numerico disponivel       º±±
±±º          ³                                                                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³Generico                                                          º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function LjRetLote(cCart,lNUsaQry)

Local aAreaSE5			:= SE5->(GetArea())					//Area de trabalho do SE5
Local nTamLote			:= TamSX3("E5_LOTE")[1]					//Tamanho do campo lote
Local cLote            	:= ""									//Lote retorno
Local cFilSE5			:= xFilial("SE5")						//Filial SE5

Default cCart			:= "R"
Default lNUsaQry		:= .F.

If ValType(cCart) # "C" .OR. !cCart $ "P|R" .OR. ValType(lNUsaQry) # "L"
	Return 
Endif

cLote 	:= Replicate("0",nTamLote)

dbSelectArea("SE5")
SE5->(dbSetOrder(5))	//E5_FILIAL+E5_LOTE+E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+DtoS(E5_DATA)
SE5->( dbSeek(cFilSE5+Replicate("9",nTamLote), .T.) )
SE5->(dbSkip(-1))
If SE5->E5_FILIAL == cFilSE5
	cLote := PadL(AllTrim(SE5->E5_LOTE),nTamLote,"0")
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Com o lote definido, verificar sua disponibilidade e caso   ³
//³seja necessario, buscar proxima sequencia disponivel.       ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cLote := Soma1(cLote,nTamLote)
Do While SE5->(dbSeek(cFilSE5 + cLote))
	cLote := Soma1(cLote,nTamLote)
EndDo

RestArea(aAreaSE5)

Return cLote

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LjVldBco   ºAutor  ³Vendas Clientes       º Data ³25/11/10        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Funcao para validacao de caixas e bancos contidos na SA6, a pes-  º±±
±±º          ³quisa pode ser completa e/ou parcial.                             º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³Exp01[C] : Codigo do banco                                        º±±
±±º          ³Exp02[C] : (Opcional) Codigo da agencia                           º±±
±±º          ³Exp03[C] : (Opcional) Codigo da conta                             º±±
±±º          ³Exp04[L] : (Opcional) Validar agencia na pesquisa. Padrao .T.     º±±
±±º          ³Exp05[L] : (Opcional) Validar conta na pesquisa. Padrao .T.       º±±
±±º          ³Exp06[L] : (Opcional) Exibir mensagem de help caso o banco nao    º±±
±±º          ³           tenha sido encontrado. Padrao .T.                      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³lRet[L] :  Retorna o proximo sequencial numerico disponivel       º±±
±±º          ³                                                                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³Generico                                                          º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function LjVldBco(cBco,cAgencia,cConta,lVldAg,lVldCta,lHelp)

Local lRet 				:= .T.					//Retorno
Local aAreaSA6			:= SA6->(GetArea())	//Area da SA6
Local cChave			:= ""					//Chave de pesquisa
Local cChvInd			:= ""					//Chave de indice para pesquisa

Default cBco			:= ""
Default cAgencia		:= ""
Default cConta			:= ""
Default lVldAg			:= .T.
Default lVldCta  		:= .T.  
Default lHelp 			:= .F. 

dbSelectArea("SA6")
SA6->(dbSetOrder(1))
DBClearFilter()
If !Empty(cBco) .AND. (!lVldAg .OR. !Empty(cAgencia)) .AND. (!lVldCta .OR. !Empty(cConta))	
	cChave := xFilial("SA6") 
	cChave += PadR(cBco		,TamSX3("A6_COD")[1])
	cChave += PadR(cAgencia	,TamSX3("A6_AGENCIA")[1])
	cChave += PadR(cConta	,TamSX3("A6_NUMCON")[1])
	cChvInd := "A6_FILIAL+A6_COD"
	If !Empty(cAgencia)
		cChvInd += "+A6_AGENCIA"
	Endif
	If !Empty(cConta)
		cChvInd += "+A6_NUMCON"
	Endif
	//Verifica se o registro posicionado nao eh o banco solicitado
	If SA6->(Found()) .AND. RTrim(SA6->&(cChvInd)) == RTrim(cChave)
		lRet := .T.
	Else
		//Buscar na tabela
		SA6->(dbGoTop())
		If !SA6->(dbSeek(RTrim(cChave)))
			lRet := .F.		
		Endif
	Endif
Else
	lRet := .F.
EndIf
If !lRet .AND. lHelp
	Help(" ",1,"FA100BCO")
Endif
RestArea(aAreaSA6)

Return lRet
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³FormataHlp ºAutor  ³Vendas Clientes       º Data ³06/12/10        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Rotina para formatar uma string em uma array respeitando o tamanhoº±±
±±º          ³maximo para visualizacao de help de campo.                        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³Exp01[C] : Texto                                                  º±±
±±º          ³Exp02[C] : (Opcional) Limite por bloco de conteudo do help        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³aRet[A]  : Retorna array com o texto dividido em blocos que res-  º±±
±±º          ³           peitam o limite de conteudo por bloco de help          º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³Generico                                                          º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function FormataHlp(cTexto,nLimite)

Local aRet			:= {}
Local ni			:= 0
Local nTam			:= 0
Local nCont			:= 1
Local nPos			:= 0
Local cVogais		:= "AEIOUÁÉÍÓÚÂÊÎÔÛÀÈÌÒÙÃÕÄËÏÖÜ"
Local cConsoa		:= "BCDFGHJKLMNPQRSTVXWYZÇÑ"
Local cPontua		:= "(){}[]:.,;"
Local cNum			:= "0123456789"
Local cEspaco		:= " " + CHR(13) + CHR(10)
Local lPontua 		:= .F.
Local lUltVog		:= .F.
Local lEncVoc		:= .F.
Local lEncCon		:= .F.
Local lTritongo 	:= .F.
Local lEspaco		:= .F.
Local lConEsp		:= .F.
Local lPalDuas		:= .F.
Local lPalTres		:= .F.

Default cTexto 	:= ""
Default nLimite	:= 35

If Empty(cTexto)
	Return aRet
Endif
cTexto	:= AllTrim(cTexto)
nTam 	:= Len(cTexto)
aRet	:= Array(1)
nPos	:= Len(aRet)
If nTam > nLimite
	aRet[nPos] := ""
	For ni := 1 to nTam 
		If ni > 1
			lPontua := Upper(Substr(cTexto,ni,1)) $ (cPontua + cNum)
			lUltVog	:= Upper(Right(aRet[nPos],1)) $ cVogais
			lEncVoc	:= Upper(Substr(cTexto,ni,1)) $ cVogais .AND. lUltVog
			lEncCon	:= Upper(Substr(cTexto,ni,1)) $ cConsoa .AND. Upper(Substr(cTexto,ni + 1,1)) $ cConsoa
			If lEncCon
				If Upper(Substr(cTexto,ni + 2,1)) $ "LR"
					lTritongo := .T.
				Else
					lTritongo := .F.
				Endif
			Else
				lTritongo := .F.
			Endif
			lEspaco	:= Upper(Substr(cTexto,ni,1)) $ cEspaco
			lConEsp	:= Upper(Substr(cTexto,ni,1)) $ cConsoa .AND. Upper(Substr(cTexto,ni + 1,1)) $ cEspaco 
			//Palavra duas letras, que nao deve ser quebrada
			If ni > 2
				lPalDuas := Upper(Substr(cTexto,ni - 2,1)) $ cEspaco .AND. Upper(Substr(cTexto,ni,1)) $ (cConsoa + cVogais) .AND. ;
					Upper(Substr(cTexto,ni + 2,1)) $ (cEspaco + cPontua)
			Else
				lPalDuas := .F.
			Endif			
			//Palavra tres letras, que nao deve ser quebrada
			If !lPalDuas .AND. ni > 2
				lPalTres := Upper(Substr(cTexto,ni - 2,1)) $ cEspaco .AND. Upper(Substr(cTexto,ni,1)) $ (cConsoa + cVogais) .AND. ;
					Upper(Substr(cTexto,ni + 1,1)) $ (cConsoa + cVogais) .AND. Upper(Substr(cTexto,ni + 2,1)) $ (cEspaco + cPontua)
			Else
				lPalTres := .F.
			Endif
			If nCont > nLimite .AND. ((!lPontua .AND. lUltVog .AND. !lEncVoc .AND. (!lEncCon .OR. lTritongo) .AND. !lConEsp .AND. !lPalDuas .AND. !lPalTres) .OR. (lEspaco))
				nCont := 0
				//Se nao for o ultimo caracter
				If ni < nTam
					//Se o caracter processado for uma consoante ou vogal e nao for um tritongo inserir o separador
					If Upper(Substr(cTexto,ni,1)) $ (cVogais + cConsoa)
						If lTritongo
							aRet[nPos] += Substr(cTexto,ni,1) + "-"
						Else
							aRet[nPos] += "-"
						Endif
					Endif
				Endif
				aAdd(aRet,"")
				nPos := Len(aRet)
			Else
				//Negar o tritongo, pois nao havera necessidade de quebra e a letra precisa ser adicionada
				lTritongo := .F.
			Endif
		Endif
		If !lTritongo
			aRet[nPos] += Substr(cTexto,ni,1)
		Endif
		nCont++
	Next ni
	For ni := 1 to Len(aRet)
		aRet[ni] := LTrim(aRet[ni])
	Next ni	
Else
	aRet[nPos] := cTexto
Endif

Return aRet
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LjMntEBar  ºAutor  ³Vendas Clientes       º Data ³07/12/10        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Funcao para montar uma enchoicebar atraves da classe FWButtonBar  º±±
±±º          ³                                                                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³Exp01[O] : Tela / Painel                                          º±±
±±º          ³Exp02[B] : Acao de confirmacao                                    º±±
±±º          ³Exp03[B] : Acao de cancelamento                                   º±±
±±º          ³Exp04[A] : Lista de botoes graficos                               º±±
±±º          ³Exp05[A] : Lista de botoes de texto                               º±±
±±º          ³Exp06[L] : Utilizar botoes graficos padrao da enchoice            º±±
±±º          ³Exp07[L] : Utilizar botao grafico de legenda                      º±±
±±º          ³Exp08[C] : Alias da tabela (para consulta de legenda)             º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³Nenhum                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³LOJA057                                                           º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function LjMntEBar(oDlg,bOk,bCancel,aButtons,aButText,lIsEnchoice,lLegenda,cAlias)

Local nx 				:= 0
Local lFWGetVersao 		:= FindFunction("GetVersao")

Default aButtons		:= {}
Default aButText		:= {}
Default lIsEnchoice 	:= .T.
Default lLegenda  		:= .F.
Default cAlias			:= ""
	
If !lFWGetVersao .OR. GetVersao(.F.) == "P10"
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Protheus 10  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	oButtonBar := FWButtonBar():New()
	oButtonBar:Init(oDlg,015,015,CONTROL_ALIGN_BOTTOM,.T.,lIsEnchoice)
	If lIsEnchoice
		oButtonBar:SetEnchBar(bOk,bCancel,,,,.T.)
	Else
		//Criacao dos botoes de Texto OK e Cancela quando nao for enchoicebar
		If !Empty(bCancel)
			oButtonBar:AddBtnText("Cancelar","Cancelar",bCancel,,,CONTROL_ALIGN_RIGHT,.T.)
			SetKEY(24,{||Eval(bCancel)})
		Endif
		If !Empty(bOk)
			oButtonBar:AddBtnText("Ok","Confirmar",bOk,,,CONTROL_ALIGN_RIGHT)
			SetKEY(15,{||Eval(bOk)})
		Endif
	Endif
	//Criacao dos botoes de texto do usuario ou complementares
	If Len(aButText) > 0
		For nx := 1 to Len(aButText)
			oButtonBar:addBtnText(aButText[nX,1],aButText[nX,2],aButText[nX,3],,,CONTROL_ALIGN_RIGHT)
		Next nx
	Endif
	//Se a FAMYBAR esta sendo montada num browse e este tiver legenda alguns botoes padrao sao criados (botao imagem)
	If lLegenda .AND. !Empty(cAlias) .AND. ValType(cAlias) == "C"
		oButtonBar:AddBtnImage("PMSCOLOR","Legenda",{||LJ057Leg(cAlias,(cAlias)->(Recno()))},,.T.,CONTROL_ALIGN_LEFT) 
	Endif
	//Criacao dos botoes de imagem do usuario ou complementares
	If Len(aButtons) > 0
		For nx := 1 To Len(aButtons)
			oButtonBar:AddBtnImage(aButtons[nX,1],aButtons[nX,3],aButtons[nX,2],,.T.,CONTROL_ALIGN_LEFT)
	   	Next nx
	EndIf
Else
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Protheus 11  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	oButtonBar := FWFormBar():New(oDlg)
	//Criacao dos botoes de Texto OK e Cancela quando nao for enchoicebar
	If !Empty(bOk)
		oButtonBar:AddOK(bOk,"Confirmar")
	Endif
	If !Empty(bCancel)
		oButtonBar:AddClose(bCancel,"Cancelar")
	Endif
	//Criacao dos botoes de texto do usuario ou complementares
	If Len(aButText) > 0
		For Nx := 1 to Len(aButText)
			oButtonBar:AddUserBtn("",aButText[nX,2],aButText[nX,3],aButText[nX,2])
		Next
	Endif
	//Se a FAMYBAR esta sendo montada num browse e este tiver legenda alguns botoes padrao sao criados
	If lLegenda .AND. !Empty(cAlias) .AND. ValType(cAlias) == "C"
		oButtonBar:AddUserBtn("","Legenda",{|| LJ057Leg(cAlias,(cAlias)->(Recno()))},"Legenda")
	Endif
	//Criacao dos botoes de imagem do usuario ou complementares
	If Len(aButtons) > 0
		For nx := 1 To Len(aButtons)
			oButtonBar:AddUserBtn("",aButtons[nX,3],aButtons[nX,2],aButtons[nX,3])
		Next nx
	EndIf
	If lIsEnchoice
		oButtonBar:AddCalc()    
		oButtonBar:AddSpool()  
	Endif
	oButtonBar:Activate()
Endif	

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LjMntBrw   ºAutor  ³Vendas Clientes       º Data ³07/12/10        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Funcao para montar um browse (TcBrowse) em uma janela             º±±
±±º          ³                                                                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³Exp01[O] : Janela                                                 º±±
±±º          ³Exp02[C] : Alias ou Array de dados                                º±±
±±º          ³Exp03[A] : Coordenadas da browse                                  º±±
±±º          ³Exp04[O] : Browse                                                 º±±
±±º          ³Exp05[L] : Utilizar dicionario para compor colunas                º±±
±±º          ³Exp06[A] : Lista de campos desejados                              º±±
±±º          ³Exp07[C] : Expressao para legenda automatica                      º±±
±±º          ³Exp08[A] : Codigo de cores para legenda automatica                º±±
±±º          ³Exp09[C] : Expressao para posicionamento no inicio                º±±
±±º          ³Exp10[C] : Expressao para posicionamento no final                 º±±
±±º          ³Exp11[B] : Expressao ao clicar em um item da lista                º±±
±±º          ³Exp12[N] : Coluna que ficara congelada na exibicao                º±±
±±º          ³Exp13[A] : Classificacao por cabecalho (header)                   º±±
±±º          ³Exp14[A] : Array de legenda                                       º±±
±±º          ³Exp15[L] : Formatar dados com a picture informada (origem array)  º±±
±±º          ³Exp16[L] : A ordem dos campos deve respeitar o SX3 (origem alias) º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³oBrw[O] : Objeto do tipo TCBrowse                                 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³Generico                                                          º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function LjMntBrw(oWndBrw,cAlias,aCoord,oBrow,lDic,aCampos,cFun,aResource,cTopFun,cBotFun,bViewReg,nBrFreeze,aHeadOrd,aCores,lFormata,lOrdDic)

Local oBrowse
Local oEnable
Local oDisable
Local oRes
Local nAlias			:= 0
Local lUsado			:= .F.
Local cField			:= ""
Local cExpr				:= "Empty(" + IIf(cFun == Nil," ",cFun) + ")"
Local nx				:= 0
Local ni				:= 0
Local aColsF			:= {}											//Lista de colunas fixas (origem array)
Local aColsS			:= {}											//Lista de largura das colunas (origem array)
Local nRefLrg01			:= 2
Local nRefLrg02			:= 3
Local cTMP				:= ""
Local aTMP				:= {}
Local lOk				:= .T.											//Controle de fluxo
Local nPosLeg			:= 0											//Posicionamento para legenda em fonte de dados de array
Local aCores02			:= {}											//Novo array de regras para legenda em fonte de dados de array
Local lLegenda			:= .F.
Local nPosREG			:= 0											//Posicao de registro para expressoes de legenda
Local nPosCExp			:= 0											//Posicao de campo em expressoes de legenda

Default lDic      		:= .T.
Default nBrFreeze 		:= 0
Default aCampos   		:= {}
Default cBotFun   		:= ""
Default cTopFun			:= ""
Default lFormata		:= .F.
Default lOrdDic			:= IIf(Len(aCampos) == 0,.T.,.F.)

If !ValType(cAlias) $ "A|C"
	Return oBrowse
Endif
If aResource == Nil
	aResource:= {{ "LBTIK"," "},{"DISABLE"," "}}
EndIf                                   
nBrFreeze:= IIf(Valtype(nBrFreeze) == "N",nBrFreeze,0)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Estrutura do aCampos (Origem dados - ALIAS)   ³
//³----------------------------------------------³
//³[01] CAMPO                                    ³
//³----------------------------------------------³
//³Estrutura do aCampos (Origem dados - ARRAY)   ³
//³----------------------------------------------³
//³[01] CAMPO                                    ³
//³[02] PICTURE                                  ³
//³[03] TITULO                                   ³
//³[04] TAMANHO                                  ³
//³[05] TIPO                                     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Estrutura do aCores (Origem dados - ALIAS)               ³
//³----------------------------------------------           ³
//³[01] - EXPRESSAO                                         ³
//³                                                         ³
//³[02] - CODIGO COR                                        ³
//³                                                         ³
//³Estrutura do aCores (Origem dados - ARRAY)               ³
//³----------------------------------------------           ³
//³[01] - EXPRESSAO                                         ³
//³        [01][01] - CAMPOS CONTIDOS NA EXPRESSAO          ³
//³                   (DEVEM SER SEPARADOS POR VIRGULAS)    ³
//³        [01][02] - EXPRESSAO                             ³
//³                                                         ³
//³[02] - CODIGO COR                                        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

If !ValType(cAlias) $ "A|C"
	Return oBrowse
Endif
If aResource == Nil
	aResource:= {{ "LBTIK"," "},{"DISABLE"," "}}
EndIf                                   
nBrFreeze := IIf(Valtype(nBrFreeze) == "N",nBrFreeze,0)
If ValType(cAlias) == "C"
	lDic := .T.
	nAlias := Select(cAlias)        
	dbSelectArea(cAlias)
	nAlias := Select()        
	cField := IIf(Empty(cFilial),Nil,cAlias + "->" + PrefixoCpo(cAlias) + "_FILIAL")
	If !Empty(cTopFun)
		cField := IndexKey()
	EndIf
	cTopFun := IIf(cTopFun==Nil,xFilial(cAlias),&(cTopFun))
	cBotFun := IIf(cBotFun==Nil,xFilial(cAlias),&(cBotFun))
	If ValType(oBrow) # "O"
		oBrowse := TcBrowse():New(aCoord[1],aCoord[2],aCoord[3],aCoord[4],,,,oWndBrw,cField,cTopFun,cBotFun,/*DClick*/,bViewReg,/*Font*/,/*Cursor*/,;
			,/*CorFnt*/,/*CorBck*/,/*Mens*/,.F.,cAlias,.T.,/*when*/,.F.,/*valid*/,/*HScroll*/,.F./*VScroll*/)
	Else
		oBrowse := oBrow
	Endif
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Ordenacao do cabecalho  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If aHeadOrd <> Nil .And. Len(aHeadOrd) > 0
		oBrowse:bHeaderClick := &("{|oBrw,nCol| WndChgOrd(nCol,oBrw,aHeadOrd,cAlias),oBrowse:SetFocus(),oBrowse:Refresh()}")
	Endif
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Expressao para legenda automatica ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Empty(cFun)
		oEnable  := LoadBitmap(GetResources(),aResource[1][1])
	  	oDisable := LoadBitmap(GetResources(),aResource[2][1])
	  	oBrowse:AddColumn(TCColumn():New("",{|| IIf(&(cExpr),oEnable,oDisable)},,,,"LEFT",10,.T.,.F.,,,,.T.,))
	ElseIf ValType(aCores) == "A" .AND. Len(aCores) > 0
		oBrowse:AddColumn(TCColumn():New("",{|| oRes:=Nil, aEval(aCores,{|x| IIf(&(x[1]),IIf(oRes==Nil,oRes:=LoadBitmap(GetResources(),x[2]),""),"")} ), oRes },,,,;
			"LEFT", 10,.T.,.F.,,,,.T.,))
	Endif
Else
	If ValType(aCampos) # "A" .OR. Len(aCampos) == 0 .OR. ValType(aCampos[1]) # "A" .OR. Len(aCampos[1]) # 5
		Return oBrowse
	Endif
	lDic := .F.
	For nx := 1 to Len(aCampos)
		aAdd(aColsF,aCampos[nx][3])
	Next nx
	If ValType(oBrow) # "O"
		oBrowse := TcBrowse():New(aCoord[1],aCoord[2],aCoord[3],aCoord[4],,aColsF,,oWndBrw,,,,{||},{||},/*Font*/,/*Cursor*/,;
			,/*CorFnt*/,/*CorBck*/,/*Mens*/,.F.,/*cAlias*/,.T.,/*when*/,.F.,/*valid*/,/*HScroll*/,.F./*VScroll*/)
	Else
		oBrowse := oBrow
	Endif
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Formatar os dados  da array  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lFormata
		For nx := 1 to Len(cAlias)
			For ni := 1 to Len(cAlias[nx])
				cMasc := aCampos[ni][2]
				If !Empty(cMasc)
					Do Case
						Case aCampos[ni][5] == "N"
							cAlias[nx][ni] := AllTrim(Transform(cAlias[nx][ni],cMasc))
						Otherwise
							cAlias[nx][ni] := Transform(cAlias[nx][ni],cMasc)
					EndCase
				Endif
			Next ni
		Next nx
	Endif
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Expressao para legenda automatica ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ValType(aCores) == "A" .AND. Len(aCores) > 0
		lOk := .T.
		//Definir posicao da legenda
		For nx := 1 to Len(aCores)
			If Len(aCores[nx]) # 2 .OR. Len(aCores[nx][1]) # 2
				lOk := .F.
				Exit
			Endif
			//Transformar o texto na celula de declaracao de campos do filtro em array
			aTMP := StrTokArr(aCores[nx][1][1],",")
			cTMP := RTrim(aCores[nx][1][2])
			For ni := 1 to Len(aTMP)
				aTMP[ni] := AllTrim(aTMP[ni])
				//Verifica se o campo declarado consta na estrutura dos dados
				If (nPosLeg := aScan(aCampos,{|x| Upper(AllTrim(x[1])) == Upper(AllTrim(aTMP[ni]))})) == 0
					lOk := .F.
					Exit
				Endif
				//Caso exista mais de um campo na expressao, validar se cada um deles esta declarado na expressao, caso nao esteja invalidar legenda
				If (nPosCExp := At(Upper(AllTrim(aTMP[ni])),Upper(cTMP))) == 0
					If Len(aTMP) > 1
						lOk := .F.
						Exit
					Else
						//Caso a expressao possua apenas um campo, permitir a expressao sem declaracao explicita do campo
						cTMP := "cAlias[nPosREG," + cValToChar(nPosLeg + 1) + "] " + cTMP
					Endif
				Else
					Do While (nPosCExp := At(Upper(AllTrim(aTMP[ni])),Upper(cTMP))) > 0
						If nPosCExp == 1
							cTMP := "cAlias[nPosREG," + cValToChar(nPosLeg + 1) + "] " + Substr(cTMP,Len(aTMP[ni]) + 1,Len(cTMP))
						Else
							cTMP := Substr(cTMP,1,nPosCExp - 1) + "cAlias[nPosREG," + cValToChar(nPosLeg + 1) + "] " + ;
								Substr(cTMP,nPosCExp + Len(aTMP[ni]),Len(cTMP))
						Endif
					EndDo
				Endif
			Next ni				
            If lOk
				//Verificar se na expressao consta o nome do campo
				aAdd(aCores02,{&("{|| " + cTMP + "}"),aCores[nx][2]})
			Else
				Exit
			Endif
		Next nx		
		If lOk 
			lLegenda := .T.
			nPosLeg := 1						
			//Adicionar legenda ao grupo de HEADER
			aAdd(oBrowse:aHeaders,"")
			For ni := Len(oBrowse:aHeaders) to 2 Step -1
				oBrowse:aHeaders[ni] := oBrowse:aHeaders[ni - 1]
			Next ni
			oBrowse:aHeaders[1] := " "
			//Adicionar legenda ao grupo de COLUMNS
			aAdd(oBrowse:aColumns,"")
			For ni := Len(oBrowse:aColumns) to 2 Step -1
				oBrowse:aColumns[ni] := oBrowse:aColumns[ni - 1]
			Next ni
			oBrowse:aColumns[1] := " "
			For nx := 1 to Len(cAlias)
				nPosREG := nx
				//Adicionar novo elemento e alimenta-lo com a primeira variacao de legenda
				aSize(cAlias[nx],Len(cAlias[nx]) + 1)
				//Empurrar os itens para as posicoes abaixo
				For ni := Len(cAlias[nx]) to 2 Step -1
					cAlias[nx][ni] := cAlias[nx][ni - 1]
				Next ni
				cAlias[nx][1] := 1
				//Checar posicao encontrada
				For ni := 1 to Len(aCores02)
					If Eval(aCores02[ni][1])
						cAlias[nx][1] := ni
						Exit
					Endif
				Next ni
			Next nx
		Else
			nPosLeg := 0
		Endif
	Else
		lOk := .F.
	EndIf	
	
	If FunName() <> "LOJA057"
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Montando lista de dados  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		oBrowse:SetArray(cAlias)
	    oBrow := oBrowse
	    aTMP := Array(Len(cAlias[1]))
		For nx := 1 to Len(cAlias[1])
			If lLegenda .AND. nx == nPosLeg
				aTMP[nx] := "LoadBitmap(GetResources(),aCores02[cAlias[oBrow:nAt," + cValToChar(nx) + "]][2])"
			Else
				aTMP[nx] := "cAlias[oBrow:nAt," + cValToChar(nx) + "]"
			Endif
		Next nx
		oBrow:bLine := &("{|| {" + Eval({|| cTMP := "", aEval(aTMP,{|x| cTMP += x + ","}), Substr(cTMP,1,Len(cTMP) - 1)}) + "}}")	
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Ordenacao do cabecalho  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	    oBrowse:bHeaderClick := {|oBrw,nCol| LjMntBrwOrd(cAlias,nCol),oBrw:SetFocus(),oBrow:Refresh()}
	Endif 
EndIf
        
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Montagem do cabecalho ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ		
If lDic .AND. nAlias > 0
	dbSelectArea("SX3")
	If lOrdDic
		SX3->(dbSetOrder(1))
		SX3->(dbSeek(cAlias))
		Do While !SX3->(Eof()) .AND. (SX3->X3_ARQUIVO == cAlias)
			If Len(aCampos) == 0
				lUsado := SX3->X3_BROWSE == "S"
			Else
				lUsado := (aScan(aCampos,AllTrim(SX3->X3_CAMPO)) > 0)
			Endif
			If lUsado
				If SX3->X3_CONTEXT == "V"
					oBrowse:AddColumn(TCColumn():New(AllTrim(X3Titulo()),;
						&("{||" + SX3->X3_INIBRW + "}"),;
						AllTrim(SX3->X3_PICTURE),,,;
						IIf(SX3->X3_TIPO == "N","RIGHT","LEFT"),;
						IIf(SX3->X3_TAMANHO > Len(SX3->X3_TITULO),nRefLrg01 + (SX3->X3_TAMANHO * nRefLrg02),nRefLrg01 + (Len(SX3->X3_TITULO) * nRefLrg02)),.F.,.F.,,,,.F.,))
				Else
			       	oBrowse:AddColumn(TCColumn():New(AllTrim(X3Titulo()),;
			       		FieldWBlock(SX3->X3_CAMPO,nAlias),;
			       		AllTrim(SX3->X3_PICTURE),,,;
			       		IIf(SX3->X3_TIPO == "N","RIGHT","LEFT"),;
			       		IIf(SX3->X3_TAMANHO > Len(SX3->X3_TITULO),nRefLrg01 + (SX3->X3_TAMANHO * nRefLrg02),nRefLrg01 + (Len(SX3->X3_TITULO) * nRefLrg02)),.F.,.F.,,,,.F.,))
			 	EndIf
			Endif                                                 
			SX3->(dbSkip())
		EndDo
	Else
		For nx := 1 to Len(aCampos)
			SX3->(dbSetOrder(2))
			If SX3->(dbSeek(Upper(AllTrim(aCampos[nx]))))
				If SX3->X3_CONTEXT == "V"
					oBrowse:AddColumn(TCColumn():New(AllTrim(X3Titulo()),;
						&("{||" + SX3->X3_INIBRW + "}"),;
						AllTrim(SX3->X3_PICTURE),,,;
						IIf(SX3->X3_TIPO == "N","RIGHT","LEFT"),;
						IIf(SX3->X3_TAMANHO > Len(SX3->X3_TITULO),nRefLrg01 + (SX3->X3_TAMANHO * nRefLrg02),nRefLrg01 + (Len(SX3->X3_TITULO) * nRefLrg02)),.F.,.F.,,,,.F.,))
				Else
			       	oBrowse:AddColumn(TCColumn():New(AllTrim(X3Titulo()),;
			       		FieldWBlock(SX3->X3_CAMPO,nAlias),;
			       		AllTrim(SX3->X3_PICTURE),,,;
			       		IIf(SX3->X3_TIPO == "N","RIGHT","LEFT"),;
			       		IIf(SX3->X3_TAMANHO > Len(SX3->X3_TITULO),nRefLrg01 + (SX3->X3_TAMANHO * nRefLrg02),nRefLrg01 + (Len(SX3->X3_TITULO) * nRefLrg02)),.F.,.F.,,,,.F.,))
			 	EndIf			
			Endif
		Next nx
	Endif
	dbSelectArea(cAlias)
Else
	For nx := 1 to Len(aCampos) + IIf(lLegenda, 1, 0)
		If lLegenda .AND. nx == nPosLeg
			aAdd(aColsS,nRefLrg01 + (4 * nRefLrg02))
		Else
			If lLegenda .AND. nPosLeg == 1
				aAdd(aColsS,IIf(aCampos[nx - 1][4] > Len(aCampos[nx - 1][3]),nRefLrg01 + (aCampos[nx - 1][4] * nRefLrg02),nRefLrg01 + (Len(aCampos[nx - 1][3]) * nRefLrg02)))
			Else
				aAdd(aColsS,IIf(aCampos[nx][4] > Len(aCampos[nx][3]),nRefLrg01 + (aCampos[nx][4] * nRefLrg02),nRefLrg01 + (Len(aCampos[nx][3]) * nRefLrg02)))
			Endif
		Endif
	Next nx
	//Largura das colunas
	oBrowse:aColSizes := aColsS
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Coluna congelada  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nBrFreeze > 0
	oBrowse:nFreeze := nBrFreeze
Endif
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Ordenar cabecalho  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nAlias > 0
	If aHeadOrd <> Nil .And. Len(aHeadOrd) > 0
		WndChgOrd(aHeadOrd[1][1],oBrowse,aHeadOrd,cAlias)
	EndIf
Endif
SysRefresh()

Return oBrowse

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LjBrwLine  ºAutor  ³Vendas Clientes       º Data ³09/12/10        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Para objetos TcBrowse com origem de dados baseado em array alimen-º±±
±±º          ³ta o bl.de codigo da lista de campos para apresentacao das linhas º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³Exp01[O] : Nome do objeto do tipo TcBrowse                        º±±
±±º          ³Exp02[C] : Nome da variavel de lista de dados                     º±±
±±º          ³Exp03[C] : Nome da variavel do objeto TcBrowse                    º±±
±±º          ³Exp04[A] : (Opcional) Lista de pictures p/formatacao dos dados    º±±
±±º          ³Exp05[L] : (Opcional) Quando usa formata.remov.espaco de numeros  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³cRet[C] : Expressao formato caracter que devera ser interpretada  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³Generico                                                          º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function LjBrwLine(oBrowse,cNomeLst,cNomeBrw,aLstPict,lRmvEspNum)

Local nx                := 0			//Contador
Local aColsL			:= {}			//Colunas a serem exibidas (origem array)
Local cTMP				:= ""          	//Temporaria
Local nLimite			:= 0			//Limite de campos
Local cRet				:= "{|| }"		//Variavel de retorno
Local lUsaPict			:= .F.			//Utilizar picture

Default cNomeLst		:= ""
Default cNomeBrw		:= ""
Default aLstPict		:= {}
Default lRmvEspNum		:= .T.

If oBrowse == Nil .OR. ValType(oBrowse) # "O" .OR. Upper(AllTrim(oBrowse:cAlias)) # "ARRAY" .OR. Empty(cNomeLst) .OR. ;
	Empty(cNomeBrw) .OR. ValType(aLstPict) # "A"
	
	Return cRet
Endif
cNomeLst 	:= AllTrim(cNomeLst)
cNomeBrw 	:= AllTrim(cNomeBrw)
nLimite		:= Len(oBrowse:aHeaders)
If nLimite == 0
	Return cRet
Endif
If Len(aLstPict) == nLimite
	lUsaPict := !lUsaPict
Endif
//Montar array de linhas para exibicao
For nx := 1 to nLimite
	If !lUsaPict
		aAdd(aColsL,cNomeLst + "[" + cNomeBrw + ":nAt," + cValToChar(nx) + "]")
	Else
		If !Empty(aLstPict[nx])
			//Validar se a mascara eh numerica, para remocao de espacos vazios
			If At("9",aLstPict[nx]) == 0 .OR. !lRmvEspNum
				aAdd(aColsL,"Transform(" + cNomeLst + "[" + cNomeBrw + ":nAt," + cValToChar(nx) + "],'" + aLstPict[nx] + "')")
			Else
				aAdd(aColsL,"AllTrim(Transform(" + cNomeLst + "[" + cNomeBrw + ":nAt," + cValToChar(nx) + "],'" + aLstPict[nx] + "'))")
			Endif
		Else
			aAdd(aColsL,cNomeLst + "[" + cNomeBrw + ":nAt," + cValToChar(nx) + "]")
		Endif
	Endif
Next nx
//Definicao da linha a ser exibida no browse
cTMP := ""
Eval({|| aEval(aColsL,{|x| cTMP += x + ","}),cTMP := Substr(cTMP,1,Len(cTMP) - 1)})
cRet := "{|| {" + cTMP + "}}"

Return cRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³LjAParc     ³ Autor ³ Vendas CRM          ³ Data ³ 23/03/11            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Tela com simulacao das parcelas a serem alteradas apos a              ³±±
±±³          ³ confirmacao da forma de pagamento						             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ LjAParc(ExpN1,ExpA2,ExpN3,ExpD4,ExpC5,ExpN6,ExpC7,ExpN8,ExpL9,ExpN10) ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametro ³ ExpN1  - Variavel que verifica se utiliza ou nao nas proximas parcelas³±±
±±³          ³ ExpA2  - Temp da aPgtos    								             ³±±
±±³          ³ ExpN3  - Valor a ser pago em cartao de credito			             ³±±
±±³          ³ ExpD4  - Data base para soma dos vencimentos				             ³±±
±±³          ³ ExpC5  - Forma de pagamento CC ou CD						             ³±±
±±³          ³ ExpN6  - Linha que o usuario esta alterando       		             ³±±
±±³          ³ ExpC7  - Lista as administradoras financeiras       		             ³±±
±±³          ³ ExpN8  - Intervalor em dias entre as parcelas       		             ³±±
±±³          ³ ExpL9  - Valor do parametro MV_LJJURCC            		             ³±±
±±³          ³ ExpN10 - Verifica se utiliza mais de um cartao na venda	             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T.										          	                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³ LOJXFUNA													             ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/                                   
Function LjAParc( nUtilPar, aTmpPgtos	, nValor	, dDataForm	,;
				  cForma  , nLinha		, cComboAdm	, nIntervalo,;
				  lMvJurCc, nIdCartao	)

Local aParTmp	:= {} 					//Array para gravar as parcelas
Local aParBrw	:= {}					//Registros do browser
Local nX		:= 0 					//Variavel para o laco FOR  
Local aHeaders	:= {STR0111, STR0112} 	//Descricao das colunas do browser "Data", "Valor"
Local aTamHead  := {70,30} 				//Definicao e tamanho das colunas do browser
Local cCodAdm	:= ""					//Codigo da administradora
Local nTxJurAdm	:= 0					//Porcentagem de juros 
Local nVrSJuros	:= 0					//Valor total sem juros
Local nVrJuros	:= 0					//Valor do juros 
Local nCont		:= 0					//Contador de parcelas
Local nTotVen	:= 0					//Total da venda
                                  
Default nUtilPar 		:= 1
Default aTmpPgtos		:= {}  
Default nValor			:= 0
Default dDataForm		:= cToD("  /  /  ")
Default cForma			:= ""
Default nLinha			:= 0
Default cComboAdm		:= ""
Default nIntervalo	:= 0
Default lMvJurCc		:= .F.
Default nIdCartao		:= 0

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Cod da administradora   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cCodAdm += SubStr(cComboAdm,1,3)         

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Captura a porcentagem de juros ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If FindFunction("Fr272ATxAd") .AND. (cForma $ _FORMATEF)
	Fr272ATxAd( cCodAdm, nUtilPar, @nTxJurAdm, cForma,;
		 	 	lMvJurCc)
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Caso a administradora escolhida tenha juros, mostra a tela de simulacao   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If (nTxJurAdm > 0) .AND. (Len(aTmpPgtos) > 0)

	aParTmp := Aclone(aTmpPgtos)
	                 
    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Soma o valor total pago em CC ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ         
	For nX := 1 To Len(aParTmp)
		If (aParTmp[nX][3] $ _FORMATEF)
			nVrSJuros += aParTmp[nX][2]
		EndIf				
		nTotVen += aParTmp[nX][2]
	Next nX 	
	
	If (nUtilPar > 1)                    				  
		
		aParTmp[nLinha][2] := nValor       
		nLinha += 1
	
	    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Quantas parcelas existe apos a linha ³ 
		//³ que o usuario esta alterando         ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ         	
		For nX := nLinha To Len(aParTmp)
			If (aParTmp[nX][3] $ _FORMATEF)
				nCont += 1
			EndIf				
		Next nX            
		
	    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Divide o valor que resta nas outras parcelas ³ 
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ         	
		nVrSJuros := nVrSJuros - nValor				 
		
		For nX := nLinha To Len(aParTmp)
			If (aParTmp[nX][3] $ _FORMATEF)
				aParTmp[nX][2] := A410Arred(nVrSJuros / nCont, "L2_VRUNIT")
			EndIf				
		Next nX
		
		nLinha -= 1
		
	    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atribuindo juros as parcelas ³ 
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ         			
		For nX := nLinha To Len(aParTmp)
			If (aParTmp[nX][3] $ _FORMATEF)
				nVrJuros 		+= A410Arred(aParTmp[nX][2] * nTxJurAdm / 100, "L2_VRUNIT")
				aParTmp[nX][2] 	+= A410Arred(aParTmp[nX][2] * nTxJurAdm / 100, "L2_VRUNIT")
			EndIf				
		Next nX		
						 
	Else
	    //ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Atribuindo juros a parcela ³ 
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ  
		nVrJuros			:= A410Arred(nValor * nTxJurAdm / 100, "L2_VRUNIT")
		aParTmp[nLinha][2] 	:= A410Arred(nValor, "L2_VRUNIT") 		         				                                
		aParTmp[nLinha][2]	+= A410Arred(aParTmp[nLinha][2] * nTxJurAdm / 100, "L2_VRUNIT")
		
	EndIf		                                        
                                            
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Cria um array temporario para calculo das parcelas ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nCont := 1
	If nUtilPar > 1
		For nX := nLinha To Len(aParTmp)
			AAdd(aParBrw, {dDataForm + If(nCont = 1, 0, nIntervalo * (nCont - 1)), aParTmp[nX][2]})
			nCont += 1
		Next nX
	Else
		AAdd(aParBrw, {aParTmp[nLinha][1], aParTmp[nLinha][2]})
	EndIf
	   
	DEFINE MSDIALOG oDlgTx FROM 0,0 TO 330,402 PIXEL TITLE STR0172 //"Simulacao de Parcelas com Juros em Cartão de Credito"
	DEFINE SBUTTON FROM 145,173 TYPE 1 ACTION (oDlgTx:End()) ENABLE OF oDlgTx	

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Criando um novo browser para simulacao das parcelas  ³
	//ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 		                                   
	oBrowseTx := TCBrowse():New( 5,5,194,130, ,aHeaders,aTamHead,;
	                oDlgTx,,,,,{||},,,,,,,.F.,,.T.,,.F.,,,)	

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Setando o conteudo do array temporario para o browser ³
	//ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 		                                   			
	oBrowseTx:SetArray(aParBrw)                               
	oBrowseTx:bLine := {||{ aParBrw[oBrowseTx:nAt,1],TRANSFORM(aParBrw[oBrowseTx:nAt,2],PesqPict("SL2", "L2_VRUNIT")) } }	

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Cria label Taxa de Juros   ³
	//ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ		
	@ 138, 5 SAY STR0173 PIXEL OF oDlgTx 																//Taxa de Juros..:
	@ 138, 80 SAY nTxJurAdm PICTURE "@E 99.99%" PIXEL RIGHT SIZE 28,0 OF oDlgTx        

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Cria label Total sem Juros ³
	//ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ			                					
	@ 148, 5 SAY STR0174 PIXEL OF oDlgTx 																//Total sem Juros:
	@ 148, 80 SAY nTotVen PICTURE PesqPict("SL2", "L2_VRUNIT") COLOR CLR_HBLUE PIXEL RIGHT SIZE 28,0 OF oDlgTx

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Cria label Total com Juros ³
	//ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ			                						
	@ 156, 5 SAY STR0175 PIXEL OF oDlgTx 																//Total com Juros:
	@ 156, 80 SAY A410Arred(nTotVen + nVrJuros, "L2_VRUNIT") PICTURE PesqPict("SL2", "L2_VRUNIT") COLOR CLR_HRED PIXEL RIGHT SIZE 28,0 OF oDlgTx
					
	ACTIVATE MSDIALOG oDlgTx CENTERED
	
	oDlgTx		:= NIL   
	oBrowseTx	:= NIL 
	
EndIf
	 		                                                                                                    	
Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LjMntBrwOrdºAutor  ³Vendas Clientes       º Data ³09/01/11        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Funcao auxiliar do componente LjMntBrw, para classificacao de da- º±±
±±º          ³dos originados em array.                                          º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³Exp01[A] : Array de dados                                         º±±
±±º          ³Exp02[C] : Posicao da coluna a ser classificada                   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³Nenhum                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³Generico                                                          º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function LjMntBrwOrd(aDados,nPos)

Default aDados         := {}
Default nPos			:= 0

If ValType(aDados) # "A" .OR. Len(aDados) == 0 .OR. ValType(nPos) # "N" .OR. nPos <= 0
	Return Nil
Endif
aSort(aDados,,,{|x,y| x[nPos] < y[nPos]})

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LjModelo3 ºAutor  ³Vendas Clientes       º Data ³16/02/11         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Funcao para montagem de tela no modelo 03                         º±±
±±º          ³                                                                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³Exp01[C] : Titulo da janela                                       º±±
±±º          ³Exp02[C] : Alias para a enchoice                                  º±±
±±º          ³Exp03[C] : Alias para a getdados                                  º±±
±±º          ³Exp04[A] : Campos da enchoice                                     º±±
±±º          ³Exp05[C] : Funcao de validacao de linha                           º±±
±±º          ³Exp06[C] : Funcao de validacao da getdados                        º±±
±±º          ³Exp07[N] : Modo de edicao da enchoice                             º±±
±±º          ³Exp08[N] : Modo de edicao da getdados                             º±±
±±º          ³Exp09[C] : Funcao de validacao de campos                          º±±
±±º          ³Exp10[L] : Indica se utiliza var de memo ou campos da tabela      º±±
±±º          ³Exp11[N] : Numero de linhas da getdados                           º±±
±±º          ³Exp12[A] : Campos editaveis da enchoice                           º±±
±±º          ³Exp13[A] : Campos editaveis da getdados                           º±±
±±º          ³Exp14[A] : Coordenadas da tela                                    º±±
±±º          ³Exp15[A] : Coordenadas da enchoice                                º±±
±±º          ³Exp16[A] : Coordenadas da getdados                                º±±
±±º          ³Exp17[L] : Valid. da primeira coluna do aCols nao pode estar vaziaº±±
±±º          ³Exp18[C] : Funcao de validacao da enchoice                        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³                                                                  º±±
±±º          ³                                                                  º±±
±±º          ³                                                                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³Generico                                                          º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function LjModelo3(	cTitulo	,cAlias1	,cAlias2	,aMyEncho		,;
					cLinOk	,cTudoOk	,nOpcE		,nOpcG			,;
					cFieldOk,lMemo		,nLinhas	,aAltEnchoice	,;
					aAlter	,aTamTela	,aTamEN		,aTamGD			,;
					lVazio	,cTudoOkE	)
						
Local lRet             	:= .F.
Local nOpca 			:= 0
Local nReg				:= IIf(Select(cAlias1) == 0,0,(cAlias1)->(Recno()))
Local oDlg              
Local oEnch
Local oGetDados
Local aSize				:= FWGetDialogSize(oMainWnd)

Private lRefresh		:= .T.
Private aTela			:= Array(0,0)
Private aGets			:= Array(0)
Private bCampo			:= {|nCPO| Field(nCPO)}
Private nPosAnt			:= 9999
Private nColAnt			:= 9999
Private nPosAtu			:= 0
Private cSavScrVT
Private cSavScrVP
Private cSavScrHT
Private cSavScrHP
Private CurLen

Default cTitulo			:= ""
Default cAlias1			:= ""
Default cAlias2			:= ""
Default aMyEncho		:= {}
Default cLinOk			:= "AllwaysTrue()"
Default cTudoOk			:= "AllwaysTrue()"
Default cFieldOk		:= "AllwaysTrue()"
Default nOpcE			:= 3
Default nOpcG			:= 3
Default lMemo			:= .F.					//Indica se a enchoice utilizará variáveis de memória ou os campos da tabela na edição
Default nLinhas			:= 99
Default aAltEnchoice	:= {}
Default aAlter			:= {}
Default aTamTela		:= {000,000,aSize[3] * 0.9,aSize[4] * 0.6}		
Default aTamEN			:= {001,;											//Top
							001,;											//Left
							Int(((aTamTela[3] / 2) * 0.95) * 0.4),;		//Bottom
							Int((aTamTela[4] / 2))}						//Right
Default aTamGD			:= {Int(((aTamTela[3] / 2) * 0.95) * 0.45),;		//Top
							001,;											//Left
							Int((aTamTela[3] / 2) * 0.95),;				//Bottom
							Int((aTamTela[4] / 2))}						//Right
Default lVazio			:= .F.
Default cTudoOkE		:= cTudoOk

//Validar variaveis
If Empty(cTitulo) .OR. Empty(cAlias1) .OR. Empty(cAlias2) .OR. ValType(aMyEncho) # "A" .OR. ValType(aAltEnchoice) # "A" .OR. ;
	Len(aMyEncho) == 0 .OR. Len(aAltEnchoice) == 0

	Return lRet
Endif
//Montar tela
DEFINE MSDIALOG oDlg TITLE cTitulo FROM aTamTela[1],aTamTela[2] TO aTamTela[3],aTamTela[4] OF oMainWnd PIXEL 

oEnch := MsMGet():New(cAlias1,nReg,nOpcE,,,,aMyEncho,aTamEN,aAltEnchoice,3,,,cTudoOkE,oDlg,.F.,lMemo,.F.,"",.F.,.F.)
oEnch:oBox:Align := CONTROL_ALIGN_TOP
oGetDados := MsGetDados():New(aTamGD[1],aTamGD[2],aTamGD[3],aTamGD[4],nOpcG,cLinOk,cTudoOk,"",.T.,aAlter,000,lVazio,nLinhas,cFieldOk,,,,oDlg)
oGetDados:oBrowse:nFreeze := 0
//oDlg:bInit := EnchoiceBar(oDlg,{|| nOpca := 1,IIf(Eval({||&(cTudoOkE)}),IIf(!Obrigatorio(aGets,aTela),nOpca := 0,oDlg:End()),nOpca := 0)},{||oDlg:End()}) 
oDlg:lCentered := .T.       

ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{|| nOpca := 1,IIf(Eval({||&(cTudoOkE)}),IIf(!Obrigatorio(aGets,aTela),nOpca := 0,oDlg:End()),nOpca := 0)},{||oDlg:End()}) 

//ACTIVATE MSDIALOG oDlg ON INIT 

lRet := (nOpca == 1)

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LjUpd78Ok ºAutor  ³Vendas Clientes       º Data ³17/02/11     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Funcao que verifica se todas as tabelas e campos criados pelo º±±
±±º          ³UPDLOJA77, necessarios para o funcionamento da lista de pre-  º±±
±±º          ³sentes.                                                       º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³                                                              º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function LjUpd78Ok()
Local lRet			:= .T.																				//Retorno
Local lOnline		:= Select("SX2") > 0 .AND. Select("SX3") > 0 .AND. Select("SX6") > 0				//Conexao online
Local lTop			:= .T.
Local lMvLjPdvPa	:= .F.																				//PDV?

lMvLjPdvPa := FindFunction("LjxBGetPaf") .AND. LjxBGetPaf()[2]
#IFNDEF TOP
	//Se o modulo ativo for SIGAFRT, permitir o uso
	If !AmIIn(23)
		//Se nao for PDV
		If !lMvLjPdvPa
			lTop := !lTop
		Endif
	Endif
#ELSE
	If Upper(AllTrim(TcSrvType())) == "AS/400"
		lTop := !lTop
	Endif
#ENDIF
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Caso a funcao seja chamada por um job e os arquivos SXs  ³
//³não estejam disponiveis para validacao, retornar falso.  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lOnline .OR. !lTop
	lRet := .F.
	Return lRet
Endif

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LjExibeTextoºAutor  ³Vendas Clientes       º Data ³17/02/11       º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Funcao para exibicao de texto ou resultado de processamento.      º±±
±±º          ³                                                                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³Exp01[C] : Titulo da janela                                       º±±
±±º          ³Exp02[C] : Mensagem a ser exibida na tGet                         º±±
±±º          ³Exp03[L] : Exibir botao para salvar conteudo em arquivo?          º±±
±±º          ³Exp04[N] : Percentual de largura a ser utilizada                  º±±
±±º          ³Exp05[N] : Percentual de altura a ser utilizada                   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³Generico                                                          º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function LjExibeTexto(cTitulo, cMens, lBotSalvar, nPercLarg, nPercAlt)

Local cArq				:= ""
Local cTipoArq    		:= "Arquivos Texto (*.TXT) |*.txt|"
Local lOnLine			:= !(Select("SX6") == 0) .AND. Type("oMainWnd") == "O"
Local aTamObjLJT		:= Array(4)
Local aTMPLJT			:= {}
Local nCoefRedT			:= 1
Local oTelaLJT	
Local oMemoLJT
Local oFontLJT
Local oBot01LJT
Local oBot02LJT

Static nBotAltLJT		:= 012
Static nBotLargLJT		:= 030
Static nDist01LJT		:= 002

Default cTitulo			:= ""
Default cMens			:= ""
Default lBotSalvar		:= .T.
Default nPercLarg		:= 0.6
Default nPercAlt		:= 0.7

If Empty(cTitulo) .OR. PCount() > 5
	Return Nil
Endif
If nPercLarg > 1 ; Eval({|| nPercLarg := nPercLarg / 100,IIf(nPercLarg > 1,nPercLarg := 1,nPercLarg := nPercLarg)}) ; Endif
If nPercAlt > 1 ; Eval({|| nPercAlt := nPercAlt / 100,IIf(nPercAlt > 1,nPercAlt := 1,nPercAlt := nPercAlt)}) ; Endif

If lOnline .AND. FindFunction("FWGetDialogSize")
	aTMPLJT			:= FWGetDialogSize(oMainWnd)
	aTamObjLJT[1] 	:= aTMPLJT[1]
	aTamObjLJT[2] 	:= aTMPLJT[2]
	aTamObjLJT[3] 	:= aTMPLJT[3] * nPercAlt
	aTamObjLJT[4] 	:= aTMPLJT[4] * nPercLarg
Else
	aTamObjLJT[1] 	:= 003
	aTamObjLJT[2] 	:= 000
	aTamObjLJT[3] 	:= 500
	aTamObjLJT[4] 	:= 658
Endif
//ÚÄÄÄÄÄÄÄÄÄÄÄ¿
//³Interface  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÙ
DEFINE FONT oFontLJT NAME "ARIAL" SIZE 06,16
DEFINE MSDIALOG oTelaLJT TITLE cTitulo FROM aTamObjLJT[1],aTamObjLJT[2] TO aTamObjLJT[3],aTamObjLJT[4] PIXEL
//Dimensoes do objeto - MEMO - TOP|LEFT|WIDTH|HEIGHT
aTMPLJT := aClone(aTamObjLJT)
aTamObjLJT[1] := nDist01LJT
aTamObjLJT[2] := nDist01LJT
aTamObjLJT[3] := Int((aTMPLJT[4] / 2) * 0.995)
aTamObjLJT[4] := Int((((aTMPLJT[3] / 2) * 0.99) - (nBotAltLJT + (nDist01LJT * 2))) * nCoefRedT)
@aTamObjLJT[1],aTamObjLJT[2] GET oMemoLJT VAR cMens MEMO SIZE aTamObjLJT[3],aTamObjLJT[4] OF oTelaLJT PIXEL READONLY
oMemoLJT:bRClicked := {|| AllwaysTrue()}
oMemoLJT:oFont := oFontLJT 
//Dimensoes do objeto - BOTOES - TOP|WIDTH|HEIGHT|LEFT
aTamObjLJT[1] := Int((oMemoLJT:nBottom / 2) + nDist01LJT)
aTamObjLJT[3] := 030
aTamObjLJT[4] := 012
aTamObjLJT[2] := Int(((oMemoLJT:nLeft + oMemoLJT:nWidth) / 2) - aTamObjLJT[3])
//Botao - OK
oBot01LJT := tButton():New(aTamObjLJT[1],aTamObjLJT[2],"OK",oTelaLJT,{|| oTelaLJT:End()},aTamObjLJT[3],aTamObjLJT[4],,/*Font*/,,.T.,,,,/*When*/)
//Botao - Salvar
If lBotSalvar
	aTamObjLJT[2] := Int(((oBot01LJT:nLeft / 2) - aTamObjLJT[3]) - 2)
	oBot02LJT := tButton():New(aTamObjLJT[1],aTamObjLJT[2],STR0206,oTelaLJT,{|| cArq := cGetFile(cTipoArq,""),IIf(Empty(cArq),.T.,MemoWrite(cArq,cMens))},aTamObjLJT[3],aTamObjLJT[4],,/*Font*/,,.T.,,,,/*When*/)
Endif
oTelaLJT:lMaximized := .F.
oTelaLJT:lCentered := .T.
oTelaLJT:Activate()

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³ArrTokStr ºAutor  ³Vendas Cliente        º Data ³11/03/11         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Converte o conteudo de uma array mono-dimensional em string       º±±
±±º          ³                                                                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³Exp01[A] : Array a ser convertida em string                       º±±
±±º          ³Exp02[C] : Delimitador de elementos da array                      º±±
±±º          ³Exp03[N] : Numero de caracteres por linha (caso deseje quebra)    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³Generico                                                          º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function ArrTokStr(aStr,cDelimita,nTamLin)

Local cResp				:= ""						//Resultado
Local cLinha			:= ""
Local ni				:= 0						//Contador
Local nx				:= 0						//Contador 02
Local nz				:= 0						//Contador 03
Local nLimite			:= 1
Local uTMP				:= ""						//Valor de elemento
Local cDSTR				:= ""						//Delimitador de string a ser utilizado
Local cAspD				:= CHR(34)					//Aspas dupla
Local cAspS				:= CHR(39)					//Aspas simples

Default aStr			:= {}
Default cDelimita		:= "|"
Default nTamLin		:= 0						

If ValType(aStr) # "A" .OR. Len(aStr) == 0 .OR. ValType(cDelimita) # "C" .OR. ValType(nTamLin) # "N"
	Return cResp
Endif
For ni := 1 to Len(aStr)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Tratamento de array - Nivel 02  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ValType(aStr[ni]) == "A" 
		If Len(aStr[ni]) > 0
			cResp += "{"
			For nx := 1 to Len(aStr[ni])
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Tratamento de array - Nivel 03  ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If ValType(aStr[ni][nx]) == "A" 
					If Len(aStr[ni][nx]) > 0
						cResp += "{"
						For nz := 1 to Len(aStr[ni][nx])
							uTMP := aStr[ni][nx][nz]
							cDSTR := IIf(ValType(uTMP) == "C",IIf(At(cAspD,uTMP) > 0,cAspS,cAspD),cAspD)
							uTMP := IIf(ValType(uTMP) == "C",cDSTR + IIf(Empty(uTMP),Space(1),uTMP) + cDSTR,uTMP)
							cResp += IIf(ValType(uTMP) # "N",AllToChar(uTMP),AllTrim(AllToChar(uTMP))) + ;
								IIf(nz < Len(aStr[ni][nx]),",","")
						Next nz
						cResp += "}" + IIf(nx < Len(aStr[ni]),",","")
					Else
						cResp += "{}"
					Endif
				Else
					uTMP := aStr[ni][nx]
					cDSTR := IIf(ValType(uTMP) == "C",IIf(At(cAspD,uTMP) > 0,cAspS,cAspD),cAspD)
					uTMP := IIf(ValType(uTMP) == "C",cDSTR + IIf(Empty(uTMP),Space(1),uTMP) + cDSTR,uTMP)				
					cResp += IIf(ValType(uTMP) # "N",AllToChar(uTMP),AllTrim(AllToChar(uTMP))) + IIf(nx < Len(aStr[ni]),",","")
				Endif
			Next nx
			cResp += "}" + IIf(ni < Len(aStr),cDelimita,"")
			Loop
		Else
			cResp += "{}" + IIf(ni < Len(aStr),cDelimita,"")
			Loop
		Endif
	Endif
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Tratamento para outros tipos de dados  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	uTMP := aStr[ni]
	uTMP := IIf(ValType(uTMP) == "C",IIf(Empty(uTMP),Space(1),uTMP),uTMP)	
	cLinha := IIf(ValType(uTMP) # "N",AllToChar(uTMP),AllTrim(AllToChar(uTMP)))
	If nTamLin > 0
		nInicio := 1
		If Len(cLinha) > nTamLin
			nLimite := Int(Len(cLinha) / nTamLin) + 1
		Else
			nLimite := 1
		Endif
		If nLimite == 1
			cResp += cLinha + CRLF
		Else
			For nx := 1 to nLimite
				cResp += Substr(cLinha,(1 + (nTamLin * nx)),nTamLin) + CRLF
				nInicio += nTamLin
			Next nx	
		Endif		
	Else
		cResp += cLinha + IIf(ni < Len(aStr),cDelimita,"")
	Endif
Next ni

Return cResp

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LjEnvEmLP ºAutor  ³Vendas Cliente        º Data ³14/03/11         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Funcao de envio de e-mail da lista de presentes.                  º±±
±±º          ³                                                                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³Exp01[A] : Array a ser convertida em string                       º±±
±±º          ³Exp02[C] : Delimitador de elementos da array                      º±±
±±º          ³Exp03[N] : Numero de caracteres por linha (caso deseje quebra)    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³Generico                                                          º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function LjEnvEmLP(cNumLst,cNumOrc)

Local lRet				:= .T.													//Retorno
Local lLstPre			:= SuperGetMV("MV_LJLSPRE",.T.,.F.) .AND. LjUpd78Ok()	//Lista de presente ativa?
Local aArea				:= {}
Local aTabs				:= {"ME1","ME2","ME4","SU5","MEE","SL2"}				//Lista de tabelas para controle de area
Local aEmailO			:= {}													//Lista de e-mails do organizador e atores
Local aEmailP			:= {}													//E-mail do comprador
Local cQry				:= ""													//Query de consulta
Local cAlias			:= GetNextAlias()										//Alias para a consulta 01
Local cAlias02			:= GetNextAlias()										//Alias para a consulta 02
Local lLPresOk			:= LjUpd78Ok()	//Validacao de aplicacao do pacote
Local cTMP				:= ""													//String temporaria
Local aTMP				:= {}													//Array temporario
Local ni				:= 0													//Contador
Local nPos				:= 0													//Posicionador
Local lOk				:= .T.													//Controle de fluxo
Local cLinkLOGO			:= SuperGetMV("MV_LINKLOG",.F.,"")						//Link do logo da empresa
Local cChave			:= ""													//Chave de pesquisa
Local aLstMens			:= {}													//Lista de mensagens levantada a partir da SL2
Local cEmlDest			:= ""													//E-mails de destino
Local cTitulo			:= "Lista de presentes - Alerta de compra"				//Titulo da mensagem e do assunto do e-mail
Local cRotina			:= "[LOJXFUNA:LjEnvEmLP] "								//Nome da rotina
Local cCabec			:= ""													//Cabecalho da mensagem
Local aLstOrc			:= {}													//Lista de orcamentos
//Variaveis de conectividade de e-mail
Local cSMTPUsu 			:= SuperGetMV("MV_RELAUSR",.F.,"")						//Usuario de autenticacao SMTP
Local cConta 			:= SuperGetMV("MV_RELACNT",.F.,"")
Local cServ 			:= SuperGetMV("MV_RELSERV",.F.,"")
Local cSenha 			:= SuperGetMV("MV_RELPSW",.F.,"")
Local lSMTPAut			:= SuperGetMV("MV_RELAUTH",.F.,.F.)
Local lTLS				:= SuperGetMV("MV_RELTLS ",.F.,.F.)
Local nTOUT				:= SuperGetMV("MV_RELTIME",.F.,120)					//Time-Out
Local cPorta			:= ""													//Porta SMTP
Local cErro				:= ""													//Retorno de erro do envio de mensagem

Default cNumLst			:= ""
Default cNumOrc			:= ""

PARAMTYPE 0 Var cNumLst		AS Character	DEFAULT ""
PARAMTYPE 1 Var cNumOrc		AS Character	DEFAULT ""

If !lLstPre .OR. Empty(cConta) .OR. Empty(cServ) .OR. Empty(cSenha)
	//Alerta de erro e instrucoes ao usuario para indicar parametros necessarios e seus valores jah definidos
	ConOut(cRotina + STR0152)
	ConOut(cRotina + STR0153)
	ConOut(cRotina + "MV_RELAUSR - " + AllToChar(cSMTPUsu))
	ConOut(cRotina + "MV_RELACNT - " + AllToChar(cConta))
	ConOut(cRotina + "MV_RELSERV - " + AllToChar(cServ))
	ConOut(cRotina + "MV_RELPSW - " + AllToChar(cSenha))
	ConOut(cRotina + "MV_RELAUTH - " + AllToChar(lSMTPAut))
	ConOut(cRotina + "MV_RELTLS - " + AllToChar(lTLS))
	ConOut(cRotina + "MV_RELTIME - " + AllToChar(nTOUT))
	Return !lRet
Endif
//Armazenando dados da area de trabalho
For ni := 1 to Len(aTabs)
	aAdd(aArea,(aTabs[ni])->(GetArea()))
Next ni
//Separar servidor x porta
If (nPos := At(":",cServ)) > 0
	cPorta := Substr(cServ,nPos + 1,Len(cServ))
	cServ := Substr(cServ,1,nPos - 1)
Endif
cNumLst := PadR(AllTrim(cNumLst),TamSX3("ME1_CODIGO")[1])
cNumOrc := PadR(AllTrim(cNumOrc),TamSX3("ME4_NUMORC")[1])
dbSelectArea("ME1")
ME1->(dbSetOrder(2))
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Levantar lista de e-mails - Organizador ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cQry := "SELECT DISTINCT ME1.ME1_FILIAL, ME1.ME1_CODIGO, ME1.ME1_TIPO, ME1.ME1_CODCLI, ME1.ME1_LOJCLI, ME1.ME1_CONTAT, ME1.ME1_DTEVEN, ME1.ME1_NOME, "
cQry += "ME1.ME1_TPEVEN, ME1.ME1_ALERTA, ME1.ME1_CODMEN, "
cQry += "(SELECT SA1.A1_EMAIL FROM " + RetSQLName("SA1") + " SA1 "
cQry += "WHERE " + RetSQLDel("SA1") + " AND SA1.A1_FILIAL = '" + xFilial("SA1") + "' "
cQry += "AND SA1.A1_COD = ME1.ME1_CODCLI AND SA1.A1_LOJA = ME1.ME1_LOJCLI) AS EMAIL01, "
cQry += "(SELECT SU5.U5_EMAIL FROM " + RetSQLName("SU5") + " SU5 "
cQry += "WHERE " + RetSQLDel("SU5") + " AND SU5.U5_FILIAL = '" + xFilial("SU5") + "' "
cQry += "AND SU5.U5_CODCONT = ME1.ME1_CONTAT) AS EMAIL02 "
cQry += "FROM " + RetSQLName("ME1") + " ME1 "
cQry += "WHERE " + RetSQLDel("ME1") + " "
If SX2Modo("ME1") == "E"
	cQry += "AND ME1.ME1_FILIAL = '" + xFilial("ME1") + "' "
Endif
cQry += "AND ME1.ME1_CODIGO = '" + cNumLst + "' "
cQry += "ORDER BY " + SqlOrder(ME1->(IndexKey()))
dbUseArea(.T.,__cRDD,TcGenQry(,,ChangeQuery(cQry)),cAlias,.T.,.F.)
(cAlias)->(dbGoTop())
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Sair, caso :                                            ³
//³1. Nenhum registro tenha sido encontrado                ³
//³2. A lista nao esta configurado para alerta de compras  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If (cAlias)->(Eof()) .OR. (cAlias)->ME1_ALERTA == "2"
	FechaArqT(cAlias)
	//Restaurando a area de trabalho
	aEval(aArea,{|x| RestArea(x)})
	Return !lRet
Endif
//Ajusta a estrutura dos campos necessarios da Query
TcSetField( cAlias, "ME1_DTEVEN", "D", 8, 0 )

//Email SA1
cTMP := Lower(AllTrim((cAlias)->(FieldGet(FieldPos("EMAIL01")))))
If !Empty(cTMP)
	aAdd(aEmailO,cTMP)
Endif
//Email SU5
cTMP := Lower(AllTrim((cAlias)->(FieldGet(FieldPos("EMAIL02")))))
If !Empty(cTMP) .AND. aScan(aEmailO,{|x| Lower(AllTrim(x)) == cTMP}) == 0
	aAdd(aEmailO,cTMP)
Endif
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Levantar lista de e-mails - Atores  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cChave := xFilial("MEE") + cNumLst
dbSelectArea("MEE")
MEE->(dbSetOrder(1))	//MEE_FILIAL+MEE_CODLIS+MEE_CODATO
MEE->(dbSeek(cChave))
Do While !MEE->(Eof()) .AND. MEE->(MEE_FILIAL + MEE_CODLIS) == cChave
	If !Empty(MEE->MEE_EMAIL)
		cTMP := Lower(AllTrim(MEE->MEE_EMAIL))
		If aScan(aEmailO,{|x| Lower(AllTrim(x)) == cTMP}) == 0
			aAdd(aEmailO,cTMP)
		Endif
	Endif
	aAdd(aTMP,MEE->MEE_NOME)
	MEE->(dbSkip())
EndDo
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Levantar lista de e-mails - Presenteador³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("ME4")
ME4->(dbSetOrder(1))	//ME4_FILIAL+ME4_CODIGO+ME4_ITLST+ME4_SEQ
cQry := "SELECT DISTINCT ME4.ME4_FILIAL, ME4.ME4_CODIGO, ME4.ME4_ITLST, ME4.ME4_SEQ, ME4.ME4_QUANT, ME4.ME4_CODCLI, ME4.ME4_LOJCLI, ME4.ME4_NOMCLI, ME4.ME4_COD, "
cQry += "ME4.ME4_NUMORC, ME4.ME4_ITORC, "
cQry += "(SELECT SA1.A1_EMAIL FROM " + RetSQLName("SA1") + " SA1 "
cQry += "WHERE " + RetSQLDel("SA1") + " AND SA1.A1_FILIAL = '" + xFilial("SA1") + "' "
cQry += "AND SA1.A1_COD = ME4.ME4_CODCLI AND SA1.A1_LOJA = ME4.ME4_LOJCLI) AS EMAIL "
cQry += "FROM " + RetSQLName("ME4") + " ME4 "
cQry += "INNER JOIN " + RetSQLName("SL2") + " SL2 ON SL2.L2_CODLPRE = ME4.ME4_CODIGO AND SL2.L2_NUM = ME4.ME4_NUMORC "
cQry += "WHERE " + RetSQLDel("ME4") + " "
If SX2Modo("ME4") == "E"
	cQry += "AND ME4.ME4_FILIAL = '" + xFilial("ME4") + "' "
Endif
cQry += "AND ME4.ME4_NUMORC = '" + cNumOrc + "' AND ME4.ME4_TIPO = '1' " 
cQry += "AND ME4.ME4_CODIGO = '" + cNumLst + "' "
cQry += "ORDER BY " + SqlOrder(ME4->(IndexKey()))
dbUseArea(.T.,__cRDD,TcGenQry(,,ChangeQuery(cQry)),cAlias02,.T.,.F.)
(cAlias02)->(dbGoTop())
If (cAlias02)->(Eof())
	FechaArqT(cAlias)
	FechaArqT(cAlias02)
	//Restaurando a area de trabalho
	aEval(aArea,{|x| RestArea(x)})
	Return !lRet
Endif
//Ajusta a estrutura dos campos necessarios da Query
TcSetField( cAlias02, "ME4_QUANT", "N", TamSX3("ME4_QUANT")[1], TamSX3("ME4_QUANT")[2] )

Do While !(cAlias02)->(Eof())
	//Email SA1 - Presenteador
	cTMP := Lower(AllTrim((cAlias02)->(FieldGet(FieldPos("EMAIL")))))
	If !Empty(cTMP) .AND. aScan(aEmailP,{|x| Lower(AllTrim(x)) == cTMP}) == 0
		aAdd(aEmailP,cTMP)
	Endif
	//Montar a lista de orcamento para a busca das mensagens no SYP
	aAdd(aLstOrc,{(cAlias02)->ME4_NUMORC,(cAlias02)->ME4_ITORC})
	(cAlias02)->(dbSkip())
EndDo
(cAlias02)->(dbGoTop())
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Validar e-mails ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lOk := .F.
If Len(aEmailO) > 0
	aEval(aEmailO,{|x| IIf(At("@",x) > 0 .AND. !lOk,lOk := !lOk,.T.)})
Endif
If lOk .AND. Len(aEmailP) > 0
	lOk := .F.
	aEval(aEmailP,{|x| IIf(At("@",x) > 0 .AND. !lOk,lOk := !lOk,.T.)})
Endif
If !lOk
	FechaArqT(cAlias)
	FechaArqT(cAlias02)
	//Restaurando a area de trabalho
	aEval(aArea,{|x| RestArea(x)})
	Return !lRet
Endif
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Levantar os codigos de mensagens do presenteador SL2 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Len(aLstOrc) > 0
	For ni := 1 to Len(aLstOrc)
		dbSelectArea("SL2")
		SL2->(dbSetOrder(1))	//L2_FILIAL+L2_NUM+L2_ITEM+L2_PRODUTO
		If SL2->(dbSeek(xFilial("SL2") + PadR(aLstOrc[ni][1],TamSX3("L2_NUM")[1]) + PadR(aLstOrc[ni][2],TamSX3("L2_ITEM")[1])))
			If !Empty(SL2->L2_MSMLPRE) .AND. aScan(aLstMens,{|x| AllTrim(x) == AllTrim(SL2->L2_MSMLPRE)}) == 0
				aAdd(aLstMens,SL2->L2_MSMLPRE)
			Endif
		Endif
	Next ni
Endif
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Envio 01 - Mensagem de alerta  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//HEADER
cCabec := '<html><head>' + CRLF
cCabec += '<title>' + STR0154 + '</title>' + CRLF
cCabec += '<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">' + CRLF
cCabec += '</head>' + CRLF
//FORM
cCabec += '<form name="FORM">' + CRLF
cCabec += '<div align="center">' + CRLF
cCabec += '<table background="" border="0" cellpadding="0" cellspacing="0" width="100%">' + CRLF
cCabec += '<tbody>' + CRLF
cCabec += '<tr>' + CRLF
cCabec += '<td height="84">' + CRLF
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³CABECALHO PRINCIPAL  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cCabec += '<table border="0" cellpadding="0" cellspacing="0" width="100%">' + CRLF
cCabec += '<tbody>' + CRLF
cCabec += '<tr>' + CRLF
cCabec += '<td height="16" width="33%">' + CRLF
cCabec += '<div align="left">' + IIf(!Empty(cLinkLOGO),'<img src="' + RTrim(cLinkLOGO) + '" height="65" width="170">','') + '</div>' + CRLF
cCabec += '</td>' + CRLF
cCabec += '<td height="16" width="33%">' + CRLF
cCabec += '<div align="center"><font face="Arial, Helvetica, sans-serif" size="2"><b><font size="4">' + cTitulo + '</font></b></font></div>' + CRLF
cCabec += '</td>' + CRLF
cCabec += '<td height="16" valign="top" width="34%"> <br>' + CRLF
cCabec += '</td>' + CRLF
cCabec += '</tr>' + CRLF
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³DADOS DA EMPRESA  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cCabec += '<tr>' + CRLF
cCabec += '<td colspan="2" height="41"><b><font face="Arial, Helvetica, sans-serif" size="1">' + SM0->M0_NOMECOM + '<br></font></b>' + CRLF
cCabec += '<font face="Arial, Helvetica, sans-serif" size="1">' + STR0155 + SM0->M0_CGC + '<br>' + CRLF
cCabec += SM0->M0_ENDENT + '<br>' + CRLF
cCabec += STR0156 + RTrim(SM0->M0_CEPENT) + STR0157 + RTrim(SM0->M0_TEL) + '<br>' + CRLF
cCabec += '</font></td>' + CRLF
cCabec += '<td height="41" valign="top" width="34%"> <br>' + CRLF
cCabec += '</td>' + CRLF
cCabec += '</tr>' + CRLF
//QUEBRA DE LINHA
cCabec += '<tr>' + CRLF
cCabec += '<td colspan="3">' + CRLF
cCabec += '<hr noshade="noshade"> </td>' + CRLF
cCabec += '</tr>' + CRLF
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³BLOCO EMISSAO + NUMERO LISTA  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cCabec += '<tr>' + CRLF
cCabec += '<td width="33%"><b><font face="Arial, Helvetica, sans-serif" size="1">' + STR0158 + DtoC(Date()) + '</font>' + CRLF
cCabec += '</b></td>' + CRLF
cCabec += '<td width="33%"><br>' + CRLF
cCabec += '</td>' + CRLF
cCabec += '<td valign="top" width="34%">' + CRLF
cCabec += '<div align="right"><b><span style="font-family: Arial,sans-serif;">' + STR0159 + PadL(cNumLst,TamSX3("ME1_CODIGO")[1],"0") + '&nbsp; </span></b></div>' + CRLF
cCabec += '</td>' + CRLF
cCabec += '</tr>' + CRLF
cCabec += '</tbody>' + CRLF
cCabec += '</table>' + CRLF
//QUEBRA DE LINHA
cCabec += '<tr>' + CRLF
cCabec += '<td>' + CRLF
cCabec += '<hr noshade="noshade">' + CRLF
cCabec += '</td>' + CRLF
cCabec += '</tr>' + CRLF
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³DADOS DO EVENTO  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cCabec += '<tr>' + CRLF
cCabec += '<td>' + CRLF
cCabec += '<font face="Verdana" size="1">' + STR0160 + (cAlias)->ME1_NOME + '</font>' + CRLF
cCabec += '</td>' + CRLF
cCabec += '</tr>' + CRLF
cCabec += '<tr>' + CRLF
cCabec += '<td>' + CRLF
cCabec += '<font face="Verdana" size="1">' + STR0161 + DtoC((cAlias)->ME1_DTEVEN) + '</font>' + CRLF
cCabec += '</td>' + CRLF
cCabec += '</tr>' + CRLF
cCabec += '<tr>' + CRLF
cCabec += '<td>' + CRLF
cCabec += '<font face="Verdana" size="1">' + STR0162 + GetAdvfVal("ME3","ME3_DESCRI",xFilial("ME3") + (cAlias)->ME1_TPEVEN,1) + '</font>' + CRLF
cCabec += '</td>' + CRLF
cCabec += '</tr>' + CRLF
cCabec += '<tr>' + CRLF
cCabec += '<td>' + CRLF
cCabec += '<font face="Verdana" size="1">' + STR0163 + Eval({|| cTMP := "",aEval(aTMP,{|x| cTMP += AllTrim(x) + ","}),Substr(cTMP,1,Len(cTMP) - 1)}) + '</font>' + CRLF
cCabec += '</td>' + CRLF
cCabec += '</tr>' + CRLF

If ExistBlock("LJEMAILLP")
	cCabec += ExecBlock("LJEMAILLP",.F.,.F.,{cNumLst,cNumOrc,"CAB"})
ElseIf !(AllTrim((cAlias02)->ME4_CODCLI) + AllTrim((cAlias02)->ME4_LOJCLI) == AllTrim(SuperGetMV("MV_CLIPAD",,"")) + AllTrim(SuperGetMV("MV_LOJAPAD",,"")))
	//Nome do convidado:
	cCabec += '<tr>' + CRLF
	cCabec += '<td>' + CRLF
	cCabec += '<font face="Verdana" size="1">' + "Convidado(a): " + (cAlias02)->ME4_NOMCLI + '</font>' + CRLF //Convidado(a): 
	cCabec += '</td>' + CRLF
	cCabec += '</tr>' + CRLF
EndIf

//QUEBRA DE LINHA
cCabec += '<tr>' + CRLF
cCabec += '<td>' + CRLF
cCabec += '<hr noshade="noshade">' + CRLF
cCabec += '</td>' + CRLF
cCabec += '</tr>' + CRLF
//ÚÄÄÄÄÄÄÄÄÄÄ¿
//³MENSAGEM  ³
//ÀÄÄÄÄÄÄÄÄÄÄÙ
cMens := ""
If Len(aLstMens) > 0
	For ni := 1 to Len(aLstMens)
		cMens += '<tr>' + CRLF
		cMens += '<td valign="top" width="50%>' + CRLF
		cMens += '<font face="Verdana" size="1">' + STR0164 + StrZero(ni,2) + ' : ' + Lj843RtSYP(aLstMens[ni],"ME1_CODMEN",GetSx3Cache("ME1_MENSAG","X3_TAMANHO")) + '</font>' + CRLF
		cMens += '</td>' + CRLF
		//Celula de complemento de espaco
		cMens += '<td valign="top" width="50%>' + CRLF
		cMens += '</td>' + CRLF
		cMens += '</tr>' + CRLF
	Next ni
Endif
//QUEBRA DE LINHA
cMens += '<tr>' + CRLF
cMens += '<td>' + CRLF
cMens += '<hr noshade="noshade">' + CRLF
cMens += '</td>' + CRLF
cMens += '</tr>' + CRLF
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³CABECALHO - ITENS  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
dbSelectArea("ME2")
cMens += '<tr>' + CRLF
cMens += '<td height="163">' + CRLF
cMens += '<table style="width: 100%;" nowrap="1" background="" border="0" bordercolor="#cccccc" cellpadding="0" cellspacing="0">' + CRLF
cMens += '<thead> <tr bgcolor="#cccccc">' + CRLF
cMens += '<td height="23">' + CRLF
cMens += '<div align="center"><b><font face="Arial, Helvetica, sans-serif" size="1">' + Capital(AllTrim(RetTitle("ME2_ITEM"))) + '</font></b></div>' + CRLF
cMens += '</td>' + CRLF
cMens += '<td height="23">' + CRLF
cMens += '<div align="left"><b><font face="Arial, Helvetica, sans-serif" size="1">' + Capital(AllTrim(RetTitle("ME2_PRODUT"))) + '</font></b></div>' + CRLF
cMens += '</td>' + CRLF
cMens += '<td height="23">' + CRLF
cMens += '<div align="left"><b><font face="Arial, Helvetica, sans-serif" size="1">' + Capital(AllTrim(RetTitle("ME2_DESCRI"))) + '</font></b></div>' + CRLF
cMens += '</td>' + CRLF
cMens += '<td height="23">' + CRLF
cMens += '<div align="left"><b><font face="Arial, Helvetica, sans-serif" size="1">' + Capital(AllTrim(RetTitle("ME2_UM"))) + '</font></b></div>' + CRLF
cMens += '</td>' + CRLF
cMens += '<td height="23">' + CRLF
cMens += '<div align="left"><b><font face="Arial, Helvetica, sans-serif" size="1">' + Capital(AllTrim(RetTitle("ME2_QTDSOL"))) + '</font></b></div>' + CRLF
cMens += '</td>' + CRLF
cMens += '</tr>' + CRLF
cMens += '</thead>' + CRLF
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ITENS - PRODUTOS  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
ni := 0
cMens += '<tbody>' + CRLF
cChave := xFilial("ME2") + cNumLst
dbSelectArea("ME2")
ME2->(dbSetOrder(1))	//ME2_FILIAL+ME2_CODIGO+ME2_ITEM
Do While !(cAlias02)->(Eof())
	If ME2->(dbSeek(cChave + (cAlias02)->ME4_ITLST))
		cMens += '<tr>' + CRLF
		cMens += '<td>&nbsp;<font face="Verdana" size="1">' + ME2->ME2_ITEM + '</font></td>' + CRLF
		cMens += '<td>&nbsp;<font face="Verdana" size="1">' + ME2->ME2_PRODUT + '</font></td>' + CRLF
		cMens += '<td>&nbsp;<font face="Verdana" size="1">' + ME2->ME2_DESCRI + '</font></td>' + CRLF
		cMens += '<td>&nbsp;<font face="Verdana" size="1">' + ME2->ME2_UM + '</font></td>' + CRLF
		cMens += '<td>&nbsp;<font face="Verdana" size="1">' + AllTrim(AllToChar((cAlias02)->ME4_QUANT)) + '</font></td>' + CRLF
		cMens += '</tr>' + CRLF
		ni++
	Endif
	(cAlias02)->(dbSkip())
EndDo
cMens += '</tbody>' + CRLF
//ÚÄÄÄÄÄÄÄÄ¿
//³RODAPE  ³
//ÀÄÄÄÄÄÄÄÄÙ
cMens += '<tbody>' + CRLF
//QUEBRA DE LINHA
cMens += '<tr>' + CRLF
cMens += '<td colspan="14">' + CRLF
cMens += '<hr noshade="noshade">' + CRLF
cMens += '</td>' + CRLF
cMens += '</tr>' + CRLF
//TOTALIZADOR
cMens += '<tr>' + CRLF
cMens += '<td colspan="14">' + CRLF
cMens += '<b><font face="Verdana" size="1">' + STR0165 + cValToChar(ni) + '</font></b>' + CRLF
cMens += '</td>' + CRLF
cMens += '</tr>' + CRLF
//FECHAMENTO ARQUIVO
cMens += '</tbody>' + CRLF
cMens += '</tbody>' + CRLF
cMens += '</table>' + CRLF
cMens += '</div>' + CRLF
cMens += '</form>' + CRLF
cMens += '</body></html>' + CRLF
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Envio da mensagem  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lOK := .F.
cEmlDest := ""
aEval(aEmailO,{|x| IIf(!Empty(x),cEmlDest += AllTrim(x) + ";",.T.)})
If !lTLS
	//MailSMTPOn
	CONNECT SMTP SERVER cServ ACCOUNT cSMTPUsu PASSWORD cSenha RESULT lOk
	If 	lOk
		SEND MAIL FROM cConta ;
			TO cEmlDest ;
			SUBJECT cTitulo ;
			BODY cCabec + cMens;
			ATTACHMENT ;
			RESULT lOk
		If !lOk
			GET MAIL ERROR cErro
			ConOut(cRotina + STR0166 + RTrim(cErro))
		EndIf
		DISCONNECT SMTP SERVER
	Else
		GET MAIL ERROR cErro
		ConOut(cRotina + STR0167 + RTrim(cErro))
	EndIf
Else
	//tMailManager
	lOk := LjEnvEmail(.F.,lTLS,lSMTPAut,cConta,cEmlDest,,,cTitulo,cCabec + cMens,cServ,cSenha,cPorta,cSMTPUsu,nTOUT,.T.)
Endif
If !lOk
	FechaArqT(cAlias)
	FechaArqT(cAlias02)
	//Restaurando a area de trabalho
	aEval(aArea,{|x| RestArea(x)})
	Return !lRet
Endif
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Envio 02 - Mensagem de agradecimento  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty((cAlias)->ME1_CODMEN)
	cMens := ""
	cMens += '<tr>' + CRLF
	cMens += '<td valign="top" width="50%>' + CRLF
	cMens += '<font face="Verdana" size="1">' + STR0164 + StrZero(ni,2) + ' : ' + Lj843RtSYP((cAlias)->ME1_CODMEN,"ME1_CODMEN",GetSx3Cache("ME1_MENSAG","X3_TAMANHO")) + '</font>' + CRLF
	cMens += '</td>' + CRLF
	//Celula de complemento de espaco
	cMens += '<td valign="top" width="50%>' + CRLF
	cMens += '</td>' + CRLF
	cMens += '</tr>' + CRLF
	//ENVIO DA MENSAGEM
	lOK := .F.
	cEmlDest := ""
	aEval(aEmailP,{|x| IIf(!Empty(x),cEmlDest += AllTrim(x) + ";",.T.)})
	If !lTLS
		//MailSMTPOn
		CONNECT SMTP SERVER cServ ACCOUNT cConta PASSWORD cSenha RESULT lOk
		If 	lOk
			SEND MAIL FROM cConta ;
				TO cEmlDest ;
				SUBJECT cTitulo ;
				BODY cCabec + cMens;
				ATTACHMENT ;
				RESULT lOk
			If !lOk
				GET MAIL ERROR cErro
				ConOut(cRotina + STR0166 + RTrim(cErro))
			EndIf
			DISCONNECT SMTP SERVER
		Else
			GET MAIL ERROR cErro
			ConOut(cRotina + STR0167 + RTrim(cErro))
		Endif
	Else
		//tMailManager
		lOk := LjEnvEmail(.F.,lTLS,lSMTPAut,cConta,cEmlDest,,,cTitulo,cCabec + cMens,cServ,cSenha,cPorta,cSMTPUsu,nTOUT,.T.)
	Endif
Endif
FechaArqT(cAlias)
FechaArqT(cAlias02)
//Restaurando a area de trabalho
aEval(aArea,{|x| RestArea(x)})

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LjEnvEmailºAutor  ³Vendas Cliente        º Data ³15/03/11         º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Funcao de envio de e-mail utilizando as classe tMailManager e     º±±
±±º          ³tMailMessage.                                                     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³Exp01[L] : Conexao SSL                                            º±±
±±º          ³Exp02[L] : Conexao TLS                                            º±±
±±º          ³Exp03[L] : Autenticar para envio                                  º±±
±±º          ³Exp04[C] : E-mail do remetente                                    º±±
±±º          ³Exp05[C] : E-mail de destino                                      º±±
±±º          ³Exp06[C] : E-mail com copia                                       º±±
±±º          ³Exp07[C] : E-mail com copia oculta                                º±±
±±º          ³Exp08[C] : Assunto (subject)                                      º±±
±±º          ³Exp09[C] : Mensagem (body)                                        º±±
±±º          ³Exp10[C] : Servidor SMTP                                          º±±
±±º          ³Exp11[C] : Senha da conta / usuario                               º±±
±±º          ³Exp12[C] : Porta do servidor SMTP (padrao 25)                     º±±
±±º          ³Exp13[C] : Nome do usuario (para autenticacao)                    º±±
±±º          ³Exp14[N] : Time-out                                               º±±
±±º          ³Exp15[L] : Gerar arquivo EML?                                     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³Generico                                                          º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function LjEnvEmail(lSSL,lTLS,lAuth,cEmissor,cDest,cCC,cBCC,cAssunto,cMens,cServ,cSenha,cPorta,cUsuario,nTOUT,lGeraArq)

Local lRet				:= .T.
Local cPath 			:= ""
Local nPos				:= 0
Local nStatusCode 		:= 0
Local MailServer 		:= tMailManager():New()
Local MailMessage 		:= tMailMessage():New()
Local cRotina			:= "[LOJXFUNA:LjEnvEmail] "

Default cEmissor		:= ""
Default cDest			:= ""
Default cCC			:= ""
Default cBCC			:= ""
Default cAssunto		:= ""
Default cMens			:= ""
Default cServ			:= ""
Default cSenha			:= ""
Default cPorta			:= "25"
Default cUsuario		:= cEmissor
Default nTOUT			:= 30
Default lGeraArq		:= .T.

If Empty(cEmissor) .OR. Empty(cDest) .OR. Empty(cServ) .OR. Empty(cSenha)
	ConOut(cRotina + STR0168)
	Return !lRet
Endif
lSSL 	:= IIf(lSSL == Nil,.F.,lSSL)
lTLS 	:= IIf(lTLS == Nil,.F.,lTLS)
lAuth 	:= IIf(lAuth == Nil,.F.,lAuth)
cPorta	:= IIf(!Empty(cPorta),Val(cPorta),Nil)
If lGeraArq
	cPath	:= GetSrvProfString("RootPath","")
	cPath 	+= IIf(!(Left(cPath,1) == IIf(IsSrvUnix(),"/","\")),IIf(IsSrvUnix(),"/","\"),"")
Endif
// Redefine a chave Protocol com o valor POP3 na seção Mail
WritePProString("Mail","Protocol","POP3",GetAdv97())
//Define o servidor de e-mails
If lSSL
	MailServer:SetUseSSL(.T.)
	nStatusCode := MailServer:Init("",cServ,cUsuario,cSenha,,cPorta)
ElseIf lTLS
	MailServer:SetUseTLS(.T.)
	nStatusCode := MailServer:Init("",cServ,cUsuario,cSenha,,cPorta)
Else
	nStatusCode := MailServer:Init("",cServ,cUsuario,cSenha,,cPorta)
Endif
If nStatusCode # 0
	ConOut(cRotina + MailServer:GetErrorString(nStatusCode))
	Return !lRet
Endif
//Conecta com o servidor de e-mails
ConOut(cRotina + STR0169 + cUsuario)
nStatusCode := MailServer:SMTPConnect()
If nStatusCode # 0
	ConOut(cRotina + MailServer:GetErrorString(nStatusCode))
	//Se o usuario possuir @, tentar conectar sem
	If (nPos := At("@",cUsuario)) > 0
		cUsuario := Substr(cUsuario,1,nPos - 1)
		nStatusCode := MailServer:Init("",cServ,cUsuario,cSenha,,cPorta)
		If nStatusCode # 0
			ConOut(cRotina + MailServer:GetErrorString(nStatusCode))
			Return !lRet
		Endif
		ConOut(cRotina + STR0169 + cUsuario)
		nStatusCode := MailServer:SMTPConnect()
	Else
		cUsuario := cEmissor
		nStatusCode := MailServer:Init("",cServ,cUsuario,cSenha,,cPorta)
		If nStatusCode # 0
			ConOut(cRotina + MailServer:GetErrorString(nStatusCode))
			Return !lRet
		Endif
		ConOut(cRotina + STR0169 + cUsuario)
		nStatusCode := MailServer:SMTPConnect()		
	Endif
	If nStatusCode # 0
		ConOut(cRotina + MailServer:GetErrorString(nStatusCode))
		If lGeraArq
			MailMessage:Clear()
			MailMessage:cFrom    := cEmissor
			MailMessage:cTo      := cDest
			MailMessage:cCC      := cCC
			MailMessage:cBcc     := cBCC
			MailMessage:cSubject := cAssunto
			MailMessage:cBody    := cMens
			MailMessage:Save(IIf(lSSL,cPath,cPath) + "mensagem.eml")		
		Endif
		Return !lRet
	Endif	
Endif
//O servidor de e-mails requer autenticação
If lAuth
	nStatusCode := MailServer:SMTPAuth(cUsuario,cSenha)
	If nStatusCode # 0
		ConOut(cRotina + MailServer:GetErrorString(nStatusCode))
		Return !lRet
  	Endif
Endif
MailMessage:Clear()
MailMessage:cFrom    := cEmissor	//Conta SMTP
MailMessage:cTo      := cDest
MailMessage:cCC      := cCC
MailMessage:cBcc     := cBCC
MailMessage:cSubject := cAssunto
MailMessage:cBody    := cMens
//Salvar
If lGeraArq
	MailMessage:Save(IIf(lSSL,cPath,cPath) + "mensagem.eml")
Endif
//Enviar
nStatusCode := MailMessage:Send(MailServer)
If nStatusCode # 0
	ConOut(cRotina + MailServer:GetErrorString(nStatusCode))
	Return !lRet
Else
	ConOut(cRotina + STR0170)
Endif
// Desconecta
MailServer:SMTPDisconnect()

Return lRet   

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºPrograma  ³LjFTVD		  ºAutor  ³Vendas Clientes º Data ³  22/11/2011 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Verficar se a chamada foi realizada pelo Venda Direta	    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametro ³      	                        					 	    º±±
±±º          ³ 															    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Loja701                                                      º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function LjFTVD()

Local lRet 			:= .F.
Local lMvLjPdvPa    := .F. //Indica se é pdv  
Local lMenFisOnLog	:= .F. //Valida se foi chamado Menu Fiscal da Tela de Login
Local lLjNfPafEcf	:= .F.
Local lLjNfNoPaf	:= .F.
Local lLJLBNT 		:= .F.
Local cCallRot		:= ""

// Fizemos uma protecao atraves da pilha de chamada,
// pois apesar de ser possivel, o NMODULO nao e 
// utilizado nas funcoes de RPC do Varejo
// Se for via JOB (GravaBatch) vai retornar .F.
If TYPE("NMODULO") == "N"
	If nModulo == 5 .And. ExistFunc("Lj7GetCRot")
		//Verifica se está sendo chamada a rotina LOJA701 via ExecAuto como Venda Direta (VD) com módulo 5=Faturamento
		cCallRot := Lj7GetCRot()
	EndIf
	If !IsBlind() .Or. cCallRot == "VD"
		If nModulo == 5 .AND. !IsInCallStack("FR271CRPCORC")
			
			If (Type("lFiscal") == "L") .AND. (nModAnt > 0) .And. (nModAnt <> nModulo)
				lFiscAnt  := lFiscal
			EndIf
			
			nModAnt	:= nModulo
			lRet	:= .T.
			
		ElseIf nModAnt > 0 .AND. nModAnt <> nModulo .AND. !IsInCallStack("SIGAMDI")
		
			If nModulo <> 5
				If ValType(lFiscAnt) <> "L"
					
					lFiscAnt := .F. 
					
					//Regra de alimentação da variável lFiscal do Loja
					lMvLjPdvPa  := LjxBGetPaf()[2] 				//Indica se é pdv
					lMenFisOnLog:= IsInCallStack("LjMenFiLog")	//Valida se foi chamado Menu Fiscal da Tela de Login
					lLjNfPafEcf	:= LjNfPafEcf(SM0->M0_CGC)
					lLjNfNoPaf	:= LjNfNoPaf(SM0->M0_CGC)
					lLJLBNT		:= SuperGetMV("MV_LJLBNT",,0) > 0
					//Quando logar com a função do Menu Fiscal deve colocar como lFiscal pois
					//posteriormente é validado o lFiscal e se ele acessar o sistema sem o ECF evita conseguir acessar a venda assistida
					lFiscal		:= IIf( lMenFisOnLog , .T. , IIF((lLjNfPafEcf .AND. !lMvLjPdvPa .And. !lLJLBNT) .OR. lLjNfNoPaf, .F., LJProFile(3)))
					lFiscAnt	:= lFiscal
				Else
					//Restaura o usuário Fiscal, alimentado anteriormente
					lFiscal   := lFiscAnt
				EndIf
			Else
				lFiscal   := .F.
			EndIf
			
			nModAnt	:= nModulo
		EndIf
	EndIf
EndIf

Return lRet

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºPrograma  ³LjUpd90Ok ºAutor  ³Vendas Clientes       º Data ³27/02/12     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Funcao que verifica se todas as tabelas e campos criados pelo º±±
±±º          ³UPDLOJA90, necessarios para o funcionamento da integracao FS  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³                                                              º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function LjUpd90Ok(lSoSL1, lShowMsg)
Local lRet			:= .T.	//Retorno da funcao
Local lOnline		:= Select("SX2") > 0 .AND. Select("SX3") > 0 .AND. Select("SIX") > 0	//Conexao online
Local lTop			:= .T.  //Ambiente TOP
Local lMvLjPdvPa	:= .F.  //Ambiente PAF
Local aAreaAnt		:= GetArea()  //Workarea ativa
Local lMvLjIntFS	:= .F.
Local cMsg			:= ""

Default lSoSL1 := .F.   //Valida somente o SL1 (validacao no front)
Default lShowMsg := .F.

lMvLjPdvPa := LjxBGetPaf()[2]
#IFNDEF TOP
	//Se o modulo ativo for SIGAFRT, permitir o uso
	If !AmIIn(23)
		//Se nao for PDV
		If !lMvLjPdvPa
			lTop := !lTop
		Endif
	Endif
#ENDIF

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Caso a funcao seja chamada por um job e os arquivos SXs  ³
//³não estejam disponiveis para validacao, retornar falso.  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lOnline .OR. !lTop
	lRet := .F.
	Return lRet
Endif

lMvLjIntFS := SuperGetMv("MV_LJINTFS",, .F.)

//Verifica se os parametros da integração estão habilitados, caso negativo, seta como falso
If lMvLjIntFS

	If ( (nModulo == 12 .OR. nModulo == 5  ) .AND. !lMvLjPdvPa)
		If Empty(SuperGetMv("MV_LJUSRFS", , ""))
			cMsg := STR0193 + " MV_LJUSRFS" + STR0194 //"Parâmetro" ##" está sem conteúdo." 
			lRet := .F.
		EndIf
		
		If SuperGetMv("MV_TIPACRD",.F. , 1) <> 3
			cMsg += CRLF + STR0193 + " MV_TIPACRD " + STR0195+ " [3]."//"Parâmetro"##"está com conteúdo diferente de"
			lRet := .F.
		EndIf
		
		If !FWHasEAI( "LOJA2503", .F., .T., .t.)
			cMsg += CRLF + STR0196 + "LOJA2503."//"Falta de configuração do adapter EAI: "##
		EndIf
		
		If !FWHasEAI( "LOJA2507", .F., .T., .t.)
			cMsg += CRLF + STR0196 + "LOJA2507."//"Falta de configuração do adapter EAI: "
		EndIf
	
		If !FWHasEAI( "LOJA2510", .T., .F., .t.)
			cMsg += CRLF + STR0196 + "LOJA2510."//"Falta de configuração do adapter EAI: "
		EndIf
		
		If !FWHasEAI( "LOJA2512", .T., .F., .t.)
			cMsg += CRLF + STR0196 + "LOJA2512."//"Falta de configuração do adapter EAI: "
		EndIf
	
		cMsg +=  CRLF + CRLF + STR0199 + " http://tdn.totvs.com/pages/releaseview.action?pageId=46079046" //"Para maiores detalhes, acesse a documentação dessa funcionalidade disponível no link:"

		If !lRet
			If lShowMsg
				cMsg := STR0197 + CRLF + cMsg//"Parâmetro MV_LJINTFS, refente à ativação da Integração Financial Services foi desabilidado porque faltam as seguintes configurações: "	
				MsgAlert(cMsg)
				PutMv("MV_LJINTFS", .F.)
				LjGrvlog("MV_LJINTFS", cMsg)			
			Else
				cMsg := STR0198 + CRLF + cMsg //"Integração Financial Services foi Desconsiderada porque faltam as seguintes configurações: "		
				LjGrvlog(Nil, cMsg)
			EndIf
	
		EndIf
	EndIf
EndIf

RestArea(aAreaAnt)

Return lRet

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºPrograma  ³LjCkCfgIFS ºAutor  ³Vendas Clientes       º Data ³15/03/12        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Funcao que verifica se a configuracao da integracao financial     º±±
±±º          ³services da estacao esta alinhado com a configuracao da retaguardaº±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³                                                                  º±±
±±º          ³                                                                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³lRet [L] : Retorna se a configuracao esta OK                      º±±
±±º          ³                                                                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³SIGAFRT                                                           º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function LjCkCfgIFS()
Local lRet				:= .T.		//Retorno
Local lLjIntFSRe		:= .F.  	//Integracao com o financial services na retaguarda
Local lMens				:= .F.      //Exibe mensagem?
Local lCmpSL1			:= LjUpd90Ok(.T.)   //Ambiente atualizado para integracao com o FS?
Local lMvLjIntFS     	:= SuperGetMV("MV_LJINTFS",.F.,.F.) .AND. lCmpSL1 //Integracao com o financial services esta habilitada
Local cMvVlBxRec		:= SuperGetMV("MV_VLBXREC", , "~")
Local cMvVlBxRet        := ""
 
//Aplicavel apenas para SIGAFRT e PAF
If !AmIIn(23,72)
	Return lRet
Endif

// Somente busca na retaguarda se tiver habilitado no PDV, pois ocasiona mta demora na entrada
If lMvLjIntFS
	lLjIntFSRe 		:= LjRetParSrv("MV_LJINTFS", "L")   
	cMvVlBxRet      := LjRetParSrv("MV_VLBXREC", "C")
EndIf

If ValType(lLjIntFSRe) == "L"    

	If lLjIntFSRe
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Integracao com o Financial Service ATIVADA na retaguarda  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !lMvLjIntFS			
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Conferencia de caixa DESATIVADA na estacao  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !lCmpSL1
				//Se a campo de integracao com o FS não estiver no PDV,caracteriza inconsistencia, bloquear.
				lMens := .T.
				lRet := !lRet
			EndIf
			//Caso a validacao nao tenha retornado falso, alinhar o valor do parametro com o da retaguarda
			
			If lRet
				PutMV("MV_LJINTFS",lLjIntFSRe)
				ApMsgInfo(STR0176)	//"O parametro MV_LJINTFS, que ativa a integracao com o financial services, foi automaticamente ATIVADO, respeitando a definição da retaguarda."
			Else
				If lMens
					Alert(STR0177)	//"A integraÇÃo com o Financial Service está ATIVADA na retaguarda e o update do pacote (UPDLOJ90) ainda não foi aplicado nesta estação."
				EndIf
			EndIf
		EndIf  
		
		If ValType(cMvVlBxRet)  == "C" .AND. !Empty(cMvVlBxRet) //Parâmetro que valida o valor a receber no frente de Lojas
			If !(cMvVlBxRec == "~") 
				If cMvVlBxRet <> cMvVlBxRec
					PutMV("MV_VLBXREC",cMvVlBxRet) 
					ApMsgInfo(STR0163)	//"O parametro MV_VLBXREC, que indica a validação do valor a receber na baixa, foi automaticamente ALTERADO, respeitando a definição da retaguarda."
			    EndIf
			Else
				ApMsgInfo(STR0164)	//"O parametro MV_VLBXREC, que indica a validação do valor a receber na baixa, não existe. Favor criá-lo"							
			EndIf
		EndIf
	Else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Integracao com o financial services DESATIVADO na retaguarda  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lMvLjIntFS  
		
			//Alinhar o valor do parametro com o da retaguarda caso a conferencia esteja ativada na estacao (desativar)
			If lRet
				PutMV("MV_LJINTFS",lLjIntFSRe)
				ApMsgInfo(STR0178)	//"O parâmetro MV_LJINTFS, que ativa a integracao com o financial services, foi automaticamente DESATIVADO, respeitando a definição da retaguarda."
			EndIf

		EndIf
	EndIf
EndIf

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³LJDelCxOk ³ Autor ³ Vandas e CRM			³ Data ³ 17/05/12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Responsavel em enviar os dados para integracao off-line	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ Cadastro de Senhas					                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function LJDelCxOk()

	Local oProcessOff 	:= Nil				   							//Objeto do tipo LJCProcessoOffLine
	Local lAmbOffLn 	:= SuperGetMv("MV_LJOFFLN", Nil, .F.)			//Identifica se o ambiente esta operando em offline
	
	//Verifica se o ambiente esta em off-line
	If lAmbOffLn
		//Instancia o objeto LJCProcessoOffLine
		oProcessOff := LJCProcessoOffLine():New("017")
		
		SET DELETED OFF
			    
		//Insere os dados do processo (registro da tabela)
		oProcessOff:Inserir("SA6", xFilial("SA6") + SA6->A6_COD, 1, "DELETE")	
		oProcessOff:Inserir("SLF", xFilial("SLF") + SLF->LF_COD, 1, "DELETE")	
		
		//Processa os dados 
		oProcessOff:Processar()	
		
		SET DELETED ON

	EndIf
	
Return Nil

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºPrograma  ³LjUP104ok ºAutor  ³Vendas Clientes       º Data ³27/02/12     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Funcao que verifica se todas as tabelas e campos criados pelo º±±
±±º          ³UPDLO104, necessarios para o funcionamento da Garantia Estend º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³                                                              º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function LjUp104Ok(lSoSL2)
Local lRet			:= .T.						//Retorno da funcao
Local lOnline		:= .F.						//Conexao online
Local nI			:= 0    					//Variavel contadora
Local lTop			:= .T.  					//Ambiente TOP
Local lMvLjPdvPa	:= .F.  					//Ambiente PAF
Local cParVazio	:= "!@#$%¨&*()"					//Valor do Parametro Vazio
Local aSX6			:= NIL						//Parâmetros do update 
Local aAreaAnt		:= GetArea()				//Workarea ativa

Default lSoSL2 := .F.   //Valida somente o SL1 (validacao no front)

//Verifica se ja foi validado 
If lGetLjUp104 <> Nil
	Return lGetLjUp104
EndIf

//Somente valida campos na 11.8 e se parametro possuir conteudo
If Empty(SuperGetMV("MV_LJTPGAR",,""))
	lGetLjUp104	:= .F.	
	Return lGetLjUp104
EndIf	

lMvLjPdvPa := LjxBGetPaf()[2]
#IFNDEF TOP
	//Se o modulo ativo for SIGAFRT, permitir o uso
	If !AmIIn(23)
		//Se nao for PDV
		If !lMvLjPdvPa
			lTop := !lTop
		Endif
	Endif
#ENDIF

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Caso a funcao seja chamada por um job e os arquivos SXs  ³
//³não estejam disponiveis para validacao, retornar falso.  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lOnline	:= Select("SX2") > 0 .AND. Select("SX3") > 0 .AND. Select("SIX") > 0				//Conexao online

If !lOnline .OR. !lTop
	lRet := .F.
	lGetLjUp104	:= .F.	
	Return lRet
Endif

If lSoSL2
	aSX6		:= {{"MV_LJIMPGF", "L" ,cParVazio},;     
					{"MV_LJTPGAR", "C" ,cParVazio},;
					{"MV_RELGART", "C" ,cParVazio} ;
					} //Parâmetros do update

Else
	aSX6		:= {{"MV_LJIMPGF", "L" ,cParVazio},;
					{"MV_LJTPGAR", "C" ,cParVazio},;
					{"MV_LJTISE1", "C" ,cParVazio},;
					{"MV_RELGART", "C" ,cParVazio} ;
					} //Parâmetros do update 

EndIf
 
If lRet
	If lRet		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Validar os parâmetros do pacote ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		For nI := 1 to Len(aSX6)
			If ValType(SuperGetMV(aSX6[nI, 1],,aSX6[nI, 3])) == Valtype(aSX6[nI, 3]) .AND. ;
				SuperGetMV(aSX6[nI, 1],,aSX6[nI, 3]) == aSX6[nI, 3] //Parâmetro naõ criado conteúdo igual ao default
				lRet := .F.
				Exit
			Endif
		Next nI
	EndIf
	
EndIf

RestArea(aAreaAnt)

lGetLjUp104	:= lRet

Return lRet


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡„o    ³lj7DecECF ³ Autor ³ Vendas Clientes		 ³ Data ³ 14/05/14 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descri‡„o ³Grava no sigaloja.ini o numero de decimais utilizados       ³±±
±±³            nos ecfs para os calculos de rateio de desconto e base de   ³±±
±±³            de imposto                                                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Sintaxe   ³lj7DecECF(cExpA1)                                           ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±³Parametros³ cExpA1  - Tipo de operacao									   	   ±±	 
±±³					 	1 - Grv informacao ECF no Sigaloja.Ini                 ±±
±±³						2 - Recupera informacao do ECF no INI                  ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±³	Retorno - Casas decimais que são usadas na regra do ECF  
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function lj7DecECF(cExpA1)

Local cDecimais	:= "15"  //Padrao bematech de decimais , para truncamento de valor no calculo no ECF  
Local cGetCliDir	:= GetClientDir()
Local cDecIni 		:= ""

Default cExpA1	:= "0" 

If cExpA1 == "1"  
	cDecIni 	:= GetPvProfString("Decimais ECF", "Decimais", " ", cGetCliDir + "SIGALOJA.INI" )	// Ler qtd decimais usada no ECF. Informacao grv na inicalizacao do sistema
	
	If Empty(cDecIni) //Somente grava a chave no "SIGALOJA.INI" caso ela ainda nao exista
		If !WritePProString( "Decimais ECF", "Decimais", cDecimais , cGetCliDir + "SIGALOJA.INI" )
			Conout(STR0181) //"LojxFuna - Falha ao atualizar o Sigaloja.ini com informações de CEF"
		EndIf
	EndIf
	
ElseIf cExpA1 == "2" 
	cDecimais 	:= GetPvProfString("Decimais ECF", "Decimais", cDecimais, cGetCliDir + "SIGALOJA.INI" )	// Ler qtd decimais usada no ECF. Informacao grv na inicalizacao do sistema
EndIF

Return cDecimais

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³LjValidNBS| Autor ³ Vendas Clientes       ³ Data ³20/05/2014³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Valida a informacao de NBS                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ ExpL1 := LjValidNBS(cProduto)                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cProduto - Produto que esta sendo alterado ou inserido no  ³±±
±±³            complemento (SB5). A validacao consiste em verificar se o  ³±±
±±³            produto eh servico e nao possui codigo NCM(produto)        ³±±
±±³            preenchido na SB1                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Generico                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/ 


Function LjValidNBS(cProduto)
Local lRet := .T.
Local aAreaSB1 := SB1->(GetArea()) 

DEFAULT cProduto := ""

If !Empty(cProduto) .AND. nModulo == 12
    DbSelectArea( "SB1" )
    If SB1->(DbSeek( xFilial("SB1") + cProduto ))
        If Empty(SB1->B1_CODISS) .OR. !Empty(SB1->B1_POSIPI) 
            lRet := .F.
        EndIf
    
        If !lRet 
             MsgInfo(AllTrim(cProduto) + " - " + ;
             AllTrim(SB1->B1_DESC) + STR0182 + chr(13) + chr(10) + ;
             STR0183 ,STR0001) //  " não é um serviço ." ; "Cod.Serv.ISS deve estar preenchido e Pos.IPI/NCM em branco!" ; "Atenção" 
        EndIf
    EndIf
EndIf

RestArea(aAreaSB1)

Return lRet 

//-------------------------------------------------------------------
/*{Protheus.doc} LjGrvLog
Grava Logs para detectar ações realizadas pelo usuário do sistema.

@param   
@author  Varejo
@version P11.8
@since   24/04/2015
@param	cNumControl	, caracter, codigo de controle ex: L1_NUM
		cLogText	, caracter	, texto descritivo do log
		xVar		, U			, vaiavel para apresentação no log
		lCallStack	, logico	, Indica se deseja imprimir a pilha de chamada
		lForceLog	, logico	, indica se força a gravação do log, mesmo que esteja desabilitado.
@return  Nulo
@obs     
@sample
/*/
//-------------------------------------------------------------------
Function LjGrvLog( cNumControl, cLogText, xVar, lCallStack, lForceLog )
Local cThreadID 	:= ""   //Retorna o ID (número de identificação) da thread em que a chamada da função foi realizada
Local cProcLine 	:= ""   //Retorna o número da linha do código fonte executado que fez a chamada da geração do LOG
Local cFunction 	:= ""   //Retorna o nome da funcao em execução que fez a chamada da geração do LOG
Local cPath 		:= ""
Local cLogFile 		:= ""
Local nHandle 		:= 0
Local cCallStack 	:= ""
Local nX 			:= 0
Local cMsgLog		:= ""

Default cNumControl	:= "" 	//Numero de controle para poder identificar o processo em execução. Exemplo: L1_NUM: 000001, L1_DOC: 000100,...etc
Default lCallStack 	:= .F.  //Variavel que determina se exibe a pilha de chamadas ou nao
Default cLogText    := ""  // Proteção Default para nao dar erro caso nao seja enviado.
Default lForceLog	:= .F.

If lLogCliCfg == Nil
	lLogCliCfg 	:= !Empty(AllTrim(GetPvProfString( "LogClient"  , "server", "", GetAdv97() )))
EndIf

If lLogCliCfg
	cMsgLog := Time() + " " + "[" + AllTrim(Str(ThreadID())) + "]" + " " + ProcName(1) + " Line " + AllTrim(Str(ProcLine(1))) + " " + "[" + cNumControl + "]" + " " + cLogText
EndIf

//Somente executa a gercao do LOG caso esteja habilitado
If LjEnableLog() .OR. lForceLog

	cThreadID 	:= AllTrim(Str(ThreadID())) 	//Retorna o ID (número de identificação) da thread em que a chamada da função foi realizada
	cProcLine 	:= AllTrim(Str(ProcLine(1))) 	//Retorna o número da linha do código fonte executado que fez a chamada da geração do LOG
	cFunction 	:= ProcName(1) 					//Retorna o nome da funcao em execução que fez a chamada da geração do LOG

    //Tratamento para não gerar errorlog, se por acaso o parâmetro for passado de forma incorreta
    If ValType(lCallStack) <> "L"
        Conout( cFunction + " [" + cProcLine + "] - Conteudo do parametro lCallStack, passado de forma incorreta para a funcao LjGrvLog.")
        lCallStack := .F.
    EndIf
	
	cPath 		:= LjFilePath() 	//Retorna o Caminho onde o arquivo de LOG será gerado
	cLogFile 	:= LjFileName() 	//Retorna o nome do arquivo de LOG que será gerado.
	
	//Verifica se o arquivo de LOG existe
	If !File( cPath+cLogFile )
		LjCheckDir() //Se nao existir, cria o arquivo de LOG
	EndIf

	If xVar <> Nil	// Caso venha uma variavel vai "logar" ela através do VarInfo
		cLogText := cLogText + VarInfo("",xVar,NIL,.F.,.F.)
		cLogText := Left(cLogText,Len(cLogText)-2)
	EndIf
	
	//Verifica se precisa gravar as informações de Cabeçalho do LOG
	If lHeadInfo
		lHeadInfo := .F. //Seta para .F., para não gerar o LOG do Cabeçalho novamente, gera apenas uma vez
		
		GeraHeader( cPath+cLogFile )
	EndIf

	cFunction := " Function " + cFunction
	
	cLogText := Time() + " " + "["+cThreadID+"]" + cFunction + " Line " + cProcLine + CRLF +;
				Space(5) +  "[" + cNumControl + "] " + cLogText + CRLF
	
	If lCStack .Or. lCallStack //Verifica se eh para listar a pilha de chamadas
		nX := 1
		cCallStack := Space(5) + "Call Stacks:" + CRLF
		While !Empty(ProcName(nX))
			cCallStack 	+= Space(10) + "Called from "
			cCallStack 	+= ProcName(nX)								//Retorna o nome da funcao executada
			cCallStack 	+= " line: " + AllTrim(Str(ProcLine(nX))) + CRLF	//Retorna o número da linha do código fonte executado
			nX++
		End
		
		cLogText := cLogText + cCallStack + CRLF
	EndIf

	// Grava o texto no Arquivo de LOG
	nHandle := FOpen( cPath+cLogFile, 2 )
	FSeek ( nHandle, 0, 2 )	// Posiciona no final do arquivo.
	FWrite( nHandle, cLogText, Len(cLogText) )
	FClose( nHandle )
		
EndIf

If lLogCliCfg .AND. ValidFonte(ProcSource(1))
	LogMsg(ProcName(1), 23, 6, 1, '', '', "|Data=" + FwTimeStamp(3) + "|Versao=" + GetRPORelease() + "|Empresa=" + IIF(Type("cEmpAnt") <> "U", cEmpAnt, "Null")  + "|Filial=" + IIF(Type("cFilAnt") <> "U", cFilAnt, "Null") + "|Fonte=" + ProcSource(1) + "|Funcao=" + ProcName(1) + "|Linha=" + AllTrim(Str(ProcLine(1))) + "|Thread=" + AllTrim(Str(ThreadID())) + "|Mensagem=" + StrTran(FwCutOff(AllTrim(cMsgLog)),"|","") + "|Variavel=" + StrTran(FwCutOff(AllTrim(VarInfo("",xVar,NIL,.F.,.F.))),"|","") + "|")
EndIf

Return Nil

//-------------------------------------------------------------------
/*{Protheus.doc} LjEnableLog
Verifica se o LOGLOJA está ativado no arquivo AppServer.INI.

@author  Varejo
@version P11.8
@since   24/04/2015
@return  lRet			Retorna se o LOG está ativo (.T. = Ativado, .F. = Desativado)
@obs
@sample
/*/
//-------------------------------------------------------------------
Static Function LjEnableLog()
Local cIniFile		:= GetADV97() //Retorna nome do AppServer.INI
Local cValueDef 	:= "0" //Valor Default de Configuração do LOG. (0=Log Inativo; 1=Log Ativo)
Local cValueLog 	:= ""
Local cCallStack 	:= "0"

//Verifica se virou o dia (Data), no caso onde a thread fica em execução por mais de 1 dia
If dDate_Log <> Date()
 	//Reinicia variaveis para que o novo arquivo de LOG seja criado
	lEnableLog	:= Nil
	cFile_Log	:= Nil
	
	dDate_Log 	:= Date()
EndIf

If lEnableLog == Nil

	cValueLog 	:= GetPvProfString( LOGSECTION, "enable", cValueDef, cInIfile )

	If cValueLog == "1" //0=Log Inativo; 1=Log Ativo
		
		//Verifica se o diretório existe, caso não existir, cria o diretório.
		If LjCheckDir()
			lEnableLog := .T.
			ConOut("##############################")
			ConOut("### LogLOJA HABILITADO !!! ###")
			ConOut("##############################")

			cCallStack 	:= GetPvProfString( LOGSECTION, "CallStack", cCallStack,cInIfile ) //Faz a Leitura do parametro CallStack da secao LOGLOJA
			lCStack 	:= cCallStack == "1" //(0=Nao Gera pilha de chamadas; 1=Gera pilha de chamadas)
		Else
			//Se o diretorio nao existe ou se nao conseguiu criar, entao determina que o LOG esta desativado
			lEnableLog := .F.
		EndIf
		
	Else
		
		lEnableLog := .F.
		
	EndIf
	
EndIf

Return lEnableLog

//-------------------------------------------------------------------
/*{Protheus.doc} LjCheckDir
Verifica se o diretório existe, caso não existir, cria o diretório.

@author  Varejo
@version P11.8
@since   24/04/2015
@return  lRet			Retorna .T., caso o diretório já exista ou tem sido criado com sucesso
@obs
@sample
/*/
//-------------------------------------------------------------------
Static Function LjCheckDir()
Local lRet 		:= .T.
Local nRet 		:= 0
Local cDir 		:= ""
Local cFileLOG 	:= LjFilePath()+LjFileName()
Local nHandle	:= 0

//Verifica se ja existe o diretório principal (Diretorio Pai)
cDir := "\"+LOGPATH
If !ExistDir(cDir)
	nRet := MakeDir(cDir)
	
	If nRet != 0
		ConOut( "Não foi possível criar o diretório " + cDir +". Erro: " + cValToChar( FError() ) )
		lRet := .F.
	EndIf
EndIf

//Verifica se ja existe o sub-diretório onde será criado o arquivo de LOG
cDir := "\"+LOGPATH+"\"+LOGSUBPATH
If !ExistDir(cDir)
	nRet := MakeDir(cDir)
	
	If nRet != 0
		ConOut( "Não foi possível criar o diretório " + cDir +". Erro: " + cValToChar( FError() ) )
		lRet := .F.
	EndIf
EndIf

If lRet
	If !File( cFileLOG )	// Cria o arquivo caso ainda nao existir
		
		nHandle := FCreate( cFileLOG )
		If nHandle == -1
			ConOut("Erro ao tentar criar o arquivo de LOG [" + cFileLOG + "] - Erro " + STR(FERROR()))
		Else
			FClose( nHandle )
		EndIf

		lHeadInfo 	:= .T. //Seta variavel para que a lista de fontes seja gerada no arquivo de LOG
	Else 
		lHeadInfo := .F.  	
	EndIf
EndIf

Return lRet 

//-------------------------------------------------------------------
/*{Protheus.doc} LjFilePath
Retorna o caminho onde sera gerado o arquivo de LOG.

@param   
@author  Varejo
@version P11.8
@since   24/04/2015
@return  cRet			Retorna o caminho onde será gerado o arquivo de LOG
@obs
@sample
/*/
//-------------------------------------------------------------------
Static Function LjFilePath()
Local cRet 	:= "\"+LOGPATH+"\"+LOGSUBPATH+"\"
Return cRet 

//-------------------------------------------------------------------
/*{Protheus.doc} LjFileName
Retorna o nome do arquivo de LOG que será gerado.

@param   
@author  Varejo
@version P11.8
@since   24/04/2015
@return  cRet			Retorna o nome do arquivo de LOG que será gerado.
@obs
@sample
/*/
//-------------------------------------------------------------------
Static Function LjFileName()

If cFile_Log == Nil
	If Type("cEmpAnt") != "U"  .And. Type("cFilAnt") != "U" //Verifica as variaveis empresa e filial para saber se o ambiente esta iniciado
		cFile_Log 	:= "LOG_"+cEmpAnt+cFilAnt+"_"+DToS(Date())+".TXT"
	Else
		cFile_Log := "LOG"+DToS(Date())+".TXT"
	EndIf
EndIf

Return cFile_Log

//-------------------------------------------------------------------
/*{Protheus.doc} GeraHeader
Gera o cabeçalho do LOG.

@param   
@author  Varejo
@version P11.8
@since   28/04/2015
@return  aRet			Retorna um array com uma lista de fontes compilados no RPO.
@obs
@sample
/*/
//-------------------------------------------------------------------
Static Function GeraHeader( cFileLog )
Local cHeadInfo 	:= ""
Local nHandle 		:= 0

cHeadInfo :=  "############ BEGIN HEADER INFORMATION ############" + CRLF

//-------
// Data
//-------
cHeadInfo += "[Date: " + DToC(Date()) + "]" + CRLF

//-------
// Hora
//-------
cHeadInfo += "[Time: " + Time() + "]" + CRLF

//----------------------------------------------------------------------------------------
// Retorna o número IP (Internet Protocol) onde o Smart Client está sendo executado
//----------------------------------------------------------------------------------------
cHeadInfo += "[IP: " + GetClientIP() + "]" + CRLF

//----------------------------------------------------------------------------------------
// Retorna o nome da máquina (Hostname) onde o Smart Client está sendo executado
//----------------------------------------------------------------------------------------
cHeadInfo += "[Hostname: " + GetComputerName() + "]" + CRLF

//-----------------
// ID do Usuário
//-----------------
If Type("__cUserID") <> "U"
	cHeadInfo += "[User ID: " + __cUserID + "]" + CRLF
EndIf

//-------------------
// Nome do Usuário
//-------------------
If Type("cUserName") <> "U"
	cHeadInfo += "[User Name: " + cUserName + "]" + CRLF
EndIf

//------------------------------------------------------------------------
// Informações da build (ID da compilação) em uso do Application Server
//------------------------------------------------------------------------
cHeadInfo += "[Build Application Server: " + GetBuild(.F.) + "]" + CRLF

If !IsBlind()
	//-----------------------------------------------------------------
	// Informações da build (ID da compilação) em uso do SmartClient
	//-----------------------------------------------------------------
	cHeadInfo += "[Build SmartClient: " + GetBuild(.T.) + "]" + CRLF
EndIf

//--------------------------------------------------------------------------------------------
// Retorna uma string com o nome do ambiente (ENVIRONMENT) em execução no Application Server
//--------------------------------------------------------------------------------------------
cHeadInfo += "[Environment: " + GetEnvServer() + "]" + CRLF

//--------------------------------------------------------------------------------------------
// Verifica se a conexão efetuada com o Protheus possui ou não interface com o usuário
//--------------------------------------------------------------------------------------------
cHeadInfo += "[Interface: " + If(IsBlind(),"NO","YES") + "]" + CRLF

//--------------------------
// Informação do Sistema
//--------------------------
cHeadInfo += "[System: " + GetVersao() + "]" + CRLF

//---------------------------------------
// Informação da Versão em Utilização
//---------------------------------------
cHeadInfo += "[Version: " + GetVersao(.F.) + "]" + CRLF

//---------------------------------------
// Informação do Release em Utilização
//---------------------------------------
cHeadInfo += "[Release: " + GetRPORelease() + "]" + CRLF

//---------------------------------------
// Informação da Empresa em Utilização
//---------------------------------------

If Type("cEmpAnt") != "U"
	cHeadInfo += "[Company: " + cEmpAnt + "]" + CRLF
	ConOut("[Company: " + cEmpAnt + "]")
Endif 

//---------------------------------------
// Informação da Filial em Utilização
//---------------------------------------

If  Type("cFilAnt") != "U"
	cHeadInfo += "[Branch: " + cFilAnt + "]" + CRLF
	ConOut("[Branch: " + cFilAnt + "]")
Endif 

If !IsBlind()
	//---------------------------------------
	// Informação da Estacao em execução
	//---------------------------------------
	cHeadInfo += "[Estação: " + cEstacao + "]" + CRLF
	
	//---------------------------------------
	// Informação do Usuario Caixa
	//---------------------------------------
	cHeadInfo += "[Caixa: " + xNumCaixa() + "]" + CRLF
EndIf

cHeadInfo += "--------------------------------------------------" + CRLF
cHeadInfo += LjVerAcumu() + CRLF

//---------------------------------------
//Data de fontes compilados no RPO
//---------------------------------------
cHeadInfo += "--------------------------------------------------" + CRLF
cHeadInfo += "List of sources: "
nHandle := FOpen( cFileLog, 2 ) // Abre o arquivo de LOG
FSeek ( nHandle, 0, 2 )	// Posiciona no final do arquivo.
FWrite( nHandle, cHeadInfo + CRLF, Len(cHeadInfo) + 2 )
FClose( nHandle ) //Fecha o arquivo de LOG
cHeadInfo := ""
ListaFonte(cFileLog)
cHeadInfo += "--------------------------------------------------" + CRLF
cHeadInfo += "Parameter list: "
nHandle := FOpen( cFileLog, 2 ) // Abre o arquivo de LOG
FSeek ( nHandle, 0, 2 )	// Posiciona no final do arquivo.
FWrite( nHandle, cHeadInfo + CRLF, Len(cHeadInfo) + 2 )
FClose( nHandle ) //Fecha o arquivo de LOG
cHeadInfo := ""
ListaParam(cFileLog)
cHeadInfo += "--------------------------------------------------" + CRLF

//------------------
//Versao da DLL
//------------------
// TO DO


cHeadInfo +=  "############# END HEADER INFORMATION #############"

nHandle := FOpen( cFileLog, 2 ) // Abre o arquivo de LOG
FSeek ( nHandle, 0, 2 )	// Posiciona no final do arquivo.
FWrite( nHandle, cHeadInfo + CRLF, Len(cHeadInfo) + 2 )
FClose( nHandle ) //Fecha o arquivo de LOG

Return Nil

//-------------------------------------------------------------------
/*{Protheus.doc} ListaFonte
Grava no arquivo e LOG uma lista de fontes compilados no RPO, com sua data de compilação.

@param   
@author  Varejo
@version P11.8
@since   28/04/2015
@return  Nulo
@obs
@sample
/*/
//-------------------------------------------------------------------
Static Function ListaFonte(cFileLog)
Local aFontes 		:= {}

//Relacao de Fontes que sera gerado no log (LOGLOJA)
aFontes := LjLstFonte()

//Gera log dos fontes listados
LjLogFonte(cFileLog, aFontes)

Return Nil

//-------------------------------------------------------------------
/*{Protheus.doc} LjIsLogEnable
Verifica se O LOG está ativado

@author  Varejo
@version P11.8
@since   24/04/2015
@return  lRet			Retorna se o LOG está ativo (.T. = Ativado, .F. = Desativado)
@obs
@sample
/*/
//-------------------------------------------------------------------
Function LjIsLogEnable()

Return LjEnableLog()


//-------------------------------------------------------------------
/*{Protheus.doc} LjIsLogEnable
Habilita/Desabilita o log
@param  lHabilita .F. (default)/.t. 
@author  Varejo
@version P11.8
@since   24/04/2015
@return  lRet			Retorna se o LOG está ativo (.T. = Ativado, .F. = Desativado)
@obs
@sample
/*/
//------------------------------------------------------------------- 
Function LjSetLogEn(lHabilita)
Local cValue := "0" //Valor do Log
Local cIniFile		:= GetADV97() //Arquivo Ini
Local cValueLog 	:= "" //Valor do Log

Default lHabilita := .F.

If lHabilita
	cValue := "1"
EndIf

cValueLog 	:= GetPvProfString( LOGSECTION, "enable", cValue, cInIfile )

If cValueLog <> cValue
	WritePProString(LOGSECTION ,"enable" ,cValue, cIniFile)
	lEnableLog := Nil //Reseta a variável de log
	LjEnableLog()
EndIf

Return lHabilita 

//-------------------------------------------------------------------
/*{Protheus.doc} LjGetLogFile
Caputra o arquivo de Log
@author  Varejo
@version P11.8
@since   24/04/2015
@return  lRet			Retorna se copiou o arquivo de log
@obs
@sample LjGetLogFile()
/*/
//------------------------------------------------------------------- 
Function LjGetLogFile()
Local cPath := ""  //Caminho
Local cLogFile := "" //Arquivo Log
Local cIniName:= GetRemoteIniName() //Nome do Ini do Remote
Local lUnix:= IsSrvUnix() //Linux?
Local nPos:= Rat( IIf(lUnix,"/","\"),cIniName )//Pos do separador de arquivos
Local cRemotePath := "" //Caminho do Remote
Local lRet := .F. //Retorno da rotina

	cPath 		:= LjFilePath() 	//Retorna o Caminho onde o arquivo de LOG será gerado
	cLogFile 	:= LjFileName() 	//Retorna o nome do arquivo de LOG que será gerado.
	
  If nPos!=0
    cRemotePath := Substr( cIniName,1,nPos-1 )
  Else
    cRemotePath := "C:"
  EndIf

// Copia arquivos do servidor para o remote local, compactando antes de transmitir
 	If File(cPath+cLogFile)
		lRet := CpyS2T( cPath+cLogFile , cRemotePath, .T. )
	EndIf
	
	If lRet
		MsgAlert(STR0188 +  cLogFile +STR0189 + cRemotePath) //"Arquivo " #" copiado para a pasta "
	EndIf
	
Return lRet


/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºPrograma  ³LjRmvAcent  ºAutor  ³ Leandro Lima     º Data ³  07/05/16   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Remove acentos/caracteres especiais nao suportados pelo ECF º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹*/
Function LjRmvAcent(cString)
Local nX        := 0 
Local nY        := 0 
Local cSubStr   := ""
Local cRetorno  := ""

Local cStrEsp	:= "ÁÃÂÀáàâãÓÕÔóôõÇçÉÊéêº–"  
Local cStrEqu   := "AAAAaaaaOOOoooCcEEeer-" //char equivalente ao char especial
Local cPode		:= "ASDFGHJKLÇQWERTYUIOPZXCVBNM<>:?^}`{}´\|/;.,]~[´]''1234567890-=_+!@#$%&*()"+'"' + Chr(13) + Chr(10)

For nX:= 1 To Len(cString)
	cSubStr := SubStr(cString,nX,1)
	nY := At(cSubStr,cStrEsp)
	If nY > 0 
		cSubStr := SubStr(cStrEqu,nY,1)
	EndIf
    // Alem de substitu os especiais someente adiciona os caracteres que pode
    If Upper(cSubStr) $ cPode
    	cRetorno += cSubStr
    Else
    	cRetorno += " "
    EndIf
Next nX

Return cRetorno

//---------------------------------------------------
/*/{Protheus.doc} LjRmvChEs
Remove os caracteres invalidos da string para 
evitar erro de parser no XML

@param1	 cString - String a ser validada
@author  Varejo
@version P11.8
@since   15/06/2015
@return	 cNewStr - String sem os caracteres especiais
/*/
//---------------------------------------------------
Function LjRmvChEs( cString )
Local cChar		:= ""
Local cNewStr	:= ""
Local nSizeStr	:= 0
Local nI		:= 0

Default cString := ""

//transforma em maiuscula e substitui caracteres com acentos
cString := AllTrim( FwNoAccent(cString) )

//tamanho da string
nSizeStr := Len( cString )

For nI := 1 to nSizeStr
	cChar := SubStr(cString, nI, 1)
	If cChar $ ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnoprqstuvwxyz0123456789#=+-_/*?!,.:;()[]{}|\$<>@' ")
		cNewStr += cChar
	ElseIf cChar == Chr(13) .OR. cChar == CRLF
		cNewStr += "|"
	ElseIf SubStr(cString, nI-1, 1) == " "	//remove os espaços a esquerda do caracter especial
		cNewStr := Rtrim(cNewStr)
	EndIf
Next

Return cNewStr

//---------------------------------------------------
/*/{Protheus.doc} LjCrTmpTbl
Função responsável por criar uma tabela temporaria

@param1 	cTblAlias	- Alias da tabela temporaria
@param2 	aStruct		- Colunas que irá possuir na tabela temporaria
@param3 	aIndex		- Indices da tabela temporaria		
@author 	bruno.inoue 
@version 	12.1.14
@since 		01/2017  
@return 	oTempTable - Objeto da tabela temporaria
/*/
//---------------------------------------------------
Function LjCrTmpTbl(cTblAlias, aStruct, aIndex)

Local oTempTable	:= Nil	//Objeto tabela temporaria
Local nX			:= 0	//Contador
Local lRet			:= .F.	//Verifica as informacoes para criar a tabela

Default cTblAlias	:= ""	//Alias
Default aStruct	    := {}	//Estrutura
Default aIndex      := {}	//Indices 

cTblAlias := AllTrim(cTblAlias)

If Len(aStruct) > 0 .And. Len(aStruct[1]) == 4 .AND. !Empty(cTblAlias) 
	lRet := .T.
Else
	LjGrvLog( "TempTable", "Nao possui Alias ou a estrutura do campo é diferente de 4" )
	LjGrvLog( "TempTable", "Alias informado - cTblAlias:",cTblAlias )
	LjGrvLog( "TempTable", "Estrutura informada - aStruct:",aStruct )
EndIf

If lRet
	// Instância o Objeto  
	oTempTable := FWTemporaryTable():New( cTblAlias )
	// Atribui campos e índices.  
	oTempTable:SetFields( aStruct )
	If Len(aIndex) > 0
		For nX := 1 To Len(aIndex)
			oTempTable:AddIndex(cValToChar(nX),Separa(aIndex[nX],"+",.F.))
		Next nX	
	EndIf
	//Criação da tabela
	oTempTable:Create()
EndIf

Return oTempTable

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Fun‡„o    ³LjxANota ³ Autor ³ Vendas Clientes		³ Data ³ 14.01.97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Achoice para numero e serie da nota fiscal                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ LOJA020                                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Data     ³ Bops ³Programa³  Motivo da Alteracao    		   	          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ 14.07.05 ³ 83762³Henry   ³Implementacao do parametro "MV_LJNRNFS" de  ³±±
±±³          ³      ³        ³modo a tratar a numeracao e a possibilidade ³±±
±±³          ³      ³        ³de utilizacao do ponto de entrada CHGX5FIL  ³±±
±±³          ³      ³        ³conforme os processos semelhantes ao fatura ³±±
±±³          ³      ³        ³mento                                       ³±±
±±³ 18/03/06 ³094211|Geronimo³substituido MsRUnlock() por MsUnlock(), pois³±±
±±³          ³      |        ³ele eh incompativel c/ controle de transacao³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function LjxANota(cMvSerieTr)

Local aSerNf    := {}                

Local cCadastro := "Notas"
Local cVarQ     := "  "

Local lDone     := .F.
Local lAbandona := .F.
Local lInterno  := .T.

Local nOpcA 	 := 0
Local nSaveSx8 	 := GetSx8Len()
Local nCntErro	 := 0

Local oQual
Local oDlg

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ\¿
//³Parametro MV_LJAVANC, definia na função NxtSX5Nota()- MATXFUNA.PRX, se possivel ³
//³alterar o numero da Nota sugerida.                                              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ\Ù

Local lAvanca   := SuperGetMV("MV_LJAVANC")
Local cMV_TPNRNFS:= LjTpNrNFS()			// Retorno do parametro MV_TPNRNFS, utilizado pela Sx5NumNota() de onde serah controlado o numero da NF  1=SX5  2=SXE/SXF  3=SD9
Local cFilSx5   	:= If(FindFunction("LjFilSX5"),LjFilSX5(),xFilial("SX5"))  // Retorna Filial SX5 

PRIVATE lSX5Troca := .F.
PRIVATE aSerNFTrc[0]

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Faz um tratamento diferenciado para o controle de NF pelo SD9 quando ³
//³ o parametro MV_TPNRNFS for igual a "3"                               ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cMV_TPNRNFS == "3"
	If Empty( cMvSerieTr )
		If !Sx5NumNota( Nil, cMV_TPNRNFS )
			Return .F.
		Else
			Return .T.
		Endif
	Else
		Return .T.
	Endif
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Caso o Parƒmetro MV_LJNFTRO estiver vazio, Desenha  ³
//³ a Telinha para escolha do Nota/Serie			    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Empty(cMvSerieTr)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Caso o Numero de Serie/Nota for autom tico ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SuperGetMV("MV_LJNFSXE")
	
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Faz o tratamento de pegar o numero da nota L via semaforo ou via    ³
		//³ SX5 (tabela 1)                                                           ³
		//³ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
		//³ Foi feito dessa forma devido as alteracoes feitas para o cliente Cepar   ³
		//³ de Joinville e para nao alterar o que ja temos em campo ja que estamos   ³
		//³ terminando o desenvolvimento da versao 7.10                              ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		
		cSerieDev	:= cMvSerieTr

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Se a serie estiver em branco abre a tela para a escolha do usuario³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		
		If !Sx5NumNota(,SuperGetMV("MV_LJNRNFS",.F.,"2"))
		   Return .F.
		Endif
		cSerieDev   :=cSerie
		cNumTroc	:= NxtSx5Nota( cSerieDev,,'2',lAvanca )
        cNumTroc    := PadR( StrZero(Val(cNumTroc),Len(cNumTroc)) , TamSx3("F1_DOC")[1] )    
		If ! LjValNota(cSerieDev,cNumTroc) // Varifica se jah existe a nota
			Return .F.
		Endif
		While (GetSX8Len() > nSaveSx8 )
			ConfirmSX8()
		End
	
	Else
	
		vNumero := SPACE(TamSx3("F1_DOC")[1])
		
		DbSelectArea("SX5")
		While !lAbandona .AND. DbSeek( cFilSx5+"01",.F. ) .AND. !lDone
			
			lInterno := .T.
			While cFilial+"01" == X5_FILIAL+X5_TABELA .AND. !lAbandona
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Se a S‚rie for CPF, n„o mostra no aChoice, pois ‚ utilizada ³
				//³ internamente para emissao de Cupom Fiscal.	   			    ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If (Alltrim(SX5->X5_CHAVE) == "CPF") .OR.;
					(Alltrim(SX5->X5_CHAVE) == "CP")
					DbSkip()
				Else
					If !MsRLock()
						lInterno    := .F.
						lDone   	:= .F.
						aSerNF  	:= {}
						If (++nCntErro > 10)
							lAbandona := .T.
						EndIf
					Endif
					
					If !lAbandona
						If !(ValType(aSerNF) == "A")
							aSerNF := {}
						EndIf
						
						lDone := .T.
						If cPaisLoc == "BRA"
							AADD( aSerNF,{ Padr( X5_CHAVE, 3 ), StrZero( Val( X5Descri() ), 6 ) } )
						Else
							AADD( aSerNF,{ Padr( X5_CHAVE, 3 ), StrZero( Val( X5Descri() ),12 ) } )
						EndIf
						DbSkip()
					EndIf
				EndIf
			End
		End
		
		If (Len(aSerNF) == 0) .OR. lAbandona
			MsUnLock()
			Help(" ",1,"A460FLOCK")
			Return(.F.)
		Endif
		
		nOpcA := 0
		While nOpcA <> 1
			DEFINE MSDIALOG oDlg TITLE cCadastro From 10,30 To 19,68 OF oMainWnd
			// Serie
			@ .5,.80 LISTBOX oQual VAR cVarQ Fields HEADER STR0192,cCadastro SIZE 130,42 ON DBLCLICK (aSerNF:=LjSx5Troca(oQual:nAt,aSerNF),oQual:Refresh()) NOSCROLL //"Série"
			oQual:SetArray(aSerNF)
			oQual:bLine := { || {aSerNf[oQual:nAT,1],aSerNf[oQual:nAT,2]}}
			
			DEFINE SBUTTON FROM 51,109	TYPE 1 ACTION ;
			(If(LJ010ANF(oQual,aSernf,@cSerieDev,@cNumTroc),(	nOpcA := 1,	oDlg:End()),)) ENABLE OF oDlg
			
			ACTIVATE MSDIALOG oDlg
		End
		
		If !lSX5Troca
			vNumero := cNumTroc
		Endif
	
		DbSelectArea("SX5")	
		If DbSeek( cFilSx5+"01"+cSerieDev,.F. )
			MsRLock()
            SX5->X5_DESCRI  := PadR( StrZero(Val(cNumTroc)+1,Len(cNumNota)) , TamSx3("F1_DOC")[1] )     // Era: StrZero(Val(cNumTroc)+1,TamSx3("F1_DOC")[1])
			SX5->X5_DESCSPA := PadR( StrZero(Val(cNumTroc)+1,Len(cNumNota)) , TamSx3("F1_DOC")[1] )     // Era: StrZero(Val(cNumTroc)+1,TamSx3("F1_DOC")[1])
			SX5->X5_DESCENG := PadR( StrZero(Val(cNumTroc)+1,Len(cNumNota)) , TamSx3("F1_DOC")[1] )     // Era: StrZero(Val(cNumTroc)+1,TamSx3("F1_DOC")[1])
			MsUnLock()
		Else
			MsUnLock()
			Return(.F.)
		EndIf

	EndIf

Else

	DbSelectArea("SX5")
	DbSeek(cFilSx5+"01"+cMvSerieTr)
	If Eof()
		HELP(" ",1,"ERROSERIE")
		Return .F.
	EndIf
		
	cSerieDev	:= cMvSerieTr
	cNumTroc	:= NxtSx5Nota( cSerieDev )
    cNumTroc    := PadR( StrZero(Val(cNumTroc),Len(cNumTroc)) , TamSx3("F1_DOC")[1] )   
Endif

Return .T.

//---------------------------------------------------
/*/{Protheus.doc} LjxAAjSX
Criada para efetuar os ajustes de dicionário na V12
caso sejam permitidos.

Atenção a documentação do TDN: 
http://tdn.totvs.com/pages/releaseview.action?pageId=272700444

@author 	Julio.Nery 
@version 	12.1.17
@since 		02/2018
/*/
//---------------------------------------------------
Function LjxAAjSX()

LjGrvLog( Nil, " Ajuste de dicionário não permitido para essa versão")

Return NIL

//-------------------------------------------------------------------
/*{Protheus.doc} LjLstFonte
Funcao responsavel por retornar a lista de fontes que se deseja gerar no log (LOGLOJA)

@author  Alberto Deviciente
@version P12.1.17
@since  06/04/2018
@return  aRet 		Lista da relacao de fontes que deseja gerar o log
@obs
@sample
/*/
//-------------------------------------------------------------------
Static Function LjLstFonte()
Local aRet 			:= {}
Local aLstSearch 	:= {}
Local cRotina   	:= ""
Local nX 			:= 0
Local cFonte 		:= ""
Local aAuxFontes 	:= {}

//Relacao de Fontes ou Prefixos de fontes que deseja buscar no RPO
aAdd(aLstSearch, "ST*") 	//Fontes cujo nome inicia com "ST" (Fontes relacionados ao Totvs PDV)
aAdd(aLstSearch, "FRT*") 	//Fontes cujo nome inicia com "FRT" (Fontes relacionados ao FronLoja)
aAdd(aLstSearch, "LJ*")		//Fontes cujo nome inicia com "LJ" (Fontes relacionados ao SIGALOJA)
aAdd(aLstSearch, "LOJ*")	//Fontes cujo nome inicia com "LOJ" (Fontes relacionados ao SIGALOJA)
aAdd(aLstSearch, "CRD*")	//Fontes cujo nome inicia com "CRD" (Fontes relacionados ao SIGALCRD)
aAdd(aLstSearch, "WSFRT*")	//Fontes cujo nome inicia com "WSFRT" (Fontes relacionados ao FronLoja)
aAdd(aLstSearch, "WSLOJ*")	//Fontes cujo nome inicia com "WSLOJ" (Fontes relacionados ao SIGALOJA)
aAdd(aLstSearch, "WSLJ*")	//Fontes cujo nome inicia com "WSLJ" (Fontes relacionados ao SIGALOJA)
aAdd(aLstSearch, "WSCRD*")	//Fontes cujo nome inicia com "WSCRD" (Fontes relacionados ao SIGALCRD)
aAdd(aLstSearch, "FAT*")	//Fontes cujo nome inicia com "FAT" (Fontes relacionados ao Faturamento)
aAdd(aLstSearch, "FIN*")	//Fontes cujo nome inicia com "FIN" (Fontes relacionados ao Financeiro)
aAdd(aLstSearch, "MAT*")	//Fontes cujo nome inicia com "MAT" (Fontes relacionados a Materiais)
aAdd(aLstSearch, "SIGACUS*")//Fontes cujo nome inicia com "SIGACUS" (Fontes SIGACUS, SIGACUSA, SIGACUSB, etc)
aAdd(aLstSearch, "OFI*")	//Fontes cujo nome inicia com "OFI" (Fontes relacionados ao Módulo de Oficina - Parceiro MIL)
aAdd(aLstSearch, "VEI*")	//Fontes cujo nome inicia com "VEI" (Fontes relacionados ao Módulo de Veiculos - Parceiro MIL)
aAdd(aLstSearch, "SCR*")	//Fontes cujo nome inicia com "SCR"
aAdd(aLstSearch, "DRO*")	//Fontes cujo nome inicia com "DRO" (Fontes relacionados ao Template de Drogaria)
aAdd(aLstSearch, "TPL*")	//Fontes cujo nome inicia com "TPL" (Fontes relacionados ao Template)
aAdd(aLstSearch, "WSC_*")	//Fontes cujo nome inicia com "WSLJ" (Fontes relacionados ao SIGALOJA)
aAdd(aLstSearch, "RMI*")	//Fontes cujo nome inicia com "RMI" (Integração com SIGALOJA)
aAdd(aLstSearch, "RETAIL*")	//Fontes cujo nome inicia com "RETAIL" (Integração com SIGALOJA)
aAdd(aLstSearch, "PSH*")	//Fontes cujo nome inicia com "PSH" (Integração)

//Fontes relacionados a integração
aAdd(aLstSearch, "CARGALOJA*")
aAdd(aLstSearch, "CREDBX*")
aAdd(aLstSearch, "CREDITO*")
aAdd(aLstSearch, "ESTOQUE*")
aAdd(aLstSearch, "IDENTIFICADORPDV*")
aAdd(aLstSearch, "LISTAORCAMENTO*")
aAdd(aLstSearch, "NOTAENTRADA*")
aAdd(aLstSearch, "NOTASAIDA*")
aAdd(aLstSearch, "ORCAMENTO*")
aAdd(aLstSearch, "RESERVA*")
aAdd(aLstSearch, "AMBIENTE*")
aAdd(aLstSearch, "INTEGRACAOTOTVSPDV*")
aAdd(aLstSearch, "STATUSINTEGVENDAS*")

//Fontes especificos
aAdd(aLstSearch, "OMSA010.PRX")
aAdd(aLstSearch, "OMSA010A.PRX")
aAdd(aLstSearch, "WSC_WSINTEGRACAO.PRW") 
aAdd(aLstSearch, "IMPXFIS.PRW")
aAdd(aLstSearch, "LIVE.TLPP")
aAdd(aLstSearch, "PDVSYNC.TLPP")
aAdd(aLstSearch, "ATUSTATUSINTEGOBJ.TLPP")
aAdd(aLstSearch, "GERAINTEGMANUALPDV.TLPP")
aAdd(aLstSearch, "WIZINTMANUALOBJ.TLPP")
aAdd(aLstSearch, "MONITORPOUI.PRW")

aSort(aLstSearch)
	
For nX:=1 To Len(aLstSearch)
	cFonte := aLstSearch[nX]
	If "*" $ cFonte
		cRotina   	:= "GetSrcArray('"+cFonte+"')"
		If FindFunction( cRotina )
			aAuxFontes := &cRotina
		EndIf
	Else
		aAuxFontes := {cFonte}
	EndIf
	
	aEval(aAuxFontes, { |x| aAdd(aRet, x) } )
Next nX

Return aRet

//-------------------------------------------------------------------
/*{Protheus.doc} LjLogFonte
Gera o log (LOGLOJA) da lista de fontes desejados. 

@author  Alberto Deviciente
@version P12.1.17
@since  06/04/2018
@return  Nil
@obs
@sample
/*/
//-------------------------------------------------------------------
Static Function LjLogFonte(cFileLog, aFontes)
Local nHandle 		:= 0
Local cLogText 		:= ""
Local cThreadID 	:= "[Thread "+AllTrim(Str(ThreadID()))+"]" 	//Retorna o ID (número de identificação) da thread em que a chamada da função foi realizada
Local nX 			:= 0
Local aFonteInfo 	:= {}

If File( cFileLog )	// Verifica se o arquilo de LOG existe
	// Abre o arquivo de LOG
	nHandle := FOpen( cFileLog, 2 )
	FSeek ( nHandle, 0, 2 )	// Posiciona no final do arquivo.
	
	For nX:=1 to Len(aFontes)
		 aFonteInfo := GetAPOInfo(aFontes[nX])
		 
		 If Len(aFonteInfo) > 0
			 								//FONTE.PRW      -         DD/MM/AA             -     HH:MM:SS
			 cLogText := cThreadID + PadL(aFonteInfo[1],35) + " " + DToC(aFonteInfo[4]) + " " + aFonteInfo[5] + " [" +  aFonteInfo[3] + "]"
			 FWrite( nHandle, cLogText + CRLF, Len(cLogText) + 2 )
		 EndIf
	Next nX
	FClose( nHandle ) //Fecha o arquivo de LOG
EndIf

Return

//-------------------------------------------------------------------
/*{Protheus.doc} LjVerAcumu
Verifica a data o pacote do patch acumulado de Varejo que está presente no RPO. 

@author  Alberto Deviciente
@version P12.1.17
@since  06/04/2018
@return  Nil
@obs
@sample
/*/
//-------------------------------------------------------------------
Static Function LjVerAcumu()
Local cRet			:= ""
Local aDadosPack 	:= {{},{}} 

If ExistFunc("EngRefLoj") //Segunda funcao criada para retornar a data do pacote acumulado de Varejo ( Essa funcao substitui a funcao EngRefVare )
	aDadosPack[1] := EngRefLoj()
ElseIf ExistFunc("EngRefVare") //Primeira funcao criada para retornar a data do pacote acumulado de Varejo
	aDadosPack[1] := EngRefVare()
EndIf

If ExistFunc("EngRefCia") //Segunda funcao criada para retornar a data do pacote acumulado do CiaShop ( Essa funcao substitui a funcao EngRefCone )
	aDadosPack[2] := EngRefCia()
ElseIf ExistFunc("EngRefCone") //Primeira funcao criada para retornar a data do pacote acumulado do CiaShop
	aDadosPack[2] := EngRefCone()
EndIf


cRet := "############ Pacote Acumulado Varejo: ############" + CRLF
If Len(aDadosPack[1]) > 0
	cRet += "- Release...............................: " + aDadosPack[1][1] 		+ CRLF
	cRet += "- Data de Corte (Issues expedidas até)..: " + dToC(aDadosPack[1][2])	+ CRLF
	cRet += "- Data da Geração do Pacote Acumulado...: " + dToC(aDadosPack[1][3]) 	+ CRLF
	cRet += "- Hora da Geração do Pacote Acumulado...: " + aDadosPack[1][4] 		+ CRLF
Else
	cRet += "- Informação Indisponível/Pacote não aplicado." + CRLF
EndIf
cRet += "##################################################" + CRLF

cRet += "--------------------------------------------------" + CRLF

cRet += "############ Pacote Acumulado CiaShop: ###########" + CRLF
If Len(aDadosPack[2]) > 0
	cRet += "- Release...............................: " + aDadosPack[2][1] 		+ CRLF
	cRet += "- Data de Corte (Issues expedidas até)..: " + dToC(aDadosPack[2][2])	+ CRLF
	cRet += "- Data da Geração do Pacote Acumulado...: " + dToC(aDadosPack[2][3]) 	+ CRLF
	cRet += "- Hora da Geração do Pacote Acumulado...: " + aDadosPack[2][4] 		+ CRLF
Else
	cRet += "- Informação Indisponível/Pacote não aplicado." + CRLF
EndIf
cRet += "##################################################"

Return cRet

//-------------------------------------------------------------------
/*{Protheus.doc} ListaParam
Grava no arquivo de LOG uma lista dos principais parametros utilizados pelo Varejo.

@param   
@author  Varejo
@version P11.8
@since   02/10/2018
@return  Nulo
@obs
@sample
/*/
//-------------------------------------------------------------------
Static Function ListaParam(cFileLog)
Local aParamList	:= {}
Local nHandle 		:= 0
Local cLogText 		:= ""
Local cThreadID 	:= "[Thread "+AllTrim(Str(ThreadID()))+"]" 	//Retorna o ID (número de identificação) da thread em que a chamada da função foi realizada
Local nX 			:= 0
Local cParametro	:= ""
Local xConteudo		:= Nil

If Type("cEmpAnt") != "U"  .And. Type("cFilAnt") != "U" //Verifica as variaveis empresa e filial para saber se o ambiente esta iniciado
	aAdd(aParamList, "MV_LINKLOG")
	aAdd(aParamList, "MV_LJECOMD")
	aAdd(aParamList, "MV_LJ130MN")
	aAdd(aParamList, "MV_ACRSRET")
	aAdd(aParamList, "MV_LJ850AI")
	aAdd(aParamList, "MV_ATLSNED")
	aAdd(aParamList, "MV_LJ850HI")
	aAdd(aParamList, "MV_CARTEIR")
	aAdd(aParamList, "MV_LJ850MO")
	aAdd(aParamList, "MV_CFO3668")
	aAdd(aParamList, "MV_LJABNCC")
	aAdd(aParamList, "MV_CMC7FIN")
	aAdd(aParamList, "MV_LJABRCX")
	aAdd(aParamList, "MV_CRDBLEN")
	aAdd(aParamList, "MV_LJALTPG")
	aAdd(aParamList, "MV_CRDMIND")
	aAdd(aParamList, "MV_LJAPRSC")
	aAdd(aParamList, "MV_CRDMTBL")
	aAdd(aParamList, "MV_LJASNNC")
	aAdd(aParamList, "MV_CRDTIME")
	aAdd(aParamList, "MV_LJATIPI")
	aAdd(aParamList, "MV_CRDTWS")
	aAdd(aParamList, "MV_LJATVEN")
	aAdd(aParamList, "MV_CXLJFIN")
	aAdd(aParamList, "MV_LJAVBOD")
	aAdd(aParamList, "MV_DIREST")
	aAdd(aParamList, "MV_LJAVBOT")
	aAdd(aParamList, "MV_DROVLRC")
	aAdd(aParamList, "MV_LJAVSUB")
	aAdd(aParamList, "MV_EAICOMP")
	aAdd(aParamList, "MV_LJAVTOP")
	aAdd(aParamList, "MV_EAIURL")
	aAdd(aParamList, "MV_LJBXTIT")
	aAdd(aParamList, "MV_EAIWS")
	aAdd(aParamList, "MV_LJCCRDF")
	aAdd(aParamList, "MV_EXCNFS")
	aAdd(aParamList, "MV_LJCDDIS")
	aAdd(aParamList, "MV_FCICALC")
	aAdd(aParamList, "MV_LJCFDES")
	aAdd(aParamList, "MV_FINALVD")
	aAdd(aParamList, "MV_LJCFOP")
	aAdd(aParamList, "MV_FNTCTRB")
	aAdd(aParamList, "MV_LJCFSPG")
	aAdd(aParamList, "MV_FORMAFI")
	aAdd(aParamList, "MV_LJCFTEF")
	aAdd(aParamList, "MV_FTZRDES")
	aAdd(aParamList, "MV_LJCHSAT")
	aAdd(aParamList, "MV_GLAGLUT")
	aAdd(aParamList, "MV_LJCMP")
	aAdd(aParamList, "MV_HSPCFIS")
	aAdd(aParamList, "MV_LJCNPIA")
	aAdd(aParamList, "MV_IMPNOTA")
	aAdd(aParamList, "MV_LJCOMVA")
	aAdd(aParamList, "MV_INCEFIS")
	aAdd(aParamList, "MV_LJCPFCH")
	aAdd(aParamList, "MV_INUTILI")
	aAdd(aParamList, "MV_LJCTINT")
	aAdd(aParamList, "MV_2DUPREF")
	aAdd(aParamList, "MV_LJCUP")
	aAdd(aParamList, "MV_BONUSTD")
	aAdd(aParamList, "MV_LJCUPL")
	aAdd(aParamList, "MV_CLIPADG")
	aAdd(aParamList, "MV_LJDATSC")
	aAdd(aParamList, "MV_CRDESTO")
	aAdd(aParamList, "MV_LJDCMAX")
	aAdd(aParamList, "MV_CRDREIN")
	aAdd(aParamList, "MV_LJDENCC")
	aAdd(aParamList, "MV_CXFIN")
	aAdd(aParamList, "MV_LJDENT")
	aAdd(aParamList, "MV_DROREV")
	aAdd(aParamList, "MV_LJDEVFI")
	aAdd(aParamList, "MV_EAIPORT")
	aAdd(aParamList, "MV_LJDIAEN")
	aAdd(aParamList, "MV_ENVCDGE")
	aAdd(aParamList, "MV_LJDIAMO")
	aAdd(aParamList, "MV_FCIMOD")
	aAdd(aParamList, "MV_LJDIAOT")
	aAdd(aParamList, "MV_FOCVEND")
	aAdd(aParamList, "MV_LJDIRBT")
	aAdd(aParamList, "MV_GCPPORT")
	aAdd(aParamList, "MV_LJDREC")
	aAdd(aParamList, "MV_HTLNADC")
	aAdd(aParamList, "MV_LJDROLF")
	aAdd(aParamList, "MV_INTGFE")
	aAdd(aParamList, "MV_LJDVLCP")
	aAdd(aParamList, "MV_ALIQIRF")
	aAdd(aParamList, "MV_LJECDES")
	aAdd(aParamList, "MV_COMISCR")
	aAdd(aParamList, "MV_LJECDIR")
	aAdd(aParamList, "MV_CRDTPBX")
	aAdd(aParamList, "MV_LJECDNF")
	aAdd(aParamList, "MV_DROVLTC")
	aAdd(aParamList, "MV_LJECLPE")
	aAdd(aParamList, "MV_FATSLG")
	aAdd(aParamList, "MV_LJECMM2")
	aAdd(aParamList, "MV_FRTBZFU")
	aAdd(aParamList, "MV_LJECMMA")
	aAdd(aParamList, "MV_IMPORC")
	aAdd(aParamList, "MV_LJECMMB")
	aAdd(aParamList, "MV_CFDUSO")
	aAdd(aParamList, "MV_LJECNDI")
	aAdd(aParamList, "MV_DBLQMOV")
	aAdd(aParamList, "MV_LJECOM1")
	aAdd(aParamList, "MV_FISAUCF")
	aAdd(aParamList, "MV_LJECOM7")
	aAdd(aParamList, "MV_LJECOME")
	aAdd(aParamList, "MV_LJECOM8")
	aAdd(aParamList, "MV_EAIURL2")
	aAdd(aParamList, "MV_LJECOM9")
	aAdd(aParamList, "MV_CRDMSG")
	aAdd(aParamList, "MV_LJECOMA")
	aAdd(aParamList, "MV_GRADE")
	aAdd(aParamList, "MV_LJECOMC")
	aAdd(aParamList, "MV_LJMSGCX")
	aAdd(aParamList, "MV_LJLPHIS")
	aAdd(aParamList, "MV_LJMICAP")
	aAdd(aParamList, "MV_LJECOMI")
	aAdd(aParamList, "MV_LJMNACR")
	aAdd(aParamList, "MV_LJECOMR")
	aAdd(aParamList, "MV_LJMNDES")
	aAdd(aParamList, "MV_LJECOMW")
	aAdd(aParamList, "MV_LJMNDIA")
	aAdd(aParamList, "MV_LJECOMZ")
	aAdd(aParamList, "MV_LJMNTPG")
	aAdd(aParamList, "MV_LJEMLAD")
	aAdd(aParamList, "MV_LJMOCFG")
	aAdd(aParamList, "MV_LJENTVF")
	aAdd(aParamList, "MV_LJTCPFS")
	aAdd(aParamList, "MV_LJESTCX")
	aAdd(aParamList, "MV_LJNATFI")
	aAdd(aParamList, "MV_LJEXEAN")
	aAdd(aParamList, "MV_LJNATPA")
	aAdd(aParamList, "MV_LJFICOM")
	aAdd(aParamList, "MV_LJNCART")
	aAdd(aParamList, "MV_LJFLMIX")
	aAdd(aParamList, "MV_LJNCCBA")
	aAdd(aParamList, "MV_LJFORHT")
	aAdd(aParamList, "MV_LJNCCFI")
	aAdd(aParamList, "MV_LJNCCLJ")
	aAdd(aParamList, "MV_LJNCCOF")
	aAdd(aParamList, "MV_LJGRCOR")
	aAdd(aParamList, "MV_LJNCVFE")
	aAdd(aParamList, "MV_LJGRTAM")
	aAdd(aParamList, "MV_LJNECPT")
	aAdd(aParamList, "MV_LJGRVJB")
	aAdd(aParamList, "MV_LJNEESP")
	aAdd(aParamList, "MV_LJHMPAF")
	aAdd(aParamList, "MV_LJNEOBK")
	aAdd(aParamList, "MV_LJIFSEM")
	aAdd(aParamList, "MV_LJNEOCP")
	aAdd(aParamList, "MV_LJINFO")
	aAdd(aParamList, "MV_LJNEOEM")
	aAdd(aParamList, "MV_LJITCHK")
	aAdd(aParamList, "MV_LJNEOGR")
	aAdd(aParamList, "MV_LjKillT")
	aAdd(aParamList, "MV_LJNEOPV")
	aAdd(aParamList, "MV_LJLLOG")
	aAdd(aParamList, "MV_LJNEOUT")
	aAdd(aParamList, "MV_LJLOTNF")
	aAdd(aParamList, "MV_LJNERCV")
	aAdd(aParamList, "MV_LJECOMP")
	aAdd(aParamList, "MV_LJNESER")
	aAdd(aParamList, "MV_LJECOMY")
	aAdd(aParamList, "MV_LJNETEE")
	aAdd(aParamList, "MV_LJNETES")
	aAdd(aParamList, "MV_LJEXAV")
	aAdd(aParamList, "MV_LJFINEN")
	aAdd(aParamList, "MV_LJNSU")
	aAdd(aParamList, "MV_LJOCOEN")
	aAdd(aParamList, "MV_LJGERRG")
	aAdd(aParamList, "MV_LJOCOMO")
	aAdd(aParamList, "MV_LJGRVCS")
	aAdd(aParamList, "MV_LJORDFP")
	aAdd(aParamList, "MV_LJIDCLI")
	aAdd(aParamList, "MV_LJPEDSF")
	aAdd(aParamList, "MV_LJINTEC")
	aAdd(aParamList, "MV_LJPEVP")
	aAdd(aParamList, "MV_LJLIBPE")
	aAdd(aParamList, "MV_LJPORIM")
	aAdd(aParamList, "MV_LJSUAUT")
	aAdd(aParamList, "MV_LJPRAZ")
	aAdd(aParamList, "MV_LJECURL")
	aAdd(aParamList, "MV_LJPRCP")
	aAdd(aParamList, "MV_LJFCVDA")
	aAdd(aParamList, "MV_LJPREPA")
	aAdd(aParamList, "MV_LJPRODR")
	aAdd(aParamList, "MV_LJHBTFP")
	aAdd(aParamList, "MV_LJQTDPL")
	aAdd(aParamList, "MV_LJITMSG")
	aAdd(aParamList, "MV_LJRCFPG")
	aAdd(aParamList, "MV_LJECOMV")
	aAdd(aParamList, "MV_LJREGEN")
	aAdd(aParamList, "MV_LJFORCN")
	aAdd(aParamList, "MV_LJRENT")
	aAdd(aParamList, "MV_LJIMPCR")
	aAdd(aParamList, "MV_LJRESIA")
	aAdd(aParamList, "MV_LJESTAV")
	aAdd(aParamList, "MV_LJSEMPR")
	aAdd(aParamList, "MV_LJLODIS")
	aAdd(aParamList, "MV_LJGRSLS")
	aAdd(aParamList, "MV_LJSTFS")
	aAdd(aParamList, "MV_NUMPDV")
	aAdd(aParamList, "MV_OGENOTC")
	aAdd(aParamList, "MV_LJTEFPD")
	aAdd(aParamList, "MV_VLRETIR")
	aAdd(aParamList, "MV_LJTIMEM")
	aAdd(aParamList, "MV_LJTMLOG")
	aAdd(aParamList, "MV_LJTNINT")
	aAdd(aParamList, "MV_PCLTMP")
	aAdd(aParamList, "MV_LJTPESQ")
	aAdd(aParamList, "MV_PLSDRO")
	aAdd(aParamList, "MV_LJTPMOV")
	aAdd(aParamList, "MV_PRFSPED")
	aAdd(aParamList, "MV_LJTPSER")
	aAdd(aParamList, "MV_PRIOPBM")
	aAdd(aParamList, "MV_LJTURNO")
	aAdd(aParamList, "MV_RELDEST")
	aAdd(aParamList, "MV_LJUSAMD")
	aAdd(aParamList, "MV_RELSUG")
	aAdd(aParamList, "MV_LJVALVP")
	aAdd(aParamList, "MV_RETZERO")
	aAdd(aParamList, "MV_LJVERCX")
	aAdd(aParamList, "MV_RISCO")
	aAdd(aParamList, "MV_LJVFSER")
	aAdd(aParamList, "MV_RMCLASS")
	aAdd(aParamList, "MV_LOCALIZ")
	aAdd(aParamList, "MV_RNDISS")
	aAdd(aParamList, "MV_LPADICM")
	aAdd(aParamList, "MV_RTOPOTC")
	aAdd(aParamList, "MV_LWCPAUT")
	aAdd(aParamList, "MV_SATTRDT")
	aAdd(aParamList, "MV_MATA000")
	aAdd(aParamList, "MV_SATXML")
	aAdd(aParamList, "MV_MAXUPL")
	aAdd(aParamList, "MV_MOEDA2")
	aAdd(aParamList, "MV_SCLOG")
	aAdd(aParamList, "MV_MOEDA4")
	aAdd(aParamList, "MV_SCPRDLT")
	aAdd(aParamList, "MV_NATFATU")
	aAdd(aParamList, "MV_SCRFIS")
	aAdd(aParamList, "MV_NUMBLOQ")
	aAdd(aParamList, "MV_SCRPED")
	aAdd(aParamList, "MV_LJTESTC")
	aAdd(aParamList, "MV_SEQATE")
	aAdd(aParamList, "MV_LJTMPAC")
	aAdd(aParamList, "MV_SHWCPAG")
	aAdd(aParamList, "MV_LJTPMIC")
	aAdd(aParamList, "MV_SOMAGNR")
	aAdd(aParamList, "MV_LJTRVFE")
	aAdd(aParamList, "MV_TECOCOA")
	aAdd(aParamList, "MV_LJUSDRP")
	aAdd(aParamList, "MV_TECOCOM")
	aAdd(aParamList, "MV_LJVEROD")
	aAdd(aParamList, "MV_TEFCLI2")
	aAdd(aParamList, "MV_LOGCF")
	aAdd(aParamList, "MV_TEFMODE")
	aAdd(aParamList, "MV_LWUSERS")
	aAdd(aParamList, "MV_TEFPSW")
	aAdd(aParamList, "MV_MICTERM")
	aAdd(aParamList, "MV_TEFREST")
	aAdd(aParamList, "MV_MOEDA5")
	aAdd(aParamList, "MV_TESDV")
	aAdd(aParamList, "MV_LJTEF20")
	aAdd(aParamList, "MV_TIPOPRZ")
	aAdd(aParamList, "MV_LJTOKIA")
	aAdd(aParamList, "MV_TOLLAYO")
	aAdd(aParamList, "MV_LJURLIA")
	aAdd(aParamList, "MV_TOLPOVE")
	aAdd(aParamList, "MV_LJVFTEE")
	aAdd(aParamList, "MV_TOLTIVE")
	aAdd(aParamList, "MV_MATA020")
	aAdd(aParamList, "MV_TPCOMIS")
	aAdd(aParamList, "MV_NATGE")
	aAdd(aParamList, "MV_TPRTDSP")
	aAdd(aParamList, "MV_LJTPRG")
	aAdd(aParamList, "MV_TREPORT")
	aAdd(aParamList, "MV_LWCOND")
	aAdd(aParamList, "MV_TROCAD")
	aAdd(aParamList, "MV_LJTLOG")
	aAdd(aParamList, "MV_UMOVINF")
	aAdd(aParamList, "MV_MOEDA3")
	aAdd(aParamList, "MV_URLANVI")
	aAdd(aParamList, "MV_LJVCRED")
	aAdd(aParamList, "MV_VINCVEN")
	aAdd(aParamList, "MV_LIMFACT")
	aAdd(aParamList, "MV_LJCHKPP")
	aAdd(aParamList, "MV_CRDLCAR")
	aAdd(aParamList, "MV_LIBNIV")
	aAdd(aParamList, "MV_LJCISS")
	aAdd(aParamList, "MV_DESCZF")
	aAdd(aParamList, "MV_CRDMAXL")
	aAdd(aParamList, "MV_DIRACA")
	aAdd(aParamList, "MV_LJCSETE")
	aAdd(aParamList, "MV_DOCSEQ")
	aAdd(aParamList, "MV_LJCTSER")
	aAdd(aParamList, "MV_LJAJCP")
	aAdd(aParamList, "MV_LJDELTD")
	aAdd(aParamList, "MV_LJATUPF")
	aAdd(aParamList, "MV_ARREFIN")
	aAdd(aParamList, "MV_LJB1COD")
	aAdd(aParamList, "MV_A1M996")
	aAdd(aParamList, "MV_LJBW701")
	aAdd(aParamList, "MV_LJDESGE")
	aAdd(aParamList, "MV_LJCATPR")
	aAdd(aParamList, "MV_FORMSUP")
	aAdd(aParamList, "MV_LJCDVOU")
	aAdd(aParamList, "MV_FRTACRE")
	aAdd(aParamList, "MV_CRDBLOQ")
	aAdd(aParamList, "MV_LJDRP")
	aAdd(aParamList, "MV_CANCNFE")
	aAdd(aParamList, "MV_LJDTIPI")
	aAdd(aParamList, "MV_CNDTP3")
	aAdd(aParamList, "MV_LJDVVND")
	aAdd(aParamList, "MV_LJ300PR")
	aAdd(aParamList, "MV_CRDTIT")
	aAdd(aParamList, "MV_LJADMGN")
	aAdd(aParamList, "MV_CRDTOLE")
	aAdd(aParamList, "MV_CRDBLCT")
	aAdd(aParamList, "MV_HISTTAB")
	aAdd(aParamList, "MV_LJC030I")
	aAdd(aParamList, "MV_LJECMM1")
	aAdd(aParamList, "MV_LJCEST")
	aAdd(aParamList, "MV_LJECMM4")
	aAdd(aParamList, "MV_CRDFORM")
	aAdd(aParamList, "MV_HTLCCRT")
	aAdd(aParamList, "MV_ACRSDUP")
	aAdd(aParamList, "MV_CRDVDIF")
	aAdd(aParamList, "MV_LJBF100")
	aAdd(aParamList, "MV_LJECO01")
	aAdd(aParamList, "MV_CRDDOC1")
	aAdd(aParamList, "MV_LJECOM6")
	aAdd(aParamList, "MV_LJALTCX")
	aAdd(aParamList, "MV_CREDCLI")
	aAdd(aParamList, "MV_LIMMAX")
	aAdd(aParamList, "MV_IMPTIFA")
	aAdd(aParamList, "MV_ENTFIN")
	aAdd(aParamList, "MV_LJECOMB")
	aAdd(aParamList, "MV_LJMTDIT")
	aAdd(aParamList, "MV_LJPRSIT")
	aAdd(aParamList, "MV_LJMNFPG")
	aAdd(aParamList, "MV_LJNRPEN")
	aAdd(aParamList, "MV_LJQTTK")
	aAdd(aParamList, "MV_LJOBINF")
	aAdd(aParamList, "MV_LJNEOIN")
	aAdd(aParamList, "MV_LJLPGBR")
	aAdd(aParamList, "MV_LJRECPA")
	aAdd(aParamList, "MV_LJOPTES")
	aAdd(aParamList, "MV_LJMNPER")
	aAdd(aParamList, "MV_LJORPAR")
	aAdd(aParamList, "MV_LJEMSUP")
	aAdd(aParamList, "MV_LJPEDRC")
	aAdd(aParamList, "MV_LJLIBGE")
	aAdd(aParamList, "MV_LJPEDTS")
	aAdd(aParamList, "MV_LJRETEF")
	aAdd(aParamList, "MV_LJPESRE")
	aAdd(aParamList, "MV_LJRETIN")
	aAdd(aParamList, "MV_LJPGSAD")
	aAdd(aParamList, "MV_LJRMPAG")
	aAdd(aParamList, "MV_LJMLTOC")
	aAdd(aParamList, "MV_LJSATCP")
	aAdd(aParamList, "MV_LJGRPPR")
	aAdd(aParamList, "MV_LJGRVBT")
	aAdd(aParamList, "MV_LJICMSA")
	aAdd(aParamList, "MV_LJSERDA")
	aAdd(aParamList, "MV_LJESTFL")
	aAdd(aParamList, "MV_LJSERE5")
	aAdd(aParamList, "MV_LJOPEST")
	aAdd(aParamList, "MV_LJSERGE")
	aAdd(aParamList, "MV_LJPDVEN")
	aAdd(aParamList, "MV_LJSERPR")
	aAdd(aParamList, "MV_LJPENXM")
	aAdd(aParamList, "MV_LJSGNUM")
	aAdd(aParamList, "MV_LJPHOTO")
	aAdd(aParamList, "MV_LJECOMH")
	aAdd(aParamList, "MV_LJFECCX")
	aAdd(aParamList, "MV_LJSITTI")
	aAdd(aParamList, "MV_LJLPDBL")
	aAdd(aParamList, "MV_LJSMAIL")
	aAdd(aParamList, "MV_LJMDRD")
	aAdd(aParamList, "MV_LJSNCFP")
	aAdd(aParamList, "MV_LJECOMF")
	aAdd(aParamList, "MV_LJIMGEX")
	aAdd(aParamList, "MV_LJIMPFA")
	aAdd(aParamList, "MV_LJSTMR")
	aAdd(aParamList, "MV_LJNFTEF")
	aAdd(aParamList, "MV_LJSTPRT")
	aAdd(aParamList, "MV_LJESTOR")
	aAdd(aParamList, "MV_LJIMPCO")
	aAdd(aParamList, "MV_PAISLOC")
	aAdd(aParamList, "MV_RNDPREC")
	aAdd(aParamList, "MV_LWVLMIN")
	aAdd(aParamList, "MV_LJVLCID")
	aAdd(aParamList, "MV_LJVLCRO")
	aAdd(aParamList, "MV_LJTPPAG")
	aAdd(aParamList, "MV_LJTEFIA")
	aAdd(aParamList, "MV_MESFECH")
	aAdd(aParamList, "MV_SCPAS")
	aAdd(aParamList, "MV_MFEPUT")
	aAdd(aParamList, "MV_SCTMCOD")
	aAdd(aParamList, "MV_MVAFRE")
	aAdd(aParamList, "MV_SCUSR")
	aAdd(aParamList, "MV_NFCEGC")
	aAdd(aParamList, "MV_LJWSCPO")
	aAdd(aParamList, "MV_NORM")
	aAdd(aParamList, "MV_LJWSCRM")
	aAdd(aParamList, "MV_NUMESTA")
	aAdd(aParamList, "MV_LJTPCAL")
	aAdd(aParamList, "MV_PERGNOT")
	aAdd(aParamList, "MV_TEFEMS")
	aAdd(aParamList, "MV_PORTORC")
	aAdd(aParamList, "MV_LOJANUM")
	aAdd(aParamList, "MV_LJVBCC")
	aAdd(aParamList, "MV_LOJAOPI")
	aAdd(aParamList, "MV_RECST")
	aAdd(aParamList, "MV_TEFSAVE")
	aAdd(aParamList, "MV_RELTIME")
	aAdd(aParamList, "MV_TESSERV")
	aAdd(aParamList, "MV_VLTROCA")
	aAdd(aParamList, "MV_TOLSENH")
	aAdd(aParamList, "MV_MOEDAP1")
	aAdd(aParamList, "MV_TOLURL")
	aAdd(aParamList, "MV_NFCEOFF")
	aAdd(aParamList, "MV_TOLUSUA")
	aAdd(aParamList, "MV_LJUSARC")
	aAdd(aParamList, "MV_TPBONUS")
	aAdd(aParamList, "MV_LJTPIMO")
	aAdd(aParamList, "MV_TPEFETP")
	aAdd(aParamList, "MV_RELAUSR")
	aAdd(aParamList, "MV_TPFATOR")
	aAdd(aParamList, "MV_MFEOUT")
	aAdd(aParamList, "MV_LWNATE1")
	aAdd(aParamList, "MV_NUMBORC")
	aAdd(aParamList, "MV_USAFOTO")
	aAdd(aParamList, "MV_QTDPREV")
	aAdd(aParamList, "MV_USAMNUM")
	aAdd(aParamList, "MV_NFCEDES")
	aAdd(aParamList, "MV_VL10925")
	aAdd(aParamList, "MV_RELTLS ")
	aAdd(aParamList, "MV_VL13137")
	aAdd(aParamList, "MV_PEROT")
	aAdd(aParamList, "MV_LJTRAUT")
	aAdd(aParamList, "MV_LJCNVB0")
	aAdd(aParamList, "MV_CRDSTAT")
	aAdd(aParamList, "MV_LIMCFIS")
	aAdd(aParamList, "MV_FRTQTTK")
	aAdd(aParamList, "MV_LJDRPDA")
	aAdd(aParamList, "MV_LJCMPNC")
	aAdd(aParamList, "MV_LJDTBAR")
	aAdd(aParamList, "MV_LJCRPAF")
	aAdd(aParamList, "MV_AUTOCOM")
	aAdd(aParamList, "MV_LJDAVEC")
	aAdd(aParamList, "MV_LJE1NUM")
	aAdd(aParamList, "MV_LJ720FC")
	aAdd(aParamList, "MV_L060SB5")
	aAdd(aParamList, "MV_CRDACPT")
	aAdd(aParamList, "MV_LJCBFPG")
	aAdd(aParamList, "MV_LJDMNF")
	aAdd(aParamList, "MV_LJECMM3")
	aAdd(aParamList, "MV_FINJRTP")
	aAdd(aParamList, "MV_LJACBRU")
	aAdd(aParamList, "MV_CRDAVAL")
	aAdd(aParamList, "MV_IMPLJRE")
	aAdd(aParamList, "MV_LJCHGTP")
	aAdd(aParamList, "MV_LJECOM2")
	aAdd(aParamList, "MV_LJ350MV")
	aAdd(aParamList, "MV_L1TXMOE")
	aAdd(aParamList, "MV_CRNEG")
	aAdd(aParamList, "MV_IMPSIVA")
	aAdd(aParamList, "MV_BONUSTS")
	aAdd(aParamList, "MV_LJALTAP")
	aAdd(aParamList, "MV_LJMLTRC")
	aAdd(aParamList, "MV_LJINTUF")
	aAdd(aParamList, "MV_LJIPECF")
	aAdd(aParamList, "MV_LJMMAIL")
	aAdd(aParamList, "MV_LJPRDON")
	aAdd(aParamList, "MV_LJMNBOT")
	aAdd(aParamList, "MV_LJPREIA")
	aAdd(aParamList, "MV_LJNATIA")
	aAdd(aParamList, "MV_LJITOP")
	aAdd(aParamList, "MV_LJNEOCM")
	aAdd(aParamList, "MV_LJPSWFS")
	aAdd(aParamList, "MV_LJFORIA")
	aAdd(aParamList, "MV_LJRAPP0")
	aAdd(aParamList, "MV_LJECOMU")
	aAdd(aParamList, "MV_LJRAPP1")
	aAdd(aParamList, "MV_LJPFID")
	aAdd(aParamList, "MV_LJRECIT")
	aAdd(aParamList, "MV_LJECOMN")
	aAdd(aParamList, "MV_LJLECB")
	aAdd(aParamList, "MV_LJEMPCK")
	aAdd(aParamList, "MV_LJLIBCF")
	aAdd(aParamList, "MV_LJPEDEF")
	aAdd(aParamList, "MV_LJFSUB")
	aAdd(aParamList, "MV_LJSERVF")
	aAdd(aParamList, "MV_LJFWRPC")
	aAdd(aParamList, "MV_LJNUMIT")
	aAdd(aParamList, "MV_LJRPAUT")
	aAdd(aParamList, "MV_LJECSTF")
	aAdd(aParamList, "MV_LJLOCNC")
	aAdd(aParamList, "MV_LJPESPC")
	aAdd(aParamList, "MV_LJLOJIA")
	aAdd(aParamList, "MV_MAXPONT")
	aAdd(aParamList, "MV_TESVEND")
	aAdd(aParamList, "MV_LJVPPRO")
	aAdd(aParamList, "MV_SCRORC")
	aAdd(aParamList, "MV_TITBOT")
	aAdd(aParamList, "MV_SCRTROC")
	aAdd(aParamList, "MV_TOLER")
	aAdd(aParamList, "MV_LJTPFIN")
	aAdd(aParamList, "MV_NOTAOUT")
	aAdd(aParamList, "MV_MULNATR")
	aAdd(aParamList, "MV_PLSATIV")
	aAdd(aParamList, "MV_TEFGRT")
	aAdd(aParamList, "MV_LWALT")
	aAdd(aParamList, "MV_SCRCUP")
	aAdd(aParamList, "MV_LJTPPED")
	aAdd(aParamList, "MV_SOMAOLD")
	aAdd(aParamList, "MV_PORTNOT")
	aAdd(aParamList, "MV_LJTISE1")
	aAdd(aParamList, "MV_LJTPSFA")
	aAdd(aParamList, "MV_RECVIAS")
	aAdd(aParamList, "MV_LWVLMLT")
	aAdd(aParamList, "MV_LJTXNFE")
	aAdd(aParamList, "MV_NSRDISP")
	aAdd(aParamList, "MV_LJALTEN")
	aAdd(aParamList, "MV_B1M996")
	aAdd(aParamList, "MV_FISALCT")
	aAdd(aParamList, "MV_FILTSL1")
	aAdd(aParamList, "MV_CRDAUT")
	aAdd(aParamList, "MV_LJCRGAU")
	aAdd(aParamList, "MV_LJCUPRE")
	aAdd(aParamList, "MV_COMISCC")
	aAdd(aParamList, "MV_FISFRAS")
	aAdd(aParamList, "MV_EMPTEF")
	aAdd(aParamList, "MV_CENT")
	aAdd(aParamList, "MV_FRLMORC")
	aAdd(aParamList, "MV_FRTDIGQ")
	aAdd(aParamList, "MV_COMIDEV")
	aAdd(aParamList, "MV_DATCHE")
	aAdd(aParamList, "MV_CREDLJ")
	aAdd(aParamList, "MV_LJCONDP")
	aAdd(aParamList, "MV_LJCHGDV")
	aAdd(aParamList, "MV_CRDARQ")
	aAdd(aParamList, "MV_LJCOLOR")
	aAdd(aParamList, "MV_ALTNUM")
	aAdd(aParamList, "MV_LJDIRGR")
	aAdd(aParamList, "MV_LJMENNO")
	aAdd(aParamList, "MV_LJQTITE")
	aAdd(aParamList, "MV_LJFILIN")
	aAdd(aParamList, "MV_LJNCUPS")
	aAdd(aParamList, "MV_LJRCABT")
	aAdd(aParamList, "MV_LJECOMK")
	aAdd(aParamList, "MV_LJFSEMA")
	aAdd(aParamList, "MV_LJFILWS")
	aAdd(aParamList, "MV_LJRECNR")
	aAdd(aParamList, "MV_LJPEATU")
	aAdd(aParamList, "MV_LJIFSRE")
	aAdd(aParamList, "MV_LJMUFI")
	aAdd(aParamList, "MV_LJILAUT")
	aAdd(aParamList, "MV_LJECST1")
	aAdd(aParamList, "MV_LJILDRV")
	aAdd(aParamList, "MV_LJJUFIN")
	aAdd(aParamList, "MV_LJECOMG")
	aAdd(aParamList, "MV_LJMARGE")
	aAdd(aParamList, "MV_LJLISAN")
	aAdd(aParamList, "MV_LJINDPA")
	aAdd(aParamList, "MV_LJGCOMS")
	aAdd(aParamList, "MV_LJMLTOR")
	aAdd(aParamList, "MV_LJILTPA")
	aAdd(aParamList, "MV_LJIMAGE")
	aAdd(aParamList, "MV_LJSERIE")
	aAdd(aParamList, "MV_LJMUDIN")
	aAdd(aParamList, "MV_LJLPTIV")
	aAdd(aParamList, "MV_LJOPCON")
	aAdd(aParamList, "MV_LJLPTSV")
	aAdd(aParamList, "MV_LJPRDSC")
	aAdd(aParamList, "MV_LJSNFEP")
	aAdd(aParamList, "MV_TIPACRD")
	aAdd(aParamList, "MV_SPEDURL")
	aAdd(aParamList, "MV_TESNOTA")
	aAdd(aParamList, "MV_LOJAHSP")
	aAdd(aParamList, "MV_TXPER")
	aAdd(aParamList, "MV_NFCEIMP")
	aAdd(aParamList, "MV_NFCEEXC")
	aAdd(aParamList, "MV_LJVFNFS")
	aAdd(aParamList, "MV_VRETPIS")
	aAdd(aParamList, "MV_TPCOMLJ")
	aAdd(aParamList, "MV_VRETCSL")
	aAdd(aParamList, "MV_RATDESP")
	aAdd(aParamList, "MV_LJTRMVD")
	aAdd(aParamList, "MV_LJVFE")
	aAdd(aParamList, "MV_TABPR")
	aAdd(aParamList, "MV_LJUSRFS")
	aAdd(aParamList, "MV_LJVPCNF")
	aAdd(aParamList, "MV_RELAPSW")
	aAdd(aParamList, "MV_LJVPVAR")
	aAdd(aParamList, "MV_LJTESSV")
	aAdd(aParamList, "MV_VRETCOF")
	aAdd(aParamList, "MV_FRTDESC")
	aAdd(aParamList, "MV_DIRCFRT")
	aAdd(aParamList, "MV_LJCLION")
	aAdd(aParamList, "MV_LJDCCLI")
	aAdd(aParamList, "MV_FILACRS")
	aAdd(aParamList, "MV_LJAVANC")
	aAdd(aParamList, "MV_LJAJDES")
	aAdd(aParamList, "MV_LJDESPA")
	aAdd(aParamList, "MV_LJDTORC")
	aAdd(aParamList, "MV_ENTEXCE")
	aAdd(aParamList, "MV_INUTLOJ")
	aAdd(aParamList, "MV_CMC7CHQ")
	aAdd(aParamList, "MV_ENTETRB")
	aAdd(aParamList, "MV_LJJUROS")
	aAdd(aParamList, "MV_LJILOLE")
	aAdd(aParamList, "MV_LJSENDO")
	aAdd(aParamList, "MV_LJMATOF")
	aAdd(aParamList, "MV_LJNCCBC")
	aAdd(aParamList, "MV_LJMULTA")
	aAdd(aParamList, "MV_LJPRGAR")
	aAdd(aParamList, "MV_LJIMAUT")
	aAdd(aParamList, "MV_LJNSECF")
	aAdd(aParamList, "MV_LJPARFA")
	aAdd(aParamList, "MV_LJGRMR")
	aAdd(aParamList, "MV_LJIPDES")
	aAdd(aParamList, "MV_LJSIMPN")
	aAdd(aParamList, "MV_LJECOMS")
	aAdd(aParamList, "MV_LJIFSCO")
	aAdd(aParamList, "MV_LJECOML")
	aAdd(aParamList, "MV_LJSRAUT")
	aAdd(aParamList, "MV_LJTPREC")
	aAdd(aParamList, "MV_RESAUT")
	aAdd(aParamList, "MV_TPNRNFS")
	aAdd(aParamList, "MV_PORTFIS")
	aAdd(aParamList, "MV_VRETISS")
	aAdd(aParamList, "MV_TMKLOJ")
	aAdd(aParamList, "MV_ULMES")
	aAdd(aParamList, "MV_LOJKIT")
	aAdd(aParamList, "MV_LWPARC")
	aAdd(aParamList, "MV_NFCECNJ")
	aAdd(aParamList, "MV_RNDIPI")
	aAdd(aParamList, "MV_PLSLDR")
	aAdd(aParamList, "MV_VALCNPJ")
	aAdd(aParamList, "MV_SCRNFCP")
	aAdd(aParamList, "MV_VALCPF")
	aAdd(aParamList, "MV_LJTITGR")
	aAdd(aParamList, "MV_MCUSTO")
	aAdd(aParamList, "MV_SCRNOTA")
	aAdd(aParamList, "MV_LJUSATL")
	aAdd(aParamList, "MV_PERFIL")
	aAdd(aParamList, "MV_NFCETOK")
	aAdd(aParamList, "MV_LJCONDE")
	aAdd(aParamList, "MV_LJCDL")
	aAdd(aParamList, "MV_LJDVACR")
	aAdd(aParamList, "MV_LJECOM5")
	aAdd(aParamList, "MV_LJCMPCR")
	aAdd(aParamList, "MV_FISCTRB")
	aAdd(aParamList, "MV_IMPFIS")
	aAdd(aParamList, "MV_COMP")
	aAdd(aParamList, "MV_LJCALJM")
	aAdd(aParamList, "MV_DTLIMIT")
	aAdd(aParamList, "MV_CONTNFI")
	aAdd(aParamList, "MV_LJILQTD")
	aAdd(aParamList, "MV_LJMUCH")
	aAdd(aParamList, "MV_LJIFSJU")
	aAdd(aParamList, "MV_LJPAFWS")
	aAdd(aParamList, "MV_LJGEPRE")
	aAdd(aParamList, "MV_LJSLFIN")
	aAdd(aParamList, "MV_LJPREC")
	aAdd(aParamList, "MV_LJGarFP")
	aAdd(aParamList, "MV_LJRECFI")
	aAdd(aParamList, "MV_LJOBGCF")
	aAdd(aParamList, "MV_LJFNGE")
	aAdd(aParamList, "MV_LJPVLIB")
	aAdd(aParamList, "MV_NATCCOR")
	aAdd(aParamList, "MV_NATRC")
	aAdd(aParamList, "MV_RELAUTH")
	aAdd(aParamList, "MV_PRICE")
	aAdd(aParamList, "MV_NFCEUTC")
	aAdd(aParamList, "MV_VALTOTA")
	aAdd(aParamList, "MV_SPEDEXC")
	aAdd(aParamList, "MV_INUTCLI")
	aAdd(aParamList, "MV_LJATVGP")
	aAdd(aParamList, "MV_JURTIPO")
	aAdd(aParamList, "MV_IPIBRUT")
	aAdd(aParamList, "MV_CONTNF")
	aAdd(aParamList, "MV_INUTTES")
	aAdd(aParamList, "MV_FTTEFLI")
	aAdd(aParamList, "MV_LJECOM0")
	aAdd(aParamList, "MV_CRDTPLC")
	aAdd(aParamList, "MV_LJC1VFE")
	aAdd(aParamList, "MV_ICMPAD")
	aAdd(aParamList, "MV_LJNATRE")
	aAdd(aParamList, "MV_LJPGTRO")
	aAdd(aParamList, "MV_LJGECSV")
	aAdd(aParamList, "MV_LJMVPE")
	aAdd(aParamList, "MV_TESENT")
	aAdd(aParamList, "MV_VLBXREC")
	aAdd(aParamList, "MV_LJTIPOD")
	aAdd(aParamList, "MV_RELPSW")
	aAdd(aParamList, "MV_TPABISS")
	aAdd(aParamList, "MV_RELFROM")
	aAdd(aParamList, "MV_NATDEV")
	aAdd(aParamList, "MV_RELACNT")
	aAdd(aParamList, "MV_LJVLDEV")
	aAdd(aParamList, "MV_NATCB")
	aAdd(aParamList, "MV_LJVLNCC")
	aAdd(aParamList, "MV_CODREG")
	aAdd(aParamList, "MV_CONFCLI")
	aAdd(aParamList, "MV_INUTPRO")
	aAdd(aParamList, "MV_LJBXPAR")
	aAdd(aParamList, "MV_GERIMPV")
	aAdd(aParamList, "MV_LJINSAR")
	aAdd(aParamList, "MV_LJILLEN")
	aAdd(aParamList, "MV_LJILVLO")
	aAdd(aParamList, "MV_LJILLCO")
	aAdd(aParamList, "MV_LJNFSXE")
	aAdd(aParamList, "MV_LJILLDO")
	aAdd(aParamList, "MV_LJRECEB")
	aAdd(aParamList, "MV_LJILLIM")
	aAdd(aParamList, "MV_LJILLBR")
	aAdd(aParamList, "MV_LJPEDVE")
	aAdd(aParamList, "MV_LJILLAC")
	aAdd(aParamList, "MV_LJILLKT")
	aAdd(aParamList, "MV_LJFORMD")
	aAdd(aParamList, "MV_LJECOMX")
	aAdd(aParamList, "MV_RTIPFIN")
	aAdd(aParamList, "MV_LWBSMLT")
	aAdd(aParamList, "MV_SEQESPE")
	aAdd(aParamList, "MV_NATSANG")
	aAdd(aParamList, "MV_NFCEIDT")
	aAdd(aParamList, "MV_NATCONV")
	aAdd(aParamList, "MV_RELSERV")
	aAdd(aParamList, "MV_NATCRED")
	aAdd(aParamList, "MV_LWPREF1")
	aAdd(aParamList, "MV_NATTROC")
	aAdd(aParamList, "MV_AMBNFCE")
	aAdd(aParamList, "MV_FORMCRD")
	aAdd(aParamList, "MV_LJCTRET")
	aAdd(aParamList, "MV_LJCHVST")
	aAdd(aParamList, "MV_LJDTNCC")
	aAdd(aParamList, "MV_FRTCRD")
	aAdd(aParamList, "MV_ESPECIE")
	aAdd(aParamList, "MV_CALCFIN")
	aAdd(aParamList, "MV_LJMDORC")
	aAdd(aParamList, "MV_LJILLPO")
	aAdd(aParamList, "MV_LJPAFEC")
	aAdd(aParamList, "MV_LJRETVL")
	aAdd(aParamList, "MV_LJFISMS")
	aAdd(aParamList, "MV_LJRMBAC")
	aAdd(aParamList, "MV_LJGRVON")
	aAdd(aParamList, "MV_LJIPENP")
	aAdd(aParamList, "MV_LOJAPED")
	aAdd(aParamList, "MV_PRXPARC")
	aAdd(aParamList, "MV_MODNFCE")
	aAdd(aParamList, "MV_VERSAT")
	aAdd(aParamList, "MV_SCINTEG")
	aAdd(aParamList, "MV_LOJARPS")
	aAdd(aParamList, "MV_LJTESPE")
	aAdd(aParamList, "MV_NATOUTR")
	aAdd(aParamList, "MV_HORARMT")
	aAdd(aParamList, "MV_DESCSAI")
	aAdd(aParamList, "MV_FRTIMP")
	aAdd(aParamList, "MV_LJDESM")
	aAdd(aParamList, "MV_CAT8309")
	aAdd(aParamList, "MV_HVERAO")
	aAdd(aParamList, "MV_LJCPMOD")
	aAdd(aParamList, "MV_ACATIVO")
	aAdd(aParamList, "MV_LJECOMT")
	aAdd(aParamList, "MV_LJEXAPU")
	aAdd(aParamList, "MV_TELAFIN")
	aAdd(aParamList, "MV_QUEST")
	aAdd(aParamList, "MV_SATTEST")
	aAdd(aParamList, "MV_SPEDEND")
	aAdd(aParamList, "MV_LJTPCOM")
	aAdd(aParamList, "MV_MASCGRD")
	aAdd(aParamList, "MV_NATVALE")
	aAdd(aParamList, "MV_NATFIN")
	aAdd(aParamList, "MV_TEFMILH")
	aAdd(aParamList, "MV_TXVISTA")
	aAdd(aParamList, "MV_LOJANF")
	aAdd(aParamList, "MV_TEFCRIP")
	aAdd(aParamList, "MV_TEFNSTR")
	aAdd(aParamList, "MV_LJDAVOS")
	aAdd(aParamList, "MV_INFCHEQ")
	aAdd(aParamList, "MV_LJECOMQ")
	aAdd(aParamList, "MV_LJNFTRO")
	aAdd(aParamList, "MV_LJILJLO")
	aAdd(aParamList, "MV_LJJURCC")
	aAdd(aParamList, "MV_LJILLIP")
	aAdd(aParamList, "MV_LJNRNFS")
	aAdd(aParamList, "MV_MAPARES")
	aAdd(aParamList, "MV_RELGART")
	aAdd(aParamList, "MV_USACRED")
	aAdd(aParamList, "MV_LJCUSVF")
	aAdd(aParamList, "MV_DEVNCC")
	aAdd(aParamList, "MV_LJPGCC")
	aAdd(aParamList, "MV_LJLBNT")
	aAdd(aParamList, "MV_LJVALEP")
	aAdd(aParamList, "MV_LJTRDIN")
	aAdd(aParamList, "MV_NATCHEQ")
	aAdd(aParamList, "MV_TEFMANU")
	aAdd(aParamList, "MV_TESTROC")
	aAdd(aParamList, "MV_LJADMFI")
	aAdd(aParamList, "MV_LJNCCOR")
	aAdd(aParamList, "MV_LJLVFIS")
	aAdd(aParamList, "MV_TRCMOED")
	aAdd(aParamList, "MV_LOGPATH")
	aAdd(aParamList, "MV_NFCEURL")
	aAdd(aParamList, "MV_LJTPDES")
	aAdd(aParamList, "MV_RFID")
	aAdd(aParamList, "MV_LJTSC")
	aAdd(aParamList, "MV_LJTRNAT")
	aAdd(aParamList, "MV_LJAMBIE")
	aAdd(aParamList, "MV_LJCPNCC")
	aAdd(aParamList, "MV_LJRMS")
	aAdd(aParamList, "MV_LJHMTEF")
	aAdd(aParamList, "MV_LJREST")
	aAdd(aParamList, "MV_TEFVERS")
	aAdd(aParamList, "MV_FISNOTA")
	aAdd(aParamList, "MV_CODBAR")
	aAdd(aParamList, "MV_ARQPROD")
	aAdd(aParamList, "MV_LJRECIS")
	aAdd(aParamList, "MV_LWVLINI")
	aAdd(aParamList, "MV_LJTRANS")
	aAdd(aParamList, "MV_NATCART")
	aAdd(aParamList, "MV_NUMITEN")
	aAdd(aParamList, "MV_FTTEFGU")
	aAdd(aParamList, "MV_INTEEMS")
	aAdd(aParamList, "MV_ESTNEG")
	aAdd(aParamList, "MV_LJINTER")
	aAdd(aParamList, "MV_LJPAGTO")
	aAdd(aParamList, "MV_LJGRVVB")
	aAdd(aParamList, "MV_LJVACC")
	aAdd(aParamList, "MV_LJUSAFD")
	aAdd(aParamList, "MV_FORMPAD")
	aAdd(aParamList, "MV_LJPREF")
	aAdd(aParamList, "MV_LJGERTX")
	aAdd(aParamList, "MV_LJMOD3")
	aAdd(aParamList, "MV_RASTRO")
	aAdd(aParamList, "MV_LJGERSC")
	aAdd(aParamList, "MV_VEICULO")
	aAdd(aParamList, "MV_NATDINH")
	aAdd(aParamList, "MV_LJMULTN")
	aAdd(aParamList, "MV_TEFPEND")
	aAdd(aParamList, "MV_NATNCC")
	aAdd(aParamList, "MV_LJRGDES")
	aAdd(aParamList, "MV_ESTADO")
	aAdd(aParamList, "MV_LJPRDSV")
	aAdd(aParamList, "MV_LJRGMID")
	aAdd(aParamList, "MV_INTHTL")
	aAdd(aParamList, "MV_NATTEF")
	aAdd(aParamList, "MV_VERNFCE")
	aAdd(aParamList, "MV_MOEDA1")
	aAdd(aParamList, "MV_LJECOMO")
	aAdd(aParamList, "MV_LJGRINT")
	aAdd(aParamList, "MV_LJINTFS")
	aAdd(aParamList, "MV_LJIMPGF")
	aAdd(aParamList, "MV_LJLSPRE")
	aAdd(aParamList, "MV_TPSOLCF")
	aAdd(aParamList, "MV_CONDPAD")
	aAdd(aParamList, "MV_LJCFID")
	aAdd(aParamList, "MV_LJPRVEN")
	aAdd(aParamList, "MV_NATRECE")
	aAdd(aParamList, "MV_LJSYNT")
	aAdd(aParamList, "MV_DESCISS")
	aAdd(aParamList, "MV_LJTPSF")
	aAdd(aParamList, "MV_ARREFAT")
	aAdd(aParamList, "MV_CXLOJA")
	aAdd(aParamList, "MV_LJTRLOC")
	aAdd(aParamList, "MV_ALIQISS")
	aAdd(aParamList, "MV_LJECOMM")
	aAdd(aParamList, "MV_LJCONFF")
	aAdd(aParamList, "MV_VENDPAD")
	aAdd(aParamList, "MV_CTRLFOL")
	aAdd(aParamList, "MV_LJCNVDA")
	aAdd(aParamList, "MV_LJCSF")
	aAdd(aParamList, "MV_LJTPGAR")
	aAdd(aParamList, "MV_LJTROCO")
	aAdd(aParamList, "MV_TESSAI")
	aAdd(aParamList, "MV_1DUP")
	aAdd(aParamList, "MV_LJICMJR")
	aAdd(aParamList, "MV_LJOFFLN")
	aAdd(aParamList, "MV_TEFMULT")
	aAdd(aParamList, "MV_TABPAD")
	aAdd(aParamList, "MV_MOEDA")
	aAdd(aParamList, "MV_LOJAPAD")
	aAdd(aParamList, "MV_SIMB")
	aAdd(aParamList, "MV_CLIPAD")
	aAdd(aParamList, "MV_SIMB1")
	aAdd(aParamList, "MV_URLBIOM")
    aAdd(aParamList, "MV_PSHLOCA")
    aAdd(aParamList, "MV_PSHGIT")
    aAdd(aParamList, "MV_PSHCOMP")
    aAdd(aParamList, "MV_PSHMOV")
    aAdd(aParamList, "MV_PSHCAIN")
	aAdd(aParamList, "MV_LJCRDPT")
	aAdd(aParamList, "MV_LJRDIMP")
	aAdd(aParamList, "MV_ATUCOMP")
	aAdd(aParamList, "MV_AUTHWS")
	aAdd(aParamList, "MV_BR10925")
	aAdd(aParamList, "MV_CADPROD")
	aAdd(aParamList, "MV_CFDMSG")
	aAdd(aParamList, "MV_CMP330")
	aAdd(aParamList, "MV_DATAFIS")
	aAdd(aParamList, "MV_ESTABLX")
	aAdd(aParamList, "MV_HVERAOF")
	aAdd(aParamList, "MV_HVERAOI")
	aAdd(aParamList, "MV_INSS")
	aAdd(aParamList, "MV_ISS")
	aAdd(aParamList, "MV_LJ2VCON")
	aAdd(aParamList, "MV_LJATCLI")
	aAdd(aParamList, "MV_LJATUSE")
	aAdd(aParamList, "MV_LJBENSN")
	aAdd(aParamList, "MV_LJCFPDP")
	aAdd(aParamList, "MV_LJCOMIS")
	aAdd(aParamList, "MV_LJCPRPS")
	aAdd(aParamList, "MV_LJCREVD")
	aAdd(aParamList, "MV_LJCTPDV")
	aAdd(aParamList, "MV_LJCTRES")
	aAdd(aParamList, "MV_LJDGCPF")
	aAdd(aParamList, "MV_LJECCAS")
	aAdd(aParamList, "MV_LJEMAIL")
	aAdd(aParamList, "MV_LJEMSAT")
	aAdd(aParamList, "MV_LJEXCRE")
	aAdd(aParamList, "MV_LJIFPLI")
	aAdd(aParamList, "MV_LJINFQT")
	aAdd(aParamList, "MV_LJIPCOR")
	aAdd(aParamList, "MV_LJIPIFR")
	aAdd(aParamList, "MV_LJLOGCA")
	aAdd(aParamList, "MV_LJMTPRO")
	aAdd(aParamList, "MV_LJMTSN")
	aAdd(aParamList, "MV_LJNCEST")
	aAdd(aParamList, "MV_LJNGSUP")
	aAdd(aParamList, "MV_LJPAFMP")
	aAdd(aParamList, "MV_LJPBM")
	aAdd(aParamList, "MV_LJQRCPP")
	aAdd(aParamList, "MV_LJQSTPE")
	aAdd(aParamList, "MV_LJREPAY")
	aAdd(aParamList, "MV_LJRESCX")
	aAdd(aParamList, "MV_LJRESER")
	aAdd(aParamList, "MV_LJSCCC")
	aAdd(aParamList, "MV_LJTDESI")
	aAdd(aParamList, "MV_LJTESDV")
	aAdd(aParamList, "MV_LJTFILE")
	aAdd(aParamList, "MV_LJTHREA")
	aAdd(aParamList, "MV_LJTPCAN")
	aAdd(aParamList, "MV_LJTPCNC")
	aAdd(aParamList, "MV_LJTPFRE")
	aAdd(aParamList, "MV_LJTPGCC")
	aAdd(aParamList, "MV_LJTPSCH")
	aAdd(aParamList, "MV_LJVALPA")
	aAdd(aParamList, "MV_LJVINPE")
	aAdd(aParamList, "MV_LJZRDSC")
	aAdd(aParamList, "MV_LOJPAD")
	aAdd(aParamList, "MV_LOTVENC")
	aAdd(aParamList, "MV_MTCLF3K")
	aAdd(aParamList, "MV_NATPGDG")
	aAdd(aParamList, "MV_NATPGPX")
	aAdd(aParamList, "MV_NCCRESI")
	aAdd(aParamList, "MV_NFCECON")
	aAdd(aParamList, "MV_NFCERTC")
	aAdd(aParamList, "MV_NFCESUB")
	aAdd(aParamList, "MV_NFCEVQR")
	aAdd(aParamList, "MV_RELT")
	aAdd(aParamList, "MV_RTIPESP")
	aAdd(aParamList, "MV_STMEDIA")
	aAdd(aParamList, "MV_ULTAQUI")
	aAdd(aParamList, "MV_USALOGP")
	aAdd(aParamList, "MV_VLDCTRB")
	aAdd(aParamList, "MV_WMSNEW")
EndIf

aSort(aParamList)

If File( cFileLog )	// Verifica se o arquilo de LOG existe
	// Abre o arquivo de LOG
	nHandle := FOpen( cFileLog, 2 )
	FSeek ( nHandle, 0, 2 )	// Posiciona no final do arquivo.
	
	For nX:=1 to Len(aParamList)
		
		cParametro := aParamList[nX]

		//Verifica se o parametro existe
		xConteudo := cValToChar( GetMv( cParametro, .F., "#####") )
		
		If xConteudo == "#####"
			xConteudo := "<Parametro nao encontrado>"
		Else
			If Empty(xConteudo)
				xConteudo := "<vazio>"
			EndIf
			xConteudo := "Conteudo: [" + xConteudo + "]"
		EndIf

		cLogText := cThreadID + " " + PadR(cParametro,10) + " | " + xConteudo
		FWrite( nHandle, cLogText + CRLF, Len(cLogText) + 2 )

	Next nX
	FClose( nHandle ) //Fecha o arquivo de LOG
EndIf

Return

//---------------------------------------------------
/*/{Protheus.doc} LjxAEmuBal
Retorna a qtde conforme peso no arquivo -
para emular balanca 
@author 	Julio.Nery 
@version 	12
@since 		29/04/2019
/*/
//---------------------------------------------------
Static Function LjxAEmuBal(nPADQtde)
Local cEmulBalan:= "emuladorpeso.txt"
Local nHdlTxt	:= 0
Local nQtde		:= 0
Local cQtde		:= ""

If File(cEmulBalan)
	nHdlTxt := FT_FUse(cEmulBalan)
	If nHdlTxt == -1
		Conout('Não foi possivel criar arquivo de emular balanca, assumido qtde padrão [' + cValToChar(nQtdePAD) + ']')
		nQtde := nPADQtde
	Else
		FT_FGoTop()
		cQtde := FT_FReadLn()
		FT_FUSE() //Fecha o arquivo
			
		If isdigit(cQtde)
			nQtde := Val(cQtde)
			Conout('Validado conteúdo numérico no TXT')
		Else
			nQtde := nPADQtde
		EndIf
		Conout('Qtde da balanca lido via arquivo emuladorbalanca.txt - [' + cQtde + ']')
	EndIf
EndIf

Return nQtde

//---------------------------------------------------
/*/{Protheus.doc} LjHaEmuBal
Avalia se existe o emulador - dai valida o B1_BALANCA = 2
sem emulador
@author 	Julio.Nery 
@version 	12
@since 		29/04/2019
/*/
//---------------------------------------------------
Static Function LjHaEmuBal()
Local cEmulBalan:= "emuladorpeso.txt"
Local lRet := .F.

lRet := File(cEmulBalan)

Return lRet

//---------------------------------------------------
/*/{Protheus.doc} LojAltPed
Executa o ponto de entrada para saber se libera a alteração
do pedido no MATA410 ou nao.

@author 	Bruno Almeida
@version 	12
@since 		17/11/2020
/*/
//---------------------------------------------------
Function LojAltPed()

Local lRet := .F.

If ExistBlock("LJI701O2")
	LjGrvLog( NIL, "Antes da execução do PE LJI701O2")
	lRet := ExecBlock("LJI701O2",.F.,.F.) 
	LjGrvLog( NIL, "Depois da execução do PE LJI701O2")
	If ValType(lRet) == "L"
		If lRet
			MsgInfo(STR0207,STR0208) //"Alteração de pedido liberado por meio de ponto de entrada, caso o valor total seja modificado, poderá ocorrer divergência com o valor gerado no financeiro." #"Atenção"
			LjGrvLog( NIL, STR0207)
		EndIf
	Else
		LjGrvLog( NIL, "O PE LJI701O2 nao retornou um valor do tipo logico, neste caso nao vai ser possivel alterar o pedido pelo MATA410.")
		lRet := .F.
	EndIf
EndIf

Return lRet

//--------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} LjBuscaOrc
Busca orçamento (SL1) que teve movimentação para determinado operador e data.

@type    function
@author  Alberto Deviciente
@since   15/08/2023
@version P12

@param cOperacao, Caractere, Tipo de operacao de busca a ser realizada:
				  - "EXIST": Verifica se existe pelo menos 1 orçamento com movimento deste operador nesta data.
				  - "LOAD": Carrega os orçamentos com movimento deste operador nesta data.
@param cOperador, Caractere, Codigo do operador caixa
@param dDataMov, Data, Data do movimento
@param cNumMov, Caractere, Número do movimento
@param cCdEstacao, Caractere, Código da Estação
@param cPDV, Caractere, Código do PDV
@param cSerCup, Caractere, Série do Cupom Fiscal
@param cCupIni, Caractere, Número do Cupom Fiscal Inicial do Movimento
@param cCupFim, Caractere, Número do Cupom Fiscal Final do Movimento
@param lRetLst, Lógico, Indica se a chamada é para avaliar o retorno da lista de orçamentos encontrados.
@param aLstOrc, Array, Array com a relação de orçamentos encontrados para o movimento deste operador e data.
@param lConsCanc, Lógico, Determina se considera orcamentos cancelados
@param lConsOrcIn, Lógico, Determina se considera orcamentos incompletos

@return Lógico, Retorna se encontrou o registro na tabela SL1 com movimento para operador nesta data
/*/
//--------------------------------------------------------------------------------------------------------------
Static Function LjBuscaOrc(	cOperacao 	, cOperador	, dDataMov	, cNumMov	,;
						 	cCdEstacao	, cPDV	 	, cSerCup	, cCupIni	,;
							cCupFim		, lRetLst	, aLstOrc	, lConsCanc	,;
							lConsOrcIn )
Local lFound 	 	:= .F.
Local cQuery 	 	:= ""
Local cAliasQry	 	:= ""

Default cNumMov		:= ""
Default cCdEstacao	:= ""
Default cPDV		:= ""
Default cSerCup		:= ""
Default cCupIni		:= ""
Default cCupFim		:= ""
Default lRetLst		:= .F.
Default aLstOrc		:= {}
Default lConsCanc	:= .F.
Default lConsOrcIn	:= .F.

Do Case
	//Apenas verifica se existe pelo menos 1 orçamento com movimento deste operador nesta data.
	Case cOperacao == "EXIST"

		cQuery := "SELECT L1_NUM"
		cQuery += " FROM " + RetSqlName("SL1") 
		cQuery += " WHERE"
		cQuery += " L1_FILIAL = '" + xFilial("SL1") + "'"
		cQuery += " AND L1_OPERADO = '" + cOperador + "'"
		cQuery += " AND L1_EMISNF = '" + DToS(dDataMov) +"'"
		cQuery += " AND D_E_L_E_T_ = ' '"

		cQuery := ChangeQuery(cQuery)

		lFound := !Empty(MpSysExecScalar(cQuery,"L1_NUM"))

	//Busca os orçamentos com movimento deste operador nesta data.
	Case cOperacao == "LOAD"

		cQuery := "SELECT L1_FILIAL, L1_NUM"
		cQuery += " FROM " + RetSqlName("SL1") 
		cQuery += " WHERE"
		cQuery += " L1_FILIAL = '" + xFilial("SL1") + "'"
		cQuery += " AND L1_OPERADO = '" + cOperador + "'"
		cQuery += " AND L1_EMISNF = '" + DToS(dDataMov) +"'"
		cQuery += " AND L1_TIPO != ' '"
		cQuery += " AND L1_ORCRES = ' '" //Desconsidera orçamento filho (Deve considerar apenas o orçamento Pai para não trazer duplicado)
		cQuery += " AND L1_NUMMOV = '" + cNumMov + "'"
		cQuery += " AND L1_ESTACAO = '" + cCdEstacao + "'"
		cQuery += " AND (L1_PDV = ' ' OR L1_PDV = '" + cPDV + "')"

		If !lConsCanc //Se nao deve considerar os cancelados e estornados
			cQuery += " AND L1_SITUA != '07' AND L1_STORC NOT IN ('C','E')" //Desconsidera cancelados e estornados
		Endif
		/*Este trecho de validar o range de cupom fiscal, talvez só tenha sentido quando utilizar ECF e talvez mesmo assim, não seja mais utilizado:
		If !Empty(cCupIni) .And. !Empty(cCupFim) //Caso se use a verificacao de intervalo de cupons fiscais, verificar se o documento associado ao orcamento esta dentro do intervalo
			cQuery += " AND ( L1_DOC = ' ' OR ( L1_SERIE = '" + cSerCup + "' AND L1_DOC BETWEEN '" + cCupIni + "' AND '" + cCupFim + "' ) )"
		EndIf
		*/
		If !lConsOrcIn //Verificar se o orcamento nao esta incompleto
			cQuery += " AND ( EXISTS ( SELECT L4_NUM FROM " + RetSqlName("SL4") + " WHERE L4_FILIAL = '" + xFilial("SL4") + "' AND L4_NUM = L1_NUM AND D_E_L_E_T_ = ' ' )"
			cQuery += " OR L1_CREDITO > 0 )"
		EndIf
		cQuery += " AND D_E_L_E_T_ = ' '"

		cQuery := ChangeQuery(cQuery)

		cAliasQry := MpSysOpenQuery(cQuery)

		lFound := !(cAliasQry)->(Eof())

		Do While !(cAliasQry)->(Eof())
			//Registro valido encontrado
			If !lRetLst
				Exit
			Else
				aAdd(aLstOrc,{(cAliasQry)->L1_FILIAL,(cAliasQry)->L1_NUM})
				LjGrvLog( (cAliasQry)->L1_NUM, "Orcamento considerado na movimentacao: " + (cAliasQry)->L1_NUM )
				(cAliasQry)->(dbSkip())
			EndIf
		EndDo

		(cAliasQry)->(DbCloseArea())

EndCase

LjGrvLog( Nil, "Encontrou orcamento(s) com movimentação p/ o operador " + cOperador + " e data " + dtoc(dDataMov) + " ? " + If(lFound,"SIM","NAO") )

Return lFound

//--------------------------------------------------------------------------------------------------------------
/*/{Protheus.doc} ValidFonte
Valida se a chamada do log veio a partir de um determinado fonte da integração

@type    	Function
@author  	Bruno Almeida
@since   	07/03/2025
@version 	P12
@param 		cFonte, caracter, nome do fonte que esta executando
@return 	lRet, Lógico, retorna .T. se a chamada foi feita por algum fonte da integração ou .F.
/*/
//--------------------------------------------------------------------------------------------------------------
Static Function ValidFonte(cFonte)

Local lRet 		:= .F.
Local aFontes 	:= {"RMIPUBLICA.PRW","RMIENVIAPDV.PRW","RMIINTEPDV.PRW","INTEGRACAOTOTVSPDVAPI.TLPP","INTEGRACAOTOTVSPDVOBJ.TLPP","ATUSTATUSINTEGOBJ.TLPP","RMISENHAS.PRW","RMIXFUNA.PRW"}
Local nX 		:= 0

For nX := 1 To Len(aFontes)

	If Upper(AllTrim(cFonte)) == aFontes[nX]
		lRet := .T.
		Exit
	EndIf

Next nX

Return lRet
