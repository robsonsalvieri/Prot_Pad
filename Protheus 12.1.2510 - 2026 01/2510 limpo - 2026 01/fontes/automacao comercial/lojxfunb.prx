#INCLUDE "PROTHEUS.CH"
#INCLUDE "LOJXFUNB.CH"
#INCLUDE "FILEIO.CH"
#INCLUDE "AUTODEF.CH"

//ÚÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| aDifCalc   |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÙ
#DEFINE _DIFCALC1    06
#DEFINE _DIFCALC2    07
#DEFINE _DIFCALC3    03
#DEFINE _DIFCALC4    01

//ÚÄÄÄÄÄÄÄÄÄÄ¿
//| aDifCalc |
//ÀÄÄÄÄÄÄÄÄÄÄÙ
#DEFINE _ICMSOL_     03
#DEFINE _SOLMARGEM_  01
#DEFINE _SOLBASE_    02
#DEFINE _SOLVALOR_   03

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Funcoes que nao deverao chamar a OpenDevices para a interface MDI                       |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
#DEFINE _LJLOCKBYNAME	"LOJA010,LOJA701,FATA701,LOJA220,LOJA020,LOJA140,LOJA250,LOJA160,LOJA170,LOJA180,LOJA011T,LOJA012T,LOJA013S,LOJA014T,LOJA017T,LOJA018T,LOJA019T,LOJA021T,LOJA022T,LOJA023T,LOJA024T,LOJA025T,LOJA026T,LOJA027T,LOJA030T,LOJA031T,LOJC060,LJROTTEF"

#DEFINE ACCESSPATH	"AUTOCOM" 			// Caminho principal (Diretorio Pai) onde os arquivo de controle de acesso ao sistema (por estação) serão gravados
#DEFINE ACCESSSUB	"ACCESS" 			// Sub-Caminho (Diretorio Filho) onde os os arquivo de controle de acesso ao sistema (por estação) serão gravados

Static nHdlDisplay  := -1
Static nHdlBalanca  := -1
Static nHdlDispTor	:= -1
Static lUsaBalanca  := .F.
Static aTransAtu	:= {,,,,}
Static lEnvDesf		:= .F.
Static nHandTerm	:= -1					// Arquivo de controle de numeracao do terminal TEF
Static lImpTk		:= .F.					// Imprimi tiket para australia Imp Não fical (ECNF)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Variaveis estaticas utilizadas para o controle da exibicao³
//³da tela de permissao de desconto                          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Static __lAplicDesc	:= .F.					// Variavel logica de aplicacao do desconto
Static __nDescPer	:= 0					// Variavel com a porcentagem de desconto
Static __nDescLoj	:= 0					// Variavel com o valor de desconto
Static __cCodOrca	:= ""					// Variavel com o codigo do orcamento
Static __nPosIt		:= 0					// Variavel com o numero do item
Static aCNPJDV      := {}              		// CNPJs validos para uso do ECF E
Static aCNPJDVPRC   := {}              		// CNPJs validos para atualizacao de preco
Static aUsers								// Array com todos os usuarios do Sistema
Static oTotvsApi	:= Nil					//Objeto do tipo LJCTotvsApi, responsavel em fazer comunicacao com totvsapi.dll / totvsapi.so
Static __lIsPaf		:= .F.					//Variavel responsavel para saber se esta sendo executado do SIGAPAF.exe
Static __lIsFunPaf  := ""               	//Variavel responsavel para armazenar o modulo/funcao que esta sendo executada.
Static cSenha		:= "******"				//Variavel apagada pelo Framework
Static lDebug		:= .F.	
Static aDadosEcf	:= {}					//PAF-ECF: Salva dados do ECF, movimento por ecf é emitido com o ECF desligado
Static aCxMov 		:= {}	   				//Array para consulta de caixas com movimentação
Static lImpENF 		:=  .T.					//Se impressora nao fiscal esta comunicando corretamente.
Static lHomolgPaf	:= Nil
Static cChaveSat	:= ""					//Chave de ativação SAT
Static dDtLeiPCC	:= CTOD("22/06/2015")   //Novas Regras de Retenção PIS-COFINS-CSLL - Lei 13.137/2015, publicado no DOU em 22/06/2015.
Static aSLX_Canc 	:= {}
Static cVerFirm		:= ""					//Armazena o Firmware da Impressora (Daruma DR800)
Static aPccCumul    := {}					//Armazena o Numero do orçamento e Cliente e loja quando o valor do PCC ultrapassar o minimo

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Funcao	 ³ LjCreCli ³ Autor ³ Vendas Clientes       ³ Data ³		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Pega dados do cliente e checa credito					  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ LojA010 e LojA220 										  ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function LjCreCli( cCliente ,cLoja   ,cCliAnt    ,cLojAnt  , ;
					oDlg     ,cStatus ,lExecTroca )

Local cAlias  := Alias()						// Salva o alias anterior
Local cBmp	  := "BOMBE"						// Contem o Bitmap que indica a aprovacao do cliente na tela de analise de credito
Local cMotivo := STR0001						// Nada consta
Local dTitProt									// Data do ultimo titulo protestado
Local dChqDevo									// Data do ultimo cheque devolvido
Local oDlgMotCre								// Objeto da tela de analise de credito
Local oFont										// Objeto Fonte da tela
Local lAprovado 	:= .T.						// Boleano que indica se anlise de credito do cliente esta aprovada ou nao
Local lAbreDialogo  := .T.						// Boleano que quando .T. indica  que a funcao esta sendo chamada da proria LjxDImpCli, portando nao deve chama-la novamente recursivamente.
Local l10ImpCli 	:= ExistBlock("L10IMPCL")	// Boleano que indica a existencia do campo L10IMPCL
Local FTVDIMPCLi 	:= ExistBlock("FTVDIMPCL")	// Boleano que indica a existencia do campo FTVDIMPCL
Local lFtvdVer12	:= LjFTVD() 				//Verifica se é Release 11.7 e o FunName é FATA701 - Compatibilização Venda Direta x Venda Assisitida

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica parametros									   |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cCliente  == NIL
	cCliente :=  M->L1_CLIENTE
Else
	cCliente := cCliente
EndIf

If cLoja == NIL
	cLoja := M->L1_LOJA
Else
	cLoja := cLoja
EndIf

If cCliAnt == NIL
	cCliAnt := ""
Else
	cCliAnt := cCliAnt
EndIf

If cLojAnt == NIL
	cLojAnt := ""
Else
	cLojAnt := cLojAnt
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Fica verdadeiro quando esta funcao e chamada do dialogo de troca de mercadorias         |
//| Utilizada apenas para chamar ou nao a funcao LjxDImpCli                                |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lExecTroca := IIf( lExecTroca == NIL, .F., lExecTroca )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Quando este parametro esta ativo:                                                       |
//| 1) Esta funcao esta sendo chamada da LjxDImpCli, portando nao deve chama-la novamente. |
//| 2) Nao apresenta o dialogo com o status do cliente.                                     |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lAbreDialogo := IIf( cStatus == NIL, lAbreDialogo, .F. )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se nÆo ‚ o Cliente / Loja padrƒo              ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

lAprovado := .T.

If cCliente == SuperGetMV( "MV_CLIPAD" )
	If lAbreDialogo
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//| Exibe o cliente no rodape da tela de venda                                              |
		//| com o status da analise de credito atualizado                                           |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cCliAnt := cCliente
		cLojAnt := cLoja
		If !lExecTroca
			LjxDImpCli( cCliente, cLoja, 1, cMotivo )
		EndIf
	Else
		cStatus := cMotivo
	EndIf
	Return lAprovado
EndIf

If !LJProFile(1) .OR. cCliente+cLoja == cCliAnt+cLojAnt
	Return (lAprovado)
EndIf

DbSelectArea("SA1")
DbSetOrder(1)
DbSeek(xFilial("SA1") + cCliente + cLoja)

cDescCli := SA1->A1_NOME
cLoja    := SA1->A1_LOJA

If A1_RISCO == "A"

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Cliente aprovado 									   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cBmp := "BOMBE"
    lAprovado := .T.

ElseIf A1_RISCO == "E"

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Cliente reprovado                                      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cBmp	  := "BOOM"
	cMotivo   := STR0002			 // Risco E - Cliente reprovado.
    lAprovado := .F.
Else

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Se o risco for B,C ou D entÆo analisar demais fatores  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Cliente reprovado									   ³
	//³ Motivo : O saldo de titulos em aberto ‚ maior que      ³
	//³			 limite de cr‚dito                             ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !LjSaldo(cCliente, cLoja)
		cBmp	  := "BOOM"
		cMotivo   := STR0003		// O saldo de t¡tulos em aberto ‚ maior que o limite de cr‚dito.
        lAprovado := .F.
	EndIf

	DbSelectArea("SA1")

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Cliente reprovado									   ³
	//³ Motivo : N£mero de dias em atraso maior que o No de	   ³
	//³			 dias permitido pelo parƒmetro.				   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If LjAtraso(cCliente, cLoja)
		cBmp	  := "BOOM"
		cMotivo   := STR0004		// N£mero de dias em atraso maior que o n£mero de dias permitido pelo parƒmetro.
        lAprovado := .F.
	EndIf

	DbSelectArea("SA1")

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Cliente reprovado									   ³
	//³ Motivo : Data do limite de cr‚dito vencida.            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Empty(A1_VENCLC) .AND. A1_VENCLC < dDatabase
		cBmp	  := "BOMB"
		cMotivo   := STR0005		// Data do limite de cr‚dito vencida.
        lAprovado := .F.
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Cliente reprovado									   ³
	//³ Motivo: J  houveram t¡tulos protestados anteriormente. ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If A1_TITPROT > 0
		dTitProt := A1_DTULTIT
		cBmp		:= "BOOM"
		cMotivo	:= STR0006		// J  houveram t¡tulos protestados anteriormente.
        lAprovado := .F.
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Cliente reprovado									   ³
	//³ Motivo: J  houveram cheques devolvidos anteriormente.  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If A1_CHQDEVO > 0
		dChqDevo := A1_DTULCHQ
		cBmp		:= "BOOM"
		cMotivo	:= STR0007		// J  houveram cheques devolvidos anteriormente.
        lAprovado := .F.
	EndIf

EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Ponto de entrada para alterar o texto referente a análise de credito do cliente ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If l10ImpCli .AND. !lFtvdVer12
	cMotivo := ExecBlock( "L10IMPCL",.F.,.F.,{cMotivo} )
EndIf

If FTVDIMPCLi .AND. lFtvdVer12
	cMotivo := ExecBlock( "FTVDIMPCL",.F.,.F.,{cMotivo} )
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Se deve abrir o dialogo, quer dizer que nao esta sendo chamada                          |
//| da funcao LjxDImpCli                                                                   |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lAbreDialogo

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//| An lise de Cr‚dito   |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	DEFINE MSDIALOG oDlgMotCre FROM 47,130 TO 175,490;
	TITLE (STR0008) PIXEL Of oDlg

	DEFINE FONT oFont NAME "Ms Sans Serif" SIZE 12,14 BOLD

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//| Resultado  |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÙ
	@ 04,41 TO 41,175 LABEL STR0009 OF oDlgMotCre PIXEL
	@ 13,44 Say (cMotivo) SIZE 130,27 OF oDlgMotCre PIXEL FONT oFont COLOR CLR_RED

	@ 4,04 BITMAP RESOURCE cBmp OF oDlgMotCre PIXEL SIZE 32,32 ADJUST When .F. NOBORDER

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Botoes para confirmacao ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	DEFINE SBUTTON FROM 47, 148 oButton2 TYPE 1 ENABLE OF oDlgMotCre ;
	ACTION (lRet := .T.,oDlgMotCre:End()) PIXEL

	ACTIVATE MSDIALOG oDlgMotCre CENTERED
	oFont:end()

	If ! lExecTroca
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		// Exibe o cliente no rodape da tela de venda      |
		// com o status da analise de credito atualizado   |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		LjxDImpCli( cCliente, cLoja, 1, cMotivo )
	EndIf

Else

	cStatus := cMotivo

EndIf

cCliAnt := cCliente
cLojAnt := cLoja

DbSelectArea(cAlias)

Return (lAprovado)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao	 ³  LjAtraso   ³ Autor ³ Vendas Clientes    ³ Data ³ 27.12.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Checar os titulos em aberto(Atrasados) 					  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ LojA010 e LojA220 										  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function LjAtraso( cCliente, cLoja, lCrd )

Local nNumDias 	:= 1
Local lRet		:= .F.      // Retorno da funcao
Local cCliPad	:= SuperGetMv( "MV_CLIPAD",.F., "000001" )
Default lCrd := .F.

If cCliente <> cCliPad
	If !lCrd
		If !Empty(SA1->A1_RISCO)
			nNumDias := SuperGetmv("MV_RISCO"+SA1->A1_Risco)
		Endif
	EndIf
	If Empty(nNumDias)
		nNumDias:=0
		Return .F.
	EndIf

	DbSelectArea("SE1")
	DbSetOrder(8)
	DbSeek(cFilial+cCliente+cLoja+"A")
	If Found()
		While !Eof() .AND. E1_FILIAL == xFilial() .AND. E1_CLIENTE+E1_LOJA+E1_STATUS==cCliente+cLoja+"A"
			If SE1->E1_TIPO $ MVRECANT+"/"+MVPROVIS+"/"+MV_CRNEG+"/"+MVABATIM
				DbSkip()
				Loop
			Else
				If dDataBase - E1_VENCREA <= nNumDias
					lRet := .F.
				Else
					lRet := .T.
					Exit
				EndIf
			EndIf
			DbSkip()
		End
	Endif

EndIf

Return (lRet)

/*/
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao	 ³   LjSaldo   ³ Autor ³ Vendas Clientes    ³ Data ³ 27.12.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Checar os titulos em aberto								  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ LojA010 e LojA220 										  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function LjSaldo( cCliente, cLoja )

Local lRet		:= .T.
Local nSaldoE1  := 0
Local nValor	:= 0

DbSelectArea("SE1")
DbSetOrder(8)
DbSeek(cFilial+cCliente+cLoja+"A")
If Found()
	While !Eof() .AND. E1_FILIAL == xFilial() .AND. E1_CLIENTE+E1_LOJA==cCliente+cLoja ;
		.AND. E1_Status == "A"
		nValor:=xMoeda( SE1->E1_SALDO , SE1->E1_MOEDA , 1 )
		If SE1->E1_TIPO $ MVRECANT+"/"+MV_CRNEG+"/"+MVABATIM
			nSaldoE1 -= nValor
		Else
			nSaldoE1 += nValor
		EndIf
		dbSkip()
	End
EndIf
If nSaldoE1 > SA1->A1_LC
	lRet := .F.
Else
	lRet := .T.
EndIf

Return lRet

/*ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao	 ³lj010Vend ³ Autor ³ Vendas Clientes       ³ Data ³		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Consistencia codigo do Vendedor.							  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³lj010Vend()												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nao tem													  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³LOJA010													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function lj010Vend( cVend )

Local cAlias := Alias( )
Local lRet   := .T.      	// retorno da função
Local lFtvdVer12		:= FindFunction("LjFTvd") .AND. LjFTVD() 	//Verifica se é Release 11.7 e o FunName é FATA701 - Compatibilização Venda Direta x Venda Assisitida

cVend := IIf(cVend==Nil,M->L1_VEND,cVend)

DbSelectArea( "SA3" )
If !(DbSeek(cFilial+cVend))
	If !lFtvdVer12
		Help(" ",1,"LJ010VEND" )
	ElseIf lFtvdVer12
		Help(" ",1,"FTVD010Vend" )
	EndIf
	lRet := .F.
EndIf

DbSelectArea( cAlias )

Return lRet

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³ExisteDado³ Autor ³ Vendas Clientes       ³ Data ³ 19.09.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Posiciona o arquivo e enquanto os campos = chave passada	  ³±±
±±³			 ³compara um bloco de codigo								  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ExisteDado(cChave,nOrdem,bBlocoRetF) 						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cChave 	 Chave a localizar no arquivo 					  ³±±
±±³			 ³nOrdem 	 Ordem em que o arquivo deve estar posicionao para³±±
±±³			 ³ 			 efetuar a busca								  ³±±
±±³			 ³bBlocoRetF Bloco de comparacao para retornar .F. caso seja  ³±±
±±³			 ³ 			 verdadeiro 									  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³LOJA010													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function ExisteDado( cChave ,nOrdem ,bBlocoRetF )

Local lRet	  := .T.          // retorno da função
Local nOldReg := Recno()
Local nOldOrd := IndexOrd()

If nOrdem == NIL
	DbSetOrder(IndexOrd())
Else
	DbSetOrder(nOrdem)
EndIf

If cChave <> nil
	DbSeek(cChave)
EndIf

If lRet
	While &(indexkey()) = cChave
		If eval(bBlocoRetF)
			lRet := .F.
			exit
		EndIf
		dbSkip()
	End
EndIf
DbSetOrder(nOldOrd)
DbGoto(nOldReg)

Return (lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao	 ³ SubTotal ³ Autor ³ Vendas Clientes       ³ Data ³ 20.12.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Executa a Soma das Mercadorias Vendidas.					  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ SigaLoja 												  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function SubTotal()

Local nI		:=  0   // controle de loop
Local nItensAtv :=  0
Local lRet		:= .T.  //	retorno da função

nValorBase := 0
nVlraPag   := 0
nRedIcms   := 0
For nI := 1 To Len(aCols)
	nItensAtv++
	If aCols[nI][nUsado+1]
		nValorBase -= aCols[nI][nPosTotal]
		nVlraPag   -= (aCols[nI][nPosTotal]+Iif(nPosValIpi>0,aCols[nI][nPosValIpi],0))
		nItensAtv--
	EndIf
	nValorBase += aCols[nI][nPosTotal]
	nVlraPag   += (aCols[nI][nPosTotal]+Iif(nPosValIpi>0,aCols[nI][nPosValIpi],0))
	SB1->(DbSeek(xFilial("SB1")+aCols[nI][nPosProd]))
	SF4->(DbSeek(xFilial("SB1")+aCols[nI][nPosTes]))
	If AllTrim(SA1->A1_TIPO) $ SuperGetmv("MV_TPSOLCF") .AND. SB1->B1_PICMRET > 0;
		.AND. SF4->F4_CREDICM == "S"
		nRedIcms += ((aCols[nI][nPosValIcm] * SB1->B1_PICMRET /100) )
	EndIf
Next nI
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Somando Icms Solidario para titulo do cliente solidario ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nValorBase	+= nRedIcms
nVlraPag 	+= nRedIcms
M->L1_VLRTOT := nValorBase
M->L1_VLRLIQ := M->L1_VLRTOT - (M->L1_DESCONT + M->L1_CREDITO)
M->L1_VLRLIQ := Iif(M->L1_VLRLIQ < 0,0,M->L1_VLRLIQ)
nValorbase	 := M->L1_VLRLIQ
nLiq		 := nValorBase
oVlrTot:Refresh()
oVlrLiq:Refresh()
oVlrLiq1:Refresh()

Return lRet

/*ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao	 ³lj130Forn ³ Autor ³ Vendas Clientes       ³ Data ³		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Verifica se existe fornecedor e loja 						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³lj010Forn()												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cForn	Codigo do fornecedor 								  ³±±
±±³			 ³cLoja	Codigo da loja do fornecedor						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³LOJA010													  ³±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±*/
Function lj130Forn( cForn ,cLoja )

Local cAlias := Alias()
Local lRet	 := .T.      // retorno da funcao
Local lFtvdVer12		:= FindFunction("LjFTvd") .AND. LjFTVD() 	//Verifica se é Release 11.7 e o FunName é FATA701 - Compatibilização Venda Direta x Venda Assisitida

Default cLoja  		:= Space(2)

cChave := cForn+cLoja

DbSelectArea("SA2")
If !(DbSeek(cFilial+cForn ))
	If !lFtvdVer12
		Help(" ",1,"LJ130FORN" )
	ElseIf lFtvdVer12
		Help(" ",1,"FTVD130Forn" )
	EndIf
	lRet := .F.
ElseIf !Empty(cLoja)
	If !DbSeek(cFilial+cChave)
		Help(" ",1,"LOJA!FOUND")
		lRet := .F.
	EndIf
EndIf
M->L1_LOJA := SA2->A2_LOJA
DbSelectArea(cAlias)

Return lRet

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Funcao	 ³CriaTESTro³ Autor ³ Vendas Clientes       ³ Data ³ 11/10/95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Cria TES Padr„o - Troca de Mercadorias	                  ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function CriaTESTroca()
Local cAlias := Alias( )

Reclock( "SF4" , .T. )
SF4->F4_FILIAL  := cFilial
SF4->F4_CODIGO  := SuperGetMV("MV_TESTROCA")
SF4->F4_TIPO    := "E"
SF4->F4_ICM     := "S"
SF4->F4_IPI     := "N"
SF4->F4_CREDICM := "N"
SF4->F4_ESTOQUE := "S"
SF4->F4_CF		:= "199"
SF4->F4_DUPLIC  := "N"
SF4->F4_TEXTO	:= "ENTR.MERC.P/ TROCA"
SF4->F4_BASEICM := 0
SF4->F4_BASEIPI := 0
SF4->F4_INCIDE  := "N"
SF4->F4_LFICM	:= "T"
SF4->F4_LFIPI	:= "N"
SF4->F4_ISS 	:= "N"
SF4->F4_DESTACA := "N"
SF4->F4_PODER3  :="N"
SF4->F4_COMPL	:="N"
SF4->F4_CREDIPI :="N"
MsUnLock()

DbSelectArea( cAlias )

Return NIL

/*ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao	 ³lj010Cond ³ Autor ³ Vendas Clientes    	³ Data ³		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Monta Array com as condi‡”es de pagamento. 				  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ExpA1:=lj010Cond( )										  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Retorna array com as condi‡”es cadastradas.				  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³LOJA010													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function lj010Cond( )
Local aCondicoes := { }

DbSelectArea( "SE4" )
DbSeek( cFilial )
While !Eof( ) .AND. E4_FILIAL == cFilial
	Aadd( aCondicoes , SubStr( E4_DESCRI, 1, 12 ) +"   "+SE4->E4_CODIGO )
	dbSkip( )
End

Return aCondicoes

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao	 ³lj010Entra³ Autor ³ Vendas Clientes       ³ Data ³		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Calcula valor Financiado.									  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³lj010Entra( )												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³LOJA010													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function lj010Entra( nValorBase, nEntrada, nFinanciado, lEntrada )

If nEntrada > Round(nValorBase,2)
	Help( " ", 0, "ENTRADA" )
	Return  .F.
End

If !lEntrada .AND. nEntrada <> 0 .OR. lEntrada .AND. nParcelas==1 .AND. Round(NoRound(nEntrada,4),4) < Round(NoRound(nValorBase,4),4) .AND. nEntrada > 0
	nParcelas := Iif(nParcelas > 1,nParcelas,2)
EndIf
If nEntrada == Round(nValorBase,2)
	nParcelas:=1
EndIf

nFinanciado := Round(nValorBase,2) - nEntrada

oEntrada:Refresh()
oFinanciado:Refresh()

Return .T.

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao	 ³lj010Finan³ Autor ³ Vendas Clientes       ³ Data ³		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Consiste valor financiado									  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³lj010Finan( )												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³LOJA010													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function lj010Finan( nValorBase, nEntrada, nFinanciado )

Local lRet := .T.   //retorno da funcao

If Str(nFinanciado,16,2 ) <> Str(nValorBase - nEntrada,16,2)
	lRet := .F.
End

Return (lRet)

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³SomaParc	³ Autor ³ Vendas Clientes		³ Data ³ 01.08.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Soma as parcelas da venda para validar a parcela digitada   ³±±
±±³			 ³somada com as parcelas anteriores 						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³SomaParc(nLin,nValor,nTotal)								  ³±±
±±³			 ³nLin	Elemento do vetor aParcelas que est  sendo getado	  ³±±
±±³			 ³nValor  Valor que foi getado								  ³±±
±±³			 ³nTotal  Valor total a ser parcelado						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno	 ³.T. 	Se o valor digitado for v lido						  ³±±
±±³			 ³.F. 	Caso contr rio 										  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³LOJA010													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function SomaParc( nLin ,nValor ,nTotal )

Local nI 		:=  0	// controle de loop
Local nRet		:=  0
Local lRet		:= .F. //retorno da funcao
Local nDecimal  :=  0

For nI := 1 to nLin - 1
	nRet += aParcelas[nI][2]
Next nI

nDecimal := ( ( nParcelas - nLin ) /100 )

nRet += nValor
If nRet <= ( nTotal - nDecimal )
	lRet := .T.
EndIf

Return (lRet)

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³VerUltCheq³ Autor ³ Vendas Clientes		³ Data ³ 09.08.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Verifica se o valor do ultimo cheque ‚ igual ao que resta   ³±±
±±³			 ³para completar o valor total da venda.					  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³VerUltCheq(nValCheq,nValTot)								  ³±±
±±³			 ³nValCheq	Valor do cheque									  ³±±
±±³			 ³nValTot	Valor do que resta para completar a venda 		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno	 ³.T. 	 Se o valor digitado for igual ao restante			  ³±±
±±³			 ³.F. 	Caso contr rio 										  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³LOJA010													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function VerUltCheq( nValCheq ,nValTot )

Local lRet  := .T.		//retorno da funcao
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Alterada Comparacao entre Valor de Cheque e Parcela   |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Abs(nValCheq - nValTot) > .02
	Help( " ", 1, "CHEQ#TOTAL" )
	lRet  := .F.
EndIf

Return (lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³lj010LinOk³ Autor ³ Vendas Clientes 		³ Data ³ 13/10/92 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Verifica a validade da linha digitada						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³lj010LinOk() 												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³LojA010													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function lj010LinOk( o )

Local lRet := .T.     	//retorno da funcao

If !SubTotal()
	lRet  := .F.
EndIf

Return (lRet)


/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao	 ³A010TudOk ³ Autor ³ Vendas Clientes       ³ Data ³		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Consistencia geral dos itens do Orcamento. 				  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ExpN1 = A010TudOk											  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpN1 = Valor devolvido pela funcao						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³Generico													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function lj010TudOk( o )

Static nErro	 := 0

Local lRet		 := .T.	 //retorno da funcao
Local nDif		 := 0
Local nValIcms   := 0
Local nUltIt	 := 0
Local nColIcm	 := 0
Local nX		 := 0 // controle de loop
Local nY         := 0 // controle de loop
Local lRecIcm	 := (ExistBlock("RECICM"))
Local nPosValIpi := aPosicoes[7][2]
Local nPosTotal  := aPosicoes[2][2]
Local nPosValIcm := aPosicoes[6][2]

nRedIcms := 0
nTotalIPI:= 0

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ verifica se o ultimo elemento do array esta em branco		  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nMaxArray := Len(aCols)

If Empty(aCOLS[nMaxArray][1])
	nMaxArray--
End

If nMaxArray == 0
	Return .T.
End

For nY := 1 to Len(aHeader)
	If Empty(aCols[nMaxArray][nY]) .AND. !aCols[nMaxArray][nUsado+1]
		If (Trim(aHeader[nY][2]) == "L2_QUANT"   .OR.;
			Trim(aHeader[nY][2]) == "L2_VRUNIT"  .OR.;
			Trim(aHeader[nY][2]) == "L2_VLRITEM" .OR.;
			Trim(aHeader[nY][2]) == "L2_TES" )
			Help(" ",1,"A010VAZ")
			lRet := .F.
			nMaxArray--
			nErro++
			Exit
		EndIf
	End
Next nY

If !lRet
	Return .F.
End

M->L1_VLRTOT := 0
M->L1_VLRLIQ := 0

For nX := 1 to nMaxArray
	If !aCols[nX][Len(aCols[nX])]
		If cPaisLoc == "BRA"  //Localizacoes 16/05/2000 Fernando M.
			nTotalIpi += aCols[nX][nPosValIpi]
		EndIf
		For nY := 1 to Len(aHeader)
			If AllTrim(aHeader[nY][2]) == "L2_PRODUTO"
				M->L1_VLRTOT += aCols[nX][nPosTotal]
				M->L1_VLRLIQ += aCols[nX][nPosTotal]
			EndIf
			If cPaisLoc == "BRA" //Localizacoes 16/05/2000 Fernando M.
				If Trim(aHeader[nY][2]) == "L2_VALICM" .AND. aCols[nX][nPosValIcm] > 0
					If !lRecIcm
						nValIcms 	  := ljxDIcms(nX,@nDif)
						aCols[nX][nY] := nValIcms
						nUltIt		  := IIf(nValIcms > 0,nX,nUltIt)
						nColIcm		  := nY
					EndIf
				EndIf
			EndIf
			If Trim(aHeader[nY][2]) == "L2_TES"
				DbSelectArea( "SF4" )
				If !(DbSeek( cFilial + aCols[nX][nY] ) )
					Help( " ",1,"A010TES")
					Return .F.
				EndIf
			EndIf
		Next nY
	EndIf
Next nX
oGet:Refresh()
M->L1_VLRLIQ -= If(lTroca,nCredito,0)
M->L1_VLRTOT := Iif( M->L1_VLRTOT < 0 , 0 , M->L1_VLRTOT ) + nRedIcms
M->L1_VLRLIQ := Iif( M->L1_VLRLIQ < 0 , 0 , M->L1_VLRLIQ ) + nRedIcms

nDif := NoRound(nDif,2)

If nDif >= 0.01 .AND. nUltIt > 0 .AND. nColIcm > 0
	aCols[nUltIt][nColIcm] += nDif
EndIf

Return .T.


/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³ LjBit 	³ Autor ³ Vendas Clientes       ³ Data ³ 10/07/96 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Mostra foto do produto									  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³LOJA010													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LjBit()

ShowBitMap(oBmp,SB1->B1_BITMAP)
oBmp:Refresh()

Return .T.


/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao	 ³ConValor2 ³ Autor ³ Vendas Clientes	    ³ Data ³ 15/03/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Converte "." para ","                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ConValor2()												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³LOJA010													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function ConValor2( cString, nLen )

Local cValor  := cString
Local cValorA := ""
Local nK	  := 0           // Controle de loop

For nK := 1 To Len(cValor)
	If !SubStr(cValor,nK,1) $".,"
		cValorA += SubStr(cValor,nK,1)
	EndIf
	If SubStr(cValor,nK,1) == "."
		cValorA += ","
	EndIf
Next nK

If Len(cValorA) <= nLen
	cValorA := Space( nLen - Len(cValorA) ) + cValorA
Else
	cValorA := Right(cValorA,nLen)
EndIf

Return (cValorA)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³lj010Nivel³ Autor ³ Vendas Clientes       ³ Data ³ 04/03/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Verifica se usu rio pode ou nao dar desconto no ¡tem		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ 1 - nTipo = 1 para desconto % | 2 para desconto Valor Item ³±±
±±³			 ³ 2 - Campo (Valor) ou Campo (Percentual)	                  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ xRet - Numerico com o valor do desconto para utilizacao em ³±±
±±³          ³        gatilhos ou                                         ³±±
±±³          ³        Logico para utilizacao dentro do fonte              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Sigaloja                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Lj010Nivel( nTipo , cValor , oDesc )

Local xRet 			:= 0            // Retorno da funcao
Local nPosProduto 	:= 0
Local lContinua		:= .T.

Default nTipo       	:= 0

If "L2_DESC" $ ReadVar() .OR. "L2_VALDESC" $ ReadVar()
	xRet  := &(ReadVar())
EndIf

If Type("aHeader") == "A"
	nPosProduto  := aScan( aHeader, {|x| Alltrim(Upper(x[2])) == "L2_PRODUTO" } )
EndIf

If Type("aPosicoes") == "A"
	lContinua := !Empty(aCols[n][nPosProduto])
EndIf

If nPosProduto > 0 .AND. lContinua
	If (nTipo == 1)
		If Type("aPosicoes") == "A"
			M->L2_PRCTAB   	:= aCols[n][aPosicoes[13][2]]
		EndIf
		xRet := Min(M->L2_DESC,(1-(0.01/M->L2_PRCTAB))*100)
	ElseIf (nTipo == 2)
		If Type("aPosicoes") == "A"
			M->L2_PRCTAB := aCols[n][aPosicoes[13][2]]
			M->L2_QUANT := acols[n][aPosicoes[11][2]]
		EndIf
		xRet := Min(M->L2_VALDESC,(M->L2_PRCTAB-0.01)*M->L2_QUANT)
	ElseIf (nTipo == 3) .OR. (nTipo == 4) //Venda BalcÆo Windows 3- Desconto Valor 4- Desconto Percentual
		xRet := .T.
		If nTipo == 3
			cValor	:=	Round(cValor,nDecimais)
		EndIf
	EndIf
ElseIf (nTipo == 3) .OR. (nTipo == 4) //Venda BalcÆo Windows 3- Desconto Valor 4- Desconto Percentual
	xRet := .T.
	If nTipo == 3
		cValor	:=	Round(cValor,nDecimais)
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Se chamado pelo Windows, aceita o valor do parƒmetro , se Dos utiliza o valor em mem¢ria|
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !((nTipo == 3) .OR. (nTipo == 4))
	cValor  := xRet
EndIf

If cNivelSup < 5
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//| Chama a tela de autorizacao de desconto  |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If (cValor > 0)
		Help(" ","1","SEMPERWIN")

		If !Lj010AutD(5)
			If (nTipo == 1)
				M->L2_DESC := 0
				xRet	   := 0
			ElseIf nTipo == 2
				M->L2_VALDESC := 0
				xRet		  := 0
			ElseIf (nTipo == 3) .OR. (nTipo == 4)
				cValor:= 0
				oDesc:Refresh()
				xRet  := .F.
			EndIf
		EndIf
	EndIf
EndIf

cNivelSup  := cNivel

Return (xRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³lj010AutD ³ Autor ³ Vendas Clientes       ³ Data ³ 14.10.99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Janela de autorizacao para desconto no total. 			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpN1 = Valor a ser avaliado.							  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ SIGALOJA 												  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function lj010AutD( nValor )

Local cNivelAnt := cNivel	                  // N¡vel do usu rio atual
Local cSenhaAnt := cSenha	                  // Senha do usu rio atual

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Pega a senha de usu rio ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
LjSenha("")
nNivelRet := cNivel

If __cUserID == "000000"
	nNivelRet := 9
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Restaura a senha e o n¡vel anterior ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cSenha := cSenhaAnt
cNivel := cNivelAnt

Return (nNivelRet >= nValor)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³lj010ValDe³ Autor ³ Vendas Clientes		³ Data ³ 08.10.97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Verifica valor do desconto. 								  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ SigaLoja 												  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function lj010ValDes()

Local nValor	  := 0
Local nPrcTab	  := aCols[n][aPosicoes[13][2]]
Local nValorDesc  := aCols[n][aPosicoes[3][2]]

If nValorDesc >= nPrcTab
	Help(" ","1","DESCMAIOR2")
	nValor := 0
Else
	nValor := nValorDesc
EndIf

Return (nValor)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³AnimaIcon ³ Autor ³ Vendas Clientes  	    ³ Data ³ 09/09/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Anima um icone 											  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ AnimaIcon												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parƒmetros³ Expo1 -> Objeto que referencia a Dialog que chamou esta fun³±±
±±³			 ³ Expn1 -> Linha para desenhar o Icone						  ³±±
±±³			 ³ Expn2 -> Coluna para desenhar o Icone					  ³±±
±±³			 ³ Expn3 -> Intervalo de tempo entre cada frame.			  ³±±
±±³			 ³ Expa1 -> Array com todos os nomes dos icones.			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ SLJ010													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| so sera utilizado qdo o TEF estiver ativo no Windows  |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Function AnimaIcon( oDlgAnima, nLinha, nColuna, nIntervalo,;
					aIcones )
/*

Local oIcon
Local oTimer
Local lPositivo := .T.
Local nFrame	 := 1
Local cFirstIco := aIcones[1]
Local nLastFram := Int(Len(aIcones))
Local lTimeOut  := .F.
LOCAL nSecIni	 := Seconds()
LOCAL nCount	 := 0
LOCAL nSecAnt	 := Int( Seconds() )

@ nLinha , nColuna ICON oIcon RESOURCE cFirstIco OF oDlgAnima ;
COLOR GetsysColor(15),GetsysColor(15)

DEFINE TIMER oTimer OF oDlgAnima INTERVAL nIntervalo;
ACTION ( If(!lTimeOut,oDlgAnima:End(),),Iif( nFrame == nLastFram ,;
lPositivo := .F.,If(nFrame == 1,lPositivo := .T.,) ),;
Iif( lPositivo, nFrame++ , nFrame-- ),nFrame := nFrame ,;
oIcon:SetName( aIcones[nFrame] ) , oIcon:Refresh(),;
lTimeOut := l010WaitWin(nSecAnt,nSecIni))

ACTIVATE TIMER oTimer
*/

Return NIL

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Fun‡„o	 ³AbreGaveta³ Autor ³ Vendas Clientes       ³ Data ³ 18/08/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Abre a gaveta de Dinheiro									  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³AbreGaveta												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ SLJ010													  ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function Abregaveta()
Local nRet  := 0
Local lAbre	:= .T.

//Ponto de Entrada que permite definir se deve abrir ou nao a gaveta
If ExistBlock( "LJGaveta" )
	LjGrvLog(""," Abregaveta - Ponto de Entrada LJGAVETA")
	lAbre := ExecBlock( "LJGaveta" , .F., .F. )
	LjGrvLog(""," Abregaveta - Retorno do Ponto de Entrada - lAbre",lAbre)
EndIf

If lAbre
	If LjProfile(13)
		If lFiscal .AND. LJGetStation("PORTIF")==LJGetStation("PORTGAV") .OR. GetRemoteType() == REMOTE_LINUX //Para Linux nao e necessario ter a porta configurada 
			LjGrvLog(""," Abregaveta - Envio de Abre Gaveta no equipamento")
			nRet := IFGaveta( nHdlECF )
			LjGrvLog(""," Abregaveta - Retorno de Abre Gaveta no equipamento - nRet ",nRet)
		ElseIf lGaveta
		    If "LPT" $ LJGetStation("PORTGAV")
		        If LJGetStation("PORTGAV")<>LJGetStation("PORTICP")
		        	MsgInfo(STR0076 +Chr(13) + STR0077) //"A Porta Selecionada para a Gaveta.", "Não é igual a Porta da Impressora de Cupom..."
		        Else
		        	MsgInfo(STR0078) //"Pressione [ENTER] para efetuar a abertura da gaveta..."
		        	LjGrvLog(""," Abregaveta - GavetaCup - Envio de Abre Gaveta (direto)")
	    	    	GavetaCup()
	    	    	LjGrvLog(""," Abregaveta - GavetaCup - Retorno de Abre Gaveta (direto)")
				EndIf
		    Else
		    	LjGrvLog(""," Abregaveta - GavetaAci - Envio de Abre Gaveta (direto)")
		        nRet := GavetaAci(nHdlGaveta,LJGetStation("PORTGAV"))
		        LjGrvLog(""," Abregaveta - GavetaAci - Retorno de Abre Gaveta (direto) - nRet",nRet)
		    EndIf
		EndIf
	Else
		MsgInfo(STR0023) //"Acesso Negado"
		nRet := .F.
	EndIf
EndIf

Return nRet

/*±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±³Fun‡„o	 ³lj010Clien³ Autor ³ Vendas Clientes 	  	³ Data ³		  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Consistencia codigo do cliente.							  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³lj010Clien()												  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Cliente, loja, Quem Chama a funcao (oCliente ou oLoja) 	  ³±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±*/
Function lj010Clien( cCliente, cLoja , cCliAnt, cLojAnt, ;
										oLoja   , cTipo , oDlg   )

Local cAlias   := Alias()
Local cChave
Local lLojCli  := ExistBlock("LOJCLI") // P.E  Ap¢s a valida‡„o do Cliente
Local lRet     := .T.	// retorno da funcao
Local nX       := 0
Local cCfo     := ""
Local aDadosCfo
Local cEstado    := SuperGetMV( "MV_ESTADO" )			// Conteudo do MV_ESTADO
Local lFTVDLOJCLI  	:= ExistBlock("FTVDLOJCLI") 					// P.E  Ap¢s a valida‡„o do Cliente
Local lFtvdVer12	:= FindFunction("LjFTvd") .AND. LjFTVD() 	//Verifica se é Release 11.7 e o FunName é FATA701 - Compatibilização Venda Direta x Venda Assisitida

If (cConfCli == "S")
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//| Busca a tabela de preco usada para os produtos do cliente  |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Empty(SA1->A1_TABELA)
		nTabela:= 1
	Else
		nTabela:= Val(SA1->A1_TABELA)
	EndIf
EndIf

cTipo := Iif(cTipo==NIl,"C",cTipo)
cLoja := Iif(cLoja==NIl,"",cLoja)
If Empty(cCliente)
	cCliente := SuperGetMV( "MV_CLIPAD"  )+Space(6-Len(SuperGetMV("MV_CLIPAD" )))
EndIf
If Empty(cLoja)
	cLoja 	 := SuperGetMV( "MV_LOJAPAD" )+Space(2-Len(SuperGetMV("MV_LOJAPAD")))
EndIf

cChave := Iif(cTipo=="C",cCliente,cCliente+cLoja)

If cTipo == "L" .AND. Empty(cCliente).AND. Empty(cLoja)
	Return .F.
EndIf

If !cCliente+cLoja == cCliAnt+cLojAnt .AND. type("aNccItens") == "A"
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//| Ja declaradas como Private anteriormente   |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nNccGerada := 0
	nNccUsada  := 0
	aNccItens  := {}
EndIf

If cTipo == "C" .AND. Empty(cCliente)
	If cPaisLoc <> "BRA"
		lExibeNF := .T.
	EndIf
	Return lRet
EndIf
If cTipo == "L" .AND. Empty(cLoja)
	Return lRet
EndIf

DbSelectArea( "SA1" )
DbSetOrder(1)
If !(DbSeek(cFilial+cChave ))
	If cTipo == "C"
		Help(" ",1,"LJ010CLI" )
	Else
		Help(" ",1,"LJ010LOJA")
	EndIf
	Return .F.
Else
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se o Cliente esta bloqueado³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If SA1->A1_MSBLQL == "1"
      Help(" ",1,"REGBLOQ")
	  lRet := .F.
	ElseIf cPaisLoc == "SAL"
      lCredFisc  := SA1->A1_TIPO $ "1|4"
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Na validacao do Cod.Cli (cTipo == "C") trato tambem a loja    ³
//³se a loja atual for valida Mantenho-a.                        ³
//³se a loja for invalida atualizo-a com a filial do cliente.    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRet .AND. cTipo == "C"
	If !(DbSeek(cFilial+cChave+cLoja ))
		If (DbSeek(cFilial+cChave ))
			cLoja := SA1->A1_LOJA
		EndIf
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Execu‡Æo do ponto de Entrada  |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lLojCli .AND. lRet .AND. !lFtvdVer12
	lRet := ExecBlock("LOJCLI",.F.,.F.)
	If lRet == NIL
		lRet:= .T.
	EndIf
EndIf

If lFTVDLOJCLI .AND. lRet .AND. lFtvdVer12
	lRet := ExecBlock("FTVDLOJCLI",.F.,.F.)
	If lRet == NIL
		lRet:= .T.
	EndIf
EndIf


//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| O Botao de Transportadora Existe Somente na Venda Balcao.  |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lVendaRapida
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//| Habilita o botal da transportadora quando altera o cliente ou for a 1 vez               |
	//| (Somente quando o usuário nao for fiscal)                                               |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lRet .AND. cTipo == "C" .AND. cCliente <> M->L1_CLIENTE .AND. !lFiscal
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		// | esta sendo ativado tb na funcao LJ010NUM  |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			oBtnTransp:Enable()
			SetKey(20,oBtnTransp:bAction)
			oBtnTransp:Refresh()
			M->L1_CLIENTE:=cCliente
	EndIf
EndIf

If cPaisLoc	== "ARG" .AND. lRet
	DbSelectArea( "SA1" )
	DbSetOrder(1)
	If DbSeek(cFilial+cCliente+cLoja)
		cSerie := Lj010SerArg()
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Inclusao do Update do CFO nos itens da venda.                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cPaisLoc == "BRA" .AND. !lVendaRapida .AND. lRet
	For nX := 1 To Len( aCols )
		If !Empty( GDFieldGet("L2_PRODUTO",nX) ) .AND. !Empty( GDFieldGet("L2_CF",nX) )
			cCfo := GDFieldGet("L2_CF",nX)
			aDadosCfo := {{"OPERNF",  "S"},;
						  {"TPCLIFOR",SA1->A1_TIPO},;
						  {"UFDEST",  SA1->A1_EST},;
						  {"INSCR", SA1->A1_INSCR}}
			cCfo := MaFisCfo(, cCfo, aDadosCfo )

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Realiza a busca do CFO para verificar se existe³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			DbSelectArea("SX5")
			DbSetOrder(1)
			If !DbSeek(xFilial() + "13" + cCfo)
				If SA1->A1_EST == cEstado
					cCfo := "5102"
				Else
					cCfo := "6102"
				EndIf
			EndIf

			GDFieldPut("L2_CF",cCfo,nX)
		EndIf
	Next nX

	oGet:oBrowse:Refresh()
EndIf

If lRet
	M->L1_CLIENTE	:= cCliente
	M->L1_LOJA		:= cLoja

	If !lVendaRapida
		Lj010Suframa()
	EndIf
EndIf

DbSelectArea(cAlias)

Return (lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao	 ³ LOJAOK	³ Autor ³ Vendas Clientes       ³ Data ³ 01.12.95 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Mensagem e confirmacao do processamento					  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ LOJA0K(void)												  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LojaOk( cMensagem, lTipo, lNaoFirst )

Local lRet  // retorno da função

lNaoFirst := If(lNaoFirst == NIL,.F.,lNaoFirst)

If lUsaDisplay
	DisplayEnv(StatDisplay(), "1C" + Upper(STR0010) )  //"Aten‡„o"
	DisplayEnv(StatDisplay(), "2C" + cMensagem)
EndIf
If lNaoFirst
	If (MsgNoYes(cMensagem, STR0010) ) //"Aten‡„o"
		lRet:= .T.
	Else
		lRet:= .F.
	EndIf
Else
	If (MsgYesNo(cMensagem,STR0010) )
		lRet:= .T.
	Else
		lRet:= .F.
	EndIf
EndIf

Return (lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³lj010Autor³ Autor ³ Vendas Clientes	    ³ Data ³ 28.01.97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Janela de autorizacao por senha. 						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 = Origem da chamada da funcao.						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ ExpL1 := lj010Autor( ExpC1 )								  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ SIGALOJA 												  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function lj010Autor( cChamada )

Local lRet       := .T.     // retorno da função
Local cNivelAnt  := cNivel	// N¡vel de usu rio atual
Local cSenhaAnt  := cSenha

cChamada := Iif(cChamada == NIL,"",cChamada)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//|Desabilitar a tecla de funcao na tela de venda balcao,para nao chamar a rotina novamante     |
//|Testar se a variavel oBtnAut, existe pois existem varias rotinas que fazem uso desta funcao. |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Type('oBtnAut')=='O'
	oBtnAut:SetDisable(.T.)
	SetKey(1,Nil)
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Pega a senha de usu rio ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lRet := LjSenha(cChamada)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Restaura a senha, o UserID e o n¡vel anterior ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cSenha	 := cSenhaAnt
cNivel	 := cNivelAnt

If Type('oBtnAut')=='O'
	oBtnAut:SetDisable(.F.)
	SetKey(1,oBtnAut:bAction)
EndIf

Return (lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao	 ³ Lj010SX5NF³ Autor ³ Vendas Clientes 		³ Data ³ 03.09.99 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Achoice para numero e serie da nota fiscal vindo do SX5	  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Lj010Sx5NF( oDlgPae )

Local nTimes
Local aSerNF    := {}
Local nTamNota  :=TamSX3("L1_DOC")[1]  // Argentina
Local oDlg
Local cCadastro := (STR0033)
Local cVarQ     :="  "
Local oQual   //"Secuencia de Facturas"
Local nOpcA     := 0
Local lAbandona := .F.
Local lTmk      := (cModulo == "TMK")  // Se o m¢dulo for SIGATMK
Local nTimeOut  := 10
Local cFilSx5	:= If(FindFunction("LjFilSX5"),LjFilSX5(),xFilial("SX5"))  // Retorna Filial SX5

PRIVATE lSX5Troca := .F.

vNumero :=""

aSerNF := {}

DbSelectArea("SX5")
DbSetOrder(1)
DbSeek( cFilSx5+"01" )

While !Eof() .AND. X5_FILIAL+X5_TABELA == cFilSx5+"01"
	AADD( aSerNF,{ Padr( X5_CHAVE, 3 ), StrZero( Val( X5Descri() ),nTamNota ) } )
	dbSkip()
End

If (Len(aSerNF) == 0) .OR. lAbandona
	MsUnLock()
	Help(" ",1,"A460FLOCK")
	Return( {} )
EndIf

DEFINE MSDIALOG oDlg TITLE cCadastro From 10,30 To 19,68 OF oDlgPae //oMainWnd
@ .5,.80 LISTBOX oQual VAR cVarQ Fields HEADER STR0034,;   //  "Serie"
cCadastro SIZE 130,42 ON DBLCLICK (aSerNF:=aSX5Troca(oQual:nAt,aSerNF,nTimeOut),;
oQual:Refresh()) NOSCROLL //"Serie"
oQual:SetArray(aSerNF)
oQual:bLine := { || {aSerNf[oQual:nAT,1],aSerNf[oQual:nAT,2]}}
DEFINE SBUTTON FROM 51,80 TYPE 1 ACTION (nOpca := 1,;
LjxDANf(oQual,aSernf),;
oDlg:End()) ENABLE OF oDlg
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Se o modulo nao for SIGATMK exibe o botao, caso contrario                               |
//| nao exibe pois essa rotina nao podera ser cancelada pelo usuario                        |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lTmk
	DEFINE SBUTTON FROM 51,107 TYPE 2 ACTION (nOpcA := 3,oDlg:End()) ENABLE OF oDlg
EndIf
ACTIVATE MSDIALOG oDlg

cEspecie := "NF"

If (nOpcA <> 1)
	MsUnLock()
	Return ( {} )
EndIf

If !lSX5Troca
	vNumero := cNumNota
EndIf

If DbSeek( cFilSx5+"01"+cSerie,.F. )
	nTimes := 0
	While !MsRLock() .AND. nTimes < 10
		nTimes++
		Inkey(.1)
		DbSeek( cFilSx5+"01"+cSerie,.F. )
	End
	If MsrLock()
        SX5->X5_DESCRI  := PadR( cNumNota , nTamNota )
		SX5->X5_DESCSPA := PadR( cNumNota , nTamNota )
		SX5->X5_DESCENG := PadR( cNumNota , nTamNota )
		MsUnLock()
	Else
		Return( {} )
	EndIf
Else
	MsUnLock()
	Return( {} )
EndIf

Return( { cNumNota, cSerie } )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao	 ³ LjIcmsSol ³ Autor ³ Vendas Clientes       ³ Data ³ 01/07/00³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Funcao utilizada para calcular Icms Solidario			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ SIGALOJA 												  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LjIcmsSol( nVlrTotItem , nQuant , nVlUnit , cTipoNF, cNFOri, cSEROri, nRecOri )

Local aArea    := GetArea()
Local nBaseRet := 0
Local nValRet  := 0
Local nPerSol  := 0
Local cTipoCli := ""
Local lFtvdVer12		:= FindFunction("LjFTvd") .AND. LjFTVD() 		//Verifica se é Release 11.7 e o FunName é FATA701 - Compatibilização Venda Direta x Venda Assisitida

Default cTipoNF  		:= "N"
Default cNFOri   		:= ""
Default cSEROri  		:= ""

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Caso o Solidario de Saida ou o ICMS de Pauta estejam preenchidos, retorno o valor de Substituicao    |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If SB1->B1_PICMRET > 0 .OR. SB1->B1_VLR_ICM > 0 .OR. !Empty( SB1->B1_GRTRIB )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//| Ponto de entrada para troca do Tipo do cliente no ato do calculo                        |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ExistBlock( "LJTIPCLI" ) .AND. !lFtvdVer12
		cTipoCli := ExecBlock( "LJTIPCLI" , .F., .F. )
	EndIf

	If ExistBlock( "FTVDLJTIPCLI" ) .AND. lFtvdVer12
		cTipoCli := ExecBlock( "FTVDLJTIPCLI" , .F., .F. )
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//| Verifico o tipo da nota para efetuar o calculo                                          |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !MaFisFound("NF")
		If cTipoNF $ "DB"
			cTipoCli := IIf( Empty( cTipoCli ), SA2->A2_TIPO, cTipoCli )
			MaFisIni(SA2->A2_COD,SA2->A2_LOJA,"F",cTipoNF,cTipoCli,,,.F.,"SB1")
		Else
			cTipoCli := IIf( Empty( cTipoCli ), SA1->A1_TIPO, cTipoCli )
			MaFisIni(SA1->A1_COD, SA1->A1_LOJA, "C", "S", cTipoCli,,, .F.,"SB1")
		EndIf

		MaFisAdd(SB1->B1_COD, SF4->F4_CODIGO, nQuant,nVlUnit, 0, cNFOri, cSEROri, nRecOri, 0, 0, 0, 0, nVlrTotItem, 0, SB1->(RecNo()))

		nBaseRet := MaFisRet(1,"IT_BASESOL")
		nValRet  := MaFisRet(1,"IT_VALSOL")
		nPerSol  := MaFisRet(1,"IT_ALIQSOL")

		MaFisEnd()
	EndIf
EndIf

RestArea( aArea )

Return ({nBaseRet,nValRet,nPerSol})

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡„o	 ³ CalcIcmSol³ Autor ³ Vendas Clientes      ³ Data ³ 10/06/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Func„o utilizada para calcular Icms Solidario			  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		 ³ Sigaloja 												  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function CalcIcmSol( nLiq       , cCliente, cLoja, oVlrLiq, ;
										nValorBase , nVlrLiq )

Local nI								// Variavel contador
Local nRetAnt     := nRetIcms			// Variavel que recebe valor do ICMS anterior
Local nPosProd    := aPosicoes[ 9][2]	// Posicao do Produto no aPosicoes
Local nPosTes	  := aPosicoes[ 5][2]	// Posição da TES no aPosicoes
Local nPosVlrItem := aPosicoes[ 2][2]	// Posição do Valor do Item no aPosicoes
Local nPosVlUni   := aPosicoes[ 1][2]	// Posição do Valor do valor unitario no aPosicoes
Local cAlias							// Variavel que recebe Alias
Local nPICMRET							// Variavel que recebe o campo B1_PICMRET
Local cGRTRIB							// Variavel que recebe o campo B1_GRTRIB
Local nTmp								// Variavel Temporaria
Local nGrade							// Variaver contador para acol da grade
Local cGrade	  := "N"				// Variavel que recebe posição da grade
Local nPosQuant   := aPosicoes[11][2]	// Posição da quantidade no array aPosições
Local cTpSolCF    := SuperGetmv("MV_TPSOLCF")      // Variavel para validacao do tipo de cliente para o calculo do solidario
Local aIcmsSol    := {} //Array que armazenara o ICMS Solidario
Local nPos //variavel para posicionamento do aCols

If Len(acols) < 1 .OR. Empty(acols[1][1])
	Return .T.
EndIf

nGrade	  :=iif(cAlias == "SD1",0,Ascan(aCampos,"L2_GRADE"))
nacRetIcms:= 0
nRetIcms  := 0

If Type( "cCliEntrega" ) == "C" .AND. Type( "cLojEntrega" ) == "C"

	If !Empty( cCliEntrega ) .AND. !Empty( cLojEntrega )
		SA1->(DbSeek(xFilial("SA1")+cCliEntrega+cLojEntrega))
	Else
		SA1->(DbSeek(xFilial("SA1")+cCliente+cLoja))
	EndIf

EndIf

If SA1->A1_TIPO $ cTpSolCF
	For nI := 1 To Len(aCols)
		If !aCols[nI][Len(aCols[nI])]
			If nGrade > 0
				cGrade := aCols[nI][nGrade]
			EndIf
			SF4->(DbSeek(xFilial("SF4")+aCols[nI][nPosTes]))
			If cGrade == "N" .OR. !lGrade
				SB1->(DbSeek(xFilial("SB1")+aCols[nI][nPosProd]))
				nPICMRET := SB1->B1_PICMRET
				cGRTRIB  := SB1->B1_GRTRIB
			Else
				SB4->(DbSeek(xFilial("SB4")+aCols[nI][nPosProd]))
				nPICMRET := SB4->B4_PICMRET
				cGRTRIB  := SPACE(3)
			EndIf

			If SF4->F4_INCSOL <> "N"
				aIcmsSol:= LjIcmsSol(aCols[nI][nPosVlrItem],aCols[nI][nPosQuant],aCols[nI][nPosVlUni])
				nTmp    := aIcmsSol[2]

				nRetIcms   += nTmp
				nacRetIcms += nTmp

				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Atualiza os campos L2_BRICMS e L2_ICMSRET  ³
				//³do acols se a chamada for pela Venda Balcão³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If Alltrim(FunName()) $ "LOJA010"
					nPos := aScan(aHeader,{|z| Alltrim(Upper(z[2]))=="L2_BRICMS" })
					aCols[nI][nPos]:= aIcmsSol[1]
					nPos := aScan(aHeader,{|z| Alltrim(Upper(z[2]))=="L2_ICMSRET" })
					aCols[nI][nPos]:= aIcmsSol[2]
				EndIf
			EndIf
		EndIf
	Next nI
EndIf
If Type( "cCliEntrega" ) == "C" .AND. Type( "cLojEntrega" ) == "C"
	If !Empty( cCliEntrega ) .AND. !Empty( cLojEntrega )
		SA1->(DbSeek(xFilial("SA1")+cCliente+cLoja))
	EndIf
EndIf

nVlrliq	   := nVlrliq + nRetIcms - nRetAnt
nValorbase := nValorbase + nRetIcms - nRetAnt
nLiq       := nLiq + nRetIcms - nRetAnt

oVlrLiq:Refresh()

Return (.T.)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ LjPsCfCs  ³Autor  ³ Vendas Clientes       ³ Data ³ 05/04/04³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Funcao utilizada para calcular PIS/COFINS/CSLL             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGALOJA                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LjPsCfCs( nVlrTotItem , nQuant , nVlUnit , cTipoNF )

Local aArea       := GetArea()
Local nVlPis      := 0
Local nVlCofins   := 0
Local nVlCsll     := 0
Local nVlBasDup   := 0
Local cTipoCli    := ""

Default cTipoNF  	:= "N"

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Verifico o tipo da nota para efetuar o calculo                                          |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cTipoNF $ "DB"
	cTipoCli := IIf( Empty( cTipoCli ), SA2->A2_TIPO, cTipoCli )
	MaFisIni(SA2->A2_COD,SA2->A2_LOJA,"F",cTipoNF,cTipoCli,,,.F.,"SB1")
Else
	cTipoCli := IIf( Empty( cTipoCli ), SA1->A1_TIPO, cTipoCli )
	MaFisIni(SA1->A1_COD, SA1->A1_LOJA, "C", "S", cTipoCli,,, .F., "SB1")
EndIf

MaFisAdd(SB1->B1_COD, SF4->F4_CODIGO, nQuant,nVlUnit, 0, "", "",, 0, 0, 0, 0, nVlrTotItem, 0, SB1->(RecNo()))

nVlPis    := MaFisRet(1,'IT_VALPIS')
nVlCofins := MaFisRet(1,'IT_VALCOF')
nVlCsll   := MaFisRet(1,'IT_VALCSL')
nVlBasDup := MaFisRet(1,'IT_BASEDUP')

MaFisEnd()

RestArea( aArea )

Return ({nVlPis,nVlCofins,nVlCsll,nVlBasDup})

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa  ³LER_CONTA ³ Autor ³ Vendas Clientes       ³ Data ³ 16/06/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Efetua a leitura do codigo de barras quando o produto for  ³±±
±±³          ³ pagamento de conta.                                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³                                                            ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function LER_CONTA()
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Define Variaveis ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local nVezes      := 1
Local cRet        := ""
Local nRet 		  := 0
Local lLeu        := .F.
Local cBufCmc7    := SPACE(44)
Local cDac1       := "0"
Local cDac2       := "0"
Local cDac3       := "0"
Local cDac4       := "0"
Local cBarra1     := SPACE(11)
Local cBarra2     := SPACE(11)
Local cBarra3     := SPACE(11)
Local cBarra4     := SPACE(11)
Local oDlgCB
Local w1    	  := 0 // controle de loop

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se o Usuario usa CMC7                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !empty(LjGetStation("CMC7"))

	While ( nVezes <= 3 )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
        //| STR0011 "Confirme, Passe a Conta, e Aguarde a Leitura..."                               |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !MsgYesNo(STR0011 + Str(nVezes) + "/3")
            cBufCmc7 := ""
            Return( cBufCmc7 )
			EndIf
			cRet := Space(200)
			nRet := CMC7LeD(nHdlCMC7,@cRet)

			nVezes := nVezes + 1

			If Empty(cRet) .OR. nRet = 1
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
            //|  STR0012 "Nao Foi Possivel Ler os Dados da Conta..."                                    |
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	        MsgAlert(STR0012)
	        Loop
			Else
            lLeu   :=.T.
            cBufCmc7 := Alltrim(cRet)
            Exit
			End
	End

EndIf


If  !Empty(LjGetStation("CMC7")) .OR. !lLeu

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//| STR0014 "Entre com codigo de barras:"                                                   |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	DEFINE MSDIALOG oDlgCB FROM 000,000 TO 110,488 Title (STR0003) PIXEL
	@ 005,005 SAY (STR0014) OF oDlgcb PIXEL

	@ 016,005 MSGET cBarra1 PICTURE "@99999999999" SIZE 50,12 PIXEL OF oDlgcb  valid Digito(cBarra1,1)
	@ 026,058 SAY cDac1 SIZE 30,07 OF oDlgcb PIXEL

	@ 016,065 MSGET cBarra2 PICTURE "@99999999999" SIZE 50,12 PIXEL OF oDlgcb valid Digito(cBarra2,2)
	@ 026,118 SAY cDac2 SIZE 30,07 OF oDlgcb PIXEL

	@ 016,125 MSGET cBarra3 PICTURE "@99999999999" SIZE 50,12 PIXEL OF oDlgcb valid Digito(cBarra3,3)
	@ 026,178 SAY cDac3 SIZE 30,07 OF oDlgcb PIXEL

	@ 016,185 MSGET cBarra4 PICTURE "@99999999999" SIZE 50,12 PIXEL OF oDlgcb  valid Digito(cBarra4,4)
	@ 026,238 SAY cDac4 SIZE 30,07 OF oDlgcb PIXEL

	DEFINE SBUTTON FROM 040,175 oButton1 TYPE 01 ENABLE OF oDlgcb;
	ACTION (lLeu := .T.,oDlgCb:END())

	DEFINE SBUTTON FROM 040,215 oButton2 TYPE 02 ENABLE OF oDlgcb;
	ACTION (lLeu := .F.,oDlgCb:END())

	ACTIVATE MSDIALOG oDlgCb CENTERED

	If lLeu
		cBufCmc7 := Alltrim(cBarra1) + Alltrim(cBarra2) + Alltrim(cBarra3) + Alltrim(cBarra4)
	Else
	cBufCmc7 := ""
	EndIf
EndIf


If lLeu
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se a conta ja foi paga                      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	SL2->( DbSetOrder(3) )
	If SL2->( DbSeek(xFilial("SL2")+Alltrim(cBufCmc7)) )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//| STR0005 "ATEN€ÇO: Ja Consta Pagamento Desta Conta no Dia, "                             |
		//| STR0006 "no Valor de R$ "                                                               |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		MsgAlert(STR0005 + Dtoc(SL2->L2_EMISSAO) + STR0006 + Alltrim(Str(SL2->L2_VRUNIT))+".")
		cBufCmc7 :=""
	Else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Verifica se a conta ja foi lida                      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		For w1 = 1 to len(aItensVenda)            // Serial ja utilizaca
			If aItensVenda[w1][28] == cBufCmc7
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//| STR0007 "ATEN€ÇO: Ja Houve a Leitura dos Dados Desta Conta, Verifique..."               |
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				MsgAlert(STR0006)
				cBufCmc7 :=""
			EndIf
		Next w1
	EndIf
EndIf

Return( cBufCmc7 )

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³Digito    ³ Autor ³ Vendas Clientes       ³ Data ³ 26/06/00 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Rotina de Geracao do Arquivo de Verificacao do Digito       ³±±
±±³          ³da Conta.                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³.T. Operacao Bem Sucedida                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³Digito(cCodVer,nNivel)                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³Digito                                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Static Function Digito( cCodVer , nNivel )

Local lRet := .T.     // retorno da função
Local lLj220DAC := ExistBlock("LJ220DAC")    // ponto de entrada
Local lFTVDLJ220DAC 	:= ExistBlock("FTVDLJ220DAC")    			// ponto de entrada
Local lFtvdVer12		:= FindFunction("LjFTvd") .AND. LjFTVD() 	//Verifica se é Release 11.7 e o FunName é FATA701 - Compatibilização Venda Direta x Venda Assisitida

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ PE para possibilitar a consistecia do DAC em campo.  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lLj220DAC .AND. !lFtvdVer12
	lRet := ExecBlock("LJ220DAC",.F.,.F.,{cCodVer,nNivel})
EndIf

If lFTVDLJ220DAC .AND. lFtvdVer12
	lRet := ExecBlock("FTVDLJ220DAC",.F.,.F.,{cCodVer,nNivel})
EndIf

If len(alltrim(cCodVer)) <> 11 .OR. val(cCodVer) < 0
	lRet := .F.
EndIf

Return lRet

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Funcao    ³ LjProfile  | Autor ³ Vendas Clientes     ³ Data ³17/07/2000³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Verificar se usuario tem acesso aos processos              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ LJProfile(nAcesso,cStrAcesso)                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ nAcesso    - Numero do Acesso do Processo                  ³±±
±±³          ³ cCaixaSup  - Nome do Caixa Superior                        ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function LJProfile(	nAcesso	, cCaixaSup	, aDesc		, nDescPer	,;
					nDescLoj, lShwMsgNeg, cCodOrca	, lCtrlB	,;
					nPosIt 	, lDescTot 	, lLJ7104	, lTelaSimul )

Local lRet		  	:= .T.								// Variavel que controla o retorno
Local aArea		  	:= GetArea()					    // Salva a area, para ser restaurada ao final da funcao
Local aPermissao  	:= {}							    // Array com as permissoes
Local lDesc 	  	:= .F.								// Valida se houve desconto
Local lDescNIL	  	:= IIf(nModulo == 23, nDescPer == NIL .OR. nDescLoj == NIL, .F.)	// Controla se os descontos foram passados como parametro
Local lVerProfile 	:= .F.								// Controla se verifica profile para desconto
Local nSA6Recno	  	:= SA6->( Recno() )					// Variavel com o registro do SA6
Local cFormDesc   	:= SuperGetMV("MV_LJFORMD",.F.,"1") // Caso nao exista o parametro assume "1" como DEFAULT
Local cTipoDesc   	:= SuperGetMV("MV_LJTIPOD",.F.,"1") // Tipo do Desconto
Local lTipoDesc   	:= .F.								// Verifica se existe o parametro
Local aPermiss	  	:= LJ120Permi()						// Array com as permissoes
Local nX		  	:= 0								// Variavel contadora para Loop
Local lAltDesc	 	:= .F.
Local lValSenha	 	:= .T.
Local nPosacess   	:= 0
Local lUsaDisplay 	:= !Empty(LjGetStation("DISPLAY"))	// Verifica se a estacao possui Display
Local lECommerce  	:= ( SuperGetMV("MV_LJECOMM",,.F.) .AND. (IsInCallStack("LOJA901A") .OR. Lj901Auto()) ) // Se e-Commerce
Local cRetLJ7110  	:= ""								// Retorno do Ponto de Entrada LJ7110
Local lFrta271    	:= nModulo == 23                	// Valida se é FrontLoja
Local lMsgPerm		:= .F.								// Valida se exibe a mensagem de permissão de desconto

Default cCaixaSup  	:= Space(25)						// Caixa superior
Default nDescPer   	:= 0								// Percentual de Desconto
Default nDescLoj   	:= 0								// Desconto
Default aDesc      	:= { "V", nDescLoj }				// Array com o desconto concedido
Default lShwMsgNeg 	:= .F.								// Define se ira exibir mensagem quando der acesso negado
Default cCodOrca   	:= ""								// Codigo do orcamento atual utilizado para controle do desconto
Default lCtrlB		:= .F.								// Define se o desconto e por ITEM ou TOTAL (.F.-Item / .T.-Total)
Default nPosIt		:= __nPosIt							// Numero do Item
Default lDescTot    := .F.                      		// Indica se o desconto é no Total da venda
Default lLJ7104		:= .F.								// Se esta utilizando o ponto de Entrada LJ7104
Default lTelaSimul	:= .F.								// Define se foi chamado pela tela de simulacao de desconto

// Se for e-Commerce, não passa pelas condições abaixo e retorna .T.
If lECommerce
	If ! AllTrim(StrZero(nAcesso, 2)) $ "02/03/04/05/06/12/13/14/17/21/20/22/24/25/30/33/34/36/37/38"
		Return .T.
	else
		Return .F.
	EndIf
EndIf

If IsBlind()
	// Como na ExecAuto nao temos usuario caixa definido nao temos que validar a permissao
	//do desconto e sempre aceitar o valor oriundo do execauto.
	Return .T.
EndIf

If nAcesso == 30 .And. !INFLocaliz()
	lRet := .F.
	Return lRet
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica se o array aDesc está vazio, se estiver coloca o valor³
//³padrão.                                                        ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Len(aDesc) == 0
	aDesc := { "V", nDescLoj }
EndIf

If ExistBlock("LJ7110")

	LjGrvLog("","Antes da Chamada do Ponto de Entrada:LJ7110")
	cRetLJ7110 := ExecBlock("LJ7110",.F.,.F.,{nAcesso})
	LjGrvLog("","Apos a Chamada do Ponto de Entrada:LJ7110",cRetLJ7110)

	If ValType(cRetLJ7110) == "C"
		If cRetLJ7110 == "S"
			Return .T.
		ElseIf cRetLJ7110 == "N"
			Return .F.
		EndIf
	EndIf

Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Parametro MV_LJFORMD (DEFAULT -> "1")                          ³
//³                                                               ³
//³"1" -> Verifica o percentual do desconto ou o valor do desconto³
//³"2" -> Verifica o percentual do desconto e o valor do desconto ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Parametro MV_LJTIPOD 				                          ³
//³                                                               ³
//³"1" -> Tipo do desconto igual a Percentual                     ³
//³"2" -> Tipo do desconto igual a Valor                          ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³aDesc[1] - Tipo de desconto, P - Percentual, D - Valor            ³
//³aDesc[2] - Valor ou Percentual do desconto, de acordo com aDesc[1]³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If cTipoDesc <> "0"
	lTipoDesc  := .T.
EndIf

// Desconto no Item
If ( !lCtrlB .Or. (SLF->(FieldPos("LF_TOTDESP")) == 0 .Or. SLF->(FieldPos("LF_TOTDESV")) == 0) ) .AND. !( lDescTot .AND. lFrta271 )
	// Validacao dos seguintes campos da tabela SLF->(Perfil/Acessos Caixa):
	// SLF->LF_DESCPER - Desconto Item Percentual
	// SLF->LF_DESCVAL - Desconto Item Valor
	If aDesc[1] == 'P'
        lDesc := ( aDesc[2] > 0 ) .AND. ( aDesc[2] > LjGetProfile( "DESCPER" ) )

		If !lDesc
            lDesc := ( nDescLoj > 0 ) .AND. ( nDescLoj > LjGetProfile( "DESCVAL" ) )
		EndIf
	Else
        lDesc := ( aDesc[2] > 0 ) .AND. ( aDesc[2] > LjGetProfile( "DESCVAL" ) )

		If !lDesc
            lDesc := ( nDescPer > 0 ) .AND. ( nDescPer > LjGetProfile( "DESCPER" ) )
		EndIf
	EndIf
Else
	// Desconto no Total <CTRL>+B
	// Validacao dos seguintes campos da tabela SLF->(Perfil/Acessos Caixa):
	// SLF->LF_TOTDESP - Desconto Total Percentual
	// SLF->LF_TOTDESV - Desconto Total Valor
	If cFormDesc == "1"
		If aDesc[1] == 'P'
			If !lTipoDesc .OR. cTipoDesc == "1"
				lDesc := ( aDesc[2] > 0 ) .AND. ( aDesc[2] > LjGetProfile( "TOTDESP" ) )
			ElseIf cTipoDesc == "2"
				lDesc := ( nDescLoj > 0 ) .AND. ( nDescLoj > LjGetProfile( "TOTDESV" ) )
			EndIf
		Else
			If !lTipoDesc .OR. cTipoDesc == "2"
				lDesc := ( aDesc[2] > 0 ) .AND. ( aDesc[2] > LjGetProfile( "TOTDESV" ) )
			ElseIf cTipoDesc == "1"
				lDesc := ( nDescPer > 0 ) .AND. ( nDescPer > LjGetProfile( "TOTDESP" ) )
			EndIf
		EndIf

	ElseIf cFormDesc == "2"
		lDesc := nDescPer > 0 .AND. nDescLoj > 0

		If lDesc
			lDesc := nDescPer > LjGetProfile( "TOTDESP" ) .OR. nDescLoj > LjGetProfile( "TOTDESV" )
		EndIf
	EndIf
Endif

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Para o Front Loja, se nao passar os descontos como    ³
//³parametro deve verificar o profile. Se passou, deve   ³
//³verificar se os descontos sao maiores que 0           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nModulo == 23
	lVerProfile  := IIf( lDescNIL, .T., nDescPer > 0 .OR. nDescLoj > 0 )
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica se houve alteracao na porcentagem de desconto³
//³ou mudanca do numero do orcamento                     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ((	!( nDescPer == __nDescPer ) .OR. !( nDescLoj == __nDescLoj ) .OR.;
		!( cCodOrca == __cCodOrca ) .OR. !( nPosIt == __nPosIt ) .OR. lVerProfile ) .AND. nAcesso == 11)
	__lAplicDesc 	:= .F.			//Seta a variavel de aplicacao de desconto como falso
	__nDescPer 		:= nDescPer		//Seta a variavel com a porcentagem de desconto com a nova porcentagem de desconto
	__nDescLoj 		:= nDescLoj		//Seta a variavel com o valor de desconto com o novo valor de desconto
	__cCodOrca		:= cCodOrca		//Seta a variavel com o numero o orcamento atual
	__nPosIt		:= nPosIt		//Seta a variavel com o numero do item
EndIf

cSenhaAnt := cSenha

aPermissao := LJ120Permi()

nPosacess := aScan( aPermissao, { |x| x[1] == nAcesso } )

If nPosacess == 0
	cStrAcesso := Subst( cStrAcesso, 1, nAcesso - 1 ) + "N" + Subst( cStrAcesso, nAcesso + 1 )

	For nX := Len( aPermissao ) + 1 To nAcesso
		aAdd( aPermissao, { nX, "", "", "", "N", "LOJ" } )
	Next nX
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Permite efetuar descontos³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nAcesso <> 11
	If !( lRet := Subs( cStrAcesso, nAcesso, 1 ) == "S" ).OR. ( lDesc )
		If ( nAcesso == 16 .AND. SubStr( cStrAcesso, nAcesso, 1 ) == " " )
			lRet:= .T.
		ElseIf ( nAcesso == 17 .AND. SubStr( cStrAcesso, nAcesso, 1 ) == "N" )
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//| "Usuário sem autorização para efetuar Cancelamento Manual de TEF","Atenção")		    |
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			MsgAlert( STR0163, STR0010 ) // "Usuário sem autorização de acesso as Rotinas Gerencias TEF"
		ElseIf 	(SubStr(cStrAcesso, nAcesso, 1) == "X") .OR.;
				(SubStr(cStrAcesso, nAcesso, 1) == " ") .OR. lDesc

			// Funcao que valida a autorizacao superior por Cartao ou Senha
			lRet := LjVldSup(	@cCaixaSup,	@aPermissao,	@nAcesso,	@cFormDesc,;
								@nDescPer,	@nDescLoj,		@cSenhaAnt)

		EndIf
	Else
		cCaixaSup := cUserName
	EndIf
Else
	If nDescPer > 0 .OR. nDescLoj > 0 .OR. lVerProfile
		If !__lAplicDesc
			Do Case
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Exibe a tela de senha de superior³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³A Tela de senha de superior é apresentada caso³
				//³a permissão de Efetuar Descontos para o caixa ³
				//³esteja em Amarelo                             ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				Case (SubStr(cStrAcesso, nAcesso, 1) == "X") .OR.;
					((SubStr(cStrAcesso, nAcesso, 1) == "S") .AND. lDesc)

					//Verifica. Caso seja Cenario de Vendas e estiver configurado no caixa para priorizar Regra de Desconto, entao nao solicita senha do superior para liberar desconto
					lValSenha := LjOpcDesc()

					If FindFunction("P_LJSENSUP")

						lAltDesc := P_LJSENSUP()

				  		If Valtype(lAltDesc) == "L"
				  			lValSenha := lAltDesc
						EndIf
					EndIf

					If lValSenha .And. !lLJ7104
						// Funcao que valida a autorizacao superior por Cartao ou Senha
						lRet := LjVldSup(	@cCaixaSup,	@aPermissao,	@nAcesso,	@cFormDesc,;
											@nDescPer,	@nDescLoj,		@cSenhaAnt, lCtrlB    ,;
											lTelaSimul)
					Else
						lRet := .T.
					EndIf

					// No Mexico sera solicitado senha do Superior em todos itens que for conceder desconto
					If lRet .AND. cPaisLoc <> "MEX"
						__lAplicDesc := lRet
					EndIf

				Case SubStr( cStrAcesso, nAcesso, 1 ) == "S"
					cCaixaSup := cUserName
			EndCase
		EndIf

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica limite do desconto³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Do Case
			Case !lRet
				If (!lCtrlB .Or. (SLF->(FieldPos("LF_TOTDESP")) == 0 .Or. SLF->(FieldPos("LF_TOTDESV")) == 0)) .And. !( lDescTot .And. lFrta271 )
					If aDesc[1] == "P"
						If aDesc[2] > 0 .AND. aDesc[2] > LjGetProfile( "DESCPER", SA6->A6_COD )    //  Critica do Desconto em % do caixa atual - Por Item
							lMsgPerm := .T.
						ElseIf nDescLoj > 0 .AND. nDescLoj > LjGetProfile( "DESCVAL", SA6->A6_COD )	// Critica do Desconto em Valor do caixa atual - Por Item
							lMsgPerm := .T.
						EndIf
					Else
						If aDesc[2] > 0 .AND. aDesc[2] > LjGetProfile( "DESCVAL", SA6->A6_COD )    //  Critica do Desconto em % do caixa atual - Por Item
							lMsgPerm := .T.
						ElseIf nDescPer > 0 .AND. nDescPer > LjGetProfile( "DESCPER", SA6->A6_COD )	// Critica do Desconto em Valor do caixa atual - Por Item
							lMsgPerm := .T.
						EndIf
					EndIf

					If lMsgPerm
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//| Valor do desconto nao permitido para o caixa atual / Desconto nao autorizado            |
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If lUsaDisplay
							// Limpar as mensagens do display
							LjLimpDisp()
							DisplayEnv(StatDisplay(), "1C"+ STR0062)				// "Desconto nao autorizado"
							DisplayEnv(StatDisplay(), "2E"+ Substr(STR0061,1,31))	// "Valor do desconto nao permitido para o caixa atual"
							DisplayEnv(StatDisplay(), "3C"+ Substr(STR0061, 33))	// "Valor do desconto nao permitido para o caixa atual"
							DisplayEnv(StatDisplay(), "4C"+ STR0128)				// "Tecle <ENTER> para continuar"
						Endif
						MsgStop( STR0061 , STR0062 )
						lRet:=.F.
					EndIf
				ElseIf cFormDesc == "1"
					If aDesc[1] == "P"
						If aDesc[2] > 0 .AND. SLF->(FieldPos("LF_TOTDESP")) > 0 .And. (aDesc[2] > LjGetProfile( "TOTDESP", SA6->A6_COD ))    //  Critica do Desconto em % do caixa atual - Total da Venda
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//| Valor do desconto nao permitido para o caixa atual / Desconto nao autorizado            |
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							If lUsaDisplay
								// Limpar as mensagens do display
								LjLimpDisp()
								DisplayEnv(StatDisplay(), "1C"+ STR0062)	// "Desconto nao autorizado"
								DisplayEnv(StatDisplay(), "2E"+ Substr(STR0061,1,31))	// "Valor do desconto nao permitido para o caixa atual"
								DisplayEnv(StatDisplay(), "3C"+ Substr(STR0061, 33))	// "Valor do desconto nao permitido para o caixa atual"
								DisplayEnv(StatDisplay(), "4C"+ STR0128)	// "Tecle <ENTER> para continuar"
							Endif
							MsgStop(  STR0061 , STR0062  )
							lRet:=.F.
						EndIf
					Else
						If aDesc[2] > 0 .AND. SLF->(FieldPos("LF_TOTDESV")) > 0 .And. aDesc[2] > LjGetProfile( "TOTDESV", SA6->A6_COD ) // Validacao do desconto em $ - Total da Venda
							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//| Valor do desconto nao permitido para o caixa atual / Desconto nao autorizado            |
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							If lUsaDisplay
								// Limpar as mensagens do display
								LjLimpDisp()
								DisplayEnv(StatDisplay(), "1C"+ STR0062)	// "Desconto nao autorizado"
								DisplayEnv(StatDisplay(), "2E"+ Substr(STR0061,1,31))	// "Valor do desconto nao permitido para o caixa atual"
								DisplayEnv(StatDisplay(), "3C"+ Substr(STR0061, 33))	// "Valor do desconto nao permitido para o caixa atual"
								DisplayEnv(StatDisplay(), "4C"+ STR0128)	// "Tecle <ENTER> para continuar"
							Endif
							MsgStop( STR0061 , STR0062 )
							lRet:=.F.
						EndIf
					EndIf
				Else
					If nDescPer > 0 .AND. nDescLoj > 0
						If ( nDescPer > LjGetProfile( "DESCPER", SA6->A6_COD ) ) .OR. ;
							( nDescLoj > LjGetProfile( "DESCVAL", SA6->A6_COD ) ) //Desconto no Item

							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//| Valor do desconto nao permitido para o caixa atual / Desconto nao autorizado            |
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							If lUsaDisplay
								// Limpar as mensagens do display
								LjLimpDisp()
								DisplayEnv(StatDisplay(), "1C"+ STR0062)	// "Desconto nao autorizado"
								DisplayEnv(StatDisplay(), "2E"+ Substr(STR0061,1,31))	// "Valor do desconto nao permitido para o caixa atual"
								DisplayEnv(StatDisplay(), "3C"+ Substr(STR0061, 33))	// "Valor do desconto nao permitido para o caixa atual"
								DisplayEnv(StatDisplay(), "4C"+ STR0128)	// "Tecle <ENTER> para continuar"
							Endif
							MsgStop( STR0061, STR0062 )
							lRet:=.F.
						ElseIf ( nDescPer > LjGetProfile( "TOTDESP", SA6->A6_COD ) ) .OR. ;
							( nDescLoj > LjGetProfile( "TOTDESV", SA6->A6_COD ) ) //Desconto no Total

							//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
							//| Valor do desconto nao permitido para o caixa atual / Desconto nao autorizado            |
							//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
							If lUsaDisplay
								// Limpar as mensagens do display
								LjLimpDisp()
								DisplayEnv(StatDisplay(), "1C"+ STR0062)	// "Desconto nao autorizado"
								DisplayEnv(StatDisplay(), "2E"+ Substr(STR0061,1,31))	// "Valor do desconto nao permitido para o caixa atual"
								DisplayEnv(StatDisplay(), "3C"+ Substr(STR0061, 33))	// "Valor do desconto nao permitido para o caixa atual"
								DisplayEnv(StatDisplay(), "4C"+ STR0128)	// "Tecle <ENTER> para continuar"
							Endif
							MsgStop( STR0061, STR0062 )
							lRet:=.F.
						EndIf
					EndIf
				EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Nao permite efetuar desconto³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			Case SubStr( cStrAcesso, nAcesso, 1 ) == "N"
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//| Valor do desconto nao permitido para o caixa atual / Desconto nao autorizado            |
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If lUsaDisplay
					// Limpar as mensagens do display
					LjLimpDisp()
					DisplayEnv(StatDisplay(), "1C"+ STR0062)	// "Desconto nao autorizado"
					DisplayEnv(StatDisplay(), "2E"+ Substr(STR0061,1,31))	// "Valor do desconto nao permitido para o caixa atual"
					DisplayEnv(StatDisplay(), "3C"+ Substr(STR0061, 33))	// "Valor do desconto nao permitido para o caixa atual"
					DisplayEnv(StatDisplay(), "4C"+ STR0128)	// "Tecle <ENTER> para continuar"
				Endif
				MsgStop( STR0061, STR0062 )
				lRet:=.F.
		EndCase
	EndIf
EndIf

If !lRet
	nDescPer := 0
	nDescLoj := 0
EndIf

If SA6->( Recno() ) <> nSA6Recno		// Reposiciona somente se houve alteracao do recno
	SA6->( DbGoTo( nSA6Recno ) )
EndIf

If lShwMsgNeg .AND. !lRet
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//| "Acesso Negado", "O usuário " ### " não tem permissão para executar a seguinte operação:|
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nPosacess > 0
		Aviso( STR0066, STR0067 + AllTrim(cUserName)+ STR0068 + Chr(13) + aPermiss[nPosacess][3], { "Ok" },, aPermiss[nPosacess][2] )
	Else
		Aviso( STR0066, STR0067 + AllTrim(cUserName)+ STR0068 + Chr(13),{"Ok"})
	EndIf
EndIf

RestArea( aArea )

Return lRet

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Funcao    ³ LJSenhaSup | Autor ³ Vendas Clientes     ³ Data ³17/07/2000³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Solicitacao de senha superior                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ LJSenhaSup(cSenhaSup,nAcesso,cCaixaSup)                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cSenhaSup  - Senha digitada na funcao AcessoSenha          ³±±
±±³          ³ nAcesso    - Numero do Acesso do Processo                  ³±±
±±³          ³ cCaixaSup  - Nome do caixa de senha superior               ³±±
±±³          ³ cFormDesc  - Tipo do desconto (MV_LJFORMD)                 ³±±
±±³          ³ nVlrDesc   - Valor do desconto                             ³±±
±±³          ³ nPerDesc   - Percentual do desconto                        ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function LJSenhaSup( cSenhaSup	, nAcesso	, cCaixaSup	, cFormDesc	,;
					nPerDesc	, nVlrDesc	, lSenha	, lSupOk	,;
					nPswOrder	, lCtrlB	, cSuperSel , cIDSel	,;
					cTpVal		, lTelaSimul )

Local lRet     	:= .T.                         		// Retorna se superior pode aprovar ou não
Local nRegSLF  	:= 0                           		// Ponteiro no registro SLF
Local nRegSA6  	:= 0                           		// Ponteiro no registro SA6
Local aArea    	:= GetArea()                   		// Salva area atual
Local lDesc		:= .F.                         		// Indica se superior tem alcada para esta quantidade de desconto (em valor e/ou percentual)
Local lLJSupApr := ExistBlock("LJSUPAPR")	   		// Verifica a existencia ou nao do ponto de entrada LJSUPAPR
Local cIdSup	:= ""                          		// Armazena a ID do usuario no sistema
Local cTipoDesc	:= SuperGetMV("MV_LJTIPOD",.F.,"0") // Tipo do Desconto
Local lTipoDesc := IIf(cTipoDesc <> "0",.T.,.F.)	// Verifica se existe o parametro
Local aRegCx	:= {}
Local lFTVDSUPAPR	:= ExistBlock("FTVDSUPAPR")	   			// Verifica a existencia ou nao do ponto de entrada FTVDSUPAPR
Local lFtvdVer12:= LjFTVD() //Verifica se é Release 11.7 e o FunName é FATA701 - Compatibilização Venda Direta x Venda Assisitida

Default cFormDesc	:= ""
Default nPerDesc	:= 0
Default nVlrDesc	:= 0
Default lSenha		:= .F.
Default cSenhaSup	:= ""
Default lSupOk		:= .F.
Default nPswOrder	:= 1
Default lCtrlB		:= .F.
Default cCaixaSup	:= ""
Default cSuperSel	:= ""
Default cIDSel		:= ""		//ID de Supervisor
Default cTpVal		:= "1"		//1-Senha, 2-Cartão
Default lTelaSimul	:= .F.		//Indica se a tela de senha de superior está sendo chamada na simulação de venda

//Quando liberacao via cartao, ja possui o nome do caixa
If Empty(cSuperSel)
	PswOrder(nPswOrder)
	If PswSeek(cCaixaSup)
		aRegCx := PswRet()
		If Len(aRegCx) > 0
			cCaixaSup := AllTrim( aRegCx[1][2] )
		EndIf
		cIdSup	  := PswID()
		PswOrder(2)
		PswSeek(cUserName)	//Retorna o arquivo de senhas para a posicao original
	EndIf
ElseIf cTpVal = "1"		//Se Senha e se cSupersel preenchido
	PswOrder(nPswOrder)
	If PswSeek(cIDSel)
		aRegCx := PswRet()
		If Len(aRegCx) > 0
			cCaixaSup := AllTrim( aRegCx[1][2] )
		EndIf
		cIdSup	  := cIdSel
		PswOrder(2)
		PswSeek(cUserName)	//Retorna o arquivo de senhas para a posicao original
	EndIf
Else		//Se cSuperSel preenchido e cTpVal for <> "1" - Cartão
	cCaixaSup := cSuperSel
EndIf

DbSelectArea("SA6")
SA6->( DbSetOrder(2) )
nRegSA6 := SA6->(Recno())
SA6->( DbSeek(xFilial("SA6")+UPPER(cCaixaSup)) )

DbSelectArea("SLF")
SLF->( DbSetOrder(1) )
nRegSLF := SLF->( Recno() )
SLF->( DBGoTop() )
SLF->( DbSeek(xFilial("SLF")+SA6->A6_COD) )

If (nAcesso <> 17) .OR. ( nAcesso == 17 .AND. AllTrim(cIdSup) <> "000000" )
	If lSenha
		If ! lSupOk
			LjDisplay()
			lRet := .F.
		EndIf
	Else
		If !lTelaSimul .and. (!lSupOk .Or. !(lRet:=subs(SLF->LF_ACESSO,nAcesso,1)=="S"))
			LjDisplay()
			lRet := .F.
		EndIf

		/* Verifica se a senha do Superior pode liberar o desconto com base
		no tipo do desconto
		"1" -> Verifica o percentual do desconto ou o valor do desconto
		"2" -> Verifica o percentual do desconto e o valor do desconto     */

		If lRet .AND. !Empty( cFormDesc ) .AND. AllTrim(cIdSup) <> "000000"
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Informar o Superior do caixa, senao como DEFAULT  ³
			//³pega o caixa atual e o acesso ao desconto é negado³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lTelaSimul .or. LjVerCxSup(cCaixaSup)
				If !lCtrlB .Or. (SLF->(FieldPos("LF_TOTDESP")) == 0 .Or. SLF->(FieldPos("LF_TOTDESV")) == 0)
					If cFormDesc == "1"
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³De acordo com o parametro valida pelo percentual ou pelo valor ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If !lTipoDesc .OR. cTipoDesc == "1"
							lDesc := (nPerDesc <= LjGetProfile("DESCPER",SA6->A6_COD))
						ElseIf cTipoDesc == "2"
							lDesc := (nVlrDesc <= LjGetProfile("DESCVAL",SA6->A6_COD))
						EndIf
					ElseIf cFormDesc == "2"
						lDesc := (nVlrDesc <= LjGetProfile("DESCVAL",SA6->A6_COD)) .AND. (nPerDesc <= LjGetProfile("DESCPER",SA6->A6_COD))
					EndIf
				Else

					If lTelaSimul					
						SA6->(dbgoto(nRegSA6))
					EndIf
					// Desconto no Total <CTRL>+B
					// Validacao dos seguintes campos da tabela SLF->(Perfil/Acessos Caixa):
					// SLF->LF_TOTDESP - Desconto Total Percentual
					// SLF->LF_TOTDESV - Desconto Total Valor
					If cFormDesc == "1"
						//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
						//³De acordo com o parametro valida pelo percentual ou pelo valor ³
						//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
						If !lTipoDesc .OR. cTipoDesc == "1"
							lDesc := (nPerDesc <= LjGetProfile("TOTDESP",SA6->A6_COD))
						ElseIf cTipoDesc == "2"
							lDesc := (nVlrDesc <= LjGetProfile("TOTDESV",SA6->A6_COD))
						EndIf
					ElseIf cFormDesc == "2"
						lDesc := (nPerDesc <= LjGetProfile("TOTDESP",SA6->A6_COD)) .AND. (nVlrDesc <= LjGetProfile("TOTDESV",SA6->A6_COD))
					EndIf
				EndIf

				If !lDesc
					lRet := .F.
					DisplayEnv( StatDisplay(), "2C" + STR0023 )		//"Acesso Negado !!"
					Iif(!lTelaSimul, MsgStop( STR0023 ),)	//Se estiver em simulação de venda, não exibe a msg
				EndIf
			Else
				lRet := .F.
				DisplayEnv( StatDisplay(), "2C" + STR0023 )		//"Acesso Negado !!"
				MsgStop( STR0023 )
			EndIf			
		EndIf
	EndIf
Else
	lRet := .T.
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Ponto de entrada retornar o UserID e nome de quem aprovou ou tentou aprovar a liberacao |
//| e se a liberacao foi com sucesso ou nao                                                 |
//| Parametros passados:                                                                    |
//| ID de usuario do superior, Codigo de Caixa do Superior, Sucesso ou nao na aprovacao     |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lLJSupApr .Or. lFTVDSUPAPR
	PswOrder(2)
	If PswSeek(cCaixaSup)
		cIdSup	  := PswID()
	EndIf
	PswOrder(2)
	PswSeek(cUserName)	//Retorna o arquivo de senhas para a posicao original

	If !lFtvdVer12
		ExecBlock('LJSUPAPR',.F.,.F.,  { cIdSup, cCaixaSup, lRet })
	ElseIf lFtvdVer12
		ExecBlock('FTVDSUPAPR',.F.,.F.,{ cIdSup, cCaixaSup, lRet })
	EndIf
EndIf

RestArea( aArea )

DbSelectArea("SA6")
dbgoto(nRegSA6)
DbSelectArea("SLF")
dbgoto(nRegSLF)

Return lRet

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºPrograma  ³LJIMPCHEQUºAutor  ³ Vendas Clientes    º Data ³  11/08/00   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Faz a impressao do cheque utilizando a dll fiscal           º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºSintaxe   ³ExpA1 := LjImpCheque(ExpC1,ExpC2,ExpC3,ExpC4,ExpN5,ExpC6,   º±±
±±º			 ³                     ExpC7,ExpD8,ExpC9,ExpC10,ExpL11,ExpN12,º±±
±±º			 ³                     ExpA13)                                º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametro ³ExpC1 - Codigo do banco                                     º±±
±±º			 ³ExpC2 - Codigo da agencia                                   º±±
±±º			 ³ExpC3 - Numero da conta corrente                            º±±
±±º			 ³ExpC4 - Numero do cheque                                    º±±
±±º			 ³ExpN5 - Valor do cheque                                     º±±
±±º			 ³ExpC6 - Nome do favorecido                                  º±±
±±º			 ³ExpC7 - Nome da cidade                                      º±±
±±º			 ³ExpD8 - Data de emissao                                     º±±
±±º			 ³ExpC9 - Observacao do cheque                                º±±
±±º			 ³ExpC10 - Dados impressos no verso do cheque                 º±±
±±º			 ³ExpL11 - Define se deve atualizar EF_IMPRESS                º±±
±±º			 ³ExpN12 - Parcela da venda(aPgtos)                           º±±
±±º			 ³ExpA13 - Controla que cheque foi impresso para gravar no    º±±
±±º			 ³		   EF_IMPRESS										  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³ExpA1[1] - Determina se eh para executar a funcao IfCheque  º±±
±±º			 ³ExpA1[2] - Determina se o cheque foi impresso no PE		  º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function LjImpCheque( cBanco     ,cAgencia  ,cConta   ,cCheque   ,;
                      nValor     ,cFavorec  ,cCidade  ,dEmissao  ,;
                      cObs       ,cVerso    ,lAtuSEF  ,nParc     ,;
                      aImpCheque )

Local aRet := {.T.,.F.}
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Estrutura da aRet                                                   ³
//³[1] - logico, se e ou nao para executar a funcao IFCheque           ³
//³[2] - logico, se o cheque foi ou nao impresso no ponto de entrada   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local lImprimiu 	:= .F. 		// Variavel que verifica se imprimiu
Local nRet 			:= 0		// Variavel de retorno
Local nOpc 			:= 0		// Variavel de opção do DEFINE SBUTTON
Local lImpCheque    := .F.    // Controla se o cheque foi impresso
Local nPosImpCheque := 0      // Posicao do cheque no array aImpCheque para determinar se foi impresso
Local lFtvdVer12	:= LjFTVD() //Verifica se é Release 11.7 e o FunName é FATA701 - Compatibilização Venda Direta x Venda Assisitida

Default lAtuSEF     	:= .T.		// Variavel que recebe atualização do SEF
Default nParc       	:= 1      	// Parcela do aPgtos
Default aImpCheque  	:= {}     	// Controla impressao do cheque
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica se existe o ponto de entrada para impressao de cheque                ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock('LJCHEQUE') .AND. !lFtvdVer12
	aRet := ExecBlock('LJCHEQUE',.F.,.F.,{cBanco,nValor,cFavorec,dEmissao,cObs,cVerso,cCheque,cConta,nParc,cCidade})
EndIf

If ExistBlock('FTVDCHEQUE') .AND. lFtvdVer12
	aRet := ExecBlock('FTVDCHEQUE',.F.,.F.,{cBanco,nValor,cFavorec,dEmissao,cObs,cVerso,cCheque,cConta,nParc,cCidade})
EndIf

If aRet[1]
	While !lImprimiu
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Executa Dialog de confirma‡Æo da ImpressÆo do Cheque                    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lUsaDisplay
			DisplayEnv(StatDisplay(), "1C"+ Upper(STR0025 + cCheque) )		//"Insira o cheque n£mero: "
			DisplayEnv(StatDisplay(), "2C"+ Upper(STR0064) )					//"E pressione <ENTER>"
		End
		DEFINE MSDIALOG oDlgCheque TITLE (STR0024) FROM 96,42 TO 230,285 PIXEL		// "Impressao de cheques"
			@ 03,03 TO 048,117 PIXEL
			@ 13,06 SAY (STR0025 + cCheque) OF oDlgCheque PIXEL SIZE 105,10										// "Insira o cheque n£mero: "
			@ 23,06 SAY (STR0026 + cBanco + STR0027 + cAgencia) OF oDlgCheque PIXEL SIZE 105,10					// "Banco: " / " - Agˆncia: "
			@ 33,06 SAY (STR0028 + cConta + STR0029 + Alltrim(Str(nValor,14,2))) OF oDlgCheque PIXEL SIZE 105,10	// "Conta: " / " - Valor  : "
			DEFINE SBUTTON FROM 53,55 TYPE 1 ENABLE OF oDlgCheque ACTION (nOpc:=1,oDlgCheque:End())
			DEFINE SBUTTON FROM 53,90 TYPE 2 ENABLE OF oDlgCheque ACTION (nOpc:=0,oDlgCheque:End())
		ACTIVATE DIALOG oDlgCheque CENTERED

		If nOpc == 1
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//| "Aguarde a impressão do cheque..."   |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If lUsaDisplay
				DisplayEnv(StatDisplay(), "1C"+ Upper(STR0035) )
				DisplayEnv(StatDisplay(), "2C"+ " " )
			End
			LJMsgRun(STR0035,, {|| nRet := CHImprime( nHdlCH, cBanco, StrZero(nValor,12,2), cFavorec, cCidade, DTOS(dEmissao), cObs, cVerso )})
			lImprimiu := (nRet==0)
		Else
			lImprimiu := .T.
			Exit
		EndIf
		If !lImprimiu
			If lUsaDisplay
				DisplayEnv(StatDisplay(), "1C"+ Upper(STR0057) )
				DisplayEnv(StatDisplay(), "2C"+ " " )
			End
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//| "Falha na impressão do cheque", "Não foi possível realizar a impressão do cheque. Será realizada a reimpressão."|
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			Aviso(STR0057, STR0058, {"Ok"})
		EndIf
	End

EndIf
lImpCheque  := lImprimiu .OR. aRet[2]
nPosImpCheque := Ascan(aImpCheque,{|x| x[1] == nParc })
If nPosImpCheque == 0
	AADD(aImpCheque,{nParc,lImpCheque})
Else
	aImpCheque[nPosImpCheque][2] := lImpCheque
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica se o cheque foi impresso para ser gravado no SEF                   ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If (lImprimiu .OR. aRet[2]) .AND. lAtuSEF
	DbSelectArea('SEF')
	DbSetOrder(1)

	cBanco   := PadR(cBanco, TamSx3("EF_BANCO")[1], " ")
	cAgencia := PadR(cAgencia, TamSx3("EF_AGENCIA")[1], " ")
	cConta   := PadR(cConta, TamSx3("EF_CONTA")[1], " ")
	cCheque  := PadR(cCheque, TamSx3("EF_NUM")[1], " ")

	If DbSeek( xFilial('SEF')+cBanco+cAgencia+cConta+cCheque )
		RecLock('SEF',.F.)
		SEF->EF_IMPRESS := 'S'
		MsUnLock()
	EndIf

EndIf

Return (aRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ LJ010LEG   | Autor ³ Vendas Clientes     ³ Data ³23/05/2001³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Exibe uma legenda contendo as descricoes das cores dos     ³±±
±±³          ³ status dos orcamentos.                                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ LJ010LEG()                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³                                                            ³±±
±±³          ³                                                            ³±±
±±³          ³                                                            ³±±
±±³          ³ 															  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ Loja010a                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LJ010LEG()

Local aLegenda := { {"BR_VERDE",	STR0038},;	//"Orcamentos em aberto"
					{"BR_VERMELHO",	STR0039},;	//"Vendas efetuadas"
					{"BR_AMARELO",	STR0040},;	//"Orcamentos com Reservas"
					{"BR_PRETO",	STR0041},;	//"Orcamentos em aberto Vencidos"
					{"BR_BRANCO", 	STR0065}}	//"Transação TEF desfeita"
BrwLegenda(STR0036,STR0037,aLegenda)		   // "Orcamentos","Legenda"

Return .T.

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LJPREFIXO ºAutor  ³ Vendas Clientes    º Data ³  06/28/01   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Devolve qual o prefixo a ser utilizado nas relacoes:       º±±
±±º          ³ SL1 -> SE1 e SL1 -> SE3                                    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGALOJA                                                   º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LJPREFIXO( cFilialSF2 )

Local nSF2Order := SF2->(IndexOrd())
Local nSF2Recno := SF2->(Recno())
Local aAreaSL1	:= SL1->(GetArea())
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Precisa estar posicionado no SL1   |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local cPrefixo 	:= ""
Local cL1Doc 	:= ""
Local cL1Serie	:= ""

DEFAULT cFilialSF2	:= xFilial("SF2")

/*----------------------------------------------------------------------
Faz a verificacao para ter certeza que esta posicionado no SL1 correto.
Posiciona no orcamento principal, que deu origem a venda.
Quando eh venda com pedido, deve estar posicionado no orcamento pai.
----------------------------------------------------------------------*/
If !Empty(SL1->L1_ORCRES)
	SL1->(DbSetOrder(1)) //L1_FILIAL + L1_NUM
	SL1->(DbSeek(SL1->L1_FILRES+SL1->L1_ORCRES))
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica se eh um pedido ou um orcamento ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If SL1->L1_TIPO == "P"
	cL1Doc   := SL1->L1_DOCPED
	cL1Serie := SL1->L1_SERPED
Else
	cL1Doc   := SL1->L1_DOC
	cL1Serie := SL1->L1_SERIE
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Ajusta a variavel cPrefixo               ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
cPrefixo := cL1Serie

SF2->(DbSetOrder(1))
If SF2->(DbSeek(cFilialSF2 + cL1Doc + cL1Serie + SL1->L1_CLIENTE + SL1->L1_LOJA )) .AND. !Empty(SF2->F2_PREFIXO)
	cPrefixo := SF2->F2_PREFIXO
EndIf
SF2->(DbSetOrder(nSF2Order))
SF2->(DbGoto(nSF2Recno))
RestArea(aAreaSL1)

Return (cPrefixo)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LJSE5SERIEºAutor  ³ Vendas Clientes    º Data ³  22/06/06   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Devolve qual a serie a ser utilizado nas relacoes:         º±±
±±º          ³ SE5 -> SL1                                                 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGALOJA                                                   º±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LJSE5SERIE( cFilialSE1, cAliasSE5 )

Local nSE1Order := SE1->(IndexOrd())
Local nSE1Recno := SE1->(Recno())
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//|Precisa estar posicionado no SE5   |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local cSerie := (cAliasSE5)->E5_PREFIXO

DEFAULT cFilialSE1 := xFilial("SE1")
DEFAULT cAliasSE5  := "SE5"

SE1->(DbSetOrder(1))
If SE1->(DbSeek(cFilialSE1 + (cAliasSE5)->E5_PREFIXO + (cAliasSE5)->E5_NUMERO + (cAliasSE5)->E5_PARCELA + ;
				(cAliasSE5)->E5_TIPO + (cAliasSE5)->E5_CLIFOR + (cAliasSE5)->E5_LOJA ))
	cSerie := SE1->E1_SERIE
EndIf
SE1->(DbSetOrder(nSE1Order))
SE1->(DbGoto(nSE1Recno))

Return (cSerie)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Função    ³LJParcela    ³ Autor ³ Vendas Clientes    ³ Data ³ 08/10/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³ Calcula o Número da Próxima Parcela                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ ExpL1 := L010Credito( [ <ExpA1> ] ) 						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parƒmetros³ [ <ExpA1> ] - Elemento 1 -> Número da Parcela 1..64       .³±±
±±³          ³ [ <ExpA2> ] - Elemento 2 -> Tipo, pode ser "A" ou "1"     .³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorna	 ³ ExpL1 -> Número da Parcela com apenas 1 caracter           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ LOJXFUNB                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function LJParcela( uParcela, cTipo )

Local cResult  := ""                    		// Retorno da função
Local iParcela                                  // Numero da parcela
Local nTam 	   := TamSx3( "E1_PARCELA" )[ 1 ]  // Tamanho do campo no SX3
Local cParcela := Space(nTam)                  // Tamanho da variável
Local lSeqParFat := SuperGetMv( "MV_LJPARFA", ,.F.) // verifica se as parcela seguirão sequência do faturamento.
Local nI := 0 //Sequencia

If ValType(uParcela) == "C"
	iParcela := Val( uParcela )
Else
	iParcela := uParcela
EndIf

If cTipo == NIL
	If !lSeqParFat
		cTipo := SuperGETMV("MV_1DUP")=="1"
	Else
		cTipo := "A"
	EndIf
EndIf


If  lSeqParFat .AND. (  "A" $ cTipo .OR. nTam == 1) //Se for sequenciamento do faturamento
	//Verifica se tipo é alfa ou tamanho é um para chamar a função do faturamento
	cResult := cTipo

	If iParcela > 1

		nI := 2
		For nI := 2 to iParcela
			cResult :=	MaParcela(cResult)
		Next nI
	EndIf
Else
	If "A" == cTipo
		// A..Z
		cResult := Chr(iParcela+64)
	ElseIf "AA" == cTipo .And. nTam == 2
		cResult := cTipo
		If iParcela > 1
			For nI := 2 to iParcela
				cResult := Soma1(cResult,nTam)
			Next nI
		EndIf
	Else
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Se o tamanho do campo no SX3 for igual 1 , parcela vai de 1...9³
		//³A....Z   e a.....z                                             ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

		If nTam == 1
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Se o tamanho do campo no SX3 for igual 1 , parcela vai de 1...9³
				//³A....Z   e a.....z                                             ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				Do Case
				  Case iParcela >= 01 .AND. iParcela <= 09
				  	cResult := AllTrim( Str(iParcela) )
				  Case iParcela >= 10 .AND. iParcela <= 35
				    cResult :=  Chr( iParcela + 55 )
				  Case iParcela >= 36 .AND. iParcela <= 61
				    cResult :=  Chr( iParcela + 61 )
				  Otherwise
				    cResult := "*"
				EndCase
		Else
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Respeita o tamanho do campo para determinar a quantidade de parcelas ³
			//³Exemplo: E1_PARCELA = 2  parcelas de 01 .......99                    ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

			//Esta regra se sequenciamento é igual a função MaParcela
			cParcela := StrZero(iParcela - 1, nTam)
			cResult  := Soma1(cParcela, nTam)

		EndIf

	EndIf

EndIf

cResult := PadR(AllTrim(cResult),nTam)		// Deve-se ajustar o retorno de cParcela ao tamanho do E1_PARCELA

Return( cResult )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Função    ³ LJ010VerCAF ³ Autor ³ Vendas Clientes    ³ Data ³ 13/11/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³ Verifica se deve ou nao calcular valor de credito de       ³±±
±±³			 ³ acrescimo financeiro e gravalo no campo D2_VAC (que deve	  ³±±
±±³			 ³ ser criado na tabela SD2 pois nao pertence ao SX padrao)   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ ExpL1 := L010VerCAF() 									  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorna	 ³ ExpL1 -> Utiliza calculo de credito de acrescimo financeiro³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ LOJA010D / SCRFIS                                          ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function LJ010VerCAF( lEmissao )

Local lRet
Local lVista
Local nCont
Local nHandle
Local nInicio
Local cByte
Local cEstado
Local cEstadoMV := AllTrim(SuperGETMV("MV_ESTADO"))

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Primeiro verifica se não existe o novo LCAF (LCAF<sigla do estado>.INI)   |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ! ( lRet := File("LCAF" + cEstadoMV + ".INI") )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//| Se não existir o arquivo novo, pesquisa o arquivo antigo e obtem o estado referente a tabela  |
	//| de limites de acrescimo financeiro                                                            |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nHandle := fOpen( "LCAF.INI", FO_READ )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//| Se conseguiu abrir o arquivo   |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( lRet := ( fError() == 0 ) )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//| Busca a sigla do estado no arquivo .INI  |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nInicio := fSeek( nHandle, 0 )
		cByte   := fReadStr( nHandle, 1 )
		cEstado := ""

		While cByte # Chr(13)

			cEstado += If( ! Empty( cByte ), cByte, "" )
			nInicio ++
			fSeek( nHandle, nInicio )
			cByte := fReadStr( nHandle, 1 )

		End

		fClose( nHandle )   // Fecha o LCAF.INI

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//| Verifica se o estado do MV_ESTADO é o mesmo do arquivo LCAF   |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		lRet := ( Upper(cEstadoMV) == Upper(AllTrim(cEstado)) )   // Para ter certeza que vai comparar corretamente.

	EndIf

EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Se passou pela validação acima, verifica se o tipo do cliente é consumidor final e se o país é brasil.          |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRet .AND. ( lRet := ( cPaisLoc == "BRA" .AND. SA1->A1_TIPO == "F" ) )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    //| Verifica se existe o campo F4_REDAFBC que identifica se o produto é bem de consumo (S/N) existe             |
    //| e se o produto é bem de consumo. Verifica se o campo F2_VALACRS que é gravado o valor de acréscimo          |
    //| existe e se o valor de acrésimo financeiro D2_VAC também existe.                                            |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( lRet := ( SF4->(FieldPos("F4_REDAFBC")) > 0 .AND. SF4->F4_REDAFBC == "S" ) .AND. ;
								( SF2->(FieldPos("F2_VALACRS")) > 0 .AND. SD2->(FieldPos("D2_VAC")) > 0 ) )

		lVista := .T.

		For nCont := 1 to Len( aPgtos )
			If aPgtos[nCont,1] # dDataBase
				lVista := .F.
				exit
			EndIf
		Next nCont

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//| Verifica se existe valor de acrescimo financeiro e se nao eh pagamento a vista. 		|
		//| Se o produto tiver percentual de icms retido e cliente for tipo solidario ou consumidor |
		//| final nao calcula o credito de acrescimo de icms.                                       |
		//| Se a TES do produto indicar que o mesmo eh isento ou nao-tributado tambem nao calcula o |
		//| credito de acrescimo financeiro.                                                        |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		lRet := ( (nVlrAcrs > 0 .AND. ! lVista) .AND. ;
							( ! ( SB1->B1_PICMRET > 0 .AND. SA1->A1_TIPO $ GetNewPar("MV_TPSOLCF","S,F") ) ) .AND. ;
							( ! (SF4->F4_LFICM $ "IN") ) )

	EndIf

EndIf

Return( lRet )

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Função    ³ LJ010TaxaCAF³ Autor ³ Vendas Clientes    ³ Data ³ 13/11/01 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³ Calcula a taxa de limite de credito de acrescimo financeiro³±±
±±³       	 ³ de acordo com as parcelas do aPagtos.                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ ExpN1 := LJ010TaxaCAF() 									  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorna	 ³ ExpN1 -> Taxa de limite de credito de acrescimo financeiro |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ LOJA010D                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function Lj010TaxaCAF()

Local nHandle
Local nTamArq
Local nPos
Local nLenPgtos
Local nDiasParc
Local nInicio
Local nValProp
Local nDiasProp
Local cLinha
Local cLinha2
Local cLinha3
Local cByte
Local cParcelas
Local cPrazo
Local cTaxa
Local aTaxas
Local lDifValParc
Local lDifDiaParc
Local lEstado											// Indica que eh a linha referente a sigla do Estado
Local cEstadoMV   := AllTrim(SuperGetmv("MV_ESTADO"))
Local nTaxa 	  := 0

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Se existir o arquivo LCAF<sigla do estado>.INI, seta o flag lEstado para falso, para não pegar a linha do     |
//| Estado no arquivo .INI                                                                                        |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If File("LCAF" + cEstadoMV + ".INI")

	lEstado  := .F.  // .F. porque nesse arquivo novo não tem a sigla, apenas as aliquotas.
	nHandle  := FOpen("LCAF" + cEstadoMV + ".INI", FO_READ)

Else

	lEstado := .T.   // Para manter o padrão, é setado para .T. para identificar que tem a linha com a sigla do estado.
	nHandle := fOpen( "LCAF.INI", FO_READ )

EndIf

If fError() == 0

	cLinha  := ""
	aTaxas  := {}
	nTamArq := fSeek( nHandle, 0, 2 )
	nInicio := fSeek( nHandle, 0 )

	For nPos := 1 to nTamArq + 1

		cByte   := fReadStr( nHandle, 1 )
		nInicio := fSeek( nHandle, nPos )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//| Pula a linha referente a identificacao do estado.                                       |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lEstado
			If cByte == Chr( 10 )
				lEstado := .F.
            EndIf
		Else
			If cByte == Chr( 10 ) .OR. cByte == Chr( 13 ) .OR. nPos == nTamArq + 1
				If ! Empty( cLinha )
					cParcelas := SubStr( cLinha, 1, At( "|", cLinha ) - 1 )
					cLinha2	  := SubStr( cLinha, At( "|", cLinha ) + 1 )
					cPrazo	  := SubStr( cLinha2, 1, At( "|", cLinha2 ) - 1 )
					cLinha3	  := SubStr( cLinha2, At( "|", cLinha2 ) + 1 )
					cTaxa	  := AllTrim(SubStr( cLinha3, 1 ))
					AAdd( aTaxas, { Val( cParcelas ), Val( SubStr( cPrazo, 1, 3 ) ), Val( SubStr( cPrazo, 4, 3 ) ), Val( cTaxa ) } )
					cLinha := ""
				EndIf
			Else
				cLinha += cByte
			EndIf
		EndIf

	Next nPos

EndIf

fClose( nHandle )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Verifica as parcelas tem os mesmos valores.   |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nLenPgtos   := Len( aPgtos )
lDifValParc := .F.
lDifDiaParc := .F.

For nPos := 1 to nLenPgtos
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//| Se nao for a ultima parcela  |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If nPos < nLenPgtos
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//| Se a parcela nao for a vista (entrada) entao executa as verificacoes de valor           |
		//| e dias entre parcelas                                                                   |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If aPgtos[nPos,1] # dDataBase
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//| Verifica se o valor das parcelas sao iguais.  |
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If aPgtos[nPos,2] # aPgtos[nPos+1,2]
				lDifValParc := .T.
				exit
			EndIf
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//| Verifica se o intervalo de dias entre as parcelas sao iguais.  |
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If aPgtos[nPos+1,1] - aPgtos[nPos,1] < 30
				lDifDiaParc := .T.
				exit
			EndIf
		EndIf
	EndIf
Next nPos

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Se as parcelas tiverem os valores iguais e a diferenca de dias entre as parcelas for    |
//| maior ou igual a trinta dias                                                            |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ! lDifValParc .AND. ! lDifDiaParc

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//| Busca direto o numero de parcelas na tabela e seleciona a taxa  |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If ( nPos := aScan( aTaxas, {|x| x[1] == (nLenPgtos - 1) } ) ) > 0
		nTaxa := aTaxas[ nPos, 4 ]
	EndIf

Else

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//| Busca a taxa pelo prazo medio de financiamento  |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nValProp := 0

	For nPos := 1 to nLenPgtos

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//| Quantidades de dias decorridos entre a data da venda e a data do vencimento da parcela  |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	    nDiasParc := ( aPgtos[ nPos, 1 ] - dDataBase )

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	    //| Somatoria do produto da multiplicacao entre o valor da parcela e nDiasParc              |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	    nValProp += aPgtos[ nPos, 2 ] * nDiasParc

	Next nPos

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//| Prazo medio e taxa equivalente na tabela   |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nDiasProp := Round( nValProp / SL1->L1_VLRTOT, 0 )

	If ( nPos := aScan( aTaxas, {|x| x[2] <= nDiasProp .AND. x[3] >= nDiasProp } ) ) > 0
		nTaxa := aTaxas[ nPos, 4 ]
	EndIf

EndIf

Return nTaxa

/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Função    ³ LjMsgVal    ³ Autor ³ Vendas Clientes    ³ Data ³ 25/04/02 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descrição ³ Apresenta mensagem  "valor invalido", no caso de valor neg.³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ LjMsgVal(uTemp,lZero)                                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorna	 ³ uTemp -> Recebe o valor para validacao                     |±±
±±³          ³ lZero -> Aceita o valor zero                               |±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGALOJA                                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function LjMsgVal( uTemp, lZero )

Local lRet :=.T.    // retorno da função
If Valtype( uTemp )='N'
    If ( lZero .AND. uTemp<0 ) .OR.( !lZero.AND. uTemp<=0)
			MsgInfo(STR0042) // Valor inv lido
			lRet:=.F.
    EndIf
EndIf
Return lRet

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Fun‡„o    ³LjOpenDevi³ Autor ³ Vendas Clientes       ³ Data ³ 18/02/98 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Cria Variaveis do Sistema                                  ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function LjOpenDevices()
Local cImpressora	:= LJGetStation("IMPFISC")
Local cPorta		:= ""
Local aPinPad		:= {}
Local aCMC7			:= {}
Local aLeitor		:= {}
Local aImpCupom		:= {}
Local aDisplay      := {}
Local aDispTor      := {}
Local aBalanca      := {}
Local nRet 			:= 0
Local cNumPdv       := Space(TamSX3("LG_PDV")[1])
Local cNumCaixa 	:= xNumCaixa()
Local aECFDir 		:= {}									//Array contendo os arquivos que deverao ser deletados caso o sistema nao utilize empresa 99 (teste)
Local nX 			:= 0									//Variavel para controle de loop
Local lApagaECF     := .T.
Local lMvLjPdvPa    := LjxBGetPaf()[2] 						//Indica se é pdv
Local lMenFisOnLog	:= IsInCallStack("LjMenFiLog") 			//Valida se foi chamado Menu Fiscal da Tela de Login
Local lLjNfPafEcf	:= LjNfPafEcf(SM0->M0_CGC)
Local lLjNfNoPaf	:= LjNfNoPaf(SM0->M0_CGC)
Local lHomolPaf		:= LjHomolPaf()
Local cValidRec		:= "2"
Local lMsgRec		:= .T.
Local lFtvdVer12	:= LjFTVD() 							//Verifica se é Release 11.7 e o FunName é FATA701 - Compatibilização Venda Direta x Venda Assisitida
Local lEmitNfce		:= LjEmitNFCe()							//Sinaliza se utiliza NFC-e
Local lCentPDV		:= LjGetCPDV()[1]		 				//Central de PDV
Local aAnalisLeg65	:= LJAnalisaLeg(65) 					//Legislação que obriga o envio do relatório gerencial
Local aRetChSat		:= {} 									//retorno chave de ativação SAT
Local aDtHrECF		:= {}
Local lRedZ			:= .F.
Local lIsPafNfce	:= STBPafNfce()							//Usa NFC-e com PAF no ECF ?
Local lEcfSemCom	:= .F.
Local lIsECF		:= .F.
Local cAux			:= ""
Local nBandeira		:= 0									//Bandeira do TEF-Discado
Local lTentar		:= .F.									//Verifica se há TEF pendente no arquivo TEFPEND
Local aTefPend		:= {}									//Array para verificação de TEF pendente
Local lLjxImpRed	:= ExistFunc("LjxImpRede")		
Local lMvFisNota	:= SuperGetMv("MV_FISNOTA",, .F.)		//Imprime Nota Fiscal		
Local lMvLjLbNt		:= SuperGetMv("MV_LJLBNT",,0) > 0		//Liberação de Geração de Nota.(0- Verificação Padrão, 1- Emissão de Nota para Pessoa Jurídica, 2 - Emissão de Nota para Pessoa Física e Jurídica) .	
Local lPOS			:= STFIsPOS() 							// Valida se é POS
Local oTEF20 		:= Nil
Local cImpEst		:= LjGetStation("LG_IMPFISC")			// Estação que está sendo utilizada
Local lImpFiscal 	:= .F. 									// Guarda se esta utilizando ECF
Local cUrlDoc       := ""
Local cMsg          := ""

/* O nome da impressora foi alterada na DLL depois de enviado para producao
 criada a impressora BEMATECH MP20FI I e foi preciso acrescentar o II para diferenciar.  */
If cImpressora == "BEMATECH MP20FI"
	cImpressora := "BEMATECH MP20FI II"
EndIf

lUsaCmc7	:= !Empty(LJGetStation("CMC7"))
lUsaCH		:= !Empty(LJGetStation("IMPCHQ"))
lUsaLeitor	:= !Empty(LjGetStation('OPTICO'))
lUsaDisplay := !Empty(LjGetStation("DISPLAY"))
lUsaDispTor := !Empty(LjGetStation("DISPTOR"))
lImpCup		:= !Empty(LjGetStation("IMPCUP"))
lUsaTef		:= IIf( lMenFisOnLog , .F. ,LJProFile(2))

If !lFtvdVer12
	//Quando logar com a função do Menu Fiscal deve colocar como lFiscal pois
	//posteriormente é validado o lFiscal e se ele acessar o sistema sem o ECF evita conseguir acessar a venda assistida
	lFiscal	:=IIf( lMenFisOnLog,.T.,IIF((lLjNfPafEcf .AND. !lMvLjPdvPa .AND. !lMvLjLbNt) .OR. lLjNfNoPaf, .F., LJProFile(3)))

	If lLjNfPafEcf
		PutMv("MV_LJPAFEC",.T.)
		If lMvLjPdvPa
			PutMv("MV_LJVACC",.T.) //Concomitancia obrigatoria conforme Requisito IV do ATo Cotepe
		EndIf
	EndIf

	//Habilita a nota automaticamente pois o CNPJ não pode utilizar ECF
	If lLjNfNoPaf
		lEmiteNF	:= .T.
		PutMv("MV_FISNOTA",.T.)

	ElseIf !lEmitNfce
		//Verifica se impressao de NF habilitada
		If lMvFisNota
			lEmiteNF := .T.
		Else
			lEmiteNF := .F.
		EndIf
	EndIf

	//Impede o acesso ao sistema caso o relatório gerencial do PAF-ECF não tenha sido entregue
	If lMvLjPdvPa .And. !STBHomolPaf() .And. !lMenFisOnLog .AND. !lLjNfPafEcf .AND. LJAnalisaLeg(64)[1] .AND.;
		aAnalisLeg65[1] .AND. !lEmitNfce .AND. !lLjNfNoPaf

		LJMsgLeg(aAnalisLeg65)
		LjMenFiLog(.F.)
		Final(STR0119) //"Relatório Gerencial não enviado e PAF-ECF não liberado! Verifique!"
	EndIf

ElseIf lFtvdVer12
	lFiscal	:= .F.
EndIf  

//Central Pode entrar sem ECf
If lCentPDV
	PutMv("MV_LJGRVON",.F.)
EndIf

lImpTk		:= IIf( lMenFisOnLog , .F. , LJProFile(30))
lGaveta		:= !Empty(LjGetStation('GAVETA'))
cTipTEF		:= LjGetStation("TIPTEF")
ltTefAberto := .F.
lUsaBalanca := SLG->(ColumnPos("LG_PORTBAL")) > 0 .AND. !Empty(LjGetStation('BALANCA')+LjGetStation('PORTBAL'))

If ExistFunc("LjTMTT")
	//Envia a telemetria para o License Server com o TEF que sendo utilizado pela estação.
	If lMvLjPdvPa
		//Quando for PDV PAF, executa a função na retaguarda
		FR271CMyCall( "LjTMTT", Nil, LjRetTpTef(cTipTEF))
	Else
		LjTMTT(LjRetTpTef(cTipTEF))
	EndIf
EndIf

If !lFtvdVer12
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Release 11.5 - SmartClient HTML³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If LjChkHtml ()
		If lFiscal 	//Acesso negado para usuario fiscal
			Final(STR0109)//"Módulo indisponível para usuário fiscal"
		EndIf

		If lUsaTEF //Acesso negado para TEF ativo
			Final(STR0110)// "Módulo indisponível para usuário com permissão TEF."
		EndIf
	EndIf
EndIf

//Tef-Auttar	//Rollback dos TEFs pendentes
If lUsaTEF .AND. (cTipTEF $ TEF_DISCADO) .AND. IsCaixaLoja( cNumCaixa ) .AND. ExistFunc("L010GetGPAtivo")
	nBandeira     := L010GetGPAtivo()					        // Controla a administradora que foi efetuada a transacao TEF baseado no aTefDisc
	If (ExistFunc("L010IsAuttar") .AND. L010IsAuttar(nBandeira)) .OR. nBandeira = -1	//A Função L010IsAuttar é carregado após a chamado do LOJA010T, porém caso não passou, o nBandeira lerá como -1 (indefinido) até o LOJA010T decidir.
		lTentar := .F.

		//Faz a leitura do arquivo TEFPEND.TEMP localizado na pasta do smartclient
		aTefPend := LJLoadDTEF()
		If aScan(aTefPend, {|x| x[8]=="PENDENTE"}) > 0			//Se Pendente, desfaz administradora
			Loja010T("X",,,,,,,,,,,,,,,,,,,,.T./*existe Trn confirmada*/)	//Dentro desta função eu verifico se é Auttar, e somente se Auttar faz o rollback dos TEFs.
		EndIf
	EndIf
EndIf

If lUsaTEF .AND. cTipTEF $ TEF_SEMCLIENT_DEDICADO+";"+TEF_COMCLIENT_DEDICADO+";"+TEF_DISCADO .AND. IsCaixaLoja( cNumCaixa )
	lUsaTef := Loja010T( "A" )
EndIf

If !lFiscal
	nHdlECF := -1
EndIf

If lGaveta .AND. LJGetStation("PORTIF")<>LJGetStation("PORTGAV") .AND. nHdlGaveta == -1 .AND. GetRemoteType() != REMOTE_LINUX //Verificacao de porta nao e necessario para linux 
	nHdlGaveta:=GavetaAbr(LJGetStation("GAVETA"),LJGetStation("PORTGAV"))
	If nHdlGaveta < 0
		lGaveta := .F.
	EndIf
EndIf

//-------------------------------------------------------------------------------------------
//|Verifica se utiliza Leitor Optico via serial, pois a maioria e via teclado				|
//-------------------------------------------------------------------------------------------
aLeitor:=LJGetStation({"OPTICO","PORTOPT"})
If lUsaLeitor .AND. !Empty(aLeitor[1]).AND. !Empty(aLeitor[2]) .AND. nHdlLeitor == -1
	nHdlLeitor:=LeitorAbr(aLeitor[1],aLeitor[2],'F')
	If nHdlLeitor < 0
		lUsaLeitor := .F.
	EndIf
EndIf

//-------------------------------
//|Verifica se utiliza Balanca	|
//-------------------------------
If SLG->(ColumnPos("LG_PORTBAL")) > 0
	aBalanca:=LJGetStation({"BALANCA","PORTBAL"})
	If lUsaBalanca .AND. !Empty(aBalanca[1]) .AND. !Empty(aBalanca[2]) .AND. nHdlBalanca == -1
		nHdlBalanca:=BalancaAbr(aBalanca[1],aBalanca[2],'F')
		If nHdlBalanca < 0
			lUsaBalanca := .F.
		EndIf
	EndIf
EndIf

//-----------------------
//| Abertura do Display |
//-----------------------
aDisplay := LJGetStation({"DISPLAY","PORTDIS"})
If lUsaDisplay .AND. !Empty(aDisplay[1]) .AND. !Empty(aDisplay[2]) .AND. StatDisplay() == -1
	StatDisplay(DisplayAbr(aDisplay[1], aDisplay[2]))
	If StatDisplay() < 0
		lUsaDisplay := .F.
	Else
		//-----------------------------------------------
		//| Exibir Mensagem de Inicializacao no Display |
		//-----------------------------------------------
		MsgDisplay(1)
	EndIf
EndIf

//-----------------------------
//| Abertura do Display Torre |
//-----------------------------
aDispTor := LJGetStation({"DISPTOR","PORTTOR"})
If lUsaDispTor .AND. !Empty(aDispTor[1]) .AND. !Empty(aDispTor[2]) .AND. StatDispTor() == -1
	StatDispTor(DispTorAbr(aDispTor[1], aDispTor[2]))
	If StatDispTor() < 0
		lUsaDispTor := .F.
	Else
		//-----------------------------------------------
		//| Exibir Mensagem de Inicializacao no Display |
		//-----------------------------------------------
		MsgDispTor(1)
	EndIf
EndIf

If lUsaCmc7 .AND. ! ExistBlock("LJCMC7") .AND. nHdlCMC7 == -1
	aCMC7 := LJGetStation({"CMC7","PORTMC7"})
	nHdlCMC7 := CMC7Abr(aCMC7[1],aCMC7[2])
	If nHdlCMC7 < 0
		MsgStop(STR0055)		// "Falha na comunicação com o Leitor de CMC7."
		lUsaCmc7 := .F.
	EndIf
EndIf

//********* Abertura da Impressora de Cheque **********
If lUsaCH .AND. !Empty(LJGetStation("PORTCHQ")) .AND. nHdlCH == -1
	nHdlCH := CHAbrir( LJGetStation("IMPCHQ"), LJGetStation("PORTCHQ") )
    If nHdlCH < 0
    	MsgStop(STR0049)		// "Falha na comunicação com a Impressora de Cheque."
    	lUsaCH := .F.
    EndIf
EndIf

//------------------------------------------------------------------------
// Faz a verificao do emulador. Somente permite a utilizacao na empresa ||
// teste (99) para efeito de testes no Laboratorio de Produtos Microsiga||
// Este controle se faz necessario para evitar que este recurso seja    ||
// utilizado em producao.                                               ||
// A unica excecao eh para a empresa Microsiga pois este recurso eh     ||
// utilizado pelo CPR para demonstracoes.                               ||
//-----------------------------------------------------------------------
If "EMULATOR" $ Upper(Alltrim(cImpressora))
    lApagaECF := LjUsaECFE(SM0->M0_CGC)
	If cEmpAnt <> "99" .AND. SM0->M0_CGC <> "53113791000122" .AND. !( lApagaECF .OR. LjRecEmul(SM0->M0_CGC , cValidRec , lMsgRec) )
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Apaga o arquivo que configura o emulador para nao permitir sua       ³
		//³ utilizacao                                                           ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aECFDir := Directory(GetClientDir()+"ECFEMUL.???")
		For nX := 1 to Len( aECFDir )
			FErase( GetClientDir()+aECFDir[nX][1] )
		Next nX
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Limpa o arquivo de estacoes para nao permitir o uso deste recurso    ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If "EMULATOR" $ Upper(SLG->LG_IMPFISC)
			RecLock("SLG",.F.)
			SLG->LG_IMPFISC := Space( TamSx3("LG_IMPFISC")[1] )
			MsUnLock()
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³ Finaliza o sistema para que o Administrador faça a correcao          ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			MsgStop( STR0070 ) // "Foi detectado que o cadastro de estação não está configurado corretamente conforme o convênio ECF. Peça ao Administrador para configurar o ECF e então continuar operando o sistema."
			Final( STR0071 )  // "Falha no cadastro de estação"
		EndIf
	EndIf
EndIf

//-------------------------------------------
//|Estabelece comunicação com a impressora   |
//-------------------------------------------
If IsCaixaLoja( cNumCaixa )

	cPorta := LJGetStation("PORTIF")
	If lFtvdVer12 .OR. lImpTk .OR.  (lEmitNfce .And. !lIsPafNfce .And. lFiscal)
		If lLjxImpRed
			cPorta := LjxRetPort( .F. , .T. )[1]
		EndIf
	EndIf
	
	If lFtvdVer12
		If  lUsaTEF .AND. !("EMULATOR" $ Upper(Alltrim(cImpressora))) .AND. !Empty(cImpressora)
			nRet :=	INFAbrir(cImpressora, cPorta )
			
			If lLjxImpRed //Precisa fechar quando em rede - Verifique documentacao
				If nRet == -1
					LjxCtImpRD( .F. , .T. )
				Else
					LjxCtImpRD( .F. , .F. )
				EndIf
			EndIf
			
			If nRet <> 0
				lImpENF := .F.
				lFiscal := .F.
				MsgStop(	STR0148 +  cImpressora + STR0149 + CHR(10) + CHR(13) + ;	//"Houve falha de comunicação com a impressora configurada nessa estação: " ## " e a conexão será finalizada."
							STR0150 + CHR(13) + ; 										//"Motivo: O usuário atual possui permissão para utilizar TEF onde é obrigatório a impressão do comprovante na finalização da venda."
							STR0151 + CHR(13) + ;										//"Verifique no módulo SIGALOJA no menu Atualizações->Ponto de Venda as opções:"
							STR0152 + CHR(13) + ;										//" -> Estações(rotina LOJA121): Para verificar as configurações do modelo de impressora na guia 'Impressoras'."
							STR0153 ) 													//" -> Caixas(rotina LOJA120): Para verificar as permissões de TEF do caixa atual."
				Final("CONEXÃO ENCERRADA")
			Else
				lImpENF := .T.
			EndIf
		EndIf	
	Else
		If lFiscal .AND. nHdlECF == -1 .AND. ( !lEmitNfce .Or. lIsPafNfce )

			If lLjNfPafEcf .And. lIsPafNfce .And. (AllTrim(SM0->M0_ESTCOB) $ "RJ|SC|MS|TO|ES|PB")
				MsgAlert(STR0143)//#"Conforme Legislação, o Uso de PAF-ECF com NFCe não é permitido para esse estado"
				Final(STR0052)
			EndIf

			lImpFiscal := Iif(!Empty(cImpEst),Lj121IsFisc(cImpEst),.F.) // Verifica se está utilizando Impressora Fiscal (ECF)

			If nModulo == 12 .And. lImpFiscal
				cUrlDoc := "https://tdn.totvs.com/pages/releaseview.action?pageId=1002497472"

				cMsg := STR0185 + Chr(13)+Chr(10)+Chr(13)+Chr(10) //"Não é mais permitido o uso de Emissor de Cupom Fiscal (ECF)."

				cMsg += STR0186 + Chr(13)+Chr(10) //"Desta forma, passa a ser obrigatória a emissão de cupom fiscal somente através de"
				cMsg += STR0187 + Chr(13)+Chr(10)+Chr(13)+Chr(10) //"NFC-e (Nota Fiscal de Consumidor Eletrônica)."

				cMsg += STR0188 //"Veja mais detalhes clicando no botão [Mais info]"

				LjMsgInfo(300, 150, Nil, cMsg, .T., cUrlDoc, "AVISOECF")

				Final( STR0052 ) // Término Normal
			EndIf			

			//-------------------------------
			//| Abre comunicacao com o ECF  |
			//-------------------------------
			If lImpFiscal
				LjMsgRun( STR0098,, { || nHdlECF := IFAbrir( cImpressora,cPorta ) } )  //"Aguarde. Abrindo a Impressora Fiscal..."
				nRet := IfAbrECF( nHdlECF )
				lIsECF:= .T.
			EndIf	
		    If nRet <> 0 .OR. !lImpFiscal
		    	//Deve permitir abrir o sistema mesmo sem comunicação com o ECF - no PDV PAF/Emissao de Nota
		    	If lMvLjPdvPa .OR. lEmiteNF
		    		If lEmiteNf
		    			lFiscal := .F.
						If lImpFiscal					
		    				MsgAlert(STR0050 + "," + STR0136) //#"Falha na comunicação com o ECF" ##"será possível apenas a emissão de Notas Fiscais."
						EndIf	
		    		EndIf
		    	Else
		    		Final( STR0050 )								//"Falha na comunicação com o ECF"
		    	EndIf
			Else
				IFPegPDV(nHdlECF, @cNumPdv)

				//Na impressora Daruma eu tenho um retorno OK mesmo com a impressora desligada
				//e no PAF , preciso acessar protheus mesmo sem comunicação do ECF
				lEcfSemCom := lMvLjPdvPa .And. Empty(cNumPdv)

				If !lEcfSemCom .And. !STBHomolPaf()
					// Verifico se o número do PDV está correto entre a estação e o PDV
					If !lIsPafNfce .And. ! (AllTrim(cNumPdv) == AllTrim(LJGetStation("PDV")))
						MsgStop( STR0051 )							// "O Número de PDV do equipamento é diferente do cadastrado na estação."
						Final( STR0052 )							// Término Normal
					EndIf
				 EndIf
		    EndIf

		    If lFiscal
			    If Empty(LjGetStation("SERIE"))
			    	MsgStop( STR0053 + CHR(13) +  STR0156 )	// "O Número de Série desta estação está em branco." | "Verifique se o atalho está configurado de acordo com o campo LG_CODIGO"
			    	Final( STR0052 )	// Término Normal
			    EndIf

			    LjVldSerie()

				If lMvLjPdvPa
					
					LJValGT(.T.) //Valida GT

					/*Somente em homologação o CNPJ seja alterado automaticamente,
					pois o CNPJ do ECF é diferente do CNPJ que pode emitir NFC-e*/
					/*Desabilitar este comentário ao usar para Homologação PAF
					If lHomolPaf .And. GetPvProfString( "HOMOLOGACAO","ALESTAUT","0",GetClientDir()+"SIGALOJA.INI") == "1"
						RecLock("SM0",.F.)
						cAux := ""

						If lIsPafNfce
							cAux := "53113791000122" //CNPJ de teste da NFC-e
							REPLACE SM0->M0_ESTCOB WITH "AM"
						EndIf

						If !Empty(cAux)
							REPLACE SM0->M0_CGC WITH cAux
							Conout("Alterado SM0")
						EndIf
						SM0->(MsUnlock())
					EndIf*/
				EndIf

				LJXGrSerie(nHdlECF, cEstacao)
			EndIf
		ElseIf (lEmitNfce .And. !lIsPafNfce .And. lFiscal)
			
			//*** Abre comunicacao com Impressora nao Fiscal ****
			LjMsgRun( STR0116,, { || nHdlECF := INFAbrir( cImpressora,cPorta ) } )  //"Aguarde. Abrindo a Impressora Não Fiscal..."
			
			If lLjxImpRed //Precisa fechar quando em rede - Verifique documentacao
				If nHdlECF == -1
					LjxCtImpRD( .F. , .T. )
				Else
					LjxCtImpRD( .F. , .F. )
				EndIf
			EndIf

			//Consulta o Firmware da Impressora
			If nHdlEcf == 0
				If "DARUMA DR800" $ Upper(Alltrim(cImpressora))
					cVerFirm := LjVerFirm(nHdlECF, "1")
				EndIf
				lImpENF := .T.
			Else
				lImpENF := .F. //Seta como falso a comunicação com a Impressora Não Fiscal
			EndIf
			
			//Fecha a comunicação após utilizar para não travar a porta
			INFFechar()

		EndIf

		If lImpTk
			//*** Abre comunicacao com Impressora nao Fiscal ****
			LjMsgRun( STR0114,, { || nRet := INFAbrir(cImpressora,cPorta)  } )  //"Aguarde. Abrindo a Impressora..."
			
			If lLjxImpRed //Precisa fechar quando em rede - Verifique documentacao
				If nRet == -1
					LjxCtImpRD( .F. , .T. )
				Else
					LjxCtImpRD( .F. , .F. )
				EndIf
			EndIf
			
			If nRet <> 0
		    	lImpTk	:= .F.
				lImpENF := .F. //Seta como falso a comunicação com a Impressora Não Fiscal
		    	Final( STR0115 )								//"Falha na comunicação com a Impressora..."
			Else
				lImpENF := .T.
			EndIf
		EndIf
	EndIf

	LjGrvLog("[TPD] LjOpenDevices ", " Antes da inicialização do objeto oTEF - lUsaTEF ", lUsaTEF)

	If lUsaTEF
		If cTipTEF $ TEF_SEMCLIENT_DEDICADO+";"+TEF_COMCLIENT_DEDICADO+";"+TEF_DISCADO
			Private aTefDados := {}
			If cTipTEF == "2" .AND. nHdlPinPad == -1
				aPinPad:=LJGetStation({"PINPAD","PORTPAD"})
				nHdlPinPad:=PinPadAbr(aPinPad[1],aPinPad[2])
			EndIf
		ElseIf cTipTEF == TEF_CLISITEF
			If SL4->(ColumnPos("L4_FORMAID")) == 0
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//| "Para utilizar o TEF na modalidade CliSiTEF, é necessário configurar corretamente o " "Atenção" |
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				MsgStop(STR0069+"L4_FORMAID.", STR0010)
				lUsaTEF := .F.
			EndIf
			If !lUsaTEF .OR. ChkAutocom() == DLL_SIGALOJA	// Verifica o parametro MV_AUTOCOM
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//| "Para utilizar o TEF na modalidade CliSiTEF, é necessário configurar corretamente o " "Atenção"    |
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				MsgStop(STR0069+"MV_AUTOCOM.", STR0010)
				lUsaTEF := .F.
			ElseIf lFiscal .OR. (!lFiscal .AND. GetRemoteType() <> REMOTE_LINUX ) // Verifica se o usuario e' fiscal e se o ambiente e' LINUX
				oTEF 	:= LJTEFAbre()	    				//Prepara o objeto TEF e carrega as variáveis necessárias para a utilização do TEF
				lUsaTef := oTef:lAtivo						//Indica se a abertura de terminal foi processada com sucesso
			EndIf
		ElseIf cTipTEF $ "DEDICADO;DISCADO;LOTE"
			MsgStop(STR0054)								// Atualize os dados sobre TEF no cadastro de estações.
			lUsaTEF := .F.
		ElseIf !lFtvdVer12 .AND. cTipTEF == TEF_CENTROPAG .AND. lFiscal .AND. cPaisLoc == "MEX"
			oTEF 	:= LJACENTPAG():New()	    				//Prepara o objeto TEF e carrega as variáveis necessárias para a utilização do TEF
			lUsaTef := oTef:lAtivo						//Indica se a abertura de terminal foi processada com sucesso
		EndIf

		//--------------------
		// Instancia o TEF 2.0
		//--------------------
		LjGrvLog("[TPD] LjOpenDevices ", " Antes de iniciar o objeto oTEF20", )
		If ExistFunc("LjIniTEF20")
			LjIniTEF20(@oTEF20)
		EndIf
		LjGrvLog("[TPD] LjOpenDevices ", " Após iniciar o objeto oTEF20 - Type -> oTEF20", ValType(oTEF20) )

	EndIf

EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica se utiliza Impressora de cupom via serial         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If "COM" $ Upper(LjGetStation("PORTICP")) .AND. nHdlCupom == -1
	aImpCupom := LjGetStation({"IMPCUP","PORTICP"})
	nHdlCupom := ImpCupAbr(aImpCupom[1],aImpCupom[2])
	If nHdlCupom < 0
		lImpCup := .F.
	EndIf
EndIf

//³ Rotina que efetua a depuracao automatica das reservas ³
A430Auto()

//³ Verifica se existe log de Orcamento ³
If !lFtvdVer12 .AND. (!lEmitNfce .Or. lIsPafNfce)
	LjMsgRun(STR0056,,{|| ljRecuperacao() } )		// "Monitorando a Base de Dados"
ElseIf lFtvdVer12
	If !IsBlind()
		LjMsgRun(STR0056,,{|| ljRecuperacao() } )		// "Monitorando a Base de Dados"
	Else
		ConOut(STR0056)
		ljRecuperacao()		// "Monitorando a Base de Dados"
	EndIf
EndIf

/*Abre o arquivo SES para uso da rotina AtuSalDup.
Isso serah utilizado qdo a base for Btrieve. No meio de uma
transacao nao se pode abrir nem fechar arquivo com Btrieve */
ChkFile("SES",.F.)

//Verifica se usa SAT
If LjProfile(3) .And. LjUseSat()
	//Pega a chave de ativação do sat para o cliente que esta acessando o sistema
	If ExistFunc("LjGetSig") .AND. Empty(SuperGetMV("MV_SATTEST",,""))
		aRetChSat := LjGetSig()
		If Len(aRetChSat) > 0 .AND. !Empty(aRetChSat[2])
			MsgAlert(aRetChSat[2])
		Else
			cChaveSat := aRetChSat[1]
		EndIf
	EndIf
EndIf

If lFiscal
	If lIsECF .And. !lEcfSemCom
		If !IFVenda(@lRedZ)
	    	If lRedZ
	    		//#"Não foi realizado o Fechamento do ECF no dia anterior. Deseja realizá-lo agora?", "Atenção"
	    		If MsgYesNo(STR0125, STR0126) .And. LOJA160()
	    			If lMvLjPdvPa
		    			LJValGT(.T.) //Recria o arquivo SIGALOJA.VLD
		    		EndIf
	    		EndIf
	    	EndIf
	    EndIf

		If LjAnalisaLeg(3)[1]
			If ! VerifHora(@aDtHrECF)
				LjMsgLeg(LjAnalisaLeg(3))
				/* "Conforme previsto no Requisito XVII (Ato Cotepe/ICMS 9, de 13 de Março de 2013),
					para PAF-ECF admite-se somente uma tolerância em minutos entre a hora do Sistema e a hora do ECF,
					limitada a uma hora, desde que na mesma data." */
				MsgAlert(" Diferença de data/hora do ECF:" + CHR(10)+ CHR(13) +;
						"ECF -> Data/Hora : " + DTOC(aDtHrECF[1]) + "-" + aDtHrECF[2] + CHR(10) + CHR(13) +;
						"PC -> Data/Hora: " + DTOC(aDtHrECF[3]) + "-" + aDtHrECF[4] )

				If lMvLjPdvPa
					Final( STR0118 )
				Else
					Final( STR0059 )
				EndIf
			EndIf
	    EndIf
	EndIf

	//Homologacao 2017 - ER-PAF-ECF 02.05
	If lLjNfPafEcf .And. ExistFunc("STBIniPAF")
		STBIniPAF(.F., lEcfSemCom)
	EndIf
EndIf

Return .T.

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Programa  ³LjCloseDevi³Autor  ³ Vendas Clientes   ³ Data ³  10/03/00   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Desc.     ³Fecha o Agente e o Sigaloja                                 ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function LjCloseDevices()
Local lFtvdVer12	:= LjFTVD()
Local lEmitNfce		:= LjEmitNFCe()	//Sinaliza se utiliza NFC-e
Local lIsPafNfce	:= STBPafNfce()					//Usa NFC-e com PAF no ECF?

/*Inserido a selecao da tabela SLG, para evitar erro de se-
lecao selecao de tabela em branco quando for executar a
a funcao LOJXFUNA - ljgetStation                           */
If nModulo <> 55
	DbSelectArea("SLG")
EndIf

//Nao enviar comando para fechar porta em equipamento não fiscal
If lFiscal .AND. (!lEmitNfce .Or. lIsPafNfce)
	nRet := IFFechar( nHdlECF, LJGetStation("PORTIF") )
EndIf

If lImpTk .Or. ( lImpENF .And. ( lFtvdVer12 .OR. FWIsMDILikeADV() ) ) 
	nRet := INFFechar()
EndIf

If lUsaCH
	CHFechar( nHdlCH, LJGetStation("PORTCHQ") )
EndIf

If lUsaTEF
	If cPaisLoc == "MEX" .AND. oTef <> Nil .AND. oTef:oTotvsApi <> Nil
		oTef:CloseTef()
		oTef:oTotvsApi := Nil
		oTef := Nil
	Else
    	PinPadFin(nHdlPinPad,LJGetStation("PORTPAD") )
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Fecha arquivo de controle de numeracao TEF³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
    L010ClTermTef()
EndIf

If lUsaCmc7
    CMC7Fec(nHdlCMC7,Alltrim(LJGetStation("PORTMC7")) )
EndIf

If lUsaLeitor
    LeitorFec(nHdlLeitor,LJGetStation("PORTOPT"))
EndIf

If lUsaBalanca
    BalancaFec(nHdlBalanca,LJGetStation("PORTBAL"))
EndIf

If lGaveta
	If LJGetStation("PORTIF") <> LJGetStation("PORTGAV")
		GavetaFec(nHdlGaveta,LJGetStation("PORTGAV") )
	EndIf
EndIf

If lFtvdVer12
	If lImpCup
		If "COM" $ Upper(LjGetStation("PORTICP"))		// Se a impressora de cupom for serial
			ImpCupFec( nHdlCupom, LjGetStation("PORTICP") )
		EndIf
	EndIf
EndIf

If lUsaDisplay
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Exibir Mensagem de Finalizacao no Display ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	MsgDisplay(2)
    DisplayFec(StatDisplay(), AllTrim(LJGetStation("PORTDIS")) )
EndIf

If StatDispTor() <> -1
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Exibir Mensagem de Finalizacao no Display ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	MsgDispTor(2)
	DispTorFec(StatDispTor(), AllTrim(LJGetStation("PORTTOR")) )
EndIf

Return NIL

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Fun‡„o     ³CriaPadrao³ Autor ³ Vendas Clientes       ³ Data ³ 04/04/97 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao  ³ Cria alguns registros padrao                               ³±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±*/
Function CriaPadrao()

Local cNattef	:= ""                 // Variavel criada para auxiliar na verificacao do conteudo do parametro MV_NATTEF
Local cNatAux	:= ""
Local aAreaSLG	:= SLG->(GetArea())

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Cria Cliente Padrao. ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Getmv("MV_CLIPAD", .T.)
	SuperGetMV("MV_CLIPAD")
Else
	DbSelectArea( "SA1" )
	If !( DbSeek( xFilial("SA1")+If(Empty(SuperGetMV("MV_CLIPAD")),"000001",SuperGetMV("MV_CLIPAD") ) ) )
		CriaClipad()
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Cria Vendedor Padr„o. ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Getmv("MV_VENDPAD", .T.)
	SuperGetmv("MV_VENDPAD")
Else
	DbSelectArea( "SA3" )
	If !( DbSeek( xFilial("SA3")+if(empty(SuperGetmv("MV_VENDPAD")),"000001",SuperGetmv("MV_VENDPAD")) ) )
		CriaVenPad( )
	End
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Cria Condi‡„o de Pagamento Padr„o. ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Getmv("MV_CONDPAD", .T.)
	SuperGetmv("MV_CONDPAD")
Else
	DbSelectArea( "SE4" )
	If !( DbSeek( xFilial("SE4")+SuperGetmv("MV_CONDPAD") ) )
		CriaCondPad( )
	End
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Cria TES Padr„o - Entrada ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Getmv("MV_TESENT", .T.)
	SuperGetmv("MV_TESENT")
Else
	DbSelectArea( "SF4" )
	If !( DbSeek( xFilial("SF4")+SuperGetmv("MV_TESENT") ) )
		CriaTesEnt( )
	End
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Cria TES Padr„o - Saida ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Getmv("MV_TESSAI", .T.)
	SuperGetmv("MV_TESSAI")
Else
	DbSelectArea( "SF4" )
	If !( DbSeek( xFilial("SF4")+SuperGetmv("MV_TESSAI") ) )
		CriaTesSai( )
	End
End

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Cria TES Padr„o - Troca ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !Empty(SuperGetmv("MV_TESTROC"))
	DbSelectArea( "SF4" )
	If !( DbSeek( xFilial("SF4")+SuperGetmv("MV_TESTROC") ) )
		CriaTesTroca( )
	EndIf
Else
	Help( "", 1, "TESTROCA", ,STR0168, 1, 0 ) // "Necessário informar o TES de troca no parâmetro MV_TESTROC, sem esta informação não será possível realizar Troca/Devolução."
	LjGrvLog("TESTROCA","CriaPadrao - Necessário informar o TES de troca no parâmetro MV_TESTROC, sem esta informação não será possível realizar Troca/Devolução.",)
EndIf

/* Verifica se existem as naturezas utilizadas no Loja */
DbSelectArea("SED")
GravaSED( STR0043, STR0044 ) 								          // "TROCO",   "Entrada de troco no Caixa"
GravaSED( STR0045, STR0046 ) 								          // "SANGRIA", "Sangria do Caixa"

If ExistFunc("LjMExeParam")
	cNatAux	:= LjMExeParam("MV_NATDINH")
	GravaSED( cNatAux, cNatAux )  // Natureza DINHEIRO

	cNatAux := LjMExeParam("MV_NATCHEQ")
	GravaSED( cNatAux, cNatAux )  // Natureza CHEQUE

	cNatAux := LjMExeParam("MV_NATCART")
	GravaSED( cNatAux , cNatAux )  // Natureza CARTAO DE CREDITO

	cNattef := LjMExeParam("MV_NATTEF")
	GravaSED( cNattef,cNattef )                                           // Natureza CARTAO DE DEBITO AUTOMATICO

	cNatAux := LjMExeParam("MV_NATFIN")
	GravaSED( cNatAux,  cNatAux )   // Natureza FINANCIADO

	cNatAux := LjMExeParam("MV_NATVALE")
	GravaSED( cNatAux, cNatAux )  // Natureza VALES

	cNatAux := LjMExeParam("MV_NATCONV")
	GravaSED( cNatAux, cNatAux )  // Natureza CONVENIO

	cNatAux := LjMExeParam("MV_NATOUTR")
	GravaSED( cNatAux, cNatAux )  // Natureza OUTRAS

	cNatAux := LjMExeParam("MV_NATCRED")
	GravaSED( cNatAux, cNatAux )  // Natureza CREDITO				Utilizado no pagamento com NCC

	cNatAux := LjMExeParam("MV_NATNCC")
	GravaSED( cNatAux ,  cNatAux )	  // Natureza NOTA DE CREDITO		Utilizado na geracao da NCC

	cNatAux := LjMExeParam("MV_NATRECE")
	GravaSED( cNatAux, cNatAux )  // Natureza RECEBIMENTO

	cNatAux := LjMExeParam("MV_NATDEV")
	GravaSED( cNatAux,  cNatAux )   // Natureza DEV./TROCA

	If ExistFunc("LjUsePayHub") .And. LjUsePayHub()
		cNatAux := LjMExeParam("MV_NATPGDG")
		GravaSED( cNatAux,  "PAGAMENTO DIGITAL" )   // Natureza PAGDIGITAL (Pagamento Digital)

		cNatAux := LjMExeParam("MV_NATPGPX")
		GravaSED( cNatAux,  "PIX" )
	EndIf

Else
	/* Realiza a verificacao do conteudo do parametro MV_NATTEF */
	cNattef := SuperGetMV("MV_NATTEF")
	If SubStr(cNattef,1,1) == "&"
		cNattef:= SubStr(cNattef,2,Len(cNattef))
		cNattef:= &(cNattef)
	ElseIf SubStr(cNattef,1,1) == "'"
		cNattef:= &(SuperGetMV("MV_NATTEF"))
	Endif

	GravaSED( &(SuperGetmv("MV_NATDINH")), &(SuperGetmv("MV_NATDINH")) )  // Natureza DINHEIRO
	GravaSED( &(SuperGetmv("MV_NATCHEQ")), &(SuperGetmv("MV_NATCHEQ")) )  // Natureza CHEQUE
	GravaSED( &(SuperGetmv("MV_NATCART")), &(SuperGetmv("MV_NATCART")) )  // Natureza CARTAO DE CREDITO
	GravaSED( cNattef,cNattef )                                           // Natureza CARTAO DE DEBITO AUTOMATICO
	GravaSED( &(SuperGetmv("MV_NATFIN")),  &(SuperGetmv("MV_NATFIN")) )   // Natureza FINANCIADO
	GravaSED( &(SuperGetmv("MV_NATVALE")), &(SuperGetmv("MV_NATVALE")) )  // Natureza VALES
	GravaSED( &(SuperGetmv("MV_NATCONV")), &(SuperGetmv("MV_NATCONV")) )  // Natureza CONVENIO
	GravaSED( &(SuperGetmv("MV_NATOUTR")), &(SuperGetmv("MV_NATOUTR")) )  // Natureza OUTRAS
	GravaSED( &(SuperGetmv("MV_NATCRED")), &(SuperGetmv("MV_NATCRED")) )  // Natureza CREDITO				Utilizado no pagamento com NCC
	GravaSED( &(SuperGetmv("MV_NATNCC")),  &(SuperGetmv("MV_NATNCC")) )	  // Natureza NOTA DE CREDITO		Utilizado na geracao da NCC
	GravaSED( &(SuperGetmv("MV_NATRECE")), &(SuperGetmv("MV_NATRECE")) )  // Natureza RECEBIMENTO
	GravaSED( &(SuperGetmv("MV_NATDEV")),  &(SuperGetmv("MV_NATDEV")) )   // Natureza DEV./TROCA
EndIf

If cPaisLoc $ "POR|EUA"
	GravaSED( STR0047, STR0048 )						           	  // "LAY-AWAY" , "Movimento de Lay-Away"
EndIf

/* Cria a ESTACAO PADRAO, caso nao exista. */
DbSelectArea("SLG")
SLG->(DbSetOrder(1))
If !SLG->(DbSeek(xFilial()+"001"))
	RecLock( "SLG", .T. )
	SLG->LG_FILIAL  := xFilial()
	SLG->LG_CODIGO  := "001"
	SLG->LG_NOME	:= STR0018                // ESTACAO PADRAO
	SLG->LG_PAFMD5  := STxPafMd5("SLG")
	SLG->(MsUnLock())
EndIf

RestArea( aAreaSLG )

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Verifica se o Caixa Geral Existe ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
xCxLoja()

Return NIL

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Funcao    ³ GravaSED ³ Autor ³ Vendas Clientes       ³ Data ³ 26/08/03 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Realiza a gravacao das naturezas utilizadas no Loja        ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function GravaSED( cCodigo, cDescricao )

If !SED->(DbSeek(xFilial("SED") + AllTrim(cCodigo)))
	RecLock("SED",.T.)
	SED->ED_FILIAL := xFilial("SED")
	SED->ED_CODIGO := AllTrim(cCodigo)
	SED->ED_DESCRIC:= cDescricao
	SED->ED_CALCIRF:= "N"
	SED->ED_CALCISS:= "N"
	SED->ED_PERCIRF:= 0
	If Alltrim(cCodigo) $ "DEV./TROCA|NOTA DE CRE|TROCO"
		SED->ED_COND   := "D"
	Else
		SED->ED_COND   := "R"
	Endif
	SED->ED_CALCINS:= "N"
	SED->ED_CALCCSL:= "N"
	SED->ED_CALCCOF:= "N"
	SED->ED_CALCPIS:= "N"
	SED->ED_DEDPIS := "2"
	SED->ED_DEDCOF := "2"
	SED->ED_TIPO   := "2"
	SED->(MsUnLock())

Else

	RecLock("SED",.F.)
	If Empty(SED->ED_COND) .and. Alltrim(cCodigo) $ "DEV./TROCA|NOTA DE CRE|TROCO"
	 	SED->ED_COND   := "D"
	Elseif Empty(SED->ED_COND)
		SED->ED_COND   := "R"
	Endif
	
	If Empty(SED->ED_CALCINS)
	 	SED->ED_CALCINS:= "N"
	Endif

	If Empty(SED->ED_CALCCSL)
	 	SED->ED_CALCCSL:= "N"
	Endif
	
	If Empty(SED->ED_CALCCOF)
	 	SED->ED_CALCCOF:= "N" 	 	
	Endif
	
	If Empty(SED->ED_CALCPIS)
	 	SED->ED_CALCPIS:= "N"
	Endif
	
	If Empty(SED->ED_DEDPIS)
	 	SED->ED_DEDPIS := "2"
	Endif
	
	If Empty(SED->ED_DEDCOF)
	 	SED->ED_DEDCOF := "2" 	
	Endif
	
	If Empty(SED->ED_TIPO)
	 	SED->ED_TIPO   := "2"
	Endif
	SED->(MsUnLock())
	
EndIf

Return NIL

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Funcao	 ³StartLoja	³ Autor ³ Vendas Clientes       ³ Data ³ 21/09/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Inicializa as funcoes padroes do Loja                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ Esta funcao eh chamada diretamente da LIB e eh utilizada   ³±±
±±³          ³ somente com a interface MDI                                ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function StartLoja
Local lPOS		:= STFIsPOS() // Valida se é POS
Local lIsMDI 	:= Iif(ExistFunc("LjIsMDI"),LjIsMDI(),SetMDIChild(0)) //Verifica se acessou via SIGAMDI

If !lPos
	If lIsMDI .Or. Type("lStartLoja") == "U" 
		OpenLoja()
	EndIf
EndIf
Return NIL

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Funcao	 ³ LOJLoad  ³ Autor ³ Vendas Clientes       ³ Data ³ 21/09/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Inicializa as funcoes padroes do Loja                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ Esta funcao eh chamada diretamente da LIB e eh utilizada   ³±±
±±³          ³ somente com a interface SDI                                ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function LOJLoad
Local lIsMDI 	:= Iif(ExistFunc("LjIsMDI"),LjIsMDI(),SetMDIChild(0)) //Verifica se acessou via SIGAMDI
Local lPafNFCe	:= IIf(ExistFunc("LjPafNFCe"),LjPafNFCe(),.F.)			//Usa PAF-NFC-e c/ Impressora Não Fiscal

// Verifica se as DLLs são compativeis com a versão atual do ERP
LjChecaDLLs()

//Verifica o compartilhamento das tabelas
LjMsgRun( STR0167,, {|| LjComparti()} ) //"Verificando o compartilhamento de tabelas."

If (HasTemplate("DRO") .Or. (ExistFunc("LjIsDro") .And. LjIsDro())) .And. ExistBlock("LjDrCriaX1")
	U_LjDrCriaX1()
EndIf

If (LjNfPafEcf(SM0->M0_CGC) .Or. lPafNFCe) .AND. LjxBGetPaf()[2] //Indica se é pdv
	If __lIsPaf .Or. lDebug .Or. lPafNFCe
		//Gera Arquivo PAFLISTA e atualiza aMd5Paf
		STxArqIdPaf()

		If !lIsMDI
			OpenLoja()
		EndIf
	ElseIf	GetRPORelease() >= "12.1.2410"
		MsgAlert("", STR0010 + CRLF + CRLF +STR0173+ CRLF + CRLF +STR0174) // "Atençäo" ## " O sistema está configurado com o modelo Emissor de Cupom Fiscal (PAF-ECF), a partir do release 12.1.2410, é necessário migrar para o modelo de emissão de Nota Fiscal de Consumidor Eletrônica (PAF-NFC-e)." ## "Favor providenciar esta migração para uso do sistema!"
		Final(STR0023) // Acesso negado !!
	Else 	
	    Final( STR0123 + SM0->M0_ESTCOB + STR0124, STR0096 ) //"UF (M0_ESTCOB): " ## " obriga o uso do PAF-ECF ou PAF-NFC-e." ### "Para acessar o PDV SIGALOJA Off-line, é necessário utilizar o executável Homologado para o PAF."
	EndIf
Else
	If !lIsMDI
		OpenLoja()
	EndIf
EndIf

If cPaisLoc $ "COL"
	CIIUCOL()
EndIf

Return NIL

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Funcao	 ³ PHOLoad  ³ Autor ³ Cesar Eduardo Valadao ³ Data ³ 21/09/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Inicializa as funcoes padroes do Loja                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ Esta funcao eh chamada diretamente da LIB e eh utilizada   ³±±
±±³          ³ somente com a interface SDI                                ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function PHOLoad
Local lIsMDI := Iif(ExistFunc("LjIsMDI"),LjIsMDI(),SetMDIChild(0)) //Verifica se acessou via SIGAMDI

If !lIsMDI
	OpenLoja()
EndIf
Return NIL

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Funcao	 ³ FRTLoad  ³ Autor ³ Vendas Clientes       ³ Data ³ 14/08/07 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Inicializa as funcoes padroes do Loja (BOPS 00000130145)   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³ Esta funcao eh chamada diretamente da LIB e eh utilizada   ³±±
±±³          ³ somente com a interface SDI                                ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function FRTLoad
Local lPOS			:= STFIsPOS() // Valida se é POS
Local lUserCaixa 	:= STFVldUser() // Valida se o usuário é Caixa
Local lIsMDI 		:= Iif(ExistFunc("LjIsMDI"),LjIsMDI(),SetMDIChild(0)) //Verifica se acessou via SIGAMDI
Local cImpEst		:= LjGetStation("LG_IMPFISC")			// Estação que está sendo utilizada
Local cUrlDoc       := ""
Local cMsg          := ""

LjAltPermi(44)

If (HasTemplate("DRO") .Or. (ExistFunc("LjIsDro") .And. LjIsDro())) .And. ExistBlock("LjDrCriaX1")
	U_LjDrCriaX1()
EndIf

If ExistFunc("FWPosLight") .And. FWPosLight() .And. ExistFunc("STFPdvOn") .And. STFPdvOn(cEstacao) 
	MsgAlert(STR0169 + cEstacao + STR0171, STR0126)// "Estação: "#" configurada para utilizar TOTVS PDV Online, o acesso é disponivel somente para SIGAFRT (Modulo 23) concectado no Banco de Dados." # "Atenção"
	Final(STR0071)// "Falha no cadastro de estação"
EndIf

//-------------------------------------
//| Verificação do ECF não permitido  |
//-------------------------------------
If lUserCaixa 
	If Lj121IsFisc(cImpEst)
		If nModulo == 23
			cUrlDoc := "https://tdn.totvs.com/pages/releaseview.action?pageId=1002497472"

			cMsg := STR0185 + Chr(13)+Chr(10)+Chr(13)+Chr(10) //"Não é mais permitido o uso de Emissor de Cupom Fiscal (ECF)."

			cMsg += STR0186 + Chr(13)+Chr(10) //"Desta forma, passa a ser obrigatória a emissão de cupom fiscal somente através de"
			cMsg += STR0187 + Chr(13)+Chr(10)+Chr(13)+Chr(10) //"NFC-e (Nota Fiscal de Consumidor Eletrônica)."

			cMsg += STR0188 //"Veja mais detalhes clicando no botão [Mais info]"

			LjMsgInfo(300, 150, Nil, cMsg, .T., cUrlDoc, "AVISOECF")

			Final( STR0052 ) // Término Normal
		EndIf	
	Elseif LjUseSat()
		LJSATMFE()
	EndiF
EndIf

If lPos .AND. !__lIsPaf
	Return .T.
EndIf

/*Release 11.5 - SmartClient HTML
Acesso negado para o modulo SIGAFRT  */
If LjChkHtml ()
	Final(STR0111)//"Modulo indisponível utilizando o remote HTML!"
EndIf

// Verifica se as DLLs são compativeis com a versão atual do ERP
LjChecaDLLs()

If LjNfPafEcf(SM0->M0_CGC) .AND. ( lPOS .OR. lUserCaixa )
	If __lIsPaf .Or. lDebug
		//Gera Arquivo PAFLISTA e atualiza aMd5Paf
		STxArqIdPaf()

		If lPOS
			Return .T.
		EndIf

		If !lIsMDI
			OpenLoja()
		EndIf
	Else
	    Final(STR0093 , STR0123 +SM0->M0_ESTCOB + STR0124 ) //"Para ter acesso ao SIGAFRT, é necessario utilizar o executável Homologado para o PAF-ECF." ##"UF (M0_ESTCOB): " ## " obriga o uso do PAF-ECF ou PAF-NFC-e."
	EndIf
Else
	If !lIsMDI
		OpenLoja()
	EndIf
EndIf

Return NIL

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Funcao	  ³ OpenLoja ³ Autor ³ Vendas Clientes       ³ Data ³ 21/09/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao  ³ Inicializa as funcoes padroes do Loja                      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso		  ³ Loja      												   ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function OpenLoja(lAuto)
Local cLock			:= cUserName+cEstacao
Local cNumCaixa 	:= ""									// Recebe de xNumCaixa o codigo do caixa
Local lHtml			:= ExistFunc("ISHTML") .And. IsHTML() 	// verifica se e remote html
Local lFtvdVer12	:= LjFTVD() 	// Verifica se é Release 11.7 e o FunName é FATA701 - Compatibilização Venda Direta x Venda Assisitida
Local nIntOtimTb	:= 0									// Intervalo de dias entre cada execucao da otimizacao de tabela.(continua)
 															//  Valor do parametro MV_LJDIAOT que sera retornado da retaguarda
Local lPOS			:= STFIsPOS() 							// Valida se é POS
Local lEmitNfce		:= LjEmitNFCe()							//Sinaliza se utiliza NFC-e
Local lEmitSAT		:= LjUseSat()							//Sinaliza se utiliza SAT
Local lIntegDef		:= Lj140GtInD()                                 	// Verifica se Integracao Mensagem Unica esta habilitada
Local cCompName		:= GetComputerName()								// Nome da maquina na rede
Local lCompName		:= SLG->(ColumnPos("LG_NOMCOMP")) > 0				// Nome de rede do computador que será feito o acesso a estação
Local lIsMDI 		:= Iif(ExistFunc("LjIsMDI"),LjIsMDI(),SetMDIChild(0)) //Verifica se acessou via SIGAMDI
Local lMvFisNota	:= SuperGetMv("MV_FISNOTA",, .F.)						//Imprime Nota Fiscal		
Local lMvLjLbNt		:= SuperGetMv("MV_LJLBNT",,0) > 0						//Liberação de Geração de Nota.(0- Verificação Padrão, 1- Emissão de Nota para Pessoa Jurídica, 2 - Emissão de Nota para Pessoa Física e Jurídica) .	
Local lAdmin		:= (__cUserID == "000000")								//User Admin
Local lPafNFCe		:= IIf(ExistFunc("LjPafNFCe"),LjPafNFCe(),.F.)			//Usa PAF-NFC-e c/ Impressora Não Fiscal
Local aDadosMHW		:= {}
Local lAtualMHW 	:= .F.													// Determina se deve ou não atualizar os dados da tabela MHW
Local lUserCaixa 	:= STFVldUser() 										// Valida se o usuário é Caixa
Default lAuto 		:= .F.

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³					ATENCAO !!!                                   ³
//³Qualquer nova variavel PUBLIC precisa ser criada tambem no     ³
//³CALL CENTER e outros modulos que usam o TEF da Software Express³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Public lTTEFAberto

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Variavel utilizada para a nova DLL Fiscal ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Public oAutocom

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Parametro MV_AUTOCOM deverá ficar fixo com valor 1, para utilizar as dlls AUTOCOM e SIGALOJA ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
PUTMV( "MV_AUTOCOM", 1 )

If lPos
	Return .T.
ElseIf !ExistFunc('LOJA070') .AND. nModulo <> 23
	//O cadastro de Adm Financeiro (LOJA070) não existe no RPO do TOTVS PDV, neste caso não existindo esse cadastro eu entendo que é RPO Reduzido.
	//Então se é RPO reduzido e o usuario estiver acessando um modulo diferente do 23, mostro a mensagem que esta abaixo.
	MsgAlert(STR0155) //'Não é permitido acessar um modulo diferente do SigaFrt (Modulo 23) porque você está utilizando um RPO reduzido que é especifico para ambiente TOTVS PDV!'
	LjGrvLog("",STR0155) //'Não é permitido acessar um modulo diferente do SigaFrt (Modulo 23) porque você está utilizando um RPO reduzido que é especifico para ambiente TOTVS PDV!'
	Final()
EndIf

//SigaPaf nao trabalha com Sat e NFC-e
If nModulo == 12 .AND. (__lIsPaf .OR. lDebug ) .AND. ( (lEmitNfce .And. !lPafNFCe) .OR. lEmitSAT )
	MsgAlert( 	STR0132 + CHR(10) + ; //"Foi identificada tentativa de acesso para NFC-e ou SAT através do executável do PAF-ECF"
				STR0133 )//"Para acessar utilize o smartclient.exe"
	Final()
EndIf


If lUserCaixa
	LJSATMFE()
EndIf

If !IsBlind() .AND. nModulo == 12 .AND. !LjxBGetPaf()[2]
	//Verifica se a tabela estática do financeiro está vazia, caso afirmativo, avisa ao usuário
	If !LjValIFin()
		Final()
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Se nao logar como admin, verifica se existe carga do server, para ser baixada    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If (RetCodUsr() <> "000000") .AND.  SuperGetMV("MV_LJILOLE",,"0") == "1" .And. ExistFunc("LOJA1157EXPRESS")
	LOJA1157Express()
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Funcao que cria o objeto oAutocom         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lIntegDef //Integracao nao carrega dll autocom
	If !lHtml .AND. !lAuto//se for remote html ou rotina automatica, nao carrega dll autocom 
		CriaAutocom()
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Estanciamento para o novo objeto de TEF³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Public oTEF

If !lFtvdVer12
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Controle para executar a StartLoja somente uma unica vez. ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Public lStartLoja
	If ValType(lStartLoja) == "L"
		Return(NIL)
	EndIf

	lStartLoja := .T.

ElseIf lFtvdVer12

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Controle para executar a FTVDStartLoja e lFTStartSilenc somente uma unica vez. ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	Public lFTStartSilenc
	Public lFTVDStartLoja

	If ValType(lFTVDStartLoja) == "L"
		Return(NIL)
	EndIf

	If lAuto
		If ValType(lFTStartSilenc) == "L"
			Return(NIL)
		EndIf
	EndIf

	If lAuto
		lFTStartSilenc   := .T.
	Else
		lFTVDStartLoja   := .T.
	EndIf

EndIf

If lAdmin
	cStrAcesso:="SNN"
    LjAtvStat()
Else
	cNumCaixa := xNumCaixa()
	If SX5->(DbSeek(xFilial("SX5")+'23'+ cNumCaixa ) )
		DbSelectArea("SLF")
		DbSetOrder(1)
		DbSeek(xFilial("SLF")+SA6->A6_COD)
		cStrAcesso:=LF_ACESSO
		If !Empty(cEstacao)
			DbSelectArea("SLG")
			If !DbSeek(xFilial("SLG")+cEstacao)
				Help(" ",1,"NOESTACAO")
			Else
				If ExistFunc("STFPdvOn") .And. STFPdvOn(cEstacao) .And. nModulo == 12
					MsgAlert(STR0169 + cEstacao + STR0170, STR0126) // "Estação: " ## " configurada para utilizar TOTVS PDV Online, o acesso é disponivel somente para SIGAFRT (Modulo 23)." ## "Atenção"
					Final(STR0071) // "Falha no cadastro de estação"
				Else	
					cTipTEF:= LjGetStation("TIPTEF")
				EndIf	
			EndIf
		EndIf
	Else
		cStrAcesso := Repl("N", TamSx3("LF_ACESSO")[1])
	EndIf
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//|  Cria Motivo padrao do SIGALOJA   |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
LjCriaMot()

If Type("lAutoExec") == "U"
	lAutoExec := lAuto
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Release 11.5 - SmartClient HTML					³
//³Acesso negado para integracao com SIGACRD ativa  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If CrdxInt() .AND. LjChkHtml()
	Final(STR0112) //"Módulo indisponível para integração com o SIGACRD."
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Nao executa as funcoes CriaPadrao e LJOpenDevices no Front Loja. ³
//³ A abertura de equipamentos eh feita pelo FRTA010A.               ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nModulo <> 23 .AND. !lAutoExec
	CriaPadrao()

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica se existe orcamento vencido com reserva ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !lFtvdVer12
		LjMsgRun(STR0073,,{|| LjOrcRes() } )		//"Verificando orçamentos em aberto vencidos com reserva. Aguarde...
	ElseIf lFtvdVer12
		If !IsBlind()
			LjMsgRun(STR0073,,{|| LjOrcRes() } )		//"Verificando orçamentos em aberto vencidos com reserva. Aguarde...
		Else
			ConOut(STR0073)  //"Verificando orçamentos em aberto vencidos com reserva. Aguarde...
			LjOrcRes()
		EndIf
	EndIf

	If !lFtvdVer12
		If lIsMDI .OR. (lEmitNFCe .AND. !lEmitSAT)

			/*
			Se for NFC-e e houver uma tentativa de uma mesma ESTACAO abrir mais de uma conexao,
			o sistema nao vai permitir, pois podem haver problemas na recuperacao da venda (L1_SITUA igual T2 ou T3)
			*/
			If lEmitNFCe .AND. LjProfile(3) .OR.;
						 (!lAdmin .AND. !lIsMDI .AND. !lFiscal .AND. !LjProfile(3) .AND.;
						 	 								lMvFisNota .AND. lMvLjLbNt)

				/*==================================================================================
				// Valida o nome se o nome da maquina esta vinculado no cadastro de estação
				// Cada estação só pode ser acessada da maquina cadastrada no campo  SLG LG_NOMCOMP
				===================================================================================*/
				If GetRemoteType() == REMOTE_LINUX .and. lCompName
					If len(cCompName) > TamSX3("LG_NOMCOMP")[1]
						MsgStop(STR0189+ cCompName +STR0190 + Replicate(CRLF,2) +;									//"Essa conexão foi encerrada, pois o nome desta estação: "  " é incompatível com a configuração atual do campo LG_NOMCOMP."
						STR0191 + alltrim(STR( TamSX3("LG_NOMCOMP")[1] )) + " "+ STR0192 + Replicate(CRLF,2) + ;	//"Não é permitido acessar o sistema com um nome de estação com tamanho maior que"  "caracteres em ambientes ainda não atualizados."
						STR0193 + Replicate(CRLF,2) + ;																//Para realizar o acesso desta máquina, é necessário aplicar o pacote de atualização de dicionário para expandir o tamanho do campo LG_NOMCOMP
						STR0194)																					//"Ação Necessária: Por favor, solicite ao administrador do sistema para baixar a atualização de dicionário mais recente no Portal do Cliente e aplicá-la ao ambiente."						
						Final(STR0195) 																				//CONEXÃO ENCERRADA
					Endif
				EndIf

				If lCompName .AND. !Empty(SLG->LG_NOMCOMP)

					If AllTrim( SLG->LG_NOMCOMP ) <> AllTrim( cCompName )
						
						MsgStop(STR0162 + cEstacao + Replicate(CRLF,2) +;	//"Essa conexão foi encerrada, pois esta estação não pode ser acessada por este dispositivo (LG_NOMCOMP): "
						STR0159 + Replicate(CRLF,2) + ;						//"Não é permitido acessar o sistema com o mesmo Código de Estação por mais de um dispositivo."
						STR0160 + CRLF + ;									//"Para realizar o acesso de outro computador é necessário que a configuração de NFC-e não esteja ativa na estação atual," 
						STR0161 + Replicate(CRLF,2) + ;						//"ou alterar o campo LG_NOMCOMP do cadastro de estação. "
						STR0147)											//"Verifique: Atualizações->Ponto de Venda->Estações(rotina LOJA121): Para verificar as configurações de NFC-e na guia 'Nfc-e'."						

						Final(STR0195) 										//CONEXÃO ENCERRADA
					
					EndIf

				ElseIf lCompName .AND. Empty(SLG->LG_NOMCOMP)

						Reclock( "SLG", .F. )			
						SLG->LG_NOMCOMP := cCompName
						SLG->( MsUnLock () )					
					
				EndIf

				LjOpenDevices()

			ElseIf Alltrim(FunName()) $ _LJLOCKBYNAME
				If LockByName( cLock )
					LjOpenDevices()
				Else
					HELP(" ",1,"LJLCKBNAME")
				EndIf
			EndIf
		Else
			LjOpenDevices()
		EndIf

		If lFiscal .AND. __lPyme
			If GetRemoteType() <> REMOTE_QT
				Final(STR0089)		//"Protheus 10 Express não está homologado para este Sistema Operacional"
			EndIf
		EndIf

	ElseIf lFtvdVer12

		If !lHtml //se for remote html, nao carrega dll de perifericos de automacao
			If lIsMDI
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³ Faz o controle via LockByName para evitar que um usuário acesse       ³
				//³ 2 vezes uma rotina que use os periféricos de automação, evitando assim³
				//³ a concorrência dos mesmos.                                            ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If Alltrim(FunName()) $ _LJLOCKBYNAME
					If LockByName( cLock )
						LjOpenDevices()
					Else
						HELP(" ",1,"LJLCKBNAME")
					EndIf
				EndIf
			Else
				LjOpenDevices()
			EndIf

			If lFiscal .AND. __lPyme
				If GetRemoteType() <> REMOTE_QT
					Final(STR0089)	//"Protheus 10 Express não está homologado para este Sistema Operacional"
				EndIf
			EndIf

		EndIf
	EndIf

EndIf

// Tratamento para popular a nova tabela MHW / Retaguarda e PDV
If AliasInDic("MHW")
	DbSelectArea("MHW")
	MHW->(DbGoTop())
	lAtualMHW := Empty(LjExistMHW( { {"MHW_FILIAL",xFilial("MHW")}, {"MHW_TIPO","PG"}, {"MHW_CDNFCE","20"} } ))
	
	If !lAtualMHW .And. ExistFunc("LjIT240002") .And. LjIT240002() //Tratamento temporario até liberação oficial SEFAZ
		lAtualMHW := Empty(LjExistMHW( { {"MHW_FILIAL",xFilial("MHW")}, {"MHW_TIPO","PG"}, {"MHW_CDNFCE","91"} } ))	
	EndIf
	If MHW->(EoF()) .Or. lAtualMHW
		CriaPgSEFAZ(@aDadosMHW)
		CriaCBSEFAZ(@aDadosMHW)
		LJIncMHW(aDadosMHW)
	EndIf
EndIf

If !lFtvdVer12
	If LjGetProfile("MULTIMI") == "S"
		LJ060Vis(.T.)
	EndIf
ElseIf lFtvdVer12
	If !(lAuto)
		If LjGetProfile("MULTIMI") == "S"
			LJ060Vis(.T.)
		EndIf
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Rotina de Otimizacao de Tabela                       ³
//³Somente executamos a rotina de otimizacao de tabela, |
//| quando o modulo for SIGAFRT ou o SIGALOJA OFFLINE.	³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nModulo == 23 .OR. __lIsPaf

	/*
	//verifica se a otimizacao de tabela ja foi realizada no dia
	If FindFunction("LjCnsRetHj") .AND. !LjCnsRetHj()

		aRet := FR271CMyCall("SuperGetMV", Nil, "MV_LJDIAOT", , 0)
		If ValType( aRet[1] ) == "N"
			nIntOtimTB := aRet[1]
		Else
			conout( STR0117 )	//"Retorno invalido ou ocorreu um erro ao conectar no servidor RPC"
		EndIf

		//se o intervalo de dias for = 0, o administrador desativou a otimizacao de tabela
		If nIntOtimTB > 0
			LjLimpaTb( nIntOtimTb )
		EndIf
	EndIf
	*/
EndIf

If ExistFunc("Lj8AIncXxy")
	Lj8AIncXxy()
EndIf

// Grava no sigaloja.ini o numero de decimais utilizados
// nos ecfs para os calculos de rateio de desconto e base de
// de imposto
If !lAutoExec .AND. !lIntegDef .AND. ExistFunc("lj7DecECF")
	lj7DecECF("1")  // 1 = Grava INI ; 2 = Busca informacao do Ini
EndIf

//Alimenta a tabela EL0
If ExistFunc("Lj8AliqServ")
	Lj8AliqServ()
EndIf

//Essa função deve ser removida quando mudar a release do protheus
If ExistFunc("LjxAAjSX")
	LjxAAjSX()
EndIf

//Cria objeto RAAS Integration
If ExistFunc("LjxRaasInt") .And. LjxRaasInt()
    LjxRaasNew(cEstacao)
EndIf

//Altera o valor do campo LG_USABIOM
If Existfunc("LJAtuUsaBiom")
	LJAtuUsaBiom()
Endif 

Return

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºPrograma  ³VerifHora ºAutor  ³ Vendas Clientes    º Data ³  02/17/03   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Verifica se a hora do Computador difere em mais de 15       º±±
±±º          ³minutos da hora do Ecf                                      º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function VerifHora(aDtHrECF)
Local cHoraPC
Local cHoraECF		:= Space(8)
Local nHoraPC
Local nHoraECF
Local cData			:= Space(8)
Local dData
Local lRet  	// retorno da função
Local nX        // auxiliar
Local lMvLjPdvPa := LjxBGetPaf()[2] //Indica se é PDV
Local nMinMax	 := iIf(lMvLjPdvPa, 60, 15) //Diferença máxima de minutos entre o sistema e a ECF conforme ATO COTEPE/ICMS 9, DE 13 DE MARÇO DE 2013

Default aDtHrECF := {}

IfStatus(nHdlEcf,'2',@cData)
dData := GetRmtDate()

IfStatus(nHdlEcf,'1',@cHoraECF)
cHoraPC := GetRmtTime()

nX :=  ( CToD(cData) - dData ) * 24 * 60
nHoraPC  := ( Val(SubStr(cHoraPC, 1, 2))*60) + Val( SubStr(cHoraPC, 4, 2) )
nHoraECF := ( Val(SubStr(cHoraECF, 1, 2))*60) + Val( SubStr(cHoraECF, 4, 2) )

//Diferença máxima de minutos entre o sistema e a ECF conforme ATO COTEPE/ICMS 9, DE 13 DE MARÇO DE 2013
If lMvLjPdvPa
	lRet := (cToD(cData) - dData) == 0 .And. ABS(nHoraECF - nHoraPC) <= nMinMax
Else
	lRet := ABS(nX + nHoraECF - nHoraPC) <= nMinMax
EndIf

aDtHrECF := {}
Aadd(aDtHrECF,Ctod(cData))
Aadd(aDtHrECF,cHoraECF)
Aadd(aDtHrECF,dData)
Aadd(aDtHrECF,cHoraPC)

Return lRet

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Funcao	 ³FinishLoja³ Autor ³ Vendas Clientes       ³ Data ³ 10/02/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Executada quando seleciona botao Log off e Botao Finalizar ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³FinishLoja(lPar1)											  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³lPar1 determina qual o botao sendo:                         ³±±
±±³          ³      .F. - Botao Log Off                                   ³±±
±±³          ³      .T. - Botao Finalizar                                 ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function FinishLoja(lSaida)
Local cLock 		:= cUserName+cEstacao
Local lPOS			:= STFIsPOS()  // Valida se é POS
Local lIsMDI 		:= Iif(ExistFunc("LjIsMDI"),LjIsMDI(),SetMDIChild(0)) //Verifica se acessou via SIGAMDI

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Variavel criada na funcao StartLoja() e devera ser inicia-³
//³ lizada sempre que finalizar o usuario.                    ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lPos
	If Type("lStartLoja") == "L" .OR. Type("lFTVDStartLoja") == "L"

		If Type("lStartLoja") == "L"
			lStartLoja := NIL
		ElseIf Type("lFTVDStartLoja") == "L"
			lFTVDStartLoja := NIL
		Endif
		
		If nModulo <> 23
			LjCloseDevices()
		EndIf            
	EndIf
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Faz o controle via LockByName para evitar que um usuário acesse       ³
	//³ 2 vezes uma rotina que use os periféricos de automação, evitando assim³
	//³ a concorrência dos mesmos.                                            ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If lIsMDI .AND. Alltrim(FunName()) $ _LJLOCKBYNAME
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Destrava o controle do LockByName                                     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		UnLockByName( cLock )
	EndIf
EndIf

Return Nil
/*/
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Fun‡„o	  ³AnalisaMov³ Autor ³ Vendas Clientes       ³ Data ³ 05/08/03 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descricao ³Analisa se o Caixa possui movimentacoes antes de exclui-lo  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Sintaxe   ³AnalisaMov(ExpC1) = Caixa                                   ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
/*/
Function AnalisaMov(cCaixa)
Local lRet     := .T.									//Retorno da funcao
Local lAcessoExc := .T.									//Verifica se eh acesso exclusivo
Local cNomeCx		:= cCaixa								//Armazena Nome do Caixa

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| PE retorna se o usuário pode efetuar exclusão no cadastro de senhas  |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ExistBlock('LJExcSnh')
	lRet := ExecBlock('LJExcSnh',.F.,.F.,{cUserName})
	lAcessoExc := lRet
EndIf

DbSelectArea( "SX5" )
DbSeek(cFilial+"23")
While !Eof() .AND. X5_TABELA == "23"
	If Trim(X5_DESCRI) == Trim(Upper(cCaixa))
		cCaixa=Upper(Alltrim(X5_CHAVE))
		Exit
	EndIF
	dbSkip()
End
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Leitura do SE5 para considerar: Sangria, Troco e Movimenta-³
//³ ‡”es banc rias.                                            ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DbSelectArea( "SA6" )
DbSetOrder( 1 )
DbSeek(cFilial+cCaixa)
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Antes de deletar eu vou verificar se existe movimentacao     ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DbSelectArea("SE5")  && Movimentacao bancaria
DbSetOrder( 3 )
DbSeek(xFilial("SE5")+cCaixa+SA6->A6_AGENCIA+SA6->A6_NUMCON)
While !Eof() .AND. ;
	E5_FILIAL == xFilial() .AND. ;
	E5_BANCO ==  cCaixa .AND.lRet
	If E5_SITUACA == "C" .OR. E5_MOEDA == "ES"
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//| Estorno ou cancelado    |
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		dbSkip()
		Loop
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//| Verifica se tem cancelamento para este titulo. |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If TemBxCanc(E5_PREFIXO+E5_NUMERO+E5_PARCELA+E5_TIPO+E5_CLIFOR+E5_LOJA+E5_SEQ)
		dbSkip()
		Loop
	EndIf

	If E5_TIPO $ MV_CRNEG .OR. SE5->E5_VENCTO > SE5->E5_DATA
		dbSkip()
		Loop
	EndIf
	If E5_TIPODOC == "LJ"		// Vendas a Vista, est  contido em L1_DINHEIRO
		dbSkip()
		Loop
	EndIf
	If E5_TIPODOC $ "DC/JR/MT/CM/D2/J2/M2/C2/V2/CP/TL"  //Valores de Baixas
		dbSkip()
		Loop
	EndIf
    lRet:= .F.
End
DbSelectArea("SL2")
DbSetOrder(1)
DbSelectArea("SL1")
DbSetOrder(5)
DbSeek( xFilial() + cCaixa )
While !Eof() .AND. ;
		L1_FILIAL == cFilial .AND. ;
		L1_OPERADO == cCaixa .AND.lRet
	If Empty(SL1->L1_DOC)
		dbSkip()
		Loop
	EndIf
	DbSelectArea( "SL2" ) ; DbSeek( xFilial("SL2") + SL1->L1_NUM )
	DbSelectArea( "SF4" ) ; DbSeek( xFilial("SF4") + SL2->L2_TES )
	DbSelectArea( "SL1" )
	If SF4->F4_DUPLIC <> "S"
		dbSkip()
		Loop
	EndIf
    lRet:= .F.
End

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Os clientes que estao com branco na 3a posicao devem continuar considerando as NCCs     |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If ! Substr(GetNewPar("MV_USACRED","SSS"),3,1) == "N" .AND. lRet
	DbSelectArea("SE1")
	DbSetOrder(1)
	DbSeek(xFilial() + cCaixa )
	While !Eof() .AND. E1_FILIAL == xFilial().AND.lRet
		If SE1->E1_PORTADOR == cCaixa .AND. SE1->E1_SALDO > 0 .AND. E1_TIPO == MV_CRNEG
	    	lRet:= .F.
        EndIf
        dbSkip()
	End
EndIF
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//| Le o SD1 para determinar as devolu‡”es  |
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DbSelectArea("SD1")
DbSetOrder(1)
DbSeek(xFilial("SD1"))
While !Eof( ) .AND. D1_FILIAL == xFilial("SD1") .AND. lRet
	If SD1->D1_TIPO == "D" .AND. SD1->D1_ORIGLAN == "LO"
		If Subs(SD1->D1_NUMCQ,1,3) == cCaixa
			lRet:= .F.
		EndIf
	EndIf
    dbSkip()
End

LjxbSetCx (cNomeCx, lRet) // Adiciona variavel Statica com caixas consultados sobre movimentacao

Return lRet

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Funcao    ³LjxbSetCx  ³ Autor ³ Vendas Clientes       ³ Data ³ 17/05/12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descricao ³Adiciona variável statica para consultas ja realizadas de   	³±±
±±³           |movimentacao de caixas										³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros ³cParm1 := Nome do Caixa(Usuario)                             ³±±
±±³           ³lParm2 := Tem Movimentacao (AnalisaMov)	                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso       ³ SIGALOJA				                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function LjxbSetCx (cCaixa, lAnalismov)

AADD(aCxMov, {Trim(UPPER(cCaixa)), lAnalismov})

Return

/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Funcao    ³LjxGetCx   ³ Autor ³ Vendas Clientes       ³ Data ³ 17/05/12 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descricao ³Retorna variável statica para consultas ja realizadas de  	³±±
±±³           |movimentacao de caixas										³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros ³cParm1 := Nome do Caixa(Usuario)                             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso       ³ SIGALOJA				                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function LjxbGetCx (cCaixa)

Local lRet := .T.		// DEFAULT .T. para indicar que nao tem movimentacao do caixa
Local nPos := aScan(aCxMov, {|x,b| x[1] == Trim(UPPER(cCaixa))}) // Posicao do nome do caixa

If nPos > 0
	lRet := aCxMov[nPos][2]
EndIf

Return lRet
/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Funcao    ³StatDisplay³ Autor ³ Vendas Clientes       ³ Data ³ 01/04/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descricao ³Utilizada para controle de handle do Display - foi criada no ³±±
±±³           ³lugar de criar uma variável PRIVATE nHdlDisplay              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe    ³StatDisplay(nValor)                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros ³nValor   Devera ser informado quando o valor do handle for   ³±±
±±³           ³          alterado, caso contrario, será retornado o valor   ³±±
±±³           ³          atual                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso       ³ SIGALOJA  / FRONT LOJA                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function StatDisplay( nValor )

If nValor <> Nil
	nHdlDisplay := nValor
EndIf

Return nHdlDisplay
/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Funcao    ³StatBalanca³ Autor ³ Vendas Clientes       ³ Data ³ 04/10/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descricao ³Utilizada para controle de handle da Balanca - foi criada no ³±±
±±³           ³lugar de criar uma variável PRIVATE nHdlBalanca              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe    ³StatBalanca(nValor)                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros ³nValor   Devera ser informado quando o valor do handle for   ³±±
±±³           ³          alterado, caso contrario, será retornado o valor   ³±±
±±³           ³          atual                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso       ³ SIGALOJA  / FRONT LOJA                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function StatBalanca( nValor )
Local aRet := {}

If nValor <> Nil
	nHdlBalanca := nValor
	lUsaBalanca := ( nHdlBalanca <> -1 )
EndIf

AAdd( aRet, lUsaBalanca )
AAdd( aRet, nHdlBalanca )

Return aRet
/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Funcao    ³TEF_aTrans ³ Autora³ Vendas Clientes       ³ Data ³ 27/05/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descricao ³Utilizada para o controle de transações de desfazimento no   ³±±
±±³           ³TEF, para não termos que ficar declarando var. private       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe    ³StatDisplay(nValor)                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros ³cParm1 := Tipo da transacao                                  ³±±
±±³           ³cParm2 := 9 primeiros dígitos do cartão	                    ³±±
±±³           ³cParm3 := Rede de destino                                    ³±±
±±³           ³nParm4 := OFFSET da transação                                ³±±
±±³           ³nParm5 := NID da transacao                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso       ³ SIGALOJA  / FRONT LOJA                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function TEF_aTrans( cParm1, cParm2, cParm3, nParm4,;
					nParm5 )
If PCount() > 0
	aTransAtu[1] := cParm1
	aTransAtu[2] := cParm2
	aTransAtu[3] := cParm3
	aTransAtu[4] := nParm4
	aTransAtu[5] := nParm5
EndIf

Return(aTransAtu)
/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Funcao    ³TEF_lEnvDF ³ Autora³ Vendas Clientes       ³ Data ³ 27/05/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descricao ³Utilizada para o controle de transações de desfazimento no   ³±±
±±³           ³TEF, para não termos que ficar declarando var. private       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe    ³StatDisplay(nValor)                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros ³lParm1 := Valor Lógico                                       ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso       ³ SIGALOJA  / FRONT LOJA                                      ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function TEF_lEnvDF( lValor )

If PCount() > 0
	lEnvDesf := lValor
EndIf

Return(lEnvDesf)
/*
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Funcao    ³Lj010Brow  ³ Autor ³ Vendas Clientes       ³ Data ³ 29/04/04     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descricao ³Consulta a Posicao de Clientes                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Retorno   ³Nenhum                                                           ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros ³ ExpC1 : Alias                                                   ³±±
±±³           ³ ExpN2 : Recno                                                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso       ³ SIGALOJA  - Venda Balcao                                        ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
*/
Function Lj010Brow( cAlias,	nRecno, aGet )

Local aParam  := {}     										//Array com as perguntas no SX1
Local aSavRot := {}											//Array com as informacoes para salvar
Local nX      := 0												//Controle de Loop

PRIVATE Inclui := .F.										//Se inclui
PRIVATE Altera := .F.     									//Se altera
PRIVATE nCasas := SuperGetmv("MV_CENT")							//Retorna o parametro MV_CENT

Private aSelFil	:= {} // Variavel requerida pela rotina Fc010Brow
Private aTmpFil	:= {} // Variavel requerida pela rotina Fc010Brow


If Pergunte("FIC010",.T.)
	aadd(aParam,MV_PAR01)
	aadd(aParam,MV_PAR02)
	aadd(aParam,MV_PAR03)
	aadd(aParam,MV_PAR04)
	aadd(aParam,MV_PAR05)
	aadd(aParam,MV_PAR06)
	aadd(aParam,MV_PAR07)
	aadd(aParam,MV_PAR08)
	aadd(aParam,MV_PAR09)
	aadd(aParam,MV_PAR10)
	aadd(aParam,MV_PAR11)
	aadd(aParam,MV_PAR12)
	aadd(aParam,MV_PAR13)
	aadd(aParam,MV_PAR14)
	aadd(aParam,MV_PAR15)
	aSavRot := aClone(aRotina)
	aRotina := {}
	For nX := 1 To Len(aSavRot)
		AAdd(aRotina,{"","",0,2})
	Next nX
	Fc010Brow(1,@cAlias,aParam,.T.,aGet)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³	Ao sair da rotina do Financ. fecha o Alias e exclui o arq. temporario gerado  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If !Empty(cAlias[2,1])
		(cAlias[2,1])->(dbCloseArea())
		Ferase(cAlias[2,2]+GetDBExtension())
		Ferase(cAlias[2,2]+OrdBagExt())
	EndIf
	aRotina := aClone(aSavRot)
EndIf

Return(Nil)


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Funcao    ³LjFilVal   ³ Autor ³ Vendas Clientes       ³ Data ³ 23/06/04 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descricao ³Funcao que traz todas as filiais de uma empresa              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Parametros³Empresa                                                      ³±±
±±³           ³Alias (Tabela)                                               ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Retorno   ³ExpA1 : Filiais                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso       ³Generico                                                     ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LjFilVal( cEmp, cAlias )
Local aArea    := GetArea()
Local aAreaSM0 := SM0->( GetArea() )
Local aRet     := {}
Local cFilAux  := ""

Default cEmp 		:= cEmpAnt
Default cAlias 	:= ""

DbSelectArea( "SM0" )
DbSetOrder( 1 )
DbSeek( cEmp )

While !Eof() .AND. M0_CODIGO == cEmp
	If !Empty(cAlias)
		cFilAux := FWxFilial(cAlias,FWGETCODFILIAL)
	Else
		cFilAux := FWGETCODFILIAL
	EndIf
	If aScan(aRet, cFilAux) == 0
		AAdd( aRet, cFilAux )
	EndIf
	dbSkip()
End

RestArea( aAreaSM0 )
RestArea( aArea )

Return aRet
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Função    ³ LJPCCIni    ³ Autor ³ Vendas Clientes ³ Data ³ 16/08/2004 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descrição ³ Inicializa o array aPISCofCSL para abatimento do PIS,     |±±
±±³           ³ Cofins e CSLL.                                            |±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LJPCCIni( cCliente, cLoja, dData )

Local aAreaSE1 := SE1->(GetArea())              // Area corrente do arquivo SE1
Local aArea    := GetArea()                     // Area corrente
Local lSE1     := .T.							// Retorno do SE1

If Type("aPISCofCSL") == "A"
	If (AllTrim(cCliente+cLoja) <> Alltrim(SuperGetMV("MV_CLIPAD") + SuperGetMV("MV_LOJAPAD"))) .AND. cPaisLoc == "BRA" .AND. ;
		LJVerCli(cCliente, cLoja) .And. dDataBase < dDtLeiPCC

		If Len(aPISCofCSL) > 0
			If aPISCofCSL[01,01] == cCliente .AND. aPISCofCSL[01,02] == cLoja
				lSE1 := .F.
			EndIf
		EndIf

		If lSE1

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//| Posiciona o SE1 para utilização da função MaNFsCalRT   |
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			SE1->(DbSetOrder(2))

			If SuperGetmv("MV_LJMOD3")
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Valida se esta utlizando venda assistida ou venda balcao³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				If Type("M->L1_CLIENTE") <> "U"
					SE1->(DbSeek( xFilial("SE1") + M->L1_CLIENTE + M->L1_LOJA ))
				Else
					SE1->(DbSeek( xFilial("SE1") + M->LQ_CLIENTE + M->LQ_LOJA ))
				EndIf
			Else
				SE1->(DbSeek( xFilial("SE1") + cCliente + cLoja ))
			EndIf

			aPISCofCSL := {}
			aAdd(aPISCofCSL, { cCliente, cLoja })

			If SE1->(FieldPos("E1_SABTPIS")) > 0 .AND. SE1->(FieldPos("E1_SABTCOF")) > 0 .AND. SE1->(FieldPos("E1_SABTCSL")) > 0
				aAdd(aPISCofCSL, MaNFsCalRT(dData))
			Else
				aAdd(aPISCofCSL, { 0, 0, 0, 0, {} })
			EndIf

			aAdd(aPISCofCSL, { 0, 0, 0, 0 })
			aAdd(aPISCofCSL, { 0, 0, 0, 0 })

		EndIf

	Else
		aPISCofCSL := {}
		aAdd(aPISCofCSL, { cCliente, cLoja })
		aAdd(aPISCofCSL, { 0, 0, 0, 0, {} })
		aAdd(aPISCofCSL, { 0, 0, 0, 0 })
		aAdd(aPISCofCSL, { 0, 0, 0, 0 })
		aPccCumul := {}
	EndIf

EndIf

SE1->(RestArea(aAreaSE1))
RestArea(aArea)

Return Nil

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Função    ³ LJPCCAlt    ³ Autor ³ Vendas Clientes ³ Data ³ 16/08/2004 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descrição ³ Altera os valores dos impostos e do total de títulos ou   |±±
±±³           ³ da venda atual.                                           |±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function LJPCCAlt( cTipo, aValores )

Local nPorc := 0
Local aPCC := {}	//Array que recebe as informações cumulativas do PCC

If Type("aPISCofCSL") == "A"
	If Len(aPisCofCSL) < 4 .OR. AllTrim(aPisCofCSL[01,01]) == SuperGetMV("MV_CLIPAD")
		Return Nil
	EndIf

	If Type("lRecebe") == "L" .And. !lRecebe
		aPcc := SumDay("R", xFilial("SE1") ,SA1->A1_COD, SA1->A1_LOJA, SA1->A1_TIPO, dDataBase , cFilant  )

		If Len(aPcc) >= 7 .And. Len(aValores) >= 4
			If ValType(aValores[2]) == "N"
				aValores[2] += aPcc[1] 
				aValores[3] += aPcc[2]
				aValores[4] += aPcc[3]
			EndIf
			//Caso o cliente já tenha atingido o valor minimo no cumulativo, qualquer valor de PCC sera retido.
			If (aPcc[5] + aPcc[6] + aPcc[7]) > SuperGetMv("MV_VL13137", .T., 10) 
				aPccCumul := {}
				AADD(aPccCumul, aPcc[5] + aPcc[6] + aPcc[7] ) 
				AADD(aPccCumul,M->LQ_NUM)
				AADD(aPccCumul, SA1->A1_COD )
				AADD(aPccCumul,SA1->A1_LOJA)			
			EndIf 
		EndIf 
	Endif 	

	Do Case
		Case AllTrim(Upper(cTipo)) == "SE"
			aEval(aValores, { |x, y| aPISCofCSL[02,y] := iIf( x == Nil, aPISCofCSL[02,y], x ) })

		Case AllTrim(Upper(cTipo)) == "SL"
			aEval(aValores, { |x, y| aPISCofCSL[03,y] := iIf( x == Nil, aPISCofCSL[03,y], x ) })

	EndCase

	aPISCofCSL[04,02] := ( aPISCofCSL[02,02] + aPISCofCSL[03,02] )
	aPISCofCSL[04,03] := ( aPISCofCSL[02,03] + aPISCofCSL[03,03] )
	aPISCofCSL[04,04] := ( aPISCofCSL[02,04] + aPISCofCSL[03,04] )
	aPISCofCSL[04,01] := ( aPISCofCSL[04,02] + aPISCofCSL[04,03] + aPISCofCSL[04,04] )

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//| Se os abatimentos dos impostos (PIS/COFINS/CSLL) for maior que a venda atual, adequa o valor    |
	//| de abatimento para dar no máximo o valor da venda.                                              |
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If aPISCofCSL[04,01] > aPISCofCSL[03,01]

		nPorc := ( ( aPISCofCSL[03,01] / aPISCofCSL[04,01] ) * 100 )

		aPISCofCSL[04,02] := Round(( ( aPISCofCSL[04,02] * nPorc ) / 100 ), 2)
		aPISCofCSL[04,03] := Round(( ( aPISCofCSL[04,03] * nPorc ) / 100 ), 2)
		aPISCofCSL[04,01] := ( aPISCofCSL[04,02] + aPISCofCSL[04,03] )
		aPISCofCSL[04,04] := ( aPISCofCSL[03,01] - aPISCofCSL[04,01] )
		aPISCofCSL[04,01] += aPISCofCSL[04,04]

	EndIf

EndIf
Return Nil

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Função    ³ LJPCCRet    ³ Autor ³ Vendas Clientes ³ Data ³ 16/08/2004 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descrição ³ Retorna o valor do imposto desejado para o abatimento.    |±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function LJPCCRet( nRet )

Local nRetVal := 0
Local lRetemPCC:= .F.
Local lRetCfg := .F.
Local lCfgTrib := If(FindFunction("LjCfgTrib"), LjCfgTrib(), .F.) //Verifica se Configurador de Tributos esta habilitado
Local nVlPccCul := 0        // Recebe o valor do PCC cumulativo que deve ser ser somado ao valor do Pcc para ver se é maior que o minimo.   

DEFAULT nRet := 0

//Configurado de Tributos IDs Retencao: PIS = 000045, COFINS = 000043 e CSLL = 000026
If lCfgTrib
	If nRet == 0
		lRetCfg := LjCfgTaxById("000045|000043|000026",, @nRetVal)
	ElseIf nRet == 1
		lRetCfg := LjCfgTaxById("000045",, @nRetVal)
	ElseIf nRet == 2
		lRetCfg := LjCfgTaxById("000043",, @nRetVal)
	ElseIf nRet == 3
		lRetCfg := LjCfgTaxById("000026",, @nRetVal)
	EndIf		
EndIf

//Se nao encontrou os impostos no Configurador de Tributos, mantem legado TES
If !lRetCfg
	If Type("aPISCofCSL") == "A"
		If Len(aPisCofCSL) < 4 .OR. AllTrim(aPisCofCSL[01,01]) == SuperGetMV("MV_CLIPAD")
			Return nRetVal
		EndIf

		If Len(aPISCofCSL) > 0 .AND. ( aPISCofCSL[03,02] + aPISCofCSL[03,03] + aPISCofCSL[03,04] ) > 0

			If dDataBase >= dDtLeiPCC
				// Se for o mesmo orçamento com o mesmo cliente verifico a cumulatividade do PCC.	
				If Len(aPccCumul) > 0 .And. Type("M->LQ_NUM") == "C" .AND. M->LQ_NUM == aPccCumul[2] .And. Type("lRecebe") == "L" .And. !lRecebe .AND. ; 
				SA1->A1_COD+SA1->A1_LOJA == aPccCumul[3]+aPccCumul[4]
					nVlPccCul := aPccCumul[1]
				EndIf 
					//Verifica se a soma dos impostos (Pis/Cofins/CSLL) ultrapassa o minimo configurado no parametro MV_VL13137
					/* Lj7RetPCC() 
						Verifica se Cliente NÃO está configurado como "P-EMPRESA PÚBLICA";
						Verifica se Natureza não está configurada para retenção PCC(PIS/COFINS/CSLL);
					*/	 
				If (aPISCofCSL[04,01] + nVlPccCul > SuperGetMv("MV_VL13137", .T., 10) .AND. If(nRet == 0, Lj7RetPCC(), .T.) )
						lRetemPCC := .T.
				EndIf			
			Else
				If ( aPISCofCSL[02,01] + aPISCofCSL[03,01] ) > GetNewPar("MV_VL10925", 5000) .AND. If(nRet == 0, Lj7RetPCC(), .T.)
					lRetemPCC := .T.
				EndIf
			EndIf

			If lRetemPCC

				Do Case
					Case nRet == 0   //-- Retorna a soma de todos os impostos.
						nRetVal := aPISCofCSL[04,01]

					Case nRet == 1   //-- Retorna o valor do PIS.
						nRetVal := aPISCofCSL[04,02]

					Case nRet == 2   //-- Retorna o valor do Cofins.
						nRetVal := aPISCofCSL[04,03]

					Case nRet == 3   //-- Retorna o valor do CSLL.
						nRetVal := aPISCofCSL[04,04]

				EndCase				

			EndIf

		EndIf
	EndIf
EndIf

Return nRetVal

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Fun‡„o	 ³LJXFTermTef³ Autora³ Vendas Clientes       ³ Data ³14/10/2004³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Criar o controle para impedir a repetição do nº de terminal ³±±
±±³          ³ o arquivo fica bloqueado ento estiver no sistema            ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³ LOJA010T                                                    ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function LJXFTermTef()
Local cTerm 	:= StrZero( LjGetStation("TERMTEF"), 3 )
Local lRet		:= .T.
Local cMsg		:= ""
Local nHandle	:= 0
Local nFError	:= 0

If Val(cTerm) > 0 .AND. Val(cTerm) < 900
	MakeDir("\SEMAFORO\TERMTEF\")
	nHandTerm := MSFCreate("\SEMAFORO\TERMTEF\"+"TERMINAL."+cTerm)
	nFError := FError()
	If nHandTerm < 0
		cMsg := "Verifique se existem duplicidades nos números de terminais TEF cadastrados nas estações."+Chr(13)+Chr(10)+;
				"Este número deve ser único para cada estação mesmo quando utilizado em diferentes empresas."+Chr(13)+Chr(10)+;
				"Já existe um terminal "+cTerm+" ativo, impossivel iniciar as operações TEF."
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Se existir o arquivo \SEMAFORO\TERMTEF\TERMINAL.LOG,           ³
		//³sera exibida a advertencia, logado e continuara a abertura TEF ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If !File("\SEMAFORO\TERMTEF\TERMINAL.LOG")
			lRet := .F.
		EndIf
	EndIf
Else
	cMsg := "O número de terminal TEF deve estar no intervalo de 1 a 899, corrija-o no cadastro de estação."+Chr(13)+Chr(10)+;
	        "Impossível iniciar as operaçoes TEF."
	lRet := .F.
EndIf
If !Empty(cMsg)
	MsgStop(cMsg)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se existir o arquivo \SEMAFORO\TERMTEF\TERMINAL.LOG,    	       ³
	//³sera exibida a advertencia, logado e continuara a abertura TEF ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If File("\SEMAFORO\TERMTEF\TERMINAL.LOG")
		nHandle := FOpen("\SEMAFORO\TERMTEF\TERMINAL.LOG", 2)
		FSeek (nHandle, 0, 2)											// Posiciona no final do arquivo
		cMsg := Repl("*",40)+Chr(13)+Chr(10)+cMsg+Chr(13)+Chr(10)
		cMsg += "Terminal : "+cTerm+Chr(13)+Chr(10)
		cMsg += "FError   : "+AllTrim(Str(nFError))+Chr(13)+Chr(10)
		cMsg += "Data/Hora: "+DToC(dDataBase)+" - "+Time()+Chr(13)+Chr(10)
		FWrite(nHandle, cMsg, Len(cMsg))
		FClose(nHandle)
	EndIf
EndIf
Return lRet

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Fun‡„o	 ³L010ClTermTef³ Autora³ Vendas Clientes       ³ Data ³30/05/2005³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Fecha o arquivo de controle de  repetição do nº de terminal   ³±±
±±³          ³ caso utilize TEF                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³ LOJA010T                                                      ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function L010ClTermTef()
FClose(nHandTerm)
Return

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Fun‡„o    ³LjOrcRes  ³ Autor ³ Vendas Clientes       ³ Data ³ 13/10/05 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Verifica se existe orcamento em aberto vencido com reserva ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function LjOrcRes(aReservas as array)
Local cQuery		:= ""				// Variavel a ser utilizada na query
Local aReserva 		:= {}              //  Array utilizado em LJ7CANRES()
Local aRet      	:= {}              //  Array de retorno das mensagens de erro em cancelamento de reserva
Local nX        	:= 0
Local cAlias		:= Alias()			// Guarda a area atual para restaurar apos a Query
Local lECommerce	:= SuperGetMV("MV_LJECOMM",,.F.)
Local cNumOrc		:= ""
Local lOrcSL1		:= .F.				// Indica se encontrou o orçamento na SL1
Local nPosicao 		:= 0
Local aArrayOrcs	:= {}				// Array que irá guardar o número dos orçamentos para exclusão das Solitações de Compras
Local lOrcEAI       := .F.
Local nDiasReser	:= SuperGetMV("MV_LJEXCRE",,0) //Parametro que sera utilizado na query para cancelamento das reservas
Local nTamL1NUM 	:= TamSX3("L1_NUM")[1]

Default aReservas := {}

LjGrvLog( NIL, "Inicio da execucao da funcao " + ProcName(0))

If (HasTemplate("DRO") .Or. (ExistFunc("LjIsDro") .And. LjIsDro())) .And. ExistBlock("LjLogDro")
	ExecBlock("LjLogDro",.F.,.F.) // limpara os Logs da Anvisa, caso o orçamento em aberto esteja vencido
EndIf

#IFDEF TOP
	//Pesquisa as reservas que estão relacionadas com a SL1 e SL2
	LjGrvLog( NIL, "Inicio - Pesquisa pelas reservas na tabela SC0 que estão relacionadas com a SL1 e SL2")
	cQuery := "SELECT DISTINCT "
	cQuery += "SL1.R_E_C_N_O_	L1REC, "
	cQuery += "SL2.R_E_C_N_O_	L2REC, "
	cQuery += "L2_ITEM		   	L2ITE, "
	cQuery += "L2_RESERVA   	L2RES, "
	cQuery += "L2_LOJARES   	L2LRE, "
	cQuery += "L2_PRODUTO    	L2PRO, "
	cQuery += "L2_LOCAL      	L2LOC "

	cQuery += "FROM "+RetSQLName("SL1")+" SL1, "
	cQuery += RetSQLName("SL2")+" SL2, "
	cQuery += RetSQLName("SC0")+" SC0 "

	cQuery += "WHERE "
	cQuery += "SL1.L1_FILIAL = '"+ xFilial( "SL1" ) +"' "
	cQuery += "AND SL1.L1_FILIAL = SL2.L2_FILIAL "
	cQuery += "AND SL2.L2_FILRES = SC0.C0_FILIAL "
	cQuery += "AND SL1.L1_NUM = SL2.L2_NUM "
	cQuery += "AND SL1.L1_RESERVA = 'S' "
	cQuery += "AND SL1.L1_TIPO <> 'P' "
	cQuery += "AND SL2.L2_RESERVA <> '' "
	cQuery += "AND SL2.L2_RESERVA = SC0.C0_NUM "		

	If Len(aReservas) > 0		
		cQuery += "AND SC0.C0_NUM IN ("
		For nX := 1 To Len(aReservas)			
			cQuery += "'"+aReservas[nX]+"'"
			cQuery += If(nX < Len(aReservas), ",", ") ")			
		Next nX		
	Else
		If ValType(nDiasReser) == "N" .AND. nDiasReser > 0
			cQuery += "AND SC0.C0_VALIDA BETWEEN '" + dToS( sToD( FwTimeUF()[1] ) - nDiasReser ) + "' AND '" + dToS( sToD( FwTimeUF()[1] ) - 1 ) + "'"
		Else
			cQuery += "AND SC0.C0_VALIDA < '" + FwTimeUF()[1] + "' "
		EndIf
	EndIf

	If lECommerce
		cQuery += " AND SL1.L1_ECFLAG <> '1' "
	EndIf
	cQuery += "AND SL1.D_E_L_E_T_ = ' ' "
	cQuery += "AND SL2.D_E_L_E_T_ = ' ' "
	cQuery += "AND SC0.D_E_L_E_T_ = ' ' "

	cQuery := ChangeQuery(cQuery)
	LjGrvLog( NIL, "Query que executou para o cancelamento das reservas", cQuery )
	dbUseArea(.T.,"TOPCONN", TCGENQRY(,,cQuery),"TRBRES", .F., .T.)

	LjGrvLog( NIL, "Encontrou dados na Query (Reservas na tabela SC0 que estão relacionadas com a SL1 e SL2)?", !TRBRES->(EOF()) )

	While ! TRBRES->(EOF())

		SL1->( DbGoto( TRBRES->L1REC ) )

		LjGrvLog( SL1->L1_NUM, "Cancelando Reserva do orçamento: " + SL1->L1_NUM )

		BEGIN TRANSACTION
		
			Reclock( "SL1", .F. )
			SL1->L1_RESERVA	:= ""
			SL1->( MsUnLock () )

			aReserva := { {TRBRES->L2RES ,TRBRES->L2LRE , TRBRES->L2PRO , TRBRES->L2LOC , , TRBRES->L2ITE } }
			
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Chama funcao para cancelamento de reservas³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			aRet := Lj7CancRes( aReserva , .T.)

			LjGrvLog( SL1->L1_NUM, "Retorno da função de Cancelamento de Reserva", aRet )

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Elimina na SL2 reserva cancelada  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			If !Empty(aRet)
				SL2->(DbSetOrder(5)) //FILIAL+RESERVA+LOJA RESERVA+PRODUTO+ITEM
				For nX :=1 to len(aRet)
					If aRet[nX][2] // Indica que conseguiu cancelar a reserva
						If SL2->(DbSeek(xFilial("SL2")+ aRet[nX][1] + aRet[nX][3] + aRet[nX][4] + aRet[nX][5]))
							LjGrvLog( SL2->L2_NUM, "Limpa dados da reserva na tabela SL2. Recno: ", SL2->(Recno()) )
							Reclock( "SL2", .F.)
							SL2->L2_RESERVA	:= ""
							SL2->L2_LOJARES	:= ""
							SL2->L2_NLOTE	:= ""
							SL2->L2_LOTECTL	:= ""
							SL2->L2_LOCALIZ	:= ""
							SL2->L2_NSERIE	:= ""
							SL2->( MsUnLock() )
							MsUnLock()
						Endif

						// Verifica se já foi incluído número de orçamento+loja que foi gerada a reserva no array aArrayOrcs
						// Esta verificação tem como objetivo chamar a função Lj7DelSC1 somente uma vez.
						If aScan(aArrayOrcs,{ |x| x == SL2->L2_NUM+aRet[nX][3] }) == 0
							AAdd(aArrayOrcs, SL2->L2_NUM+aRet[nX][3])
							
							LjGrvLog( SL2->L2_NUM, "Chamada da função para exclusão da Solicitação de Compras, caso exista.")
							// Chamada da função para exclusão da Solicitação de Compras
							Lj7DelSC1(SL2->L2_NUM, aRet[nX][3])	
						EndIf					

					Endif
				Next nX
			Endif

		END TRANSACTION

		TRBRES->(DBSkip())

	Enddo

	TRBRES->(dbCloseArea())
	DbSelectArea(cAlias)

	LjGrvLog( NIL, "Fim - Pesquisa pelas reservas na tabela SC0 que estão relacionadas com a SL1 e SL2")

	/*
		Valida as reservas pendentes na SC0
		
		- Aqui cancelo as SC0 e SB2, caso tenha ocorrido queda do sistema no momento
		de geração do orçamento, onde pode ter gerado a reserva corretamente, mas não tem SL1/SL2 correspondente
	*/
	LjGrvLog( NIL, "Inicio - Pesquisa pelas reservas na tabela SC0 que não tem registro relacionado na SL1/SL2")
	cQuery := "SELECT C0_NUM, C0_PRODUTO, C0_LOCAL, C0_FILIAL, C0_OBS"
	cQuery += " FROM " + RetSQLName("SC0") + " SC0"
	cQuery += " WHERE"	
	cQuery += " SC0.C0_FILRES = '"+ xFilial("SL1") +"'"
	If Len(aReservas) > 0		
		cQuery += " AND SC0.C0_NUM IN ("
		For nX := 1 To Len(aReservas)			
			cQuery += "'"+aReservas[nX]+"'"
			cQuery += If(nX < Len(aReservas), ",", ")")			
		Next nX	
	Else
		cQuery += " AND SC0.C0_EMISSAO >= '" + dToS( sToD( FwTimeUF()[1] ) - 30 ) + "'" //Considera apenas reservas geradas nos ultimos 30 dias, devido a performance
	EndIf
	cQuery += " AND SC0.C0_TIPO = 'LJ'"
	cQuery += " AND SC0.C0_OBS <> ''"
	cQuery += " AND SC0.D_E_L_E_T_ = ' '"	
	cQuery += " AND "
	cQuery += " NOT EXISTS ("
	cQuery += " SELECT L2_RESERVA"
	cQuery += " FROM " + RetSQLName("SL2") + " SL2"
	cQuery += " WHERE SL2.L2_FILIAL = '"+ xFilial("SL2") +"'"
	cQuery += " AND SL2.L2_FILRES = SC0.C0_FILIAL"
	cQuery += " AND SL2.L2_RESERVA = SC0.C0_NUM"
	cQuery += " AND SL2.D_E_L_E_T_ = ' ' )"

	cQuery := ChangeQuery(cQuery)
	dbUseArea(.T.,"TOPCONN", TCGENQRY(,,cQuery),"TRBSC0", .F., .T.)

	aReserva := {}
	
	LjGrvLog( NIL, "Encontrou dados na Query (SC0 sem vínculo com SL1/SL2)?", !TRBSC0->(EOF()) )

	While ! TRBSC0->(EOF())
		
		If ("PEDIDO" $ Upper(TRBSC0->C0_OBS))
			nPosicao := 7
		Else
			nPosicao := At(":", TRBSC0->C0_OBS)
		EndIf

		If nPosicao > 0
			nPosicao := nPosicao + 1
			cNumOrc  := SubStr(TRBSC0->C0_OBS,nPosicao,nTamL1NUM)
		Else
			cNumOrc  := ""
		EndIf
        
        If ("EAI" $ UPPER(TRBSC0->C0_OBS))
            nPosicao := RAt("-", TRBSC0->C0_OBS)
            cNUmOrc := Alltrim(SubStr(TRBSC0->C0_OBS,nPosicao + 1 ,len(TRBSC0->C0_OBS)))
            lOrcEAI := .T.
        EndIF

		LjGrvLog( cNumOrc, "Informações do Registro - Tabela SC0 (C0_FILIAL, C0_NUM, C0_PRODUTO, C0_OBS)", {TRBSC0->C0_FILIAL, TRBSC0->C0_NUM, TRBSC0->C0_PRODUTO, TRBSC0->C0_OBS} )

		If !Empty(cNumOrc)

			cNumOrc := PadR(cNumOrc,nTamL1NUM)

			SL1->( DbSetOrder( 1 ) ) //L1_FILIAL + L1_NUM

			// Busca Orçamentos vinculados a reserva, mesmo que forem de outras filiais
			lOrcSL1	:= SL1->( DbSeek( xFilial( "SL1" ) + cNumOrc ))

			LjGrvLog( cNumOrc, "Achou SL1 relacionado com a Reserva?", lOrcSL1 )

			If !lOrcSL1 .OR. ( lOrcSL1 .AND. SL1->L1_RESERVA <> "S" .AND. SL1->L1_ESTACAO == AllTrim(cEstacao) )

				aReserva := { {TRBSC0->C0_NUM , "" , TRBSC0->C0_PRODUTO , TRBSC0->C0_LOCAL , TRBSC0->C0_FILIAL, ""} }

				LjGrvLog( NIL, "Existe reserva pendente - [ C0_NUM,'',C0_PRODUTO,C0_LOCAL,C0_FILIAL,'']", aReserva)
				
                If !lOrcEAI
                    BEGIN TRANSACTION

                        LjGrvLog( cNumOrc, "Antes da Chamada de Lj7CancRes")
                        aRet := Lj7CancRes(aReserva, .T., Nil, Nil, Nil, cNumOrc)
                        LjGrvLog( cNumOrc, "Depois da Chamada de Lj7CancRes - Array de Retorno",aRet)

                        LjGrvLog( NIL, "Excluiu a reserva pendente")
                    
                    END TRANSACTION
                EndiF
				
			EndIf

		EndIf

		TRBSC0->(DbSkip())
	Enddo
	
	TRBSC0->(dbCloseArea())
	DbSelectArea(cAlias)

	LjGrvLog( NIL, "Fim - Pesquisa pelas reservas na tabela SC0 que não tem registro relacionado na SL1/SL2")
#Endif

LjGrvLog( NIL, "Final da execucao da funcao " + ProcName(0))

Return

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºPrograma  ³Lj010SufraºAutor  ³ Vendas Clientes     º Data ³  08/12/05   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Rotina de aplicacao do desconto de Suframa nos itens na     º±±
±±º          ³ venda.                                                      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³                                                             º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function Lj010Suframa()
Local nI 			:= 0			//Variavel de apoio
Local nPosProd 		:= AScan( aHeader, { |x| AllTrim( x[2] ) == "L2_PRODUTO" } )	//Posicao do Produto no aHeader
Local nPosQtd 		:= AScan( aHeader, { |x| AllTrim( x[2] ) == "L2_QUANT" } )		//Posicao da Qtd no aHeader
Local nPosVrUnit 	:= AScan( aHeader, { |x| AllTrim( x[2] ) == "L2_VRUNIT" } )	//Posicao do Valor Unitario no aHeader
Local nPosVrItem 	:= AScan( aHeader, { |x| AllTrim( x[2] ) == "L2_VLRITEM" } )	//Posicao do Valor do Item no aHeader
Local nPosVlDesc 	:= AScan( aHeader, { |x| AllTrim( x[2] ) == "L2_VALDESC" } )	//Posicao do Valor de Desconto no aHeader
Local nPosVlIcm 	:= AScan( aHeader, { |x| AllTrim( x[2] ) == "L2_VALICM" } )	//Posicao do Valor do ICMS no aHeader
Local nPosBaseIcm	:= AScan( aHeader, { |x| AllTrim( x[2] ) == "L2_BASEICM" } )	//Posicao da Base da ICSM no aHeader
Local nPosCF		:= AScan( aHeader, { |x| AllTrim( x[2] ) == "L2_CF" } )		//Posicao do CF no aHeader
Local nPosTES 		:= AScan( aHeader, { |x| AllTrim( x[2] ) == "L2_TES" } )		//Posicao da TES no aHeader
Local aArea 		:= GetArea()	//Area utilizada no momento
Local lRetorno 		:= .T.						//Retorno da funcao

DbSelectArea( "SA1" )
SA1->( DbSetOrder( 1 ) )

If SA1->( DbSeek( xFilial( "SA1" ) + M->L1_CLIENTE + M->L1_LOJA ) )
	If 	( !( Empty( SA1->A1_SUFRAMA ) .AND. SA1->A1_CALCSUF <> "N" ) ) .AND.;
		( !( Empty( SA1->A1_INSCR ) .OR. "ISENT" $ SA1->A1_INSCR .OR. "RG" $ SA1->A1_INSCR) ) .AND.;
		( GetNewPar( "MV_DESCZF", .T. ) )

		For nI := 1 To Len( aCols )

			DbSelectArea( "SB1" )
			SB1->( DbSetOrder( 1 ) )

			If SB1->( DbSeek( xFilial( "SB1" ) + aCols[nI][nPosProd] ) )
				If SB1->( FieldPos( "B1_IMPZFRC" ) ) > 0
					If SB1->( FieldGet( FieldPos( "B1_IMPZFRC" ) ) ) $ " N"
						DbSelectArea( "SF4" )
						SF4->( DbSetOrder( 1 ) )

						If SF4->( DbSeek( xFilial( "SF4" ) + aCols[nI][nPosTES] ) )
							If 	!( ( SF4->F4_IPI == "S" .OR. ( SF4->F4_IPI == "F" .AND. SA1->A1_TIPO == "F" .AND. SA1->A1_TIPO =="C" ) ) .AND.;
								( Substr( aCols[nI][nPosCF], 2, 3 ) $ "91 /92 /97 " .OR. ( Substr( aCols[nI][nPosCF], 2, 2 ) $ "55" .AND. Substr( aCols[nI][nPosCF], 4, 1 ) <> " " ) ) ) .AND.;
								( SF4->F4_ISS <> "S" .AND. SF4->F4_ICM == "S" )

								M->L2_PRODUTO := aCols[nI][nPosProd]

								aCols[nI][nPosVrUnit] 	:= LjxDPreco()
								aCols[nI][nPosVrItem]	:= aCols[nI][nPosVrUnit] * aCols[nI][nPosQtd]

								aCols[nI][nPosVlIcm] 	:= LjxDIcms(nI)
								aCols[nI][nPosVrUnit] 	-= ( NoRound( aCols[nI][nPosVlIcm] ) - aCols[nI][nPosVlDesc] ) / aCols[nI][nPosQtd]

								aCols[nI][nPosVlIcm] 	:= 0
								aCols[nI][nPosBaseIcm] 	:= 0

								aCols[nI][nPosVrItem]	:= aCols[nI][nPosVrUnit] * aCols[nI][nPosQtd]
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf
		Next nI
	EndIf
EndIf

RestArea( aArea )

Return lRetorno

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³Lj010SItemºAutor  ³ Vendas Clientes     º Data ³  09/12/05   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Rotina de aplicacao do desconto de Suframa no item da venda.º±±
±±º          ³ Baseado neste desconto calcula novos valores para o valor   º±±
±±º          ³ unitario e o valor do item, alem de zerar a base do Icms    º±±
±±º          ³ e o valor do Icms                                           º±±
±±º          ³ Sempre retorna o Preco Unitario (para uso no gatilho)       º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³                                                             º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function Lj010SItem()

Local nPosProd 		:= AScan( aHeader, { |x| AllTrim( x[2] ) == "L2_PRODUTO" } )			// Posicao do Produto no aHeader
Local nPosQtd 		:= AScan( aHeader, { |x| AllTrim( x[2] ) == "L2_QUANT" } )				// Posicao da Quantidade no aHeader
Local nPosVrUnit 	:= AScan( aHeader, { |x| AllTrim( x[2] ) == "L2_VRUNIT" } )			// Posicao do Valor Unitario no aHeader
Local nPosVrItem 	:= AScan( aHeader, { |x| AllTrim( x[2] ) == "L2_VLRITEM" } )			// Posicao do Valor do Item no aHeader
Local nPosVlDesc 	:= AScan( aHeader, { |x| AllTrim( x[2] ) == "L2_VALDESC" } )			// Posicao do Valor de Desconto no aHeader
Local nPosVlIcm 	:= AScan( aHeader, { |x| AllTrim( x[2] ) == "L2_VALICM" } )			// Posicao do Valor de ICMS no aHeader
Local nPosBaseIcm	:= AScan( aHeader, { |x| AllTrim( x[2] ) == "L2_BASEICM" } )			// Posicao da Base do ICMS no aHeader
Local nPosCF		:= AScan( aHeader, { |x| AllTrim( x[2] ) == "L2_CF" } )				// Posicao do CF no aHeader
Local nPosTES 		:= AScan( aHeader, { |x| AllTrim( x[2] ) == "L2_TES" } )				// Posicao da TES no aHeader
Local aArea 		:= GetArea()															// Area utilizada no momento
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Tratamento para a rotina de Troca e devolução, onde nao existe a variavel M->L1_CLIENTE  ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Type("M->L1_CLIENTE") == "U"
	M->L1_CLIENTE	:= SL1->L1_CLIENTE
	M->L1_LOJA		:= SL1->L1_LOJA
EndIf

DbSelectArea( "SA1" )
SA1->( DbSetOrder( 1 ) )

If SA1->( DbSeek( xFilial( "SA1" ) + M->L1_CLIENTE + M->L1_LOJA ) )
	If 	( !( Empty( SA1->A1_SUFRAMA ) .AND. SA1->A1_CALCSUF <> "N" ) ) .AND.;
		( !( Empty( SA1->A1_INSCR ) .OR. "ISENT" $ SA1->A1_INSCR .OR. "RG" $ SA1->A1_INSCR ) ) .AND.;
		( GetNewPar( "MV_DESCZF", .T. ) )

		DbSelectArea( "SB1" )
		SB1->( DbSetOrder( 1 ) )

		If SB1->( DbSeek( xFilial( "SB1" ) + aCols[n][nPosProd] ) )
			If SB1->( FieldPos( "B1_IMPZFRC" ) ) > 0
				If SB1->( FieldGet( FieldPos( "B1_IMPZFRC" ) ) ) $ " N"
					DbSelectArea( "SF4" )
					SF4->( DbSetOrder( 1 ) )

					If SF4->( DbSeek( xFilial( "SF4" ) + aCols[n][nPosTES] ) )
						If 	!( ( SF4->F4_IPI == "S" .OR. ( SF4->F4_IPI == "F" .AND. SA1->A1_TIPO == "F" .AND. SA1->A1_TIPO =="C" ) ) .AND.;
							( Substr( aCols[n][nPosCF], 2, 3 ) $ "91 /92 /97 " .OR. ( Substr( aCols[n][nPosCF], 2, 2 ) $ "55" .AND. Substr( aCols[n][nPosCF], 4, 1 ) <> " " ) ) ) .AND.;
							( SF4->F4_ISS <> "S" .AND. SF4->F4_ICM == "S" )

							M->L2_PRODUTO := aCols[n][nPosProd]

							aCols[n][nPosVrUnit] 	:= LjxDPreco()
							aCols[n][nPosVrItem]	:= aCols[n][nPosVrUnit] * aCols[n][nPosQtd]

							aCols[n][nPosVlIcm] 	:= LjxDIcms(n)
							aCols[n][nPosVrUnit] 	-= ( NoRound( aCols[n][nPosVlIcm] ) - aCols[n][nPosVlDesc] ) / aCols[n][nPosQtd]

							aCols[n][nPosVlIcm] 	:= 0
							aCols[n][nPosBaseIcm] 	:= 0

							aCols[n][nPosVrItem]	:= aCols[n][nPosVrUnit] * aCols[n][nPosQtd]

						EndIf
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf
EndIf

RestArea( aArea )
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Retorna o Preco Unitario para o gatilho³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Return aCols[n][nPosVrUnit]
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³CriaAutocomºAutor  ³Vendas Clientes     º Data ³  12/05/06   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Criada funcao para inicializar a Autocom.dll ou .so         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function CriaAutocom()
Local nMVAUTOCOM
Local lRet 		:= .F.	// Retorno da funcao
Local lUsFiscal := .T.	// Define se e usuario fiscal
Local lPOS			:= FindFunction("STFIsPOS") .AND. STFIsPOS()  // Valida se é POS


If lPOS
	Return (.T.)
EndIf

If Type("lAutoExec") == "L"
	If lAutoExec
		Return (.T.)
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Se a chamada for dos modulos permitidos, porem nao do loja,³
//³inicia o objeto.                                           ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

If cModulo $ "FAT|OMS|FIN" .AND. Type( "oAutocom" ) == "U"
	Public 	oAutocom := Autocom():New()
EndIf

If (nModulo == 12 .OR. nModulo == 23 .OR. nModulo == 72 .OR. (nModulo == 51 .AND. GETNEWPAR("MV_HSPCFIS", .F.)) ) ;
	.AND. ValType( oAutocom ) <> "O"

	If Type( "lFiscal" ) == "L"  .AND. GetRemoteType() <> REMOTE_LINUX
		lUsFiscal		:= lFiscal
	Else
		lUsFiscal		:= LJProFile(3)
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³ Verifica o parametro MV_AUTOCOM³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nMVAUTOCOM := ChkAutocom()

	If nMVAUTOCOM == DLL_SIGALOJA_AUTOCOM .OR. nMVAUTOCOM == DLL_AUTOCOM .OR. nMVAUTOCOM == DLL_SIGALOJA
		//Nao cria AutoCom quando utilizando SmartClient HTML(via Browser)
		If !LjChkHtml()
			oAutocom := Autocom():New()
			lRet := .T.
		EndIf
	EndIf
Else
    If (nModulo == 12 .OR. nModulo == 23 .OR. nModulo == 72 .OR.;
    	nModulo == 5 .OR. nModulo == 39 .OR. nModulo == 6 .OR. nModulo == 51 ) .AND. ValType( oAutocom ) == "O"
		lRet := .T.
	EndIf
EndIf

Return (lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao	 ³LjUsaECFE ³ Autor ³ Vendas Clientes       ³ Data ³16/06/06  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Valida se pode utilizar ECF E.							  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³LjUsaECFE(cCNPJ)										      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cCNPJ - CNPJ da empresa 									  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1 - Determina se pode usar ECF E					      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³LOJA701A													  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LjUsaECFE(cCNPJ)

Local lRet          := .F.                   // Valida se pode utilizar ECF E

If LEN(aCNPJDV) == 0
	AADD(aCNPJDV, "60957784000415")
	AADD(aCNPJDV, "60957784000687")
	AADD(aCNPJDV, "60957784000920")
	AADD(aCNPJDV, "60957784001225")
	AADD(aCNPJDV, "60957784001497")
	AADD(aCNPJDV, "60957784001659")
	AADD(aCNPJDV, "60957784005050")
	AADD(aCNPJDV, "60957784002388")
	AADD(aCNPJDV, "60957784002540")
	AADD(aCNPJDV, "60957784005131")
	AADD(aCNPJDV, "60957784002973")
	AADD(aCNPJDV, "60957784005212")
	AADD(aCNPJDV, "60957784005301")
	AADD(aCNPJDV, "60957784003511")
	AADD(aCNPJDV, "60957784003600")
	AADD(aCNPJDV, "60957784000849")
	AADD(aCNPJDV, "60957784004160")
	AADD(aCNPJDV, "60957784004240")
	AADD(aCNPJDV, "60957784004593")
	AADD(aCNPJDV, "60957784004674")
	AADD(aCNPJDV, "60957784005727")
	AADD(aCNPJDV, "60957784005808")
	AADD(aCNPJDV, "60957784001578")
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Valida pelo CNPJ e pela data limite³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
lRet := Ascan(aCNPJDV,{|x| AllTrim(x) == AllTrim(cCNPJ)}) > 0

Return (lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao	 ³LjValECFE ³ Autor ³ Vendas Clientes       ³ Data ³16/06/06  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Valida se pode utilizar ECF E.							  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³LjValECFE()    										      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nenhum 													  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1 - Determina se pode usar ECF E					      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³Venda Assistida											  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LjValECFE()

Local lRet          := .T.                        // Valida se pode utilizar ECF E
Local lApagaECF     := .T.                        // Determina que CNPJ ou data nao foram validados
Local cImpressora	:= LJGetStation("IMPFISC")    // Nome do ECF cadastrado para a estacao

If "EMULATOR" $ Upper(Alltrim(cImpressora))
	lApagaECF := !LjUsaECFE(SM0->M0_CGC)
	If cEmpAnt <> "99" .AND. SM0->M0_CGC <> "53113791000122" .AND. lApagaECF
		MsgStop("Validade do ECF E. ultrapassada.")
		lRet  := .F.
	EndIf
EndIf

Return lRet

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Funcao	 ³LjCanAtuPr³ Autor ³ Vendas Clientes       ³ Data ³16/06/06  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³Valida se pode atualizar preco 							  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³LjCanAtuPr(cCNPJ)										      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³cCNPJ - CNPJ da empresa 									  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1 - Determina se pode atualizar preco			          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³LOJA701A													  ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function LjCanAtuPr(cCNPJ)
Local lRet		:= .F.          // Valida se pode atualizar preco
Local nPos		:= 0			// Posicao no array
Local lFtvdVer12:= LjFTVD() 	//Verifica se é Release 11.7 e o FunName é FATA701 - Compatibilização Venda Direta x Venda Assisitida

Default cCNPJ := ""

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Array com os CNPJs liberados (so os 8 primeiros digitos) ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Len(aCNPJDVPRC) == 0
	AAdd( aCNPJDVPRC, {"00327385", CTOD("31/12/2010")}) // ISSAM
	If lFtvdVer12
		AAdd( aCNPJDVPRC, {"56991441", CTOD("31/12/2099")}) // AVON
	EndIf
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Valida pelo CNPJ (so os 8 primeiros numeros) e pela data limite³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nPos := Ascan(aCNPJDVPRC,{|x| AllTrim(x[1]) == Substr(AllTrim(cCNPJ),1,8) .AND. DTOS(dDatabase) <= DTOS(x[2])})

If nPos > 0
	If Ls_GetId() == 2100007800		// ISSAM
		lRet := .T.
	EndIf
EndIf

Return (lRet)
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Funcao    ³ LjTeclas    ³ Autor ³ Vendas Clientes    ³ Data ³ 18/07/06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Habilita e desabilita teclas de atalho                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpL1 := Tecla F4                                          ³±±
±±³          ³ ExpL2 := Tecla F5                                          ³±±
±±³          ³ ExpL3 := Tecla F6                                          ³±±
±±³          ³ ExpL4 := Tecla F7										  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LjTeclas( lF4, lF5, lF6, lF7 )

Default lF4 := .F.     	// Valor default da variavel lF4
Default lF5 := .F.		// Valor default da variavel lF5
Default lF6 := .F. 		// Valor default da variavel lF6
Default lF7 := .F. 		// Valor default da variavel lF7

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Se as variaveis lF4, lF5, lF6 ou lF7 desabilita a tecla de atalho correspondente ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If !lF4
	SetKey(VK_F4, Nil)
Else
	If Type ("aFuncoes") == "A" .AND. Len(aFuncoes) > 0
		SetKey(VK_F4, aFuncoes[1][4])
	EndIf
EndIf
If !lF5
	SetKey(VK_F5, Nil)
Else
	If Type ("aFuncoes") == "A" .AND. Len(aFuncoes) > 0
		SetKey(VK_F5, aFuncoes[2][4])
	EndIf
EndIf
If !lF6
	SetKey(VK_F6, Nil)
Else
	If Type ("aFuncoes") == "A" .AND. Len(aFuncoes) > 0
		SetKey(VK_F6, aFuncoes[3][4])
	EndIf
EndIf
If !lF7
	SetKey(VK_F7, Nil)
Else
	If Type ("aFuncoes") == "A" .AND. Len(aFuncoes) > 0
		SetKey(VK_F7, aFuncoes[4][4])
	EndIf
EndIf

Return .T.

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Funcao    ³ LjVerCxSup  ³ Autor ³ Vendas Clientes    ³ Data ³ 15/03/07 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Verifica quem eh o caixa superior.                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ ExpC1 := Caixa Digitado                                    ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ lRet := Se eh Superior.                                    ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function LjVerCxSup(cCaixaSup)

Local aArea		:= GetArea()				// Guarda a area corrente
Local lRet		:= .F.                    	// Retorno da funcao
Local cUsu		:= cUserName				// Recebe dados do usuario
Local aRegCx	:= {}						// Retorno
Local nX		:= 1						// Auxiliar de contador
Local aCodSup	:= ""						// Codigos dos superiores do caixa

Default cCaixaSup 	:= ""

If AllTrim(Upper(cCaixaSup)) == "ADMINISTRADOR"
	lRet := .T.
Else
	PswOrder(2)
	If PswSeek(cUsu)
		aRegCx := PswRet()
		If Len(aRegCx) > 0 .AND. !Empty(aRegCx[1][11])
			aCodSup := StrToKArr(aRegCx[1][11],"|")
			PswOrder(1)
			While nX <= Len(aCodSup) .AND. !lRet
				If PswSeek(aCodSup[nX])
					aRegCx := PswRet()
					If	(Len(aRegCx) > 0) 		.AND.;
						(!Empty(aRegCx[1][2])) .AND.;
						(AllTrim(Upper(aRegCx[1][2])) == Alltrim(Upper(cCaixaSup)))
						lRet := .T.
					EndIf
				EndIf
				nX++
			End
		EndIf
	EndIf
	PswOrder(2)
	PswSeek(cUserName)	//Retorna o arquivo de senhas para a posicao original
EndIf

RestArea( aArea )

Return lRet

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Fun‡„o    ³ LjLogCanc ³ Autor ³ Vendas Clientes       ³ Data ³ 05.10.06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Registro do cancelamento de cupom fiscal / item             ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ LjLogCanc( [cSupervisor], [cItem] )                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ cSupervisor: Codigo do supervisor que autorizou o cancela-  ³±±
±±³          ³              mento. Se nao for passado esse parametro assu- ³±±
±±³          ³              me-se que se trata de um cancelamento automa-  ³±±
±±³          ³              tico.                                          ³±±
±±³          ³ cItem: Codigo do Item a ser cancelado. Quando nao informado ³±±
±±³          ³        assume-se o cancelamento do cupom.                   ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function LjLogCanc( cSupervisor	, cItem		, lCupAberto, cCupomArg,;
					aDadosCup	, cCpCCDCanc, lCancCF)
Local lRet      	:= .T.       			// Variavel de retorno
Local aArea     	:= GetArea()			// Array contendo informações da area
Local aAreaSL1		:= SL1->(GetArea())	// Array contendo informações da area do SL1
Local aAreaSL2		:= SL2->(GetArea())	// Array contendo informações da area do SL2
Local cSerie   	 	:= ""					// Variavel contendo a serie
Local cCupom    	:= ""					// Variavel contendo o numero do cupom
Local cPDV      	:= ""					// Variavel contendo o numro do pdv
Local cCaixa    	:= ""					// Variavel contendo o numero do caixa
Local cContDoc		:= ""
Local cAux			:= ""
Local nRetCupom
Local lIsFront  	:= ( AllTrim( Upper( FunName() ) ) $ "FRTA010|FRTA271" )
Local nPIcmD2		:= 0
Local nTamDoc		:= 0
Local nTamL1PDV		:= TamSx3("L1_PDV")[1]                           // Tamanho do campo L1_PDV
Local lIntegra		:= SuperGetMv("MV_LJGRINT",.F.,.F.)				 //Verfica se a integracao esta habilitada
Local cItemSL2 		:= "" 											 //Codigo do item na tabela SL2
Local nPosItem		:= 0											 // Posicao do item
Local nPosVlrItem   := 0											 // Posicao do valor do produto
Local nPosProduto	:= 0                                             // Posicao da descrição do produto
Local nPosQtde		:= 0                                             // Posicao da quantidade
Local nContItRes 	:= 0											 // Variavel auxiliar para controlar a sequencia do item
Local nPosVlrUni   	:= 0											 // Posicao do valor unitario do produto
Local lIntegRm		:= SuperGetMv("MV_LJRMBAC", NIL, .F.) //Esta ativa a integração com RM?
Local lInteSmVen	:= .T.              //Verifica se a venda esta sendo cancelada
Local lEmitNfce		:= LjEmitNFCe()	    //Sinaliza se utiliza NFC-e
Local nX			:= 0
Local lPDVPafEcf	:= LjxBGetPaf()[2]
Local lIntegDef		:= .F.              //Integracao via Mensagem Unica
Local lLX_SITTRI	:= SLX->(ColumnPos("LX_SITTRIB")) > 0

Default cSupervisor := ""
Default cItem       := nil				//Codigo do item no Cupom Fiscal
Default lCupAberto	:= .T.
Default cCupomArg	:= ""
Default aDadosCup 	:= {}               //Dados da venda a cancelar
Default cCpCCDCanc	:= ""
Default lCancCF		:= .F.

//Verifica se Integracao Mensagem Unica esta habilitada
lIntegDef := Len(aDadosCup) > 0 .And. Lj140GtInD()

//função Type inserida pois ao abrir o sistema e existir uma venda para cancelar é gerado log e o aCols nao foi declarado
If (Type("aCols") == "A" .AND. (Len(aCols) > 0)) .And. (Type("aPosCpo") == "A" .AND. (Len(aPosCpo) > 0))
	nPosItem	:= aPosCpo[Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_ITEM"})][2]
	nPosVlrUni 	:= aPosCpo[Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_VRUNIT"})][2]
	nPosVlrItem	:= aPosCpo[Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_VLRITEM"})][2]
	nPosProduto	:= aPosCpo[Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_PRODUTO"})][2]
	nPosQtde	:= aPosCpo[Ascan(aPosCpo,{|x| AllTrim(Upper(x[1])) == "LR_QUANT"})][2]
EndIf

If cPaisLoc == "ARG"
	cSerie		:= LjxDSerArg()
	If Empty(cCupomArg)
		nRetCupom	:= IFPegCupom( nHdlECF, @cCupom, "D|" + cSerie )
	Else
		nRetCupom := 0
		cCupom := cCupomArg
	EndIf
ElseIf lIntegDef //Integracao via Mensagem Unica
	cSerie	:= aDadosCup[1]
	cCupom	:= aDadosCup[2]
	cPdv	:= aDadosCup[3]

	nRetCupom := 0
Else
	cSerie	:= LjGetStation( "Serie" )

	If lEmitNfce
		cCupom		:= SL1->L1_DOC
	Else
		nRetCupom	:= IfPegCupom( nHdlECF, @cCupom)
	EndIf
EndIf

cPdv   := IIF(Empty(cPdv),LjGetStation( "PDV" ), cPdv)
cCaixa := IIF(!lIntegDef, xNumCaixa(), aDadosCup[5])
If !lEmitNfce .And. nRetCupom <> 0
	Return .F.
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Acerto do numero do cupom pois ja cancelou o mesmo na impressora ³
//³obs : somente para cancelamento no cupom 						³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
nTamDoc 	:= Len (cCupom)

If !lIntegDef //Quando integracao via Mensagem Unica, nao necessita ajustar cupom
	If lEmitNfce
		cCupom		:= SL1->L1_DOC
	ElseIf lCupAberto
		cCupom		:= StrZero((Val(cCupom)),nTamDoc)
	Else
		If Empty(cCpCCDCanc)
			cCupom	:= StrZero((Val(cCupom) - 1),nTamDoc)
		Else
			cCupom	:= StrZero((Val(cCpCCDCanc)),nTamDoc)
		EndIf
	EndIf
EndIf

cCupom    := PadR( cCupom , TamSx3("L1_DOC")[1] )
cPDV      := PadR( cPDV , nTamL1PDV )

DbSelectArea( "SL1" )
SL1->(DbSetOrder( 2 ))
If SL1->(DbSeek( xFilial( "SL1" ) + cSerie + cCupom + cPDV ))

	DbSelectArea( "SL2" )
	DbSetOrder( 1 )
	DbSeek( xFilial( "SL2" ) + SL1->L1_NUM )
	cItemSL2 := cItem
	While !EOF() .AND. ( SL2->L2_FILIAL == SL1->L1_FILIAL ) .AND. ( SL2->L2_NUM == SL1->L1_NUM )

		//Desconsidera Item de "Entrega" ou "Retira Posterior"
		If !( SL2->L2_ENTREGA == "2" .Or. Empty(SL2->L2_ENTREGA) )
			nContItRes++
			SL2->(DbSkip())
			Loop
		EndIf

		If cItem <> NIL
			If Val(cItem) == (Val(SL2->L2_ITEM)-nContItRes)
				cItemSL2 := SL2->L2_ITEM
			Else
				SL2->(DbSkip())
				Loop
			EndIf
		EndIf

		If ( cItem == NIL ) .OR. ( SL2->L2_ITEM == StrZero( Val(AllTrim(cItemSL2)), TamSx3("L2_ITEM")[1] ) )

			lRet      	:= .T.       			// Variavel de retorno
			//******* Verifica se ja existe um registro com a mesma hora de inclusao *******
			DbSelectArea("SLX")
			DbSetOrder(1) 			//LX_FILIAL+LX_PDV+LX_CUPOM+LX_SERIE+LX_ITEM
			If DbSeek(xFilial("SLX")+ cPDV + cCupom + cSerie + SL2->L2_ITEM)
				While !Eof() .AND. (SLX->LX_FILIAL + SLX->LX_PDV+SLX->LX_CUPOM+SLX->LX_SERIE+SLX->LX_ITEM ==;
														xFilial("SLX") + cPDV + cCupom + cSerie + SL2->L2_ITEM)

					If (SLX->LX_HORA == SubStr(Time(),1,5))
						lRet := .F.
						Exit
					EndIf
					SLX->(DbSkip())
			    End
			EndIf

			If lRet 
				LjGrvLog("","ENTROU PRIMEIRA GRAVACAO SLX" )
				RecLock( "SLX", .T. )
				REPLACE SLX->LX_FILIAL  WITH xFilial( "SLX" )
				REPLACE SLX->LX_PDV     WITH cPDV
				REPLACE SLX->LX_OPERADO WITH cCaixa
				REPLACE SLX->LX_DTMOVTO WITH IIF(!lIntegDef, dDatabase, aDadosCup[7])
				REPLACE SLX->LX_HORA    WITH IIF(!lIntegDef, Time(), aDadosCup[6])
				REPLACE SLX->LX_CUPOM   WITH Right(cCupom, TamSX3("LX_CUPOM")[1])
				SerieNfId("SLX",1,"LX_SERIE",dDataBase,LjEspecieNF(),cSerie)
				REPLACE SLX->LX_ITEM    WITH SL2->L2_ITEM

				If lIntegRm
					REPLACE SLX->LX_VRUNIT   WITH SL2->L2_PRCTAB
				Else
					REPLACE SLX->LX_VRUNIT   WITH (SL2->L2_VLRITEM + SL2->L2_VALDESC)/SL2->L2_QUANT
				EndIf

				If lIntegRm
					REPLACE SLX->LX_VALOR   WITH NoRound(SL2->L2_PRCTAB * SL2->L2_QUANT, TamSx3("LX_VALOR")[2])
				Else
					REPLACE SLX->LX_VALOR   WITH SL2->L2_VLRITEM + SL2->L2_VALDESC
				EndIf
				REPLACE SLX->LX_PRODUTO WITH SL2->L2_PRODUTO
				REPLACE SLX->LX_QTDE    WITH SL2->L2_QUANT
				REPLACE SLX->LX_SUPERVI WITH cSupervisor
				REPLACE SLX->LX_SITUACA WITH "00"
				REPLACE SLX->LX_DESCON 	WITH SL2->L2_VALDESC

				lInteSmVen := .F.
				If cItem == nil
					REPLACE SLX->LX_TPCANC  WITH "C"
					lInteSmVen := .T.
				Else
					REPLACE SLX->LX_TPCANC  WITH "I"
				EndIf

				nPIcmD2	:=	LJPercIcm (	cCupom, 			cSerie, 		SL1->L1_CLIENTE,	SL1->L1_LOJA,;
										SL2->L2_PRODUTO, 	SL2->L2_ITEM)

		    	REPLACE SLX->LX_ALIQICM WITH nPIcmD2

		    	If lPDVPafEcf
		    		IFStatus(nHdlECF, "35", @cContDoc)
		    		REPLACE LX_CONTDOC WITH cContDoc
		    	EndIf
		    	
				If lLX_SITTRI
					REPLACE SLX->LX_SITTRIB WITH SL2->L2_SITTRIB
				EndIf

				SLX->(MsUnlock())

				If lEmitNfce .And. (Empty(SLX->LX_CUPOM) .Or. AllTrim(Upper(SLX->LX_CUPOM)) == "NFCE")
					aAdd( aSLX_Canc, SLX->(RECNO()) )
				ElseIf lIsFront .Or. lPDVPafEcf
					FRTGeraSLI( cCaixa, "LOG", Str(SLX->(Recno()),17,0), "NOVO" )
				EndIf
			EndIf

			If cItem <> NIL
				Exit //Abandona o laco caso seja o cancelamento de apenas um item especifico
			EndIf
		EndIf
		DbSelectArea( "SL2" )
		dbSkip()
	End

	If lIntegRm .AND. lCupAberto .AND. lInteSmVen
		DbSelectArea("SLX")
		SLX->(DbSetOrder(1))	//LX_FILIAL+LX_PDV+LX_CUPOM+LX_SERIE+LX_ITEM
		If SLX->(DbSeek(xFilial("SLX")+ cPDV + cCupom + cSerie))
			While SLX->(!Eof()) .AND. (SLX->LX_FILIAL+SLX->LX_PDV+SLX->LX_CUPOM+SLX->LX_SERIE == xFilial("SLX")+ cPDV + cCupom + cSerie)
				RecLock( "SLX", .F. )
				REPLACE SLX->LX_TPCANC  WITH "C"
				REPLACE SLX->LX_SITUA   WITH "RX"
				REPLACE SLX->LX_SITUACA WITH "00"
				MsUnlock()

				FRTGeraSLI( cCaixa, "LOG", Str(SLX->(Recno()),17,0), "NOVO" )

				SLX->(DbSkip())
		    End
		EndIf
	EndIf

	If lIsFront .AND. cItem == nil .AND. lIntegra .And. !lEmitNfce
		FRTGeraSLI( cCaixa, "SLX", xFilial( "SL1" ) + PadR(cPDV, TamSX3("LX_PDV")[1]) + PadR(cCupom, TamSX3("LX_CUPOM")[1]) + PadR(cSerie, TamSX3("LX_SERIE")[1]), "NOVO")
	EndIf
Else	
	//**** Verifica se ja existe um registro com a mesma hora de inclusao ****
	DbSelectArea( "SLX" )
	SLX->(DbSetOrder( 1 )) 	//LX_FILIAL+LX_PDV+LX_CUPOM+LX_SERIE+LX_ITEM
	If SLX->(DbSeek(xFilial("SLX")+ cPDV + cCupom + cSerie + "01"))
		While !SLX->(Eof()) .AND. (SLX->(LX_FILIAL + LX_PDV + LX_CUPOM + LX_SERIE + LX_ITEM) ==;
			  xFilial("SLX")+ cPDV + cCupom + cSerie + "01")
			
			//Se eu cancelar uma venda que tenha item cancelado não logava
			//as informações por isso o uso da variável lCancCF
			If (SLX->LX_HORA == SubStr(Time(),1,5)) .And. !lCancCF
				lRet := .F.
				Exit
			EndIf
			SLX->(DbSkip())
	    End
	EndIf

	If lRet
		LjGrvLog("","ENTROU SEGUNDA GRAVACAO SLX" )
		RecLock( "SLX", .T. )
		REPLACE SLX->LX_FILIAL  WITH xFilial( "SLX" )
		REPLACE SLX->LX_PDV     WITH cPDV
		REPLACE SLX->LX_OPERADO WITH cCaixa
		REPLACE SLX->LX_DTMOVTO WITH dDatabase
		REPLACE SLX->LX_HORA    WITH Time()
		REPLACE SLX->LX_CUPOM   WITH Right(cCupom, TamSX3("LX_CUPOM")[1])
		SerieNfId("SLX",1,"LX_SERIE",dDataBase,LjEspecieNF(),cSerie)	//Log Cancelamento x Devolução

		If cItem == NIL
			REPLACE SLX->LX_ITEM    WITH "00"
			REPLACE SLX->LX_TPCANC  WITH "A"
		Else
			//Deve verificar se a posicao do item foi setada pois depende das informações do aCols para preencher
			If nPosItem > 0
				REPLACE SLX->LX_ITEM    WITH aCols[n][nPosItem]
				REPLACE SLX->LX_VRUNIT  WITH aCols[n][nPosVlrUni]
				REPLACE SLX->LX_VALOR   WITH aCols[n][nPosVlrItem]
				REPLACE SLX->LX_PRODUTO WITH aCols[n][nPosProduto]
				REPLACE SLX->LX_QTDE    WITH aCols[n][nPosQtde]
				
		    	If lLX_SITTRI
			    	cAux := Lj7Strib( NIL, NIL, NIL, NIL, n )
					Lj7AjustSt(@cAux)
					REPLACE SLX->LX_SITTRIB WITH cAux
				EndIf
			Else
				REPLACE SLX->LX_ITEM    WITH StrZero(Val(cItem), TamSx3("L2_ITEM")[1])
			EndIf

			REPLACE SLX->LX_TPCANC  WITH "I"
		EndIf

		REPLACE SLX->LX_SUPERVI WITH cSupervisor
		REPLACE SLX->LX_SITUACA WITH "00"

    	If lPDVPafEcf
    		IFStatus(nHdlECF, "35", @cContDoc)
    		REPLACE LX_CONTDOC WITH cContDoc
    	EndIf

		SLX->(MsUnlock())

		If lPDVPafEcf .Or. (lIsFront .And. !lEmitNfce)
			FRTGeraSLI( cCaixa, "LOG", Str(SLX->(Recno()),17,0), "NOVO" )
		EndIf

		If nPosItem > 0 .And. SuperGetMV("MV_LJVACC",,.F.) .And. lPDVPafEcf
			If lCancCF
				//Como abaixo serão criados todos os itens de novo, eu apago caso já exista algum
				SLX->(DbSetOrder( 1 )) 	//LX_FILIAL+LX_PDV+LX_CUPOM+LX_SERIE+LX_ITEM
				
				cAux := xFilial("SLX") + PadR(cPDV, TamSX3("LX_PDV")[1]) + ;
							PadR(cCupom, TamSX3("LX_CUPOM")[1]) + PadR(cSerie, TamSX3("LX_SERIE")[1])
							
				If SLX->(DbSeek(cAux))
					While !SLX->(Eof()) .And. SLX->(LX_FILIAL+LX_PDV+LX_CUPOM+LX_SERIE) == cAux
						//para não apagar o registro criado acima e como não tem valor pode deixar o arquivo
					 	IF !(AllTrim(SLX->LX_ITEM) == "00")
					 		RecLock("SLX",.F.)
							SLX->(DbDelete())
							SLX->(MsUnlocK())
					 	EndIf
					 	SLX->(DbSkip())
					End
				EndIf
			EndIf
			
			For nX:= 1 to Len(aCols)
				LjGrvLog("","ENTROU TERCEIRA GRAVACAO SLX - Indice do aCols [" + cValToChar(nX) + "]" )
				Conout("ENTROU TERCEIRA GRAVACAO SLX - Indice do aCols [" + cValToChar(nX) + "]")
				RecLock( "SLX", .T. )
				REPLACE SLX->LX_FILIAL  WITH xFilial( "SLX" )
				REPLACE SLX->LX_PDV     WITH cPDV
				REPLACE SLX->LX_OPERADO WITH cCaixa
				REPLACE SLX->LX_DTMOVTO WITH dDatabase
				REPLACE SLX->LX_HORA    WITH Time()
				REPLACE SLX->LX_CUPOM   WITH Right(cCupom, TamSX3("LX_CUPOM")[1])
				SerieNfId("SLX",1,"LX_SERIE",dDataBase,LjEspecieNF(),cSerie)	//Log Cancelamento x Devolução

				//Deve verificar se a posicao do item foi setada pois depende das informações do aCols para preencher
				REPLACE SLX->LX_ITEM    WITH aCols[nX][nPosItem]
				REPLACE SLX->LX_VRUNIT   WITH aCols[nX][nPosVlrUni]
				REPLACE SLX->LX_VALOR   WITH aCols[nX][nPosVlrItem]
				REPLACE SLX->LX_PRODUTO WITH aCols[nX][nPosProduto]
				REPLACE SLX->LX_QTDE    WITH aCols[nX][nPosQtde]
				REPLACE SLX->LX_TPCANC  WITH "I"
				REPLACE SLX->LX_SUPERVI WITH cSupervisor
				REPLACE SLX->LX_SITUACA WITH "00"

		    	If SLX->(ColumnPos("LX_CONTDOC")) > 0
		    		If !Empty(cContDoc)
		    			IFStatus(nHdlECF, "35", @cContDoc)
		    		EndIf
		    		REPLACE SLX->LX_CONTDOC WITH cContDoc
		    	EndIf
		    	
		    	If lLX_SITTRI
		    		cAux := Lj7Strib( NIL, NIL, NIL, NIL, nX )
					Lj7AjustSt(@cAux)
					REPLACE SLX->LX_SITTRIB WITH cAux
				EndIf

				SLX->(MsUnlock())

				FRTGeraSLI( cCaixa, "LOG", Str(SLX->(Recno()),17,0), "NOVO" )
			Next nX
		Endif
	EndIf
EndIf

RestArea( aAreaSL1 )
RestArea( aAreaSL2 )
RestArea( aArea )

Return lRet

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Fun‡„o    ³LjPrimAbr  ³ Autor ³ Vendas Clientes       ³ Data ³ 11.10.06 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao ³ Verifica se e' a primeira abertura de caixa no dia          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe   ³ LjPrimAbr()                                                 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ .T. se for a primeira abertura, .F. caso contrario          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³                                                             ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function LjPrimAbr()
Local aArea := GetArea()
Local cPDV  := LjGetStation("PDV")
Local lRet  := .F.

If AliasInDic( "SLW" )
	DbSelectArea( "SLW" )
	DbSetOrder( 2 )
	lRet := !DbSeek( xFilial( "SLW" ) + cPDV + DTOS( dDatabase ) )
EndIf

RestArea( aArea )

Return lRet

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºPrograma  ³LjMacroBotaoºAutor  ³ Vendas Clientes    º Data ³  08/10/06   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Funcao que prepara o um campo para ser executado de forma     º±±
±±º          ³macro '&'                                                     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³SIGALOJA Interface TOUCHSCREEN                                º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function LjMacroBotao( cCampo )
Local cRet := ""

cRet := AllTrim("'" + AllTrim(StrTran(cCampo,"+","'+CHR(10)+'")) + "'")

Return cRet

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºPrograma  ³LjSitTrib ºAutor  ³ Vendas Clientes    º Data ³  16/03/07   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Retorna a sigla da tributacao do produto                    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³ExpC1 - Tributacao do produto.                              º±±
±±º          ³                                                            º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function LjSitTrib(cAlias , lConsidOutr )
Local cSitTrib 	  := ""						// Retorno da situação tributaria do produto
Local aArea 	  := GetArea()				// Guarda a area
Local lAchouSA1   := .F.						// Indica se achou o produto no SA1
Local lAchouSF4   := .F.						// Indica se achou o produto no SA1
Local cTpSolCf    := SuperGetMV("MV_TPSOLCF")	// Parametro para validacao do tipo de cliente para o calculo do solidario
Local aLjExcecao  := {}
Local lExcecaoFcl := .F.
Local lISSIsen	  := .F.
Local lCfgTrib    := If(FindFunction("LjCfgTrib"), LjCfgTrib(), .F.) //Verifica se Configurador de Tributos esta habilitado

Default lConsidOutr 	:= .F.							// Considera a legenda Outros
Default cAlias			:= "SD2"						// Alias Default

cSitTrib := If(lCfgTrib, LjCfgSitTrb(FRTPegaIT((cAlias)->D2_ITEM)), "")

If Empty(cSitTrib) //Se nao encontrou no Configurador de Tributos, verifica legado
	DbSelectArea("SB1")
	DbSetOrder(1)
	DbSeek(xFilial("SB1") + (cAlias)->D2_COD)

	DbSelectArea("SF4")
	DbSetOrder(1)
	lAchouSF4 := DbSeek(xFilial("SF4")+(cAlias)->D2_TES)

	DbSelectArea("SA1")
	DbSetOrder(1)
	lAchouSA1 := DBSeek(xFilial("SA1") + (cAlias)->D2_CLIENTE + (cAlias)->D2_LOJA)

	If lAchouSF4 .AND. lAchouSA1

		aLjExcecao := LjxExcecao(.F., cAlias)
		lExcecaoFcl:= Len(aLjExcecao) > 0
		
		// --- Verifica a situacao tributaria do item ---
		
		/*Segundo regras do Fiscal para considerar a isenção de ISS
		é necessário a regra abaixo para que não seja feito nenhum calculo*/
		If SF4->F4_ICM == "N" .And. SF4->F4_ISS == "N"
			/*
				Foi avaliado somente permitir a configuração dos tipos 07 e 06
				no caso do Isento pois os outros tipos se referem a modalidades
				que não são comumente usadas no PDV
			*/
			If SF4->F4_LFISS == "I" .And. ((ALLTRIM(SF4->F4_CSTISS) $ "07|06") .Or. (Empty(ALLTRIM(SF4->F4_CSTISS))))
				If ALLTRIM(SF4->F4_CSTISS) == "07" //Nao tributado
					cSitTrib := "NS"
				ElseIf ALLTRIM(SF4->F4_CSTISS) == "06" //Isento
					cSitTrib := "IS" 
				Else                          
					//Caso não esteja configurado, considero isento
					cSitTrib := "IS" //Isento
				EndIf
				lISSIsen := .T.
			ElseIf SF4->F4_LFISS == "N" .OR. SF4->F4_LFISS == "O"	// Não sujeito a ISS ou Outros
				cSitTrib := "NS"
				lISSIsen := .T.
			EndIf
		EndIf
		
		If !lISSIsen
			//³ Servico³
			If SF4->F4_ISS == "S"
				cSitTrib := "S"
		
			ElseIf SF4->F4_MKPSOL<>"1" .And. (SB1->B1_PICMRET > 0 .OR.;
						(SB1->B1_PICMENT > 0 .AND. ALLTRIM(SF4->F4_SITTRIB) == "60") .OR.;
						(lExcecaoFcl .AND. (aLjExcecao[3] > 0 .OR. aLjExcecao[16] > 0 )) );
					.AND. SA1->A1_TIPO $ cTpSolCf .AND. SF4->F4_BSICMST <> 100
		
				//Substituicao tributaria (Icms Solidario)
				cSitTrib := "F"
			ElseIf (SF4->F4_BASEICM > 0 .AND. SF4->F4_BASEICM < 100) .Or. ;
				(lExcecaoFcl .AND. (aLjExcecao[14] > 0) .AND. (aLjExcecao[14] < 100))
		
				//³ Com ICMS³
				cSitTrib := "T"
		
			ElseIf SF4->F4_LFICM == "I" .And. (ALLTRIM(SF4->F4_SITTRIB) == "40" .Or. ALLTRIM(SF4->F4_SITTRIB) == "41" )
				If ALLTRIM(SF4->F4_SITTRIB) == "41"
					//³ Nao tributado³
					cSitTrib := "N"
				Else
					//³ Isento³
					cSitTrib := "I"
				EndIf
		
			ElseIf SF4->F4_LFICM == "I"
				//³ Isento³
				cSitTrib := "I"
		
			ElseIf SF4->F4_LFICM == "N"	 .OR. SF4->F4_LFICM == "O"
				//³N„o sujeito a ICMS³
				cSitTrib := "N"
		
				//³Se considera Outros muda a legenda ³
				If lConsidOutr .AND. SF4->F4_LFICM == "O"
					cSitTrib := "O"
				EndIf
			Else
				//³ Com ICMS³
				cSitTrib := "T"
			EndIf
		EndIf
	EndIf
EndIf

RestArea(aArea)

Return cSitTrib

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºPrograma  ³LjVerCli  ºAutor  ³ Vendas Clientes    º Data ³  10/08/07   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Posiciona o cliente no SA1                                 º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ExpC1 - Cliente a ser pesquisado                            º±±
±±º          ³ExpC2 - Codigo da loja                                      º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function LjVerCli(cCliente, cLoja)

Local lRet  := .F.					// Retorno da funcao
Local aArea := GetArea()			// Guarda a area corrente

SA1->(dbSetOrder(1))
If SA1->(DbSeek(xFilial("SA1") + cCliente + cLoja))
	If SA1->A1_RECPIS $ "S|P" .OR. SA1->A1_RECCOFI $ "S|P" .OR. SA1->A1_RECCSLL $ "S|P"
		lRet := .T.
	EndIf
EndIf
RestArea(aArea)

Return lRet

/*ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³ Funcao    ³StatDispTor³ Autor ³ Vendas Clientes       ³ Data ³ 04/09/07 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Descricao ³Utilizada para controle de handle do DispTor - foi criada no ³±±
±±³           ³lugar de criar uma variável PRIVATE nHdlDispTor              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe    ³StatDispTor(nValor)                                          ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros ³nValor   Devera ser informado quando o valor do handle for   ³±±
±±³           ³          alterado, caso contrario, será retornado o valor   ³±±
±±³           ³          atual                                              ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso       ³ SIGALOJA  / FRONT LOJA                                      ³±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±*/
Function StatDispTor(nValor)
If nValor <> Nil
	nHdlDispTor := nValor
EndIf
Return nHdlDispTor

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LJDISPLAY ºAutor  ³ Vendas Clientes    º Data ³  29/08/07   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Verifica se utiliza display                                º±±
±±º          ³                                                            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function LjDisplay()

If lUsaDisplay
	DisplayEnv(StatDisplay(), "1C"+ "|")
	DisplayEnv(StatDisplay(), "2C"+ STR0023)		//"Acesso Negado !!"
	DisplayEnv(StatDisplay(), "3C"+ "|")
	DisplayEnv(StatDisplay(), "4C"+ "|")
EndIf
TONE(3000,1)
MsgStop(STR0023)
If lUsaDisplay
	DisplayEnv(StatDisplay(), "2C"+ STR0063)		//"Informe a Senha do Superior"
	DisplayEnv( StatDisplay(), "3E" + STR0064 )     //"E pressione <ENTER>"
	DisplayEnv( StatDisplay(), "4E|")
EndIf

Return(.T.)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LJVldSup  ºAutor  ³ Vendas Clientes    º Data ³  27/08/07   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Efetua a validacao das Permissoes do Superior atraves de   º±±
±±º          ³ Cartao Magnetico e Senha.                                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ ExpC1 - Caixa Superior                                     º±±
±±º          ³ ExpA2 - Permissoes do SIGALOJA.                            º±±
±±º          ³ ExpN3 - Numero da Permissao                                º±±
±±º          ³ ExpC4 - Forma de Desconto                                  º±±
±±º          ³ ExpN5 - Percentual de Desconto                             º±±
±±º          ³ ExpN6 - Valor do Desconto                                  º±±
±±º          ³ ExpC7 - Senha do Usuario                                   º±±
±±º          ³ ExpL8 - Verifica se eh Touch Pad                           º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³ lRet - Permite ou nega o acesso.                           º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function LJVldSup(	cCaixaSup	,aPermissao	,nAcesso	,cFormDesc,;
							nDescPer	,nDescLoj	,cSenhaAnt  , lCtrlB  ,;
							lTelaSimul)

Local aAreaSLF	:= SLF->(GetArea())			// Guarda a area do SLF
Local aUsers	:= {}
Local aCodSup	:= LjRetSup(1,"",@aUsers)		// Codigos dos Caixas Superiores
Local cCodSup	:= ""							// Codigo do Caixa Superior escolhido pelo caixa
Local cTpVal	:= "1"							// Tipo de Validacao: 1-Senha, 2-Cartao, 3-Ambos
Local cCartSup	:= ""							// Numero do Cartao do Superior
Local lCliSitef	:= LjGetStation("TIPTEF") == TEF_CLISITEF	// Tipo do Tef
Local lRet		:= .F.							// Variavel de Retorno da Funcao
Local nAUTOCOM	:= ChkAutocom()					// Captura o conteudo do MV_AUTOCOM, se e' sigaloja ou autocom
Local nTamPass := 20                            // Tamanho do campo da senha
Local cSenhaSup	:= Space( nTamPass )			// Senha digitada do supervisor
Local cSuperSel	:= ""							// Nome do Superior selecionado (caso tenha mais de um)
Local lUsaDisplay := !Empty(LjGetStation("DISPLAY"))
Local cBkReadVar:= ""							// Backup da variavel __ReadVar
Local lRetRegra := .T.							// Valida regra de permissões de usuario
Local cIDSel	:= ""							// ID do Supervisor
Local lExistPPad:= .F. 							// Existe Pinpad disponivel para leitura de cartão
Local lLjValDig	:= ExistFunc("LjValDig") .AND. ExistFunc("LjUsaBiom") .AND. LjUsaBiom()// Verifica se existe a função LjValDig() no RPO

Default lCtrlB 		:= .F.
Default lTelaSimul	:= .F.								// Define se foi chamado pela tela de simulacao de desconto


//Seleciona o superior do caixa. Se houver mais de 1 superior,
//o caixa seleciona qual superior fara a liberacao
cCodSup	:= LjSelSup( aCodSup , @cSuperSel, aUsers )

//Somente permite a utilizacao da validacao via Cartao:
//1.  Se o CliSitef estiver habilitado; e
//2.  Se o parametro MV_AUTOCOM, estiver configurado como 1 (Autocom e Sigaloja) ou 2 (Autocom)
//3.  Se existe comunicação com o PinPad

lExistPPad:= (lCliSitef .AND. (nAUTOCOM == DLL_SIGALOJA_AUTOCOM .OR. nAUTOCOM == DLL_AUTOCOM) .AND. Type("oAutocom") == "O" .And. oAutocom:SIT_VERPIN() == 1)

If !Empty(cCodSup)
	dbSelectArea("SLF")
	dbSetOrder(1)	//Filial + Caixa

	If dbSeek(xFilial("SLF") + cCodSup)

		If SLF->LF_TPVAL $ "23" .AND. lExistPPad															//Autenticação por Cartão ou Senha
			cTpVal		:= SLF->LF_TPVAL												//Guarda o Tipo de Validacao
			cCartSup	:= IIF(ExistFunc("LjEncript"),LjEncript(1,SLF->LF_NUMCART),"")	//Recupera o numero do Cartao cadastrado
		ElseIf lLjValDig .AND. SLF->LF_TPVAL=='4' .AND. SLF->(ColumnPos("LF_FINGER")) > 0 // biometria
			cSupDig		:= SLF->LF_FINGER
			cTpVal 	:= SLF->LF_TPVAL //alimenta a variável somente se está como biometria e existe campo, senão usa o default
		EndIf

	EndIf

	RestArea(aAreaSLF)

EndIf

If cTpVal $ "23" //Autenticação por Cartão ou Senha

	IF ExistFunc("LjGetCart")
		cNumCart :=  LjGetCart(2) //Realiza comunicação com o Pinpad e retorna o numero do Cartão
	Else
		cNumCart := ""
		LjGrvLog("Cartão Superior", "Função LjGetCart nao compilada, por esse motivo não será possivel utilizar o retorno do cartão magnetico.")
	Endif

	//Verifica se o cartão recebido contem no armazenado na tabela SLF
	If cCartSup $ cNumCart

		//Verifica se o usuario supervisor tem permissão
		//Faz as verificações de regra de permissão do Varejo
		If lRetRegra := LJSenhaSup(cSenhaSup	, nAcesso	, @cCaixaSup, cFormDesc	,;
									nDescPer	, nDescLoj	, NIL		, .T.		,;
									Nil			, lCtrlB	, cSuperSel , ""		,;
									"2" )	//"2" fixo para validar autenticação por cartão

			lRet := .T.
		Endif

	Else

		MsgAlert(STR0081) //"Cartão Inválido. Acesso Negado.

		If lUsaDisplay
			DisplayEnv(StatDisplay(), "1C"+ "|")
			DisplayEnv(StatDisplay(), "2C"+ STR0023)		//"Acesso Negado !!"
			DisplayEnv(StatDisplay(), "3C"+ "|")
			DisplayEnv(StatDisplay(), "4C"+ "|")
		EndIf

		lRet := .F.

	EndIf

Elseif cTpVal=='4' //Liberação do Supervisor por Biometria
	
	LjMsgrun(STR0172 + cSuperSel ,, {||lRet:= LjValDig(.T., cSupDig)}) //"Valide a biometria do Superior - "
	
EndIf

If ((!lRet .AND. cTpVal == "3" ) .OR. cTpVal == "1" ) .AND. lRetRegra

	If lUsaDisplay
		DisplayEnv( StatDisplay(), "1C" + STR0063 )     //"Informe a Senha do Superior"
		DisplayEnv( StatDisplay(), "2C" + STR0064 )     //"E pressione <ENTER>"
		DisplayEnv( StatDisplay(), "3D" + " |" )
		DisplayEnv( StatDisplay(), "**")
	EndIf

	cBkReadVar := ReadVar()	// Backup da variavel __ReadVar, pois a qdo. chamada a funcao "FWAuthSuper" o conteudo da variavel __ReadVar eh modificado para "CUSERLOGIN"

	If FWAuthSuper(@cIDSel, @cSuperSel) 
 
		//Faz as verificações de regra de permissão do Varejo
		lRet := LJSenhaSup( cSenhaSup	, nAcesso	, @cCaixaSup		, cFormDesc	,;
							nDescPer	, nDescLoj	, NIL				, .T.		,;
							Nil			, lCtrlB	, AllTrim(cSuperSel), Alltrim(cIDSel),;
							"1"	 )	//"1" fixo porque vai validar a senha ao invés do cartão

	Else
		lRet := .F.
	EndIf

	If !Empty(cBkReadVar)
		__ReadVar := cBkReadVar //Restaura o conteudo da variavel "__Readvar"
	EndIf

EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Restaura o modo de digitacao no display³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DisplayEnv(StatDisplay(), "*")
DisplayEnv( StatDisplay(), "1E|")
DisplayEnv( StatDisplay(), "2E|")
DisplayEnv( StatDisplay(), "3E|")
DisplayEnv( StatDisplay(), "4E|")

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LjRetSup  ºAutor  ³ Vendas Clientes    º Data ³  30/08/07   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Retorna lista do Codigo, ID, Nome ou Valida a Senha dos    º±±
±±º          ³ Superiores do Caixa Atual. Se o Caixa nao tiver superior umº±±
±±º          ³ elemento em branco.                                        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ ExpN1 - Tipo de informacao desejada para retorno:          º±±
±±º          ³       1 - Lista com os codigos dos superiores              º±±
±±º          ³       2 - Lista com os ID's dos superiores                 º±±
±±º          ³       3 - Lista com os nomes dos superiores                º±±
±±º          ³       4 - Retorna o nome do superior para a senha fornecidaº±±
±±º          ³ ExpC2 - Senha a ser verificada (somente quando ExpN1 = 4). º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³ Lista com informacoes dos superiores.                      º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LjRetSup(nRetorno, cSenha, aUsers)

Local aAreaSA6		:= SA6->(GetArea())			// Guarda a area do SA6
Local aIdSup		:= {}							// Array com os IDs dos superiores do usuario atual
Local aCaixaSup		:= {}							// Nomes dos superiores
Local aCodSup		:= {}							// Codigos do Superior
Local aRetorno		:= {}							// Retorno da Funcao
Local nI			:= 0							// Contador
Local nJ			:= 0							// Contador

Default aUsers			:= {}

Default nRetorno		:= 1							// Determina se retorna o Codigo (1), o ID (2), o Nome(3), ou Valida a Senha do Superior
Default cSenha			:= ""							// Senha a ser testada como senha do superior


//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³A partir do release 11.5, o array aUsers tera³
//³apenas os registros do usuario logado e seus ³
//³respectivos superiores.                      ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
aUsers := AADD(aUsers,{})
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Adciona no aUsers o usuário atual³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
PswOrder(1)
PswSeek(__cUserID)
AADD(aUsers,PswRet(1))
If !Empty(aUsers[1][1][11])
	aIdSup	:= StrToKArr(aUsers[1][1][11],"|")
Else
	AADD(aRetorno, "")
	Return aRetorno
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Adicionar no array aUsers os superiores do usuario atual³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Len(aIdSup) > 0
	For nI := 1 to Len(aIdSup)
		PswOrder(1)
		If PswSeek(aIdSup[nI])
			AADD(aUsers,PswRet(1))
		Endif
	Next nI
EndIf

If !nRetorno == 4
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Armazena o ID dos superiores³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For nI := 1 to Len(aUsers)
		If aUsers[nI][1][1] == __cUserID
			If !Empty(aUsers[nI][1][11])
				aIdSup	:= StrToKArr(aUsers[nI][1][11],"|")
			EndIf
			Exit
		Endif
	Next nI

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Guarda os nomes dos superiores³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Len(aIdSup) > 0
		For nI := 1 to Len(aUsers)
			For nJ := 1 to Len(aIdSup)
				If aUsers[nI][1][1]	 == aIdSup[nJ]
					AAdd(aCaixaSup,aUsers[nI][1][2])
				EndIf
			Next nJ
		Next nI
	EndIf

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Guarda os codigos de caixa dos superiores³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	dbSelectArea("SA6")
	dbSetOrder(2) //Filial + Nome

	For nI := 1 to Len(aCaixaSup)
		If dbSeek(xFilial("SA6") + UPPER(aCaixaSup[nI]))
			AAdd(aCodSup,SA6->A6_COD)
		EndIf
	Next nI

Else

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se a senha informada pertence a um superior do caixa³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aCaixaSup := LjRetSup(3)
	For nI := 1 to Len(aCaixaSup)
		PswOrder(2)
		PswSeek(aCaixaSup[nI])
		If PswName(cSenha)
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Se a Senha conferir retorna o nome do Caixa Superior³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			AAdd(aRetorno,aCaixaSup[nI])
		EndIf
	Next nI

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se nao encontrou superior, retorna vazio³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Empty(aRetorno)
		AAdd(aRetorno,"")
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Retorna o arquivo de senhas para a posicao original³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	PswSeek(cUserName)

EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Informa o retorno de acordo como o que foi solicitado no 1o.³
//³parametro da funcao                                         ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Do Case
	Case nRetorno == 1
		aRetorno := aCodSup
	Case nRetorno == 2
		aRetorno := aIdSup
	Case nRetorno == 3
		aRetorno := aCaixaSup
EndCase

RestArea(aAreaSA6)
Return aRetorno

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LjSelSup  ºAutor  ³ Vendas Clientes    º Data ³  28/09/07   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Selecao do superior do usuario, quando existir mais de um   º±±
±±º          ³superior cadastrado para o caixa atual                      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ ExpA1 - Lista com os codigos dos superiores associados ao  º±±
±±º          ³         caixa atual.                                       º±±
±±º          ³ ExpC2 - Nome do Superior selecionado                       º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³Codigo do superior escolhido pelo caixa.                    º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³SIGALOJA                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LjSelSup(aSuper,cSuperSel,aUsers)

Local aArea	  		:= GetArea()								// Armazena o posicionamento da tabela atual
Local aAreaSA6		:= SA6->(GetArea())							// Armazena o posicionamento da SA6
Local oDlg			:= NIL										// Objeto da janela
Local oListBox		:= Nil										// Objeto da listbox
Local aListBox 		:= {}										// Array de usuarios superiores da listbox
Local cSuper		:= ""										// Codigo do superior selecionado
Local bOk			:= {||cSuper:=aListBox[oListBox:nAt,1],cSuperSel:=aListBox[oListBox:nAt,2]}	// Codigo executado ao confirmar o superior
Local nX			:= 0										// Auxiliar de loop
Local cReadVarBk	:= ""										// Armazena o conteudo da __readvar
Local aListBox2		:= {}										// Array de usuarios superiores da listbox
Local lCont 		:= .T.										// Se continua com a operacao.
Local nI			:= 0										// Contador
Local nTamNREDUZ 	:= TamSX3("A6_NREDUZ")[1]					// Tamanho do campo A6_NREDUZ
Local lUsaDisplay 	:= !Empty(LjGetStation("DISPLAY"))	// Controla se utiliza Display

Default aSuper		:= {}
Default cSuperSel	:= ""
Default aUsers      := {}

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Cria tabela de superiores³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DbSelectArea("SA6")
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Filial + Cod.Caixa³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
DbSetOrder(1)

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³ Foi inserido abaixo mais uma casa no array aListBox2 ³
//³ com o login de Usuário do(s) Superior(es)			 ³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If Len(aUsers) > 0
	For nX := 1 to Len(aSuper)
		If DbSeek(xFilial("SA6") + aSuper[nX])
			For nI := 1 to Len(aUsers)
				If Alltrim(Upper(Left(aUsers[nI][1][2],nTamNREDUZ))) == AllTrim(Upper(SA6->A6_NREDUZ))
					Aadd(aListBox2,{SA6->A6_COD,SA6->A6_NREDUZ,aUsers[nI][1][2]})
				EndIf
			Next nI
		EndIf
	Next nX
Else
	For nX := 1 to Len(aSuper)
		If DbSeek(xFilial("SA6") + aSuper[nX])
			Aadd(aListBox2,{SA6->A6_COD,SA6->A6_NREDUZ})
		EndIf
	Next nX
EndIf

If Len(aListBox2) == 0
	RestArea(aAreaSA6)
	RestArea(aArea)
	lCont := .F.
EndIf

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Se houver apenas 1 superior, nao exibe tela de selecao³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lCont
	If Len(aSuper) == 1
		cSuper		:= aSuper[1]
		cSuperSel 	:= aListBox2[1][3]
	Else

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Armazena o conteudo da variavel publica __ReadVar, modificada³
		//³quando utiliza-se o metodo SetFocus() na ListBox             ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If Type("__ReadVar") <> "U"
			cReadVarBk := __ReadVar
		EndIf

		If lUsaDisplay
			// Limpar as mensagens do display
			LjLimpDisp()
			DisplayEnv(StatDisplay(), "1C"+ STR0085)	//"Seleção de Superior"
			DisplayEnv(StatDisplay(), "2C"+ STR0129)	// "Utilize o Monitor"
			DisplayEnv(StatDisplay(), "***")	// Bloquear echo no Display
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Tela de selecao de superior³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		DEFINE MSDIALOG oDlg TITLE STR0085 FROM CRDxTela(0),CRDxTela(0) TO CRDxTela(180),CRDxTela(300) PIXEL	STYLE DS_MODALFRAME STATUS //"Seleção de Superior"
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Desabilita a saida via ESC ou botao fechar³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			oDlg:LESCCLOSE := .F.
			//ÚÄÄÄÄÄ¿
			//³Label³
			//ÀÄÄÄÄÄÙ
			@ CRDxTela(004),CRDxTela(004) TO CRDxTela(90),CRDxTela(115) LABEL STR0086 PIXEL OF oDlg //"Selecione o superior para liberação:"
			//ÚÄÄÄÄÄÄÄÄ¿
			//³Botao Ok³
			//ÀÄÄÄÄÄÄÄÄÙ
			DEFINE SBUTTON FROM CRDxTela(006),CRDxTela(120) TYPE 1 ENABLE OF oDlg ACTION (Eval(bOk),oDlg:End())
			//ÚÄÄÄÄÄÄÄ¿
			//³ListBox³
			//ÀÄÄÄÄÄÄÄÙ
			@ CRDxTela(015),CRDxTela(009) ListBox oListBox Fields HEADER STR0087,STR0088; //"Código"###"Nome"
				Size CRDxTela(100),CRDxTela(065) Of oDlg Pixel ColSizes 25,75 ON DblClick(Eval(bOk),oDlg:End())

			oListBox:SetArray(aListBox)

			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Reorganiza o aListBox com as informacoes lidas do SA6³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			For nX := 1 To Len(aListBox2)
				If Len(aUsers) > 0
					Aadd(aListBox,{aListBox2[nX][1],aListBox2[nX][3]})
				Else
					Aadd(aListBox,{aListBox2[nX][1],aListBox2[nX][2]})
				EndIf
			Next nX

			oListBox:bLine := {|| {	aListBox[oListBox:nAT,01],aListBox[oListBox:nAT,02]}}
			oListBox:SetFocus()

		ACTIVATE MSDIALOG oDlg CENTERED

		If lUsaDisplay
			// Limpar as mensagens do display
			LjLimpDisp()
			DisplayEnv(StatDisplay(), "*")	// Liberar echo no Display
		Endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Restaura a __readvar³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	    If !Empty(cReadVarBk)
	    	__readvar := cReadVarBk
	    EndIf

	EndIf

	RestArea(aAreaSA6)
	RestArea(aArea)
EndIf

Return cSuper

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Programa   ³CRDxTela ³ Autores ³ Vendas Clientes        ³ Data ³10/05/2005³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descricao  ³ Funcao responsavel por manter o Layout independente da       ³±±
±±³           ³ resolucao horizontal do Monitor do Usuario.                  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Static Function CRDxTela(nTam)
Local nHRes	:=	oMainWnd:nClientWidth	// Resolucao horizontal do monitor
If nHRes == 640	// Resolucao 640x480 (soh o Ocean e o Classic aceitam 640)
	nTam *= 0.8
ElseIf (nHRes == 798).Or.(nHRes == 800)	// Resolucao 800x600
	nTam *= 1
Else	// Resolucao 1024x768 e acima
	nTam *= 1.28
EndIf

Return Int(nTam)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LjVldCnt    ºAutor³Vendas Clientes     º Data ³  11/04/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Valida se o contato esta devidamente amarrado com a entidadeº±±
±±º          ³informada.                                                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Venda Assistida                                            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LjVldCnt(cAlias, cCodEnt)
Local aArea			:= GetArea()							//Salva area corrente
Local cChave		:= &(ReadVar())							//Codigo do contato
Local lMVLjPedVe	:= SuperGetMv("MV_LJPEDVE", NIL, .F.)	//Parametro do pedido de venda no venda assistida
Local lRet			:= .T.									//Retorno da Funcao
Local nPosEntr		:= aPosCpo[Ascan(aPosCpo,{|x| Alltrim(Upper(x[1])) == "LR_ENTREGA"})][2]	// Posicao da codigo do produto

Default cAlias		:= "SA1"
Default cCodEnt		:= M->LQ_CLIENTE + M->LQ_LOJA

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica se a validacao e para pedido de venda pelo loja³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If nPosEntr > 0
	If lMVLjPedVe .AND. !(AllTrim(aCols[n][nPosEntr]) $ "3/5")
		lRet		:= .F.
		Alert(STR0090)		//"Contato so é valido para tipo de venda entrega"
	ElseIf !lMVLjPedVe
		lRet		:= .F.
		Alert(STR0091)		//"O Contato so é valido quando a modalidade de pedido estiver ativa"
	EndIf
EndIf
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Verifica se o contato e do cliente selecionado³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
If lRet
	DbSelectarea("AC8")
	DbSetOrder(1)		// AC8_FILIAL+AC8_CODCON+AC8_ENTIDA+AC8_FILENT+AC8_CODENT
	If !DbSeek(xFilial("AC8") + cChave + cAlias + xFilial(cAlias) + AllTrim(cCodEnt))
		lRet := .F.
		Help(" ",1,"NCONTATO")
	Endif
EndIf

RestArea(aArea)
Return(lRet)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LjInfocar ºAutor  ³Vendas Clientes     º Data ³  16/06/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Verifica se o cliente utiliza o Private-Label Infocards     º±±
±±º          ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³ Logico                                                     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametro ³ExpL1 - Verifica se fez consulta Infocards                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ AP                                                         º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LjInfocar( lConsulta )
Local lRet 			:= .F.							// Retorno da Funcao
Local cRedes		:= ""							// Verifica se utiliza Infocards
//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³"Nao" alterar o comando GETMV para SUPERGETMV³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
Local lMVLjInfo		:= GetMv("MV_LJINFO", .T.)			//Verifica se o parametro existe

DEFAULT lConsulta := .F.

If	SLG->(FieldPos("LG_REDES")) > 0
	cRedes := SubStr(LjGetStation("REDES"), 1, 1)
EndIf

If lConsulta
	lRet := (SBI->(FieldPos("BI_PRVINFO")) > 0 .AND. LjGetStation("TIPTEF") == TEF_CLISITEF .AND. cRedes == "1" .AND. ;
				SBI->(FieldPos("BI_DTINFO")) > 0 .AND. lMVLjInfo )
Else
	lRet := (SBI->(FieldPos("BI_PRVINFO")) > 0 .AND. LjGetStation("TIPTEF") == TEF_CLISITEF .AND. cRedes == "1" .AND. ;
				SBI->(FieldPos("BI_DTINFO")) > 0 .AND. lMVLjInfo )
EndIf

Return(lRet)
/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³CriaTotApiºAutor  ³Vendas Clientes     º Data ³  02/07/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Responsavel em instanciar o objeto LJCTtovsApi              º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³Logico                                                      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametro ³															  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³                                                            º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function CriaTotApi()

	Local lRetorno := .F.		// Retorno da funcao

	// Verifico se existe a funcao antes de instaciar a classe
	If oTotvsApi == Nil
		If FindFunction("LOJA1326")
			oTotvsApi := LJCTotvsApi():New()
			lRetorno := .T.
		EndIf
	Else
		lRetorno := .T.
	EndIf

Return lRetorno

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³GetTotApi ºAutor  ³Vendas Clientes     º Data ³  02/07/08   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Responsavel em retornar o objeto oTotvsApi                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³Objeto                                                      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametro ³															  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³															  º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function GetTotApi()
Return oTotvsApi

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    ³SetTotApi  ºAutor  ³Vendas Clientes     º Data ³  02/07/08  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Atribui valor ao objeto oTotvsApi			                  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametro ³ExpO1 (1 - oObj) - Objeto do tipo LJCTotvsApi               º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ 		                                                      º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function SetTotApi(oObj)

	oTotvsApi := oObj

Return Nil

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºFuncao    |LJXGrSerie ºAutor  ³Vendas Clientes     º Data ³  03/02/09  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Grava a serie do equipamento fiscal na tabela SLG           º±±
±±º          ³Sera utilizado para geracao do spedfiscal                   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametro ³ExpO1 - Handle de comunicacao				                  º±±
±±º          ³ExpO2 - Variavel para retorno do numero de serie            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Efetua a gravacao do numero de serie do equipamento        º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function LJXGrSerie(nHdlECF, cEstacao)
Local cSerie := Space(TamSx3("LG_SERPDV")[1]) // Numero de serie do PDV

IFPegSerie( nHdlECF, @cSerie )

If cSerie <> ""
	DbSelectArea("SLG")
	SLG->(DbSetOrder(1))
	If SLG->(DbSeek(xFilial("SLG")+cEstacao))
		RecLock( "SLG", .F. )
		REPLACE SLG->LG_SERPDV 	WITH cSerie
		SLG->(MsUnLock())
	EndIf
EndIf

Return Nil

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºFuncao    |LJPercIcm  ºAutor  ³Vendas Clientes     º Data ³  03/02/09  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Carrega o percentual de icms da tabela D2                   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³                                                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametro ³ExpO1 - numero do cupom cancelado							  º±±
±±º			 ³ExpO2 - serie do cumpom cancelado							  º±±
±±º			 ³ExpO3 - codigo do cliente do cupom cancelado		          º±±
±±º			 ³ExpO4 - numero da loja do L1                                º±±
±±º			 ³ExpO5 - codigo do produto                                   º±±
±±º			 ³ExpO6 - numero do item                                      º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Carrega a aliquota de icm da tabela D2                     º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Static Function LJPercIcm(	cDoc, 		cSerie, 	cCliente, 	cL1Loja,;
							cProduto, 	cItem )

Local nRetIcm	:=	0
Local aArea		:= 	GetArea()

	DbSelectArea("SD2")
	DbSetOrder(3) // NUMDOC + SERIE + CLIENTE + LOJA + PRODUTO + ITEM

	If DbSeek(xFilial("SD2")+ cDoc + cSerie + cCliente + cL1Loja + cProduto)

		While !Eof() .AND. SD2->D2_FILIAL == xFilial("SD2") .AND. SD2->D2_DOC == cDoc .AND. SD2->D2_SERIE == cSerie .AND.;
			SD2->D2_CLIENTE == cCliente .AND. SD2->D2_LOJA == cL1Loja .AND. SD2->D2_COD == cProduto

			If SD2->D2_ITEMPV == cItem
				nRetIcm	:= SD2->D2_PICM
				Exit
			EndIf
			dbSkip()
		End
	EndIf

RestArea(aArea)

Return (nRetIcm)

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³RetUMProd ³ Autor ³ Vendas e CRM          ³ Data ³ 29/01/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Carrega a unidade de medida do produto                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGAFIS                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function RetUMProd(aProdB1, cProd , nPosBusca )

Local aArea			:=	GetArea ()
Local nPosProd 		:= 0
Local nPosB1		:= 0
Local aRet			:= {"" , 0}

nPosProd := Ascan(aProdB1, {|x| x[1] == cProd})

	If nPosProd == 0
		DbSelectArea("SB1")
		SB1->(DbSetOrder(1))

		If DbSeek(xFilial("SB1")+ cProd)
			aAdd(aProdB1, {})
			nPosB1 :=	Len (aProdB1)

			aAdd(aProdB1[nPosB1], SB1->B1_COD)
			aAdd(aProdB1[nPosB1], SB1->B1_UM)

			aRet[1] := aProdB1[nPosB1][2]
			DbSelectArea("SB0")
			SB0->(DbSetOrder(1))
			If DbSeek(xFilial("SB0")+ cProd)
				aAdd(aProdB1[nPosB1], SB0->B0_ALIQRED)
				aRet[2] := aProdB1[nPosB1][3]
			Else
				conout(STR0099 + cProd + STR0100) // "SPEDFISCAL - Produto : "#" não possui SB0"
			EndIf
		EndIf
	Else
		aRet[1] := aProdB1[nPosProd][2]
		If Len(aProdB1[nPosProd]) > 2
			aRet[2] := aProdB1[nPosProd][3]
		EndIf
	EndIf

RestArea(aArea)

Return(aRet)


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o    ³QtdeCanc  ³ Autor ³ Vendas e CRM          ³ Data ³ 29/01/09 ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³ Carrega a quantidade de produtos cancelados por cupom      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³ Uso      ³ SIGAFIS                                                    ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function QtdeCanc(cPdv, cNumNF, cSerie, dDtMovim)

Local nQtdeCanc := 0
Local aArea		:=	GetArea()

	DbSelectArea("SLX")
	SLX->(DbSetOrder(1))         //PDV + CUPOM + SERIE + ITEM

	If DbSeek(xFilial("SLX")+ cPdv + cNumNF + cSerie)
		While !SLX->(Eof()) .AND. SLX->LX_DTMOVTO == dDtMovim .AND. SLX->LX_PDV == cPdv .AND.;
				SLX->LX_CUPOM == cNumNF .AND. SLX->LX_SERIE  == cSerie

			nQtdeCanc += SLX->LX_QTDE
			SLX->(dbSkip())
		End
	EndIf

RestArea(aArea)

Return nQtdeCanc

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºPrograma  ³MsgRemoteLojaºAutor  ³Microsiga           º Data ³  07/20/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Exibe mensagem caso a chave de validacao nao seja igual.       º±±
±±º          ³                                                               º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Pela Lib Main Function SIGALOJ                                º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function MsgRemoteLoja(cValid,cFunction)
Local lRet 		:= .F.
Local lValid	:= .T.
Local cCurVersion:= "12"

Default cValid := ""
Default cFunction := ""

If cValid == "20130809CENTRALPDV" // CENTRAL DE PDV

	If Alltrim(cFunction) <> "SIGALOJ"
		Alert(STR0094) //"Nao Foi Possével Validar sua Entrada."
	Else
		lRet := .T.
		//Seta variavel estatica informando que eh central de PDV
		//Retirada da função LjSetCPDV() que não existe mais 
	EndIf

ElseIf (cValid == '20170717REMOTEPAF') .Or. (cValid == '20190624REMOTEPAF')//Mesmo Laudo para todos os modulos
	
	If Substr(cValid,1,8) == "20170717"
		MsgAlert("PAF-ECF Fora da Validade! Atualize seu PAF-ECF para o novo laudo - INA0062019" + ;
				CHR(10) + CHR(13) + "ACESSO NEGADO","PAF-ECF")
		lRet := .F.
		lValid:= .F.
	EndIf
	
	If lValid .And. (Alltrim(cFunction) == "SIGAPAF" .OR. Alltrim(cFunction) == "SIGAFRT")
		//Precisa setar antes de entrar na STBSetPaf
		__lIsPaf	:= .T.
		__lIsFunPaf	:= AllTrim(cFunction)
		If Type("nModulo") == "U"
			If cFunction == "SIGAPAF" //SIGALOJA
				nModulo := 12
			Else
				nModulo := 23
			EndIf
		EndIf
		
		lRet := STBSetPaf(Substr(cValid,1,8))
	Else
		Alert(STR0102) //"Nao Foi Possével Validar sua Entrada para o SIGAPAF"
		lRet := .F.
	EndIf

Else
	Alert(STR0094  + CHR(10) + CHR(13) +;
	 	"Verifique se o seu PAF-ECF está atualizado - Versao Atual [" + cCurVersion + "]") //"Nao Foi Possível Validar sua Entrada."
	lRet := .F.
EndIf

Return lRet

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºPrograma  ³LojXAcesso   ºAutor  ³Microsiga           º Data ³  07/20/09   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Exibe mensagem caso a chave de validacao nao seja igual.       º±±
±±º          ³                                                               º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ Venda Direta                                                  º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function LojXAcesso()
Local cNumCaixa 	:= xNumCaixa()

cNumCaixa := xNumCaixa()
If SX5->(DbSeek(xFilial("SX5")+'23'+ cNumCaixa ) )
	DbSelectArea("SLF")
	DbSetOrder(1)
	DbSeek(xFilial("SLF")+SA6->A6_COD)
	cStrAcesso:=LF_ACESSO
	If !Empty(cEstacao)
			DbSelectArea("SLG")
		If !DbSeek(xFilial("SLG")+cEstacao)
			Help(" ",1,"NOESTACAO")
		EndIf
	EndIf
Else
	cStrAcesso := Repl("N", TamSx3("LF_ACESSO")[1])
EndIf

Return

/*ÚÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄ¿±±
±±³Fun‡…o	 ³LjRecVlEmu³ Autor ³ Vendas Cliente        ³ Data ³26/10/09  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Valida se pode utilizar ECF EMULATOR                        ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³LjRecVlEmul()    										      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³ExpC1 - Tipo de Validacao a ser executada no Loja NF	      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1 - Determina se pode usar ECF E					      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³Venda Assistida											  ³±±
±±ÀÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ*/
Function LjRecVlEmul(cValidRec)
Local lRet          := .F.                        	// Valida se pode utilizar ECF E
Local lRecEmul	    := .T.                        	// Determina se o CNPJ esta liberado para usar o emulador
Local cImpressora	:= LJGetStation("IMPFISC")    	// Nome do ECF cadastrado para a estacao
Local lMsgRec	 	:= .F.							// Nao mostrar mensagem de aviso de expiracao do prazo para uso
													// de impressora nao fiscal no recebimento de titulos
Default cValidRec		:= "1"								// Como default e utilizado a validacao de CNPJ E Data de vencimento

If "EMULATOR" $ Upper(Alltrim(cImpressora))

    lRecEmul := LjRecEmul(SM0->M0_CGC	, cValidRec	, lMsgRec)

	If lRecEmul
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Se for Recebimento devera permitir o uso do emulador.³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		If lRecebe
			lRet  := .T.
		Else
			MsgStop( STR0097 ) // "Não é possível realizar esta operação com Impressora Não-Fiscal."
		EndIf
	ElseIf cEmpAnt == "99" .OR. SM0->M0_CGC == "53113791000122" .OR. LjUsaECFE(SM0->M0_CGC)
		lRet  := .T.
	Else
		MsgStop( STR0097 ) // "Não é possível realizar esta operação com Impressora Não-Fiscal."
	EndIf
Else
	lRet  := .T.
EndIf

Return lRet

/*±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±³Fun‡…o	 ³LjxBGetPaf³ Autor ³ Vendas Cliente        ³ Data ³16/12/09  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡…o ³Valida entrada no sistema sendo SIGAPAF                     ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Sintaxe	 ³LjxBGetPaf()    										      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Parametros³Nil                                                         ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ExpL1 - Se entra ou nao             					      ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso		 ³Venda Assistida											  ³±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±*/
Function LjxBGetPaf()
Local aRet 		:= {} 		// Array com informações PAf
Local lRet		:= .F.		// se esta no sigapaf.exe
Local lFrtPAF	:= .F.  // 23 = SIGAFRT
Local lPOS		:= .F.

Static lAjstPaf	:= .F.

If IsBlind()
	Aadd(aRet,.F.)
	Aadd(aRet,.F.)
Else
	lPOS := STFIsPOS() // Valida se é POS

	//Tratamento para impedir acessar um PDV PAF com SmartClient
	If Type("CEMPANT") == "C" .And. !lAjstPaf .And. ( Empty(TCGetDB()) .Or. UPPER(TcGetDb()) $ "SQLITE" )

		If Select("SX6") < 1
			DbSelectArea("SX6")
		EndIf
		
		If SuperGetMV("MV_LJPAFEC",,.F.)
			
			IF Empty(__lIsFunPaf)
				Conout("Verifique!!! Acessar módulo usando o executavel do PAF [SIGAPAF.EXE]")
				
				If nModulo == 12
					__lIsFunPaf := "SIGAPAF"
				Else
					__lIsFunPaf := "SIGAFRT"
				EndIf
			EndIf
			
			lAjstPaf	:= .T.
			lFrtPAF		:= (nModulo == 23)
		EndIf
	EndIf

	If (__lIsFunPaf $ ("SIGAPAF|SIGAFRT")) .Or. lDebug
		lRet := .T.
		If !lFrtPAF
			lFrtPAF := (__lIsFunPaf == "SIGAFRT") .Or. (nModulo == 23)
		EndIf
	EndIf

	Aadd(aRet,IIF(lPOS, STIsRotina("SIGAPAF"),AtIsRotina("SIGAPAF")) .OR. lFrtPAF .Or. lDebug .Or. lAjstPaf)
	Aadd(aRet,lRet)
EndIf

Return aRet

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºPrograma  ³LjNCCItens ºAutor  ³ Vendas Clientes    º Data ³  18/02/2010 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Adiciona item no aNCCItens.   							   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±³Parametros³ExpA1 - Array no qual seram adicionados os itens da NCC.	   º±±
±±³			 ³ExpC2 - Taxa da Moeda Localizado.							   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³SigaLoja \ FrontLoja	                                       º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function LjNCCItens(aNCC, nTaxaMoe, nMoedaCor, nDecimais, cSelNccOr )

Local   nSaldoNCC := 0             // Valor de Saldo da NCC para paises diferentes de Brasil
Local   nPosNCC  := Ascan(aNCC, {|x| x[5] == SE1->(Recno())} )

Default nTaxaMoe  	:= Nil
Default nMoedaCor 	:= 1
Default nDecimais 	:= 2
Default cSelNccOr   := ""

If cPaisLoc == "BRA"
      If nPosNCC == 0

		AAdd(aNCC,       { !Empty(cSelNccOr) , SE1->E1_SALDO     , SE1->E1_NUM               , SE1->E1_EMISSAO   ,;
							  SE1->(Recno())		, SE1->E1_SALDO 	, SuperGetMV("MV_MOEDA1")	, SE1->E1_MOEDA	  	,;
							  SE1->E1_PREFIXO		, SE1->E1_PARCELA	, SE1->E1_TIPO, SE1->E1_FILIAL }				)

      ElseIf nPosNCC > 0 .And. !Empty(cSelNccOr) //Elimino linhas repetidas
          aNCC[nPosNCC][1] := .T.
      EndIf

Else
      nSaldoNCC := Round( xMoeda(SE1->E1_SALDO	, SE1->E1_MOEDA		, nMoedaCor					, dDataBase	,;
      					  nDecimais+1			, Nil				, nTaxaMoe)					, nDecimais	)

		AAdd(aNCC, 		{ .F.					, nSaldoNCC			, SE1->E1_NUM				, SE1->E1_EMISSAO	,;
							  SE1->(Recno())		, SE1->E1_SALDO		, SuperGetMV("MV_MOEDA"+Str(SE1->E1_MOEDA,1))	,;
					      SE1->E1_MOEDA			, SE1->E1_PREFIXO	, SE1->E1_PARCELA			,SE1->E1_TIPO, SE1->E1_FILIAL}		)
EndIf

Return Nil

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºPrograma  ³LjDadosEcf ºAutor  ³ Vendas Clientes    º Data ³  30/12/2010 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Atualiza aDadosEcf.			   							   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³SigaLoja \ FrontLoja	                                       º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function LjDadosEcf()
Local cMfAdic 	:= ""
Local cTipoEcf	:= ""
Local cModelo	:= ""
Local cVerSB	:= ""
Local cDtInsSB	:= ""
Local cHrInsSB	:= ""
Local cCodECF	:= ""
Local nUsuEcf	:= 0
Local cSeriePDV	:= ""
Local cRet := ""

If Len(aDadosEcf) < 1
	// Recupera letra indicativa de MF adicional
	If IFStatus(nHdlECF, "24", @cMfAdic) <> 0
		Return .F.
	EndIf

	// Recupera Tipo de ECF
	If IFStatus(nHdlECF, "25", @cTipoEcf) <> 0
		Return .F.
	EndIf

	// Recupera Modelo do ECF
	If IFStatus(nHdlECF, "27", @cModelo) <> 0
		Return .F.
	EndIf

	// Recupera Versão atual do Software Basico do ECF gravada na MF
	If IFStatus(nHdlECF, "28", @cVerSB) <> 0
		Return .F.
	EndIf

	// Recupera Data de instalacao da versao atual do Software Basico do ECF
	If IFStatus(nHdlECF, "29", @cDtInsSB) <> 0
		Return .F.
	EndIf

	// Recupera Horario de instalacao da versao atual do Software Basico do ECF
	If IFStatus(nHdlECF, "30", @cHrInsSB) <> 0
		Return .F.
	EndIf

	// Recupera Codigo Nacional do ECF
	If IFStatus(nHdlECF, "40", @cCodECF) <> 0
		Return .F.
	EndIf

	// Recupera N de ordem do usuario do ECF relativo respectiva Reducao Z
	If IFPegPDV(nHdlECF, @cRet) <> 0
		Return .F.
	EndIf
	nUsuEcf := Val(cRet)

	// Serie do Ecf
	If IFPegSerie(nHdlECF, @cSeriePDV) <> 0
		Return .F.
	EndIf

	//Atualiza Matriz
	aAdd(aDadosEcf, {"24"	,	cMfAdic})
	aAdd(aDadosEcf, {"25"	,	cTipoEcf})
	aAdd(aDadosEcf, {"27"	,	cModelo})
	aAdd(aDadosEcf, {"28"	,	cVerSB})
	aAdd(aDadosEcf, {"29"	,	cDtInsSB})
	aAdd(aDadosEcf, {"30"	,	cHrInsSB})
	aAdd(aDadosEcf, {"40"	,	cCodECF})
	aAdd(aDadosEcf, {"PDV"	,	nUsuEcf})
	aAdd(aDadosEcf, {"SERIE",	cSeriePDV})

	//Grava em arquivo para que possa recuperar as informações quando ECF estiver desligado
	//verifica se a Z esta pendente porque qdo nesse status nao captura todas as informações
	// do ECF e causa falta de informação prejudicando o relatorio de Movimento por ECF
	If !(IFStatus(nHdlECF, "8", @cRet) == 10) .AND. FindFunction("LjxELeCria")
		LjxELeCria(.T.,aDadosEcf)
	EndIf
EndIf

Return Nil


/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LjChkHtml ºAutor  ³Vendas/CRM          º Data ³  08/09/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³ Verifica se o protheus esta sendo executado pelo           º±±
±±º          ³ SmartClient HTML - Release 11.5                            º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³ SIGALOJA/SIGAFRT/SIGACRD                                   º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/

Function LjChkHtml ()
Local lLibHtml 	:= FindFunction("IsDirLocal")	// Verifica se as funcoes para tratamento do remote HTML estao compiladas no RPO.
Local lHtml			:= .F.							// Indica se e remote HTML.

If lLibHtml
	lHtml := IsHTML()
EndIf

Return lHtml

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LjIsUsrSupºAutor  ³ Vendas Clientes    º Data ³ 14/Out/11   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Verifica se o usuario eh o SUPERIOR.                        º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºParametros³ ExpC1 - ID (codigo) do usuario a ser verificado.           º±±
±±º          ³ ExpA2 - Array com os usuarios do Sistema. Padrao AllUsers()º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºRetorno   ³.T.=Eh usuario Superior ou .F.=Nao eh usuario Superior.     º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³SIGALOJA                                                    º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LjIsUsrSup(cIDUsr,aAllUsers)
Local lRet 		:= .F.

Default aAllUsers := AllUsers()  	// Array com todos os usuarios do Sistema

//Verifica se eh o SUPERIOR de pelo menos um usuario
If aScan(aAllUsers, { |x| cIDUsr $ x[1,11] } ) > 0
	lRet := .T.
EndIf

Return lRet

/*
ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
±±ºPrograma  ³LjGetInfEcfºAutor  ³ Vendas Clientes    º Data ³  25/11/2011 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Retorna valor armazenado em aDadosEcf.					   º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±³Parametros³cTipo - Tipo do valor do ECF.								   º±±
±±³			 ³cValor - Variavel para armazenar o Valor do Ecf solicitado.  º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³SigaLoja \ FrontLoja	                                       º±±
±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
*/
Function LjGetInfEcf(cTipo, cValor )
Local nPos

//PAF-ECF: Atualiza dados do ECF para ser utilizado no Movimento por ECF

If Len(aDadosEcf) == 0 //Caso necessario busca do arquivo de backup, quando o ECF estiver desligado
	LjxELeCria( .F. , @aDadosEcf)
EndIf

nPos 	:= Ascan(aDadosEcf, { |x| x[1] == cTipo } )

If nPos > 0
	cValor 	:= aDadosEcf[nPos][2]

	If Empty(AllTrim(cValor)) .AND. (cTipo == "29" .OR. cTipo == "30")
		LjxELeCria( .F. , @aDadosEcf)
		nPos 	:= Ascan(aDadosEcf, { |x| x[1] == cTipo } )
		If nPos > 0
			cValor 	:= aDadosEcf[nPos][2]
		EndIf
	EndIf
EndIf

Return Nil

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±ºPrograma  ³LjChecaDLLsºAutor  ³ Vendas Clientes    º Data ³  11/01/2012 º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºDesc.     ³Verifica a existência e chama a função de validação das DLLs.º±±
±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
±±ºUso       ³SigaLoja \ FrontLoja	                                       º±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function LjChecaDLLs()

If ExistBlock("LJ7109")
	LjGrvLog( NIL, "Antes da execução do P.E. LJ7109")
	ExecBlock( 'LJ7109',.F.,.F., )
	LjGrvLog( NIL, "Depois da execução do P.E. LJ7109")
EndIf

//³Verifica compatibilidade das DLLs com a versão do Protheus³
DllVsProtheus()

Return Nil

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Fun‡„o    |LjHomolPaf³ Autor ³ Vendas Clientes       ³ Data ³12/07/12  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Verifica Processo de Homologacao			              	  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ Se processo de homologacao ativado						  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Uso       ³ SIGALOJA                                                   ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function LjHomolPaf()

If lHomolgPaf == Nil
	lHomolgPaf := STBHomolPaf()
EndIf

Return lHomolgPaf

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Fun‡„o    |LjLimpStat³ Autor ³ Vendas Clientes       ³ Data ³24/02/14  ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Limpa as variaveis staticas do lojxfunb quando sair do orc ³±±
ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß*/
Function LjLimpStat()

__lAplicDesc 	:= .F.			//Seta a variavel de aplicacao de desconto como falso

Return Nil

/*ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
±±³Fun‡„o    |LjGtIsPafy³ Autor ³ Vendas Clientes       ³ Data ³03/09/2014³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ´±±
±±³Descri‡„o ³ Retorna o conteudo da variável LjGtIsPaf                   ³±±
±±ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´±±
±±³Retorno   ³ __lIsPaf - conteuddo da variável estática    			  ³±±
ÃÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ±±±*/
Function LjGtIsPaf()

Return __lIsPaf

//----------------------------------------------------------------
/*/{Protheus.doc} LjGetChSat
Retorna chave de ativação do cliente que esta entrando no sistema

@author  Varejo
@version P11
@since   08/07/2015
@return  cChaveSat
/*/
//----------------------------------------------------------------
Function LjGetChSat()
Return cChaveSat

//----------------------------------------------------------------
/*/{Protheus.doc} LjSetChSat
Seta chave de ativação do cliente que esta entrando no sistema

@param1   cChave
@author  Varejo
@version P11
@since   30/09/2015
@return  cChaveSat
/*/
//----------------------------------------------------------------
Function LjSetChSat(cChave)
Default cChaveSat := ""

cChaveSat := cChave

Return cChaveSat

/*/{Protheus.doc} LjClaSlxCa()
Rotina para limpar o array  aSLX_Canc                  
@author  caio.okamoto
@version P12.17
@since   24/12/2019
@return                                                                         
/*/
//--------------------------------------------------------
Function LjClaSlxCa()
	aSLX_Canc := {} //Limpa a variavel para nao influenciar na proxima venda
Return 

/*/{Protheus.doc} LjGTaSlxCa()
Rotina para Get do aSLX_Canc SLX->(RECNO()) do item a ser cancelado                 
@author  caio.okamoto
@version P12.17
@since   24/12/2019
@return  aSLX_Canc                                                                        
/*/
//--------------------------------------------------------
Function LjGTaSlxCa()
Return aSLX_Canc

//-------------------------------------------------------------------
/*/{Protheus.doc} LjGetFrmw
Retorna a versão do Firmware da impressora não fiscal

@param   	
@author  	eduardo.sales
@version 	P12
@since   	27/03/2020
@return		cVerFirm - Versão do Firmware da Impressora Não Fiscal
/*/
//-------------------------------------------------------------------
Function LjGetFrmw()
Return cVerFirm


//-------------------------------------------------------------------
/*/{Protheus.doc} LjRstStLoja
Reinicializa todos os Static e Public deste fonte

@type function
@param   	nil
@author  	marisa.cruz
@version 	P12
@since   	05/06/2020
@return		nil
/*/
//-------------------------------------------------------------------
Function LjRstStLoja()

//Finaliza Método oAutocom
If GetAPOInfo("AUTOCOM.PRW")[4] >= CTOD("11/06/2020") .AND. Type("oAutocom") == "O"
	oAutocom:Finish()
EndIf

//Variáveis Public
oAutocom := nil
lStartLoja := nil

//Variáveis Static
nHdlDisplay := -1
nHdlBalanca := -1
nHdlDispTor	:= -1
lUsaBalanca := .F.
aTransAtu	:= {,,,,}
lEnvDesf	:= .F.
nHandTerm	:= -1					// Arquivo de controle de numeracao do terminal TEF
lImpTk		:= .F.					// Imprimi tiket para australia Imp Não fical (ECNF)
__lAplicDesc:= .F.					// Variavel logica de aplicacao do desconto
__nDescPer	:= 0					// Variavel com a porcentagem de desconto
__nDescLoj	:= 0					// Variavel com o valor de desconto
__cCodOrca	:= ""					// Variavel com o codigo do orcamento
__nPosIt	:= 0					// Variavel com o numero do item
aCNPJDV     := {}              		// CNPJs validos para uso do ECF E
aCNPJDVPRC  := {}              		// CNPJs validos para atualizacao de preco
aUsers		:= Nil						// Array com todos os usuarios do Sistema
oTotvsApi	:= Nil					//Objeto do tipo LJCTotvsApi, responsavel em fazer comunicacao com totvsapi.dll / totvsapi.so
__lIsPaf	:= .F.					//Variavel responsavel para saber se esta sendo executado do SIGAPAF.exe
__lIsFunPaf := ""               	//Variavel responsavel para armazenar o modulo/funcao que esta sendo executada.
cSenha		:= "******"				//Variavel apagada pelo Framework
lDebug		:= .F.	
aDadosEcf	:= {}					//PAF-ECF: Salva dados do ECF, movimento por ecf é emitido com o ECF desligado
aCxMov 		:= {}	   				//Array para consulta de caixas com movimentação
lImpENF 	:=  .T.					//Se impressora nao fiscal esta comunicando corretamente.
lHomolgPaf	:= Nil
cChaveSat	:= ""					//Chave de ativação SAT
aSLX_Canc 	:= {}
cVerFirm	:= ""					//Armazena o Firmware da Impressora (Daruma DR800)

Return nil

//-------------------------------------------------------------------
/*/{Protheus.doc} Lj7DelSC1
	(Apagar Solictações de Compras, que tiveram suas reservas canceladas e não tiveram nenhuma ação. 
	Ex: Solicitação atendida ou atendida parcialmente)

	@author 	Gilmar Costa
	@since 		22/10/2020
	@version 	P12
	@param 		Número do Orçamento(SL2->L2_NUM)
	@return     Nil

/*/
//-------------------------------------------------------------------
Function Lj7DelSC1(cOrcamento, cLojaRes, cProduto, nQuant )
Local cFilAux 		:= cFilAnt		// Guarda Filial original 
Local cFilTrab		:= ""			// Filial da loja que foi feita reserva
Local cFilialSC1	:= ""			// Filial que foi feita Solicita de Compras
Local cAliasSC1		:= GetNextAlias()
Local cQuery		:= ""

Default cLojaRes	:= ""			// Loja que foi gerada a reserva
Default cOrcamento  := ""			// Número do orçamento(SL2->L2_NUM)
Default cProduto	:= ""			// Produto da solicitação de Compras
Default nQuant		:= 0			// Quantidade da Solicitação de Compras

If SLJ->(dbSeek(xFilial("SLJ")+cLojaRes))
	cFilTrab 	:= SLJ->LJ_RPCFIL
Endif

If !Empty(cFilTrab) .AND. !Empty(cOrcamento)
	
	cFilAnt 	:= cFilTrab				
	cFilialSC1	:= xFilial("SC1")		

	// Trecho para caso a rotina for acionada ao deletar o item na linha do orçamento
	// para soh deletar a solicitação do item da linha.
	If !Empty(cProduto) .AND. nQuant > 0

		cQuery := " SELECT C1_FILIAL, C1_NUM, C1_PRODUTO, C1_QUANT, C1_ORCAM, R_E_C_N_O_ AS RECNOSC1 "
		cQuery += " FROM " + RetSQLName("SC1") + " SC1 "
		cQuery += " WHERE SC1.C1_FILIAL = '" + cFilialSC1 + "'"
		cQuery += " AND SC1.C1_ORCAM 		= '" + cOrcamento + "' "
		cQuery += " AND SC1.C1_PRODUTO		= '" + cProduto + "' "
		cQuery += " AND SC1.C1_QUANT		= " + Str(nQuant) + " "
		cQuery += " AND SC1.D_E_L_E_T_ 	= ' ' "

		LJa801ExQu(cAliasSc1,@cQuery)		

		If !(cAliassc1)->(EOF())
			SC1->(dbgoto((cAliassc1)->RECNOSC1))
			RecLock("SC1",.F.)
			SC1->(dbDelete())
			SC1->(MsUnLock())
		Endif

		(cAliasSc1)->(DbCloseArea())

	Else		

		SC1->( DbSetOrder(10) ) //C1_FILIAL+C1_ORCAM
		If  SC1->( DbSeek(cFilialSC1+cOrcamento) )
			While SC1->( !(Eof()) .And. (SC1->C1_FILIAL) == cFilialSC1 .And. (SC1->C1_ORCAM == cOrcamento) )
				If Lj7VerifSC1() // Verifica se a SolicitaçãO de Compras não contém pendências e pode ser excluída
					RecLock("SC1",.F.)
					SC1->(dbDelete())
					SC1->(MsUnLock())
				EndIf
				SC1->(DbSkip())	
			End	
		EndIf
	EndIf

EndIf	
// Retorna para Filial de original
cFilAnt := cFilAux	
Return Nil

//-------------------------------------------------------------------
/*/{Protheus.doc} Lj7VerifSC1
	(Verifica se a Solictação de Compras possui pedências e pode ser excluída)

	@author 	Gilmar Costa
	@since 		22/10/2020
	@version 	P12
	@param 		Nil
	@return     lRet - Retorrna se a Solicitação pode ser excluída
	@example
	(examples)
	@see (links_or_references)
	/*/
//-------------------------------------------------------------------	
Function Lj7VerifSC1()
Local aAreaSC1 	:= SC1->(GetArea())     // Guarda àrea SC1
Local lRet     	:= .T.					// Retorna se a Solicitação pode ser excluída

Do Case
	Case SubStr(SC1->C1_TX,1,1)=="R" .And. SubStr(SC1->C1_TX,2,1)<>" "
		// C1_TX	- Flag para Transmissao		
		lRet :=.F.
		// Problema: Registro utlizado em transmissão não pode ser alterado.
		// Solução: Verifique este registro, pois foi recebido através de transmissão (C1_TX)
		Help(" ",1,"PORTRANS")
	Case SC1->C1_COMPRAC # '1' .And. (SC1->C1_QUJE >= SC1->C1_QUANT .Or. SC1->C1_QUJE > 0)
		// C1_COMPRAC - Em compra centralizada?
		// C1_QUJE	  - Quantidade em Pedido	
		// C1_QUANT	  - Quantidade da SC	
		lRet :=.F.		
		// Problema: Solicitação de compra não pode ser excluída, pois já foi gerado pedido desta solicitação.
		// Solução: Verifique a quantidade entregue desse produto.
		Help(,, "A110EXC",, "Solicitação de compra não pode ser excluída, pois já foi gerado pedido desta solicitação.", 1, 0,,,,,,{"Verifique a quantidade entregue desse produto."})
	Case (!Empty(SC1->C1_COTACAO) .And. !SubStr(SC1->C1_COTACAO,1,6)$"IMPORT#XXXXXX")
		// C1_COTACAO - Numero da cotacao gerada		
		lRet :=.F.
		// Problema: Não é permitido a alteração ou exclusão das Solitações com Cotações em aberto.
		// Selecione outra Solicitação.
		Help(" ",1,"A11006")
	Case SC1->C1_TPOP == "P" .And. !Empty(SC1->C1_OP)
		// C1_TPOP - Tipo da Ordem de Producao	
		// C1_OP   - Ordem de Producao
		lRet :=.F.
		// Problema: A ordem de Produção digitada não pode ser movimentada pois ainda é prevista.
		// Solução: Transforme a Ordem de Produção em uma ordem firme ou digite uma ordem válida.
		Help("  ",1,"NOPPREVIST")	
	Case SC1->C1_FLAGGCT == "1"
		// C1_FLAGGCT - Controle de Contrato			
		lRet := .F.
		// Problema: Esta solicitação está sendo atendida por contrato e não poderá ser excluída
		Aviso("SIGAGCT","Esta solicitação está sendo atendida por contrato e não poderá ser excluída.",{"Ok"}) //-- Esta solicitação está sendo atendida por contrato e não poderá ser excluída. ##"Ok"
	Case SC1->C1_TIPO == 2
		// C1_TIPO - Controle de SC ou SI		
		lRet := .F.
		// Utilize a rotina Solicitação de Importação para manutenção das Solicitações de importação geradas por esta rotina.
		Help(" ",1,"A113TIPO")
	Case !Empty(SC1->C1_NUM_SI)
		// C1_NUM_SI - Num. Solic. de Importacao		
		lRet := .F.
		// Problema: Solicitação de Compras não poderá ser excluída.
		// Solução: A solicitação de importação vinculada a esta SC deverá ser excluída através do módulo SIGAEIC
		Help(" ",1,"ITEMIMPORT")
EndCase

SC1->(RestArea(aAreaSC1))
Return(lRet)

//-------------------------------------------------------------------
/*/{Protheus.doc} CriaPgSEFAZ
Alimenta array com a lista de formas de pagamento que devem ser enviados para SEFAZ nos documentos eletrônicos (NFC-e e NF-e).

@author  eduardo.sales
@since   11/03/2021
@version P12
@param 	 aDadosMHW, Array, Array passado por referência para ser alimentado com as informações de Meios de Pagamentos definidos pela SEFAZ.
@return	 Nil, Nulo
/*/
//-------------------------------------------------------------------
Static Function CriaPgSEFAZ(aDadosMHW)

//--------------------------------------------
//	Meios de Pagamentos SEFAZ - Tag <tPag>
//--------------------------------------------
//            	MHW_TIPO, MHW_CONTEU, MHW_CDNFCE
aAdd( aDadosMHW, { "PG"	, 	"R$"	, 	"01" } )	// 01=Dinheiro
aAdd( aDadosMHW, { "PG"	, 	"CH"	, 	"02" } )	// 02=Cheque
aAdd( aDadosMHW, { "PG"	, 	"CC"	, 	"03" } )	// 03=Cartão de Crédito
aAdd( aDadosMHW, { "PG"	, 	"CD"	, 	"04" } )	// 04=Cartão de Débito
aAdd( aDadosMHW, { "PG"	, 	"CLJ"	, 	"05" } )	// 05=Cartão da Loja (Private Label)
aAdd( aDadosMHW, { "PG"	, 	"VA"	, 	"10" } )	// 10=Vale Alimentação
aAdd( aDadosMHW, { "PG"	, 	"VR"	, 	"11" } )	// 11=Vale Refeição
aAdd( aDadosMHW, { "PG"	, 	"VP"	, 	"12" } )	// 12=Vale Presente
aAdd( aDadosMHW, { "PG"	, 	"VC"	, 	"13" } )	// 13=Vale Combustível
aAdd( aDadosMHW, { "PG"	, 	"BOL"	, 	"15" } )	// 15=Boleto Bancário
aAdd( aDadosMHW, { "PG"	, 	"DC"	, 	"16" } )	// 16=Depósito Bancário
aAdd( aDadosMHW, { "PG"	, 	"PX"	, 	"17" } )	// 17=Pagamento Instantâneo (PIX) - (QR-Code Dinâmico)
aAdd( aDadosMHW, { "PG"	, 	"PD"	, 	"18" } )	// 18=Transferência bancária, Carteira Digital
aAdd( aDadosMHW, { "PG"	, 	"FID"	, 	"19" } )	// 19=Programa fidelidade, Cashback, Credito Virtual
aAdd( aDadosMHW, { "PG"	, 	"PE"	, 	"20" } )	// 20=Pagamento Instantâneo (PIX) - (QR-Code Estático ou transferência via PIX)
aAdd( aDadosMHW, { "PG"	, 	"CR"	, 	"21" } )	// 21=Crédito em Loja
aAdd( aDadosMHW, { "PG"	, 	"ENI"	, 	"22" } )	// 22=Pagamento Eletrônico Não Informado - falha de hardware do sistema emissor
aAdd( aDadosMHW, { "PG"	, 	"SPG"	, 	"90" } )	// 90=Sem Pagamentos
If ExistFunc("LjIT240002") .And. LjIT240002() //Tratamento temporario até liberação oficial SEFAZ
	aAdd( aDadosMHW, { "PG" ,   "PP"    ,   "91" } )	// 91=Pagamento Posterior
EndIf
aAdd( aDadosMHW, { "PG"	, 	"OTS"	, 	"99" } )	// 99=Outros

Return

//-------------------------------------------------------------------------------------
/*/{Protheus.doc} LJIncMHW
Popula tabela MHW.

@type       Function
@author     eduardo.sales
@since      11/03/2021
@version    P12
@param 		aDadosMHW, Array, Array com os dados a serem alimentados na tabela MHW.

@return 	Nil, Nulo
/*/
//-------------------------------------------------------------------------------------
Static Function LJIncMHW(aDadosMHW)

Local nCont		:= 0  
Local nSaveSx8 	:= GetSx8Len()
Local lAppend	:= .T.
Local cCodigo 	:= ""

INCLUI := .T.

//Carga/Atualização da tabela MHW
DbSelectArea("MHW")
MHW->(DbSetOrder(1)) //MHW_FILIAL+MHW_CODIGO+MHW_CONTEU

For nCont := 1 To Len(aDadosMHW)
	cCodigo := LjExistMHW( { {"MHW_FILIAL",xFilial("MHW")}, {"MHW_TIPO",aDadosMHW[nCont,1]}, {"MHW_CDNFCE",aDadosMHW[nCont,3]} } )
	If Empty(cCodigo)
		lAppend := .T.
	Else
		MHW->(DbSeek(xFilial("MHW")+cCodigo))
		lAppend := .F.
	EndIf
	MHW->(RecLock("MHW",lAppend))
	If lAppend
		cCodigo := CriaVar("MHW_CODIGO")
		While !Empty(LjExistMHW( { {"MHW_FILIAL",xFilial("MHW")}, {"MHW_CODIGO",cCodigo} } ))
			cCodigo := CriaVar("MHW_CODIGO")
		End
		MHW->MHW_FILIAL	:= xFilial("MHW")
		MHW->MHW_CODIGO	:= cCodigo
		MHW->MHW_TIPO	:= aDadosMHW[nCont,1]
		MHW->MHW_CDNFCE := aDadosMHW[nCont,3]
	EndIf
	MHW->MHW_CONTEU	:= aDadosMHW[nCont,2]
	MHW->(MsUnlock())
Next nCont

While (GetSX8Len() > nSaveSx8)
	ConfirmSx8()
End
                
Return Nil

//--------------------------------------------------------
/*/{Protheus.doc} Lj7RetPCC
	(Verifica se o se retem PCC de acordo com o cliente )
	@type  		Function
	@author 	Gilmar Costa
	@since 		07/04/2021
	@version 	P12
	@return 	Lógico
	/*/
//--------------------------------------------------------
Function Lj7RetPCC()
Local lRet 			:= .T. 						// Retorna se Cliente diferente "P-Empresa Pública" com Naturaza configurada para calcular PCC
Local aAreaSED		:= SED->(GetArea())			// Salva àrea SED
Local nTamSEDCod 	:= TamSx3("ED_CODIGO")[1]	// Tamanho código Natureza

/* 
Validações do Cliente
	Rec. PIS (A1_RECPIS) 		= "P" - Empresa Pública
	Rec. COFINS (A1_RECCOFI) 	= "P" - Empresa Pública
	Rec. CSLL (A1_RECCSLL) 		= "P" - Empresa Pública
	Modo de abatimento do imposto (A1_ABATIMP) = Cálculo do sistema
*/
/*
 Validações da Natureza
	Calcula PIS (ED_CALCPIS) 			= Sim
	Percentual de PIS (ED_PERCPIS) 		= Informe a alíquota
	Calcula COFINS (ED_CALCCOF) 		= Sim
	Percentual de COFINS (ED_PERCCOF) 	= Informe a alíquota
	Calcula CSLL (ED_CALCCSL) 			= Sim
	Percentual de CSLL (ED_PERCCSL) 	= Informe a alíquota
*/

// Validação dos dados do CLIENTE, conforme Documentação (SA1)
If SA1->A1_ABATIMP == "1" .AND. (SA1->A1_RECCOFI == "P" .AND. SA1->A1_RECPIS == "P" .AND. SA1->A1_RECCSLL == "P")

	// Validação dos dados da NATUREZA, conforme Documentação (SED)
	If SED->( DbSeek(xFilial("SED")+ PadR(SA1->A1_NATUREZ ,nTamSEDCod) ) )
		If (SED->ED_CALCPIS == "S" .AND. SED->ED_PERCPIS > 0) .AND. (SED->ED_CALCCOF == "S" .AND. SED->ED_PERCCOF > 0) .AND.;
		   (SED->ED_CALCCSL == "S" .AND. SED->ED_PERCCSL > 0)
			lRet := .F.   // Atendendo as condições, o retorno será Falso, para não subtrair valor dos impostos no Total da Venda
		Endif
	EndIf

EndIf
RestArea( aAreaSED )

Return lRet

//-------------------------------------------------------------------
/*/{Protheus.doc} CriaCBSEFAZ
Alimenta array com a lista de codigos de bandeiras que devem ser enviados para SEFAZ nos documentos eletrônicos (NFC-e e NF-e).

@author  caio.okamoto
@since   10/05/2021
@version P12
@param 	 aDadosMHW, Array, Array passado por referência para ser alimentado com as informações de Códigos de Bandeiras definidos pela SEFAZ.
@return	 Nil, Nulo
/*/
//-------------------------------------------------------------------
Static Function CriaCBSEFAZ(aDadosMHW)

//--------------------------------------------
//	Código da Bandeira SEFAZ - Tag <tBand>
//--------------------------------------------
//            	MHW_TIPO, 	MHW_CONTEU		, MHW_CDNFCE
aAdd( aDadosMHW, { "BD"	, "Visa"			, 	"01" } ) //01 Visa
aAdd( aDadosMHW, { "BD"	, "Mastercard"		, 	"02" } ) //02 Mastercard
aAdd( aDadosMHW, { "BD"	, "American Express", 	"03" } ) //03	American Express
aAdd( aDadosMHW, { "BD"	, "Sorocred"		, 	"04" } ) //04	Sorocred
aAdd( aDadosMHW, { "BD"	, "Diners Club"		, 	"05" } ) //05	Diners Club
aAdd( aDadosMHW, { "BD"	, "Elo"				, 	"06" } ) //06	Elo
aAdd( aDadosMHW, { "BD"	, "Hipercard"		, 	"07" } ) //07	Hipercard
aAdd( aDadosMHW, { "BD"	, "Aura"			, 	"08" } ) //08	Aura
aAdd( aDadosMHW, { "BD"	, "Cabal"			, 	"09" } ) //09	Cabal
aAdd( aDadosMHW, { "BD"	, "Alelo"			, 	"10" } ) //10	Alelo
aAdd( aDadosMHW, { "BD"	, "Banes Card"		, 	"11" } ) //11	Banes Card
aAdd( aDadosMHW, { "BD"	, "CalCard"			, 	"12" } ) //12	CalCard 
aAdd( aDadosMHW, { "BD"	, "Credz"			, 	"13" } ) //13	Credz
aAdd( aDadosMHW, { "BD"	, "Discover"		, 	"14" } ) //14	Discover
aAdd( aDadosMHW, { "BD"	, "GoodCard"		, 	"15" } ) //15	GoodCard
aAdd( aDadosMHW, { "BD"	, "GreenCard"		, 	"16" } ) //16	GreenCard
aAdd( aDadosMHW, { "BD"	, "Hiper"			, 	"17" } ) //17	Hiper
aAdd( aDadosMHW, { "BD"	, "JcB"				, 	"18" } ) //18	JcB
aAdd( aDadosMHW, { "BD"	, "Mais"			, 	"19" } ) //19	Mais
aAdd( aDadosMHW, { "BD"	, "MaxVan"			, 	"20" } ) //20	MaxVan
aAdd( aDadosMHW, { "BD"	, "Policard"		, 	"21" } ) //21	Policard
aAdd( aDadosMHW, { "BD"	, "RedeCompras"		, 	"22" } ) //22	RedeCompras
aAdd( aDadosMHW, { "BD"	, "Sodexo"			, 	"23" } ) //23	Sodexo
aAdd( aDadosMHW, { "BD"	, "ValeCard"		, 	"24" } ) //24	ValeCard
aAdd( aDadosMHW, { "BD"	, "Verocheque"		, 	"25" } ) //25	Verocheque
aAdd( aDadosMHW, { "BD"	, "VR"				, 	"26" } ) //26	VR
aAdd( aDadosMHW, { "BD"	, "Ticket"			, 	"27" } ) //27	Ticket
aAdd( aDadosMHW, { "BD"	, "Outros"			, 	"99" } ) //99	Outros

Return


//-------------------------------------------------------------------
/*/{Protheus.doc} LjComparti
Essa função tem como objetivo apenas verificar o nivel de compartilhamento
entre tabelas que são relacionadas.

@author  Bruno Almeida
@since   18/02/2022
@version P12
@return	 Nil
/*/
//-------------------------------------------------------------------
Static Function LjComparti()

Local aTabelas 	:= {{"SLG","MDG"}} //Contém todas as tabelas para realizar a comparação do compartilhamento
Local aComparti	:= {} //Armazena o compartilhamento das tabelas relacionadas no array aTabelas
Local nI		:= 0 //Variavel de loop
Local nX		:= 0 //Variavel de loop
Local lMensag	:= .F. //Controla se apresenta ou a mensagem ao usuario sobre o compartilhamento
Local cTabelas	:= "" //Tabelas que foram comparadas em nivel de compartilhamento
Local aArea    	:= GetArea() //Salva a area

For nI = 1 To Len(aTabelas)

	For nX := 1 To Len(aTabelas[nI])
		If AliasInDic(aTabelas[nI][nX])
			dbSelectArea(aTabelas[nI][nX])
			If (aTabelas[nI][nX])->(RecCount()) > 0
				Aadd(aComparti,{})
				Aadd(aComparti[nX],aTabelas[nI][nX])
				Aadd(aComparti[nX],FWModeAccess(aTabelas[nI][nX],1))
				Aadd(aComparti[nX],FWModeAccess(aTabelas[nI][nX],2))
				Aadd(aComparti[nX],FWModeAccess(aTabelas[nI][nX],3))
			Else
				Loop
			EndIf
		Else
			Loop
		EndIf
	Next nX
	
	If Len(aComparti) > 1
		For nX := 2 To Len(aComparti)
			If 	aComparti[1][2] <> aComparti[nX][2] .OR.;
				aComparti[1][2] <> aComparti[nX][3] .OR.;
				aComparti[1][2] <> aComparti[nX][4]

				lMensag := .T.
				Exit
			EndIf
		Next nX

		If lMensag
			For nX := 1 To Len(aComparti)
				cTabelas += aComparti[nX][1] + IIF((nX + 1) == Len(aComparti)," e ", ", ")
			Next nX
			MsgAlert(STR0164 + SubStr(AllTrim(cTabelas),1,Len(AllTrim(cTabelas)) - 1) + STR0165, STR0010) //"O compartilhamento das tabelas " # " estão diferentes, essas tabelas devem ter o mesmo nivel de compartilhamento." # "Atenção"
			LjGrvLog("",STR0164 + SubStr(AllTrim(cTabelas),1,Len(AllTrim(cTabelas)) - 1) + STR0165)
		EndIf
	EndIf

	cTabelas 	:= ""
	lMensag		:= .F.
	aComparti 	:= {}
Next nI

RestArea( aArea )

Return Nil

//-------------------------------------------------------------------
/*/{Protheus.doc} LjExistMHW
Verifica se existe registro na tabela MHW.

@author  Alberto Deviciente
@since   02/05/2024
@version P12

@param 	 aChave, Array, Array com o(s) campos e conteudo(s) do(s) campo(s) a ser considerado(s) no filtro
@return	 Caractere, Codigo relacionado ao campo MHW_CODIGO do registro encontrado na tabela MHW.
/*/
//-------------------------------------------------------------------
Static Function LjExistMHW( aChave )
Local cQuery	   	:= ""
Local nX 			:= 0
Local cRetCod	   	:= ""
Local oPrepared    	:= Nil

cQuery := "SELECT MHW_CODIGO "
cQuery += "FROM " + RetSqlName("MHW") + " "
For nX:=1 To Len(aChave)
	If nX == 1
		cQuery += "WHERE "+aChave[nX][1]+" = ? "
	Else
		cQuery += "AND "+aChave[nX][1]+" = ? "
	EndIf
Next nX
cQuery += "AND D_E_L_E_T_ = ' ' "

cQuery := ChangeQuery(cQuery)

oPrepared:=FWPreparedStatement():New(cQuery)

For nX:=1 To Len(aChave)
	oPrepared:SetString(nX, PadR(aChave[nX][2], TamSx3(aChave[nX][1])[1], " "))
Next nX

cQuery:=oPrepared:GetFixQuery()

cRetCod := MpSysExecScalar(cQuery,"MHW_CODIGO")

If oPrepared != NIL
	oPrepared:Destroy()
	oPrepared := NIL
Endif

Return cRetCod

//-------------------------------------------------------------------
/*/{Protheus.doc} LjMsgInfo
Exige mensagem de informação importante ao usuário.

@author  Alberto Deviciente
@since   10/10/2025
@version P12

@param 	 nDialogLar, Num?ico, Largura da Tela
@param 	 nDialogAlt, Num?ico, Altura da Tela
@param 	 cTitulo, Caractere, T?ulo da Tela
@param 	 cTexto, Caractere, Texto a ser exibido na Tela (Texto simples ou em formato HTML)
@param 	 lHtml, L?ico, Indica se o texto ?HTML
@param 	 cUrl, Caractere, URL com informações adicionais sobre o assunto do texto
@param 	 cChaveProf, Caractere, Chave do Profiler para controlar se deve ou n? continuar apresentando a mensagem nos próximos nQtdeDias dias
@param 	 nQtdeDias, Num?ico, Quantidade de Dias de intervalo para n? apresentar a mensagem novamente

@return	 Nil, Nulo
/*/
//-------------------------------------------------------------------
Function LjMsgInfo(nDialogLar, nDialogAlt, cTitulo, cTexto, lHtml, cUrl, cChaveProf, nQtdeDias)
Local aButtons		:= {}
Local lContinua		:= .F.
Local lAdmin		:= FWIsAdmin( __cUserID )
Local oModal		:= Nil
Local nMargem		:= 03
Local nScrBoxLar 	:= nDialogLar-(2*nMargem)
Local nScrBoxAlt 	:= nDialogAlt-(2*nMargem)-45
Local nSayLar 		:= nScrBoxLar-8
Local nSayAlt 		:= nScrBoxAlt-8
Local oProfile		:= Nil
Local oScrBox		:= Nil
Local oSay			:= Nil
Local cRetProf		:= ""

Default nDialogLar	:= 300
Default nDialogAlt	:= 150
Default cTitulo		:= STR0180 //"I M P O R T A N T E"
Default lHtml 		:= .F.
Default cUrl 		:= ""	

oProfile := FWProfile():New()
oProfile:SetUser( RetCodUsr() )
oProfile:SetProgram(cChaveProf)
oProfile:SetTask(cChaveProf)
oProfile:Load()

cRetProf := oProfile:GetStringProfile()

If Empty( cRetProf ) .or. DateDiffDay( Date(), SToD( cRetProf ) ) >= nQtdeDias
	lContinua := .T.
EndIf

If lContinua

	oModal := FWDialogModal():New()
	oModal:SetEscClose(.T.)
	oModal:SetTitle(cTitulo)
	oModal:SetSize(nDialogAlt,nDialogLar)
	oModal:CreateDialog()

	If !Empty(cUrl)
		AAdd(aButtons, {'',STR0181, { || FWOpenInClient():OpenURLInClient(cUrl)  },Nil,0,.T.,.F.} ) //"Saiba mais..."
	EndIf

	/*If nQtdeDias > 1
		If !lAdmin
			AAdd(aButtons, {'',STR0182+cValToChar(nQtdeDias)+STR0183, { || oProfile:SetStringProfile(DToS(Date())), oProfile:Save(), oModal:Deactivate() },Nil,0,.T.,.F.} ) //"N? exibir essa mensagem nos pr?imos " ### " dias"
		EndIf
	EndIf*/

	oModal:AddButtons(aButtons)

	oModal:AddCloseButton(nil, STR0184) //"Fechar"

	oScrBox := TScrollBox():New( oModal:GetPanelMain(), nMargem, nMargem, nScrBoxAlt, nScrBoxLar,.T.,.T.,.T.)

	oSay := TSay():New(03,03,{|| cTexto },oScrBox,,Nil,,,,.T.,,,nSayLar,nSayAlt,,,,,,lHtml)
	
	oModal:Activate()

EndIf

Return Nil



//-------------------------------------------------------------------
/*/{Protheus.doc} LJSATMFE
	Valida a data limite de utilização do SAT e MF-e exibindo msg de alerta para troca até 31/12, e após isso
	msg orientando para que mude para NFc-e
	@type  Function
	@author caio.okamoto
	@since 03/12/2025
	@version 12.1.2510
	/*/
Static Function LJSATMFE()
Local lEmitSAT		:= LjUseSat()	//Verifica se a empresa utiliza SAT ou MFe
Local cTPEmis   	:= IIF( ExistFunc("LjSiglaSat"),LjSiglaSat(), "SAT" )
Local cUrlDocSat 	:= "https://tdn.totvs.com/pages/viewpage.action?pageId=994631028" // tdn: SAT SP
Local cMsgAlert		:= ""
Local cUrlDocMFe 	:= "https://tdn.totvs.com/pages/viewpage.action?pageId=994631772" // tdn: MFe CE
Local cDTSATMF  	:= SuperGetMV("MV_LJSATMF",.F., "01/01/2026") // Data para mudança de SAT/MFe para NFC-e


If (nModulo == 12 .OR. nModulo == 23) .AND. lEmitSAT 

	If cTPEmis == "SAT"

		If Date() <= cTod(cDTSATMF)
			cMsgAlert := "A partir de 01/01/2026, de acordo com o Artigo 34 da Portaria CAT 147/2012 da Portaria SRE nº 79/2024, não será mais permitido o uso de equipamento SAT para emissão cupom fiscal eletrônico." 
			cMsgAlert += Chr(13)+Chr(10)+Chr(13)+Chr(10)
			cMsgAlert += "Desta forma, passará a ser obrigatória a emissão de cupom fiscal somente através de NFC-e (Nota Fiscal de Consumidor Eletrônica)."
			cMsgAlert += Chr(13)+Chr(10)+Chr(13)+Chr(10)
			cMsgAlert += "Veja mais detalhes clicando no botão [Mais info]"
		ElseIf Date() > cTod(cDTSATMF)
			cMsgAlert := "A partir de 01/01/2026, de acordo com o Artigo 34 da Portaria CAT 147/2012 da Portaria SRE nº 79/2024, não é permitido o uso de equipamento SAT para emissão cupom fiscal eletrônico." 
			cMsgAlert += Chr(13)+Chr(10)+Chr(13)+Chr(10)
			cMsgAlert += "Desta forma, passa a ser obrigatória a emissão de cupom fiscal somente através de NFC-e (Nota Fiscal de Consumidor Eletrônica)."
			cMsgAlert += Chr(13)+Chr(10)+Chr(13)+Chr(10)
			cMsgAlert += "Para conseguir utilizar o sistema é necessário acessar com usuário Administrador e alterar o Cadastro de Estação para o regime de vendas NFC-e."
			cMsgAlert += Chr(13)+Chr(10)+Chr(10)
			cMsgAlert += "Veja mais detalhes clicando no botão [Mais info]"		
		EndIf

		LjMsgInfo(300, 150, Nil, cMsgAlert, .T., cUrlDocSAT, "AVISO_SAT_MFE", 7)

		If Date() > cTod(cDTSATMF)
			Final("Não é permitido acessar o sistema configurado com equipamento SAT", "O sistema será finalizado!" )
		EndIf

	ElseIf cTPEmis == "MFe"
	
		If Date() <= cTod(cDTSATMF)
			cMsgAlert := "A partir de 01/01/2026, A Secretaria da Fazenda do Ceará (Sefaz-CE) reitera que desde 1º de fevereiro de 2025 tornou facultativa a emissão do Cupom Fiscal Eletrônico (CF-e) por meio dos Módulos Fiscais Eletrônicos (MFE)." 
			cMsgAlert += Chr(13)+Chr(10)+Chr(13)+Chr(10)
			cMsgAlert += "Desta forma, passa a ser obrigatória a emissão de cupom fiscal somente através de NFC-e (Nota Fiscal de Consumidor Eletrônica)."
			cMsgAlert += Chr(13)+Chr(10)+Chr(13)+Chr(10)
			cMsgAlert += "Para conseguir utilizar o sistema após essa data será necessário acessar com usuário Administrador e alterar o Cadastro de Estação para o regime de vendas NFC-e."
			cMsgAlert += Chr(13)+Chr(10)+Chr(13)+Chr(10)
			cMsgAlert += "Veja mais detalhes clicando no botão [Mais info]"
		ElseIf Date() > cTod(cDTSATMF)
			cMsgAlert := "A partir de 01/01/2026, A Secretaria da Fazenda do Ceará (Sefaz-CE) reitera que desde 1º de fevereiro de 2025 tornou facultativa a emissão do Cupom Fiscal Eletrônico (CF-e) por meio dos Módulos Fiscais Eletrônicos (MFE)." 
			cMsgAlert += Chr(13)+Chr(10)+Chr(13)+Chr(10)
			cMsgAlert += "Desta forma, passa a ser obrigatória a emissão de cupom fiscal somente através de NFC-e (Nota Fiscal de Consumidor Eletrônica)."
			cMsgAlert += Chr(13)+Chr(10)+Chr(13)+Chr(10)
			cMsgAlert += "Para conseguir utilizar o sistema é necessário acessar com usuário Administrador e alterar o Cadastro de Estação para o regime de vendas NFC-e."
			cMsgAlert += Chr(13)+Chr(10)+Chr(13)+Chr(10)
			cMsgAlert += "Veja mais detalhes clicando no botão [Mais info]"
		Endif

		LjMsgInfo(300, 150, Nil, cMsgAlert, .T., cUrlDocMFe, "AVISO_MFE", 7)

		If Date() > cTod(cDTSATMF)
			Final("Não é permitido acessar o sistema configurado com equipamento MFe", "O sistema será finalizado!" )
		EndIf

	EndIf
EndIf

Return
