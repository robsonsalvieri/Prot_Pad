#INCLUDE "TOTVS.CH"
#INCLUDE "QLTTREPORTSMANAGER.CH"

#DEFINE POS_cId          1
#DEFINE POS_cDescription 2
#DEFINE POS_cType        3
#DEFINE POS_cDisplayName 4
#DEFINE POS_cRealName    5
#DEFINE POS_cComboValues 6
#DEFINE POS_lIsRequired  7
#DEFINE POS_cRenameField 8

/*/{Protheus.doc} QLTTReportsManager
Classe responsável pelos métodos de criação e manipulação do Smart View
@author thiago.rover
@since 18/07/2023
@version 1.0
/*/
CLASS QLTTReportsManager FROM LongNameClass

    Public DATA lRetornaAninhados as Logical 

    Public METHOD aninharAliasEmPropriedade(oSelf, cIDProperty, aStruct, cAlias, jData, aCoalesce, nIndice, cCamposSeek, cChaveSeek, cDateFormat)
    Public METHOD getNestedStruct(aFields as Array) as Array
    Public METHOD getStruct(aFields, aMirrorFields, aMirrorTable)                                                                    as Array
    Public METHOD new()                                                                                                              as object
    Public METHOD formataParametroData(cParam)                                                                                       as Character
    Public METHOD retornaColunasComNovoAlias(oSelf, aTabelas, cAlias)                                                                as Character
    Public METHOD retornaColunasComNovoAliasDeCampo(oSelf, cTabela, cAlias, cPrefixoCampo)                                           as Character
    Public METHOD retornaColunasDistintasComNovoAlias(oSelf, aTabelas, cCamposChave, cAlias)                                         as Character

    Static METHOD addReportHeader(oSelf as object)
    Static METHOD addToData(oSelf, cPropertyId, cType, cFieldName, jItem, cAlias, lLinOk, lAninhada, cDateFormat)
    Static METHOD displayedSmartViewReport(cIdProt, cType, nPrintType, jPrintInfo, jParams, lRunInJob, lShowParams, lWizard, cError) as Logical
    Static METHOD getUsedSQLFields(oSelf, cUsedFields, cExternalUse)                                                                 as Character
    Static METHOD mountDefaultParams(cPerg, lExecutaPerg)                                                                            as Json

ENDCLASS

/*{Protheus.doc} getStruct
Prepara a estrutura dos campos 
@param aCpos array: Array com os campos do relatório
@return array: Array com a estrutura dos campos
@author thiago.rover
@since 18/07/2023
@version 1.0 
*/
METHOD getStruct(aFields as Array, aMirrorFields as Array, aMirrorTable as Array, lCampo as Logical) as Array CLASS QLTTReportsManager

    Local aStruct      := {}                                                                 as array
    Local aTipagem     :={{"C", "string"}, {"D", "date"}, {"N", "number"}, {"L", "boolean"}} as array
    Local cAliasECampo := ""                                                                 as character
    Local cCampo       := ""                                                                 as character
    Local cCampoX3     := ""                                                                 as character
    Local cIDJson      := ""                                                                 as character
    Local cSufLabel    := ""                                                                 as character
    Local cTipoReal    := ""                                                                 as character
    Local nContador    := 0                                                                  as numeric
    Local nMirror      := 0                                                                  as numeric
    Local nPos         := 0                                                                  as numeric

    Default aMirrorFields := {}
    Default aMirrorTable  := {}
    Default lCampo        := .T.
    
    //Adicionando Campos Padrões da SX3
    For nContador := 1 To Len(aFields)

        cAliasECampo := aFields[nContador]
        nPos         := AT(".", aFields[nContador]) + 1
        cCampo       := Substr(cAliasECampo, nPos)
        cTipo        := GetSx3Cache(cCampo, "X3_TIPO")
        
        cTipoReal := If ((nPos := aScan(aTipagem, {|c| c[01] = cTipo})) > 0, aTipagem[nPos, 02], "string")
    
        AAdd(aStruct, {StrTran(cCampo, "_", "")                                                       ,; //cId          1
                       FWSX3Util():GetDescription(cCampo)                                             ,; //cDescription 2
                       cTipoReal                                                                      ,; //cType        3
                       FWSX3Util():GetDescription(cCampo) + IIf(lCampo,"(" + AllTrim(cCampo) + ")",""),; //cDisplayName 4
                       cCampo                                                                         }) //cRealName    5


        //Checa Existência MirrorTable
        While (nMirror := aScan(aMirrorTable, {|aItemMirror| aItemMirror[1] == Left(cAliasECampo, 3) }, nMirror + 1)) > 0
            
            nPos      := AT(".", aFields[nContador]) + 1
            cCampo    := Substr(cAliasECampo, nPos)
            cCampoX3  := cCampo
            cCampo    := StrTran(cCampo, aMirrorTable[nMirror][1], aMirrorTable[nMirror][2])
            cSufLabel := aMirrorTable[nMirror][3]

            AAdd(aStruct, {StrTran(cCampo, "_", "")                                                        ,; //cId          1
                           FWSX3Util():GetDescription(cCampoX3) + " " + cSufLabel                          ,; //cDescription 2
                           cTipoReal                                                                       ,; //cType        3
                           FWSX3Util():GetDescription(cCampoX3) + cSufLabel + "(" + AllTrim(cCampoX3) + ")",; //cDisplayName 4
                           cCampo                                                                          }) //cRealName    5

        EndDo
        

    Next nContador

    //Adicionando Com Novos Alias
    For nContador := 1 To Len(aMirrorFields)

        cIDJson   := Iif(Empty(aMirrorFields[nContador][4]), StrTran(aMirrorFields[nContador][1], "_", ""), aMirrorFields[nContador][4])
        cCampo    := aMirrorFields[nContador][1]
        cCampoX3  := aMirrorFields[nContador][2]
        cSufLabel := aMirrorFields[nContador][3]
        cTipo     := GetSx3Cache(cCampoX3, "X3_TIPO")
        
        cTipoReal := If ((nPos := aScan(aTipagem, {|c| c[01] = cTipo})) > 0, aTipagem[nPos, 02], "string")
    
        AAdd(aStruct, {cIDJson                                                                         ,; //cId          1
                       FWSX3Util():GetDescription(cCampoX3) + " " + cSufLabel                          ,; //cDescription 2
                       cTipoReal                                                                       ,; //cType        3
                       FWSX3Util():GetDescription(cCampoX3) + cSufLabel + "(" + AllTrim(cCampoX3) + ")",; //cDisplayName 4
                       cCampo                                                                          }) //cRealName    5

    Next nContador

    // Adicionando estrutura dos campos auxiliares
    AADD(aStruct , {"DATAIMPR"    , STR0003, "date"  , STR0003 + "(DATA_IMPR)"     , "" }) // Data da impressão
    AADD(aStruct , {"HORAIMPR"    , STR0004, "string", STR0004 + "(HORA_IMPR)"     , "" }) // Hora da impressão
    AADD(aStruct , {"NOMEGRUPEMPR", STR0005, "string", STR0005 + "(NOME_GRUP_EMPR)", "" }) // Nome do grupo de empresas
    AADD(aStruct , {"NOMEFILIAL"  , STR0006, "string", STR0006 + "(NOME_FILIAL)"   , "" }) // Nome da filial
 
Return (aStruct)


/*{Protheus.doc} getNestedStruct
Prepara a estrutura dos campos aninhados 
@author brunno.costa
@since 06/12/2023
@version 1.0 
@param 01 - aFields, array, array com os campos do relatório para aninhar
@return aStruct: array com a estrutura dos campos para aninhar
*/
METHOD getNestedStruct(aFields as Array) as Array CLASS QLTTReportsManager

    Local aStruct      := {}                                                                 as array
    Local aTipagem     :={{"C", "string"}, {"D", "date"}, {"N", "number"}, {"L", "boolean"}} as array
    Local cAliasECampo := ""                                                                 as character
    Local cCampo       := ""                                                                 as character
    Local cTipoReal    := ""                                                                 as character
    Local nContador    := 0                                                                  as numeric
    Local nPos         := 0                                                                  as numeric
    
    //Adicionando Campos Padrões da SX3
    For nContador := 1 To Len(aFields)

        cAliasECampo := aFields[nContador]
        nPos         := AT(".", aFields[nContador]) + 1
        cCampo       := Substr(cAliasECampo, nPos)
        cTipo        := GetSx3Cache(cCampo, "X3_TIPO")
        
        If (nPos := aScan(aTipagem, {|c| c[01] = cTipo})) > 0
            cTipoReal := aTipagem[nPos, 02]

        Else
            cTipoReal := "string"

        EndIf
    
        AAdd(aStruct, {cCampo                                                          ,; //cId          1
                       FWSX3Util():GetDescription(cCampo)                              ,; //cDescription 2
                       cTipoReal                                                       ,; //cType        3
                       FWSX3Util():GetDescription(cCampo) + "(" + AllTrim(cCampo) + ")" ; //cDisplayName 4
                      })

    Next nContador
 
Return (aStruct)

/*/{Protheus.doc} addReportHeader
Adiciona dados de cabelaçho do relatório
@author brunno.costa
@since 21/11/2023
@version 1.0
@param 01 - oSelf, objeto, instancia da classe chamadora
/*/
Method addReportHeader(oSelf as object) class QLTTReportsManager

	If (oSelf:cUsedFields == "*" .OR. "DATAIMPR" $ oSelf:cUsedFields)
		oSelf:jData["DATAIMPR"]     := totvs.framework.treports.date.DateToTimeStamp(Date())    // Data da impressão Relatório
    EndIf

    If (oSelf:cUsedFields == "*" .OR. "HORAIMPR" $ oSelf:cUsedFields)
		oSelf:jData["HORAIMPR"]     := Time()                    // Hora da impressão Relatório
	EndIf

    If (oSelf:cUsedFields == "*" .OR. "NOMEGRUPEMPR" $ oSelf:cUsedFields)
		oSelf:jData["NOMEGRUPEMPR"] := AllTrim(FWArrFilAtu()[6]) // Nome do Grupo de Empresa 
	EndIf

    If (oSelf:cUsedFields == "*" .OR. "NOMEFILIAL" $ oSelf:cUsedFields)
		oSelf:jData["NOMEFILIAL"]   := AllTrim(FWArrFilAtu()[7]) // Nome da Filial
	EndIf   

Return

/*/{Protheus.doc} new
Construtor da Classe
@since 18/07/2023
@version 12.1.2210
@param Nil
@return Self, objeto, instancia da Classe QLTQueryManager
/*/
METHOD new() CLASS QLTTReportsManager
    self:lRetornaAninhados := .F.
Return Self

/*/{Protheus.doc} retornaColunasComNovoAlias
Retorna relação de campos do SCHEMA com Novo Prefixo de SubQuery
@author brunno.costa
@since 21/11/2023
@version 1.0
@param 01 - oSelf   , objeto  , instancia da classe chamadora
@param 02 - aTabelas, array   , array de tabelas para consideração
@param 03 - cAlias  , caracter, alias para consideração da subquery ou tabela após macro substituição, por exemplo, 
                                    ao passar "PRODUTO.": SB1.B1_COD    -> PRODUTO.B1_COD
                                    ao passar NULL      : QE7.QE7_LABOR -> NULL QE7_LABOR (util em querys com union all de QE7 e QE8 quando deseja configurar uso de campos personalizados, entre outros)
/*/
METHOD retornaColunasComNovoAlias(oSelf as Object, aTabelas as Array, cAlias as Character) as CHARACTER CLASS QLTTReportsManager

    Local cCampos    := ""
    Local cCamposAux := ""
    Local nIndTabela := 0
    Local nTotal     := 0
    
    cCamposAux  := oSelf:getSQLFields(.T., aTabelas, , self:lRetornaAninhados)
    cCampos     += Iif(!Empty(cCamposAux), ",", "") + cCamposAux

    If !Empty(cAlias)
        nTotal := Len(aTabelas)
        For nIndTabela := 1 to nTotal
            cCampos := StrTran(cCampos, aTabelas[nIndTabela] + ".", "*****.")
        Next
        cCampos := StrTran(cCampos, "*****.", cAlias)
    EndIf
    
RETURN cCampos

/*/{Protheus.doc} retornaColunasComNovoAliasDeCampo
Retorna relação de campos do SCHEMA com Novo Alias de Campo
@author brunno.costa
@since 21/11/2023
@version 1.0
@param 01 - oSelf        , objeto  , instancia da classe chamadora
@param 02 - cTabela      , array   , codigo da tabela para consideração na análise da SX3 x SCHEMA
@param 03 - cAlias       , caracter, alias para consideração da subquery ou tabela após macro substituição, por exemplo, 
                                    ao passar "PRODUTO.": SB1.B1_COD    -> PRODUTO.B1_COD
                                    ao passar NULL      : QE7.QE7_LABOR -> NULL QE7_LABOR (util em querys com union all de QE7 e QE8 quando deseja configurar uso de campos personalizados, entre outros)
@param 04 - cPrefixoCampo, caracter, novo prefixo de campo para substituir o prefixo original (Ex: B1_ DE B1_COD)
/*/
METHOD retornaColunasComNovoAliasDeCampo(oSelf as Object, cTabela as Character, cAlias as Character, cPrefixoCampo as Character) as CHARACTER CLASS QLTTReportsManager

    Local aCampos    := {}
    Local cCampoNV   := ""
    Local cCampos    := ""
    Local cCamposAux := ""
    Local cCampoX3   := ""
    Local nCampos    := 0
    Local nIndCampo  := 0
    Local cConteudo   := ""
    
    cCamposAux  := oSelf:getSQLFields(.T., {cTabela}, , self:lRetornaAninhados)

    If !Empty(cPrefixoCampo) .And. !Empty(cAlias) .And. !Empty(cCamposAux)
        aCampos := StrToKarr2(cCamposAux, ",")
        nCampos := Len(aCampos)
        For nIndCampo := 1 to nCampos

            cCampoNV := StrTran(aCampos[nIndCampo], cTabela + "." + cTabela, cPrefixoCampo)
            cCampoX3 := StrTran(aCampos[nIndCampo], cTabela + ".", "")

            cCampos  += " , COALESCE(" + StrTran(aCampos[nIndCampo], cTabela + ".", cAlias)

            If GetSX3Cache(cCampoNV,"X3_TIPO") == 'N'
                cConteudo := ", 0 ) "
            Else 
                cConteudo := ", ' ') "
            Endif

            cCampos  +=  cConteudo + cCampoNV

        Next
    EndIf
    
RETURN cCampos

/*/{Protheus.doc} retornaColunasDistintasComNovoAlias
Retorna relação de campos do SCHEMA + Campos Chave para uso em Sub-Querys com Prefixo de Alias da Subquery Específico
@author brunno.costa
@since 21/11/2023
@version 1.0
@param 01 - oSelf       , objeto  , instância da classe chamadora
@param 02 - aTabelas    , array   , array com relação das tabelas para consideração na análise da SX3 x SCHEMA
@param 03 - cCamposChave, caracter, string com relação de campos chave separados por virgula que compoem o relation do relacionamento da subquery
@param 04 - cAlias      , caracter, alias para consideração da subquery ou tabela após macro substituição, por exemplo, 
                                    ao passar "PRODUTO.": SB1.B1_COD    -> PRODUTO.B1_COD
                                    ao passar NULL      : QE7.QE7_LABOR -> NULL QE7_LABOR (util em querys com union all de QE7 e QE8 quando deseja configurar uso de campos personalizados, entre outros)
/*/
METHOD retornaColunasDistintasComNovoAlias(oSelf as Object, aTabelas as Array, cCamposChave as Character, cAlias as Character) as CHARACTER CLASS QLTTReportsManager

    Local aCamposChave := StrTokArr(cCamposChave,",")
    Local cCampos      := self:retornaColunasComNovoAlias(oSelf, aTabelas, cAlias)
    Local nCampos      := Len(aCamposChave)
    Local nIndCampo    := 0

    Default cAlias := ""

    For nIndCampo := 1 to nCampos
        If !(AllTrim(aCamposChave[nIndCampo]) $ cCampos)
            cCampos += ", " + cAlias + AllTrim(aCamposChave[nIndCampo])
        EndIf
    Next

RETURN cCampos

/*/{Protheus.doc} getUsedSQLFields
Retorna Campos Usados
@author brunno.costa
@since 21/11/2023
@version 1.0
@param 01 - oSelf          , objeto  , instancia da classe chamadora
@param 02 - cUsedFields    , caracter, relação de campos usados enviada pelo oFilter:getFields()
@param 03 - cExternalUse   , caracter, relação de campos com uso externo que obrigatoriamente requerem montagem da coluna na query
@param 04 - aCoalesceFields, array   , relação de campos com coalesce que deve ser adicionados em cUsedSQLFields conforme existência em da contrapartida em cUsedFields
/*/
Method getUsedSQLFields(oSelf as object, cUsedFields as Character, cExternalUse as Character, aCoalesceFields as Array) as Character class QLTTReportsManager
    
    Local aExternalFields := Nil                     as Array
    Local aStruct         := oSelf:getStructFields() as Array
	Local cUsedSQLFields  := ""                      as Character
    Local nCoalesce       := 0                       as Numeric
    Local nIndCpo         := 0                       as Numeric
    Local nPosCoalesce    := 0                       as Numeric

    Default cExternalUse    := ""
    Default cUsedFields     := ""
    Default aCoalesceFields := {}

    If cUsedFields == "*"
        cUsedSQLFields := "*"
    Else
        cUsedFields     := StrTran("," + cUsedFields + ",", " ", "")
        aExternalFields := StrTokArr(cExternalUse, ",")
        
        //Adiciona Campos cExternalUse
        aEval(aExternalFields, {|cField| cUsedSQLFields += Iif(cField $ cUsedSQLFields,;
                                                               "",;
                                                               Iif(Empty(cUsedSQLFields),"",",") + cField) } )

        //Adiciona campos cUsedFields - aStruct
        aEval(aStruct, {|aField| cUsedSQLFields += Iif( "," + AllTrim(aField:GetName()) + "," $ cUsedFields .AND. ;
                                                       !Empty(aField:GetRealName()) .And. !(aField:GetRealName() $ cUsedSQLFields),;
                                                       Iif(Empty(cUsedSQLFields),"",",") + aField:GetRealName(),;
                                                       "" ) } )

        //Adiciona campos cUsedFields - aCoalesceFields
        nCoalesce := Len(aCoalesceFields)
        For nIndCpo := 1 to nCoalesce
            nPosCoalesce   := aScan(aStruct, {|aField| aField:GetRealName() == aCoalesceFields[nIndCpo, 3] })
            cUsedSQLFields += Iif( nPosCoalesce > 0 .And. "," + AllTrim(aCoalesceFields[nIndCpo, 1]) + "," $ cUsedFields .AND. !Empty(aStruct[nPosCoalesce]:GetRealName()),;
                                  Iif(Empty(cUsedSQLFields),"",",") + aStruct[nPosCoalesce]:GetRealName(),;
                                  "" )
        Next
    EndIf

Return cUsedSQLFields

/*/{Protheus.doc} displayedSmartViewReport
Método para Injeção em Outros Fontes Questionando Chamada de SmartView para novo relatório em ambiente preparado
@author brunno.costa
@since 21/11/2023
@version 1.0

@param 01 - cIdProt
    caractere	X	
    Id do relatório que será impresso (relacionado ao nome do arquivo .trp)
    nome do arquivo .TRP contido no RPO (TFS), passar por exemplo o nome: 
                                        "manufacturing.sv.qie.fichadeinspecao" quando nome do arquivo é 
                                        "manufacturing.sv.qie.fichadeinspecao.default.rep.bra.trp"
                                        deve ser respeitada a padronização de pontos: framework.sv.framework.product.subtitle.rep.bra.trp
                                        Onde:
                                            framework: Nome da área/tribe responsável;
                                            sv: Agrupador de inovação;
                                            framework: Módulo Responsável;
                                            product: Nome do ON;
                                            subtitle: Nome complementar do ON (Ex: Analítico, Sintético...);
                                            rep: Tipo de Layout (rep=Report/pv=Pivot Table/dg=Data Grid);
                                            bra: País do ON;

@param 02 - cType (Apenas se for um recurso individual	)
    caractere	
    Tipo de dado (report, pivot-table ou data-grid)

@param 03 - nPrintType	(Apenas se for utilizada em job	)
    numérico
    Tipo do impressão (Arquivo=1, Email=2)

@param 04 - jPrintInfo (Apenas se for utilizada em job	)
    json	
    Informações para a impressão do relatório

@param 05 - jParams	(Se houver parâmetros no relatório)
    json	
    Parâmetros do relatório

@param 06 - lRunInJob	
    lógico	
    .T.	Indica se irá executar em job

@param 07 - lShowParams (Disponível a partir da LIB Label 20230807)	
    lógico	
    .T.	Indica se irá mostrar a tela de parâmetros (se for geração em job esse parâmetro sempre é .F.)

@param 08 - lWizard (Disponível a partir da LIB Label 20231009)
    lógico	
    .F.	Indica se exibe o wizard de configuração do Smart View, caso o ambiente não esteja preparado

@param 09 - cError (Disponível a partir da LIB Label 20231009)	
    caractere	
    Indica o erro na execução [referência]
/*/
METHOD displayedSmartViewReport(cIdProt      as Character ,;
                                cType        as Character ,;
                                nPrintType   as Integer   ,;
                                jPrintInfo   as Json      ,;
                                jParams      as Json      ,;
                                lRunInJob    as Json      ,;
                                lShowParams  as Logical   ,;
                                lWizard      as Logical   ,;
                                cError       as Character ,;
                               ) as Logical CLASS QLTTReportsManager

    Local lDisplayed := .F. as Logical


    If GetRpoRelease() > "12.1.2210"

        lConfig := totvs.framework.smartview.util.isConfig()

        If lConfig
            If MsgYesNo(STR0001) //"Deseja utilizar a versão do relatório do Smart View?"

                Default lShowParams := .T.
                Default lRunInJob   := IsBlind()
                Default lWizard     := .T.

                //1º parâmetro = Relatório cadastrado na tabela de 
                // De/Para (Campo TR__IDREL)
                //2º parâmetro = Tipo do relatório ("reports" = relatório, 
                //"data-grid" = visão de dados, "pivot-table" = tabela dinâmica)
                //Como não foi mandado o 6º parâmetro como .F. 
                //o relatório será gerado em job, caso esse parâmetro 
                //seja enviado será aberta a tela de opções
                lDisplayed := totvs.framework.treports.callTReports(cIdProt,cType,nPrintType,jPrintInfo,jParams,lRunInJob,lShowParams,lWizard,@cError)
                
                Iif(!lDisplayed, FwLogMsg("WARN",, "SmartView QLTTReportsManager",,, , STR0002 + " '" + cIdProt + "': " + cError, , ,), Nil) //Falha na exibição do relatório

            EndIf
        EndIf
    EndIf

RETURN lDisplayed

/*/{Protheus.doc} mountDefaultParams
Montar JSON com os parâmetros default do pergunte

**********************************
COMPORTAMENTO ATUAL DA INTEGRAÇÃO COM SMART VIEW NÃO CONSIDERA ESTES DADOS EM IMPRESSÃO COM TELA
MÉTODO PREPARADO PARA POSSÍVEL MELHORIA FUTURA CONFORME ALINHAMENTO INTERNO NA SQUAD
**********************************

@author brunno.costa
@since 21/11/2023
@version 1.0
@param 01 - cPerg       , caracter, código do pergunte para transformar em JSON
@param 02 - lExecutaPerg, lógico  , indica se deve executar Pergunte(cPerg, .F.) logo antes da conversão:
                                .T. -> Executa Pergunte(cPerg, .F.) logo antes da conversão
                                .F. -> Operação já efetuada anteriormente com atualzação manual dos MV_PAR, NÃO EXECUTA Pergunte(cPerg, .F.) NOVAMENTE
@return jParametros, json, json com os parâmetros do relatório convertidos
/*/
METHOD mountDefaultParams(cPerg as Character, lExecutaPerg as Logical) as Json CLASS QLTTReportsManager

    Local aPergunte  := {} as Array
    Local cNomeMV    := "" as Character
    Local jParametros      as Json
    Local nItemPerg  := 0  as Integer
    Local nPerguntas := 0  as Integer
    Local oFWSX1           as Object

    Default cPerg        := "" 
    Default lExecutaPerg := .T.

    //Preencher os parâmetros do relatório, caso o mesmo tenha parâmetro
    If !Empty(cPerg)
        oFWSX1  := FWSX1Util():New()
        oFWSX1:AddGroup(cPerg)
        oFWSX1:SearchGroup()
        aPergunte  := oFWSX1:GetGroup(cPerg)
        nPerguntas := Len(aPergunte[2])

        If nPerguntas > 0
            Iif(lExecutaPerg, Pergunte(cPerg, .F.), Nil)
            jParametros := JsonObject():New()
            For nItemPerg := 1 to nPerguntas
                cNomeMV              := "mv_par" + aPergunte[2,nItemPerg]:CX1_ORDEM
                jParametros[cNomeMV] := &(cNomeMV)
            Next
        EndIf

        oFWSX1:Destroy()
        FreeObj(oFWSX1)

    EndIf

RETURN jParametros


/*/{Protheus.doc} aninharAliasEmPropriedade
Aninhar os dados de um alias inteiro em uma Propriedade do objeto Json
@author brunno.costa
@since 21/11/2023
@version 1.0
@param 01 - oSelf      , objeto  , instancia da classe chamadora
@param 02 - cIDProperty, caracter, nome da propriedade aninhada para adicionar os dados em array
@param 03 - aStruct    , array   , estrutura dos campos aninhados
@param 04 - cAlias     , caracter, alias para percorrer registros e aninhar em propriedade
@param 05 - jData      , json    , objeto de dados para adição da propriedade aninhada
@param 06 - aCoalesce  , array   , array de campos para coalesce ADVPL
@param 07 - nIndice    , inteiro , indice da tabela para DbSetOrder
@param 08 - cCamposSeek, caracter, indice da tabela para comparação no While
@param 09 - cChaveSeek , caracter, chave dos dados da tabela para DbSeek e comparalção no While
@param 10 - cDateFormat, caracter, formato de data no cAlias (S - String / D - Data)
/*/
METHOD aninharAliasEmPropriedade(oSelf                   ,;
                                 cIDProperty as Character,;
                                 aStruct     as Array    ,;
                                 cAlias      as Character,;
                                 jData       as Json     ,;
                                 aCoalesce   as Array    ,;
                                 nIndice     as Integer  ,;
                                 cCamposSeek as Character,;
                                 cChaveSeek  as Character,;
                                 cIFWhile    as Character,;
                                 cLineExec   as Character,;
                                 cDateFormat as Character ;
                                 ) CLASS QLTTReportsManager

    Local cCondicaoWhile := ""           as Character
    Local cFieldName     := ""           as Character
    Local jItem                          as Json
    Local lLinOk         := .F.          as Logical
    Local nCampos        := Len(aStruct) as Integer
    Local nIndCampo      := 0            as Integer

    Default nIndice     := -1
    Default cCamposSeek := "'1'"
    Default cChaveSeek  := '1'
    Default cIFWhile    := ".T."
    Default cLineExec   := ""

    jData[cIDProperty] := {}

    If nIndice > 0
        (cAlias)->(DbSetOrder(nIndice))
        (cAlias)->(DbSeek(cChaveSeek))
        cCondicaoWhile := cAlias + "->(" + cCamposSeek + ")" + " == '" + cChaveSeek + "'"
    Else
        (cAlias)->(DbGoTop())
        cCondicaoWhile := ".T."
    EndIf

    While !(cAlias)->(Eof()) .AND. &(cCondicaoWhile)
        
        If Empty(cIFWhile) .OR. &(cIFWhile)
            jItem := JsonObject():New()

            //Adiciona Campos no Item
            For nIndCampo := 1 to nCampos
                cFieldName    := aStruct[nIndCampo][POS_cId]
                cPropertyId   := aStruct[nIndCampo][POS_cId]
                cType         := aStruct[nIndCampo][POS_cType]

                self:addToData(oSelf, cPropertyId, cType, cFieldName, @jItem, cAlias, @lLinOk, .T., cDateFormat)
            Next

            //Adiciona campos do aCoalesce que não sejam NIL referente segundo ALIAS
            aEval(aCoalesce  , {|aField| QLTTReportsManager():addToData(oSelf, aField[1], aField[2], aField[3], @jItem, cAlias, @lLinOk, .T., cDateFormat) } )
            
            //Adiciona Item na Propriedade Aninhada
            If lLinOk
                
                //Execução adicional para cada linha
                If !Empty(cLineExec)
                    &(cLineExec)
                EndIF

                aAdd(jData[cIDProperty], jItem)
            EndIf
        EndIf

        (cAlias)->(DbSkip())
    EndDo

RETURN 

/*/{Protheus.doc} addToData
Adiciona campo a estrutura de dados Json que será retornada para o Smart View
@author brunno.costa
@since 21/11/2023
@version 1.0
@param 01 - oSelf      , objeto  , instancia da classe chamadora
@param 02 - cPropertyId, caracter, ID da propriedade no JSON que será feito envio para o Smart View
@param 03 - cType      , caracter, tipo do dado
@param 04 - cFieldName , caracter, nome o campo na QUERY para recuperação do dado
@param 05 - jDataItem  , json    , objeto json para adição das propriedades e valores
@param 06 - cAlias     , caracter, alias com os dados para adição nas propriedades
@param 07 - lLinOk     , lógico  , retorno por referência para indicar se a linha recebeu dados válidos
@param 08 - lAninhada  , lógico  , indica que o campo faz parte de uma propriedade aninhada e deve ser sempre enviado
@param 09 - cDateFormat, caracter, formato de data no cAlias (S - String / D - Data)
/*/
Method addToData(oSelf as object, cPropertyId as Character, cType as Character, cFieldName as Character, jDataItem as Json, cAlias as Character, lLinOk as Logical, lAninhada as Logical, cDateFormat as Character) class QLTTReportsManager
    
	Local cComboContent := "" as Character

    Default jDataItem   := oSelf:jData
    Default cAlias      := oSelf:cAlias
    Default lAninhada   := .F.
    Default cDateFormat := "S"

	If (cAlias)->(FieldPos(cFieldName)) > 0 .AND. !Empty(cPropertyId) .AND. (lAninhada .OR. oSelf:cUsedFields == "*" .OR. cPropertyId $ oSelf:cUsedFields) .AND. (cAlias)->&(cFieldName) != NIL .AND. Empty(jDataItem[cPropertyId])

		If cType == "string" .and. !Empty(cComboContent := x3Combo(cFieldName, (cAlias)->&(cFieldName)))
			jDataItem[cPropertyId] := cComboContent

		ElseIf cType == "string" .and. oSelf:lForceAllTrim
        	jDataItem[cPropertyId] := allTrim((cAlias)->&(cFieldName))

		ElseIf cType == "date" .AND. cDateFormat == "D"
			jDataItem[cPropertyId] := totvs.framework.treports.date.dateToTimeStamp((cAlias)->&(cFieldName))

        ElseIf cType == "date" .AND. cDateFormat == "S"
			jDataItem[cPropertyId] := totvs.framework.treports.date.stringToTimeStamp((cAlias)->&(cFieldName))

        Else
			jDataItem[cPropertyId] := (cAlias)->&(cFieldName)

		EndIf

        lLinOk := .T.

	EndIf

Return

/*/{Protheus.doc} formataParametroData
Retorna o valor da data formatado caso exista ou vazio caso não exista
@author Jefferson Possidonio
@since 02/12/2024
@version 1.0
@param 01 - cParam   , caracter , parâmetro a ser analisado
/*/
METHOD formataParametroData(cParam as Character) as CHARACTER CLASS QLTTReportsManager
    
    If cParam == "0001-01-01T00:00:00"
        cParam := ""
    Else
        cParam := Left(Replace(cParam, "-", ""),8)
    Endif
    
RETURN cParam

/*/{Protheus.doc} QLTDispSVR
Function para Injeção em Outros Fontes Questionando Chamada de SmartView para novo relatório em ambiente preparado
@author brunno.costa
@since 21/11/2023
@version 1.0
@param 01 - cIdProt
    caractere	X	
    Id do relatório que será impresso (relacionado ao nome do arquivo .trp)
    nome do arquivo .TRP contido no RPO (TFS), passar por exemplo o nome: 
                                        "manufacturing.sv.qie.fichadeinspecao" quando nome do arquivo é 
                                        "manufacturing.sv.qie.fichadeinspecao.default.rep.bra.trp"
                                        deve ser respeitada a padronização de pontos: framework.sv.framework.product.subtitle.rep.bra.trp
                                        Onde:
                                            framework: Nome da área/tribe responsável;
                                            sv: Agrupador de inovação;
                                            framework: Módulo Responsável;
                                            product: Nome do ON;
                                            subtitle: Nome complementar do ON (Ex: Analítico, Sintético...);
                                            rep: Tipo de Layout (rep=Report/pv=Pivot Table/dg=Data Grid);
                                            bra: País do ON;

@param 02 - cType (Apenas se for um recurso individual	)
    caractere	
    Tipo de dado (report, pivot-table ou data-grid)

@param 03 - nPrintType	(Apenas se for utilizada em job	)
    numérico
    Tipo do impressão (Arquivo=1, Email=2)

@param 04 - jPrintInfo (Apenas se for utilizada em job	)
    json	
    Informações para a impressão do relatório

@param 05 - jParams	(Se houver parâmetros no relatório)
    json	
    Parâmetros do relatório

@param 06 - lRunInJob	
    lógico	
    .T.	Indica se irá executar em job

@param 07 - lShowParams (Disponível a partir da LIB Label 20230807)	
    lógico	
    .T.	Indica se irá mostrar a tela de parâmetros (se for geração em job esse parâmetro sempre é .F.)

@param 08 - lWizard (Disponível a partir da LIB Label 20231009)
    lógico	
    .F.	Indica se exibe o wizard de configuração do Smart View, caso o ambiente não esteja preparado

@param 09 - cError (Disponível a partir da LIB Label 20231009)	
    caractere	
    Indica o erro na execução [referência]
/*/
Function QLTDispSVR(cIdProt      as Character ,;
                    cType        as Character ,;
                    nPrintType   as Integer   ,;
                    jPrintInfo   as Json      ,;
                    jParams      as Json      ,;
                    lRunInJob    as Json      ,;
                    lShowParams  as Logical   ,;
                    lWizard      as Logical   ,;
                    cError       as Character ) 
Return QLTTReportsManager():displayedSmartViewReport(cIdProt, cType, nPrintType, jPrintInfo, jParams, lRunInJob, lShowParams, lWizard, cError)
